package SPT
public

	with BLESS, BLESS_Types, PulseOx_Types;

thread SpO2TrendThread
  features
    SpO2 : in event data port PulseOx_Types::Percent;	--oxygen saturation from pulse oximeter device
    SensorConnected : in data port BLESS_Types::Boolean;  --sensor is attached to patient
    MotionArtifact : in data port BLESS_Types::Boolean;  -- indication of motion noise in sensor reading
    SpO2Trend : out data port PulseOx_Types::SpO2Samples  --one SpO2 reading each minute for the past hour
      {BLESS::Assertion=>"<<SPO2_TREND()>>";}
         ;  
    NumSamples : out data port BLESS_Types::Integer
      {BLESS::Assertion=>"<<:=num_samples>>";}
      ;
  properties
    --Thread_Properties::
        Dispatch_Protocol => Periodic;  
    --Timing_Properties::
        Period => PulseOx_Properties::Time_Between_Trending_Samples;
end SpO2TrendThread;

thread implementation SpO2TrendThread.imp
annex BLESS 
{**
  assert
    <<HOLD:n~quantity whole: all s~quantity whole in 1 ..n --holds current values for SpO2; spo2[1]=SpO2^0
         are spo2[s]=(if MotionArtifact^(1-s) or not SensorConnected^(1-s) then 0 else SpO2^(1-s))>>
  invariant 
    <<SpO2_INV: :all s~quantity whole in 1 ..num_samples 
         are spo2[s]=(if MotionArtifact^(-s) or not SensorConnected^(-s) then 0 else SpO2^(-s))>>  
  variables
    nts~quantity whole :=#PulseOx_Properties::Num_Trending_Samples;
    spo2 ~  array [1 .. #PulseOx_Properties::Num_Trending_Samples] of quantity percent; -- := 0;  --holds SpO2 history
    spo2_nxt ~ array [1 .. #PulseOx_Properties::Num_Trending_Samples] of quantity percent; -- := 0;  --temporary copy of trend for next output
    num_samples~quantity whole := 0;  --counts samples while filling
  states
    start : initial state
      <<(num_samples<#PulseOx_Properties::Num_Trending_Samples) and (num_samples=0) and
        (all s~quantity whole in (num_samples+1) .. #PulseOx_Properties::Num_Trending_Samples
         	are not SensorConnected^(-s))>>;
    loading : complete state  --loading spo2
      <<SpO2_INV() and (num_samples<#PulseOx_Properties::Num_Trending_Samples)>>;    
    check : state  --check if full
      <<HOLD(num_samples)>>;
    run : complete state   --full spo2
      <<SpO2_INV() and (num_samples=#PulseOx_Properties::Num_Trending_Samples)>>;    
    halt : final state;  --normal termination
    fail : final state;  --error termination
  transitions
    sptt0: start-[ ]->loading{};
    sptt1: loading-[on dispatch]->check
      {
        <<SpO2_INV() and (num_samples < #PulseOx_Properties::Num_Trending_Samples)>>
      SpO2Trend!(spo2)  --put out new SpO2 trend for ui
      ;
        <<SpO2_INV() and (num_samples < #PulseOx_Properties::Num_Trending_Samples)>>
      NumSamples!(num_samples)
      ;
        <<SpO2_INV() and (num_samples < #PulseOx_Properties::Num_Trending_Samples)>>
      forall i in 1 ..num_samples
        {
          <<spo2[i]=(if MotionArtifact^(-i) or not SensorConnected^(-i) then 0 else SpO2^(-i))>>
        spo2_nxt[i+1]:=spo2[i] --shift old samples
          <<spo2_nxt[i+1]=(if MotionArtifact^(-i) or not SensorConnected^(-i) then 0 else SpO2^(-i))>>
        }
      <<SHFT: :all i~quantity whole in 1 ..num_samples 
         are spo2_nxt[i+1]=(if MotionArtifact^(-i) or not SensorConnected^(-i) then 0 else SpO2^(-i))>>
      ;  
      if
        (MotionArtifact? or not SensorConnected?)~>
            <<SHFT() and (MotionArtifact^0 or not SensorConnected^0)>>
          spo2_nxt[1]:=0  --bad sample
            <<SHFT() and (MotionArtifact^0 or not SensorConnected^0)
               and (spo2_nxt[1]=(if MotionArtifact^0 or not SensorConnected^0 then 0 else SpO2^0))>>
      []
        (not (MotionArtifact? or not SensorConnected?))~>
             <<SHFT() and not (MotionArtifact^0 or not SensorConnected^0)>>
          spo2_nxt[1]:=SpO2?  --add current sample
            <<SHFT() and not (MotionArtifact^0 or not SensorConnected^0)
               and (spo2_nxt[1]=(if MotionArtifact^0 or not SensorConnected^0 then 0 else SpO2^0))>>
      fi    
        <<(spo2_nxt[1]=(if MotionArtifact^0 or not SensorConnected^0 then 0 else SpO2^0)) and
          (all i~quantity whole in 2 .. (num_samples+1) are 
          	spo2_nxt[i]=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else SpO2^(1-i)))>>
      ;    
      num_samples:=num_samples+1  --increment count of samples
      <<all i~quantity whole in 1 ..num_samples are spo2_nxt[i]=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else SpO2^(1-i))>>
      ;
      forall i in 1 ..num_samples
        {
          <<spo2_nxt[i]=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else SpO2^(1-i))>>
        spo2[i]:=spo2_nxt[i] --copy back
          <<spo2[i]=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else SpO2^(1-i))>>
        }
      <<all i~quantity whole in 1 ..num_samples are spo2[i]=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else SpO2^(1-i))>>
      };
    sptt2a: check-[num_samples<#PulseOx_Properties::Num_Trending_Samples]->loading
      {|spo2',num_samples':=spo2,num_samples|};
    sptt2b: check-[num_samples=#PulseOx_Properties::Num_Trending_Samples]->run
      {|spo2',num_samples':=spo2,num_samples|};
    sptt2c: check-[num_samples>#PulseOx_Properties::Num_Trending_Samples]->fail{};
    sptt3: run-[on dispatch]->run
      {
        <<SpO2_INV() and (num_samples=#PulseOx_Properties::Num_Trending_Samples)>>
      SpO2Trend!(spo2)  --put out new SpO2 trend for ui
      ;
        <<SpO2_INV() and (num_samples=#PulseOx_Properties::Num_Trending_Samples)>>
      NumSamples!(num_samples)
      ;
        <<SpO2_INV() and (num_samples=#PulseOx_Properties::Num_Trending_Samples)
          and AXIOM_CR()>>
      forall i in 1 .. (num_samples - 1)
        {
          <<spo2[i]=(if MotionArtifact^(-i) or not SensorConnected^(-i) then 0 else SpO2^(-i))>>
        spo2_nxt[i+1]:=spo2[i] --shift old samples
          <<spo2_nxt[i+1]=(if MotionArtifact^(-i) or not SensorConnected^(-i) then 0 else SpO2^(-i))>>
        }
        <<SHFTR: :(all i~quantity whole in 1 .. (num_samples - 1) 
        	are spo2_nxt[i+1]=(if MotionArtifact^(-i) or not SensorConnected^(-i) then 0 else SpO2^(-i)))
          and (num_samples=#PulseOx_Properties::Num_Trending_Samples)>>
      ;  
      if
        (MotionArtifact? or not SensorConnected?)~>
            <<SHFTR() and (MotionArtifact^0 or not SensorConnected^0)>>
          spo2_nxt[1]:=0  --bad sample
            <<SHFTR() and (MotionArtifact^0 or not SensorConnected^0)
               and (spo2_nxt[1]=(if MotionArtifact^0 or not SensorConnected^0 then 0 else SpO2^0))>>
      []
        (not (MotionArtifact? or not SensorConnected?))~>
             <<SHFTR() and not (MotionArtifact^0 or not SensorConnected^0)>>
          spo2_nxt[1]:=SpO2?  --add current sample
            <<SHFTR() and not (MotionArtifact^0 or not SensorConnected^0)
               and (spo2_nxt[1]=(if MotionArtifact^0 or not SensorConnected^0 then 0 else SpO2^0))>>
      fi    
        <<(spo2_nxt[1]=(if MotionArtifact^0 or not SensorConnected^0 then 0 else SpO2^0)) and 
          (num_samples=#PulseOx_Properties::Num_Trending_Samples) and
          (all i~quantity whole in 2 ..num_samples 
          	 are spo2_nxt[i]=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else SpO2^(1-i)))>>
      ;
      forall i in 1 ..num_samples
        {
          <<spo2_nxt[i]=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else SpO2^(1-i))>>
        spo2[i]':=spo2_nxt[i] --copy back
          <<spo2[i]'=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else SpO2^(1-i))>>
        }
      <<(all i~quantity whole in 1 ..num_samples 
      	  are spo2[i]'=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else SpO2^(1-i)))
         and (num_samples=#PulseOx_Properties::Num_Trending_Samples)>> 
      ;
      num_samples':=num_samples  	
      <<(all i~quantity whole in 1 ..num_samples 
      	  are spo2[i]'=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else SpO2^(1-i)))
         and (num_samples'=#PulseOx_Properties::Num_Trending_Samples)>> 
      };
    sptt4: loading,run-[on dispatch stop]->halt{};    
**};
end SpO2TrendThread.imp;

	
end SPT;