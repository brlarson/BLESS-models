package HR
public

with PulseOx_Types, BLESS_Types, BLESS; 

thread HeartRateTrendThread
  features
    HeartRate : in data port PulseOx_Types::Heart_Rate	--oxygen saturation from pulse oximater device
      {BLESS::Value=>"<< returns quantity Hz := HEART_RATE >>";};
    SensorConnected : in data port BLESS_Types::Boolean  --sensor is attached to patient
      {BLESS::Assertion=>"<< SENSOR_CONNECTED >>";};
    MotionArtifact : in data port BLESS_Types::Boolean  -- indication of motion noise in sensor reading
      {BLESS::Assertion=>"<< MOTION_ARTIFACT >>";};
    HeartRateTrend : out data port PulseOx_Types::HeartRateSamples  --one HeartRate reading each minute for the past half-hour
      {BLESS::Value=>"<< returns heartrate_samples := HEART_RATE_HISTORY >>";};  
    NumSamples : out data port BLESS_Types::Integer
      {BLESS::Value=>"<< returns quantity whole:= NUM_SAMPLES >>";};
  properties
    --Thread_Properties::
        Dispatch_Protocol => Periodic;
    --Timing_Properties::
        Period => PulseOx_Properties::Time_Between_Trending_Samples;
end HeartRateTrendThread;

thread implementation HeartRateTrendThread.imp
annex BLESS 
{**
  assert
    -- HRV defines intended heart rate measure, k periods prior to now
    <<HRV: k ~ quantity whole returns quantity Hz := 
      (if MOTION_ARTIFACT^(-k) or not SENSOR_CONNECTED^(-k) then 0.0 Hz else HEART_RATE^(-k))>>
    -- HOLD_HR current values for HeartRate
    <<HOLD_HR:n~quantity whole:all s~quantity whole in 0 .. (n - 1) 
         are heart_rate_store[s]=HRV(s)>>
    <<GIVEN_HRT: :num_samples = NUM_SAMPLES and heart_rate_store = HEART_RATE_HISTORY >>
    <<GIVEN_CR: : num_samples - 1 < num_samples >>

  invariant 
    -- heart_rate_store[0] holds current heart rate, heart_rate_store[1] one period prior, etc.
    <<INV_HR: :all s~quantity whole in 0 .. (NUM_SAMPLES - 1) 
         are heart_rate_store[s]=HRV(s)>>  
  variables
    nts~quantity whole:=#PulseOx_Properties::Num_Trending_Samples;
    heart_rate_store ~ heartrate_samples  --holds HeartRate history
    hr_nxt ~ heartrate_samples --temporary copy of trend for next output
    num_samples ~quantity whole:=0;  --counts samples while filling
  states
    start : initial state
      <<NUM_SAMPLES<#PulseOx_Properties::Num_Trending_Samples and NUM_SAMPLES=0 >>
    fill : complete state  --loading heart_rate_store
      <<INV_HR() and NUM_SAMPLES<#PulseOx_Properties::Num_Trending_Samples >>;    
    check : state  --check if full
      <<INV_HR() and GIVEN_HRT() >>;
    run : complete state   --full heart_rate_store
      <<INV_HR() >>;    
    halt : final state;  --normal termination
    fail : final state;  --error termination
  transitions
    hrtt0: start-[ ]->fill
--      {|nts',heart_rate_store',hr_nxt',num_samples' := 
--    	        nts,heart_rate_store,hr_nxt,num_samples|};
    hrtt1: fill-[on dispatch]->check
      { --assertion of "fill" complete state true at previous period
      	<<INV_HR()^-1 and  GIVEN_HRT() >>
      	--persistent variables hold values from previous period
			|num_samples,heart_rate_store := 'num_samples,'heart_rate_store|
			  << all s~quantity whole in 0 .. (num_samples - 1)
         are heart_rate_store[s]=HRV(s + 1)>>
			; --copy old values to temporary hr_nxt, shifted by one
      forall i in 0 .. (num_samples - 1)
        {
          <<heart_rate_store[i]=HRV(i + 1) >>
        hr_nxt[i+1]:=heart_rate_store[i] --shift old samples
          <<hr_nxt[i+1]=HRV(i + 1) >>
        }
        <<SHFT_HR: :all i~quantity whole in 1 .. num_samples
         are hr_nxt[i]=HRV(i) >>
      ;  -- fill in current reading hr_nxt[0]
      if
        (MotionArtifact? or not SensorConnected?)~>
            <<SHFT_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0)>>
          hr_nxt[0] := 0.0 Hz  --bad sample
            <<SHFT_HR() and hr_nxt[0]=HRV(0) >>
      []
        (not (MotionArtifact? or not SensorConnected?))~>
             <<SHFT_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0)>>
          hr_nxt[0] := HeartRate  --add current sample
            <<SHFT_HR() and hr_nxt[0]=HRV(0) >>
      fi    
        <<SHFT_HR() and hr_nxt[0]=HRV(0) >>      
      ;  --increment count of samples  
      num_samples:=num_samples+1  
      <<all i~quantity whole in 0 .. (num_samples - 1)
        are hr_nxt[i]=HRV(i)>>
			;  -- copy hr_nxt to heart_rate_store
      forall i in 0 .. (num_samples - 1)
        {
          <<hr_nxt[i]=HRV(i) >>
        heart_rate_store[i]:=hr_nxt[i] --copy back
          <<heart_rate_store[i]=HRV(i) >>
        }
      <<(all i~quantity whole in 0 .. (num_samples - 1)
        are heart_rate_store[i]=HRV(i)) and GIVEN_HRT()>>  
			;
        {  --<<INV_HR() and GIVEN_HRT() >>
        HeartRateTrend!(heart_rate_store)  --put out new HeartRate trend 
        &
        NumSamples!(num_samples)  --put out current number of samples
        }
        <<INV_HR()>>
      };
    hrtt2a: check-[num_samples<#PulseOx_Properties::Num_Trending_Samples]->fill
    hrtt2b: check-[num_samples=#PulseOx_Properties::Num_Trending_Samples]->run
    hrtt2c: check-[num_samples>#PulseOx_Properties::Num_Trending_Samples]->fail{};
    hrtt3: run-[on dispatch]->run
       { --assertion of "fill" complete state true at previous period
        <<INV_HR()^-1 and  GIVEN_HRT() >>
        --persistent variables hold values from previous period
      |num_samples,heart_rate_store := 'num_samples,'heart_rate_store|
        << all s~quantity whole in 0 .. (num_samples - 1)
         are heart_rate_store[s]=HRV(s + 1)>>
      ; --copy old values to temporary hr_nxt, shifted by one
      forall i in 0 .. (num_samples - 1)
        {
          <<heart_rate_store[i]=HRV(i + 1) >>
        hr_nxt[i+1]:=heart_rate_store[i] --shift old samples
          <<hr_nxt[i+1]=HRV(i + 1) >>
        }
        <<SHFT_HR: :all i~quantity whole in 1 .. num_samples
         are hr_nxt[i]=HRV(i) >>
      ;  -- fill in current reading hr_nxt[0]
      if
        (MotionArtifact? or not SensorConnected?)~>
            <<SHFT_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0)>>
          hr_nxt[0] := 0.0 Hz  --bad sample
            <<SHFT_HR() and hr_nxt[0]=HRV(0) >>
      []
        (not (MotionArtifact? or not SensorConnected?))~>
             <<SHFT_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0)>>
          hr_nxt[0] := HeartRate  --add current sample
            <<SHFT_HR() and hr_nxt[0]=HRV(0) >>
      fi    
        <<SHFT_HR() and hr_nxt[0]=HRV(0) and GIVEN_CR()>>      
      ;  --don't increment count of samples  
      skip  --num_samples:=num_samples+1  
      <<all i~quantity whole in 0 .. (num_samples - 1)
        are hr_nxt[i]=HRV(i)>>
      ;  -- copy hr_nxt to heart_rate_store
      forall i in 0 .. (num_samples - 1)
        {
          <<hr_nxt[i]=HRV(i) >>
        heart_rate_store[i]:=hr_nxt[i] --copy back
          <<heart_rate_store[i]=HRV(i) >>
        }
      <<(all i~quantity whole in 0 .. (num_samples - 1)
        are heart_rate_store[i]=HRV(i)) and GIVEN_HRT()>>  
      ;
        {  --<<INV_HR() and GIVEN_HRT() >>
        HeartRateTrend!(heart_rate_store)  --put out new HeartRate trend 
        &
        NumSamples!(num_samples)  --put out current number of samples
        }
        <<INV_HR()>>
      };
--    hrtt4: fill,run-[on dispatch stop]->halt{};  
**};
end HeartRateTrendThread.imp;
	
end HR;