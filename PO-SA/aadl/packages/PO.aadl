--PO.aadl
--ICE pulse oximeter app
--provides control and smart alarms for a pulse oximeter

--ICEpoSystem has three major subcomponents
--  ICEpoInterface wraps a pulse oximeter device to provide ICE-standard interface
--  ICEpoUI defines the user interface to control the app and display its data
--  ICEpoApp performs calculations of smart alarms, etc.

--ICE_Display.aadl defines a physical Screen and Speaker used by ICEpoUI to intercat with clinicians
--PulseOx_Properties.aadl defines some types and constants used to specify app behavior


package PO

public
--  with Timing_Properties;  --predeclared AADL property set
--  with Thread_Properties;  --predeclared AADL property set
--  with Data_Model;         --property set defined by AADL Data Modeling Annex
  with Base_Types;         --package defined by AADL Data Modeling Annex
--  with Communication_Properties, Memory_Properties;  --predeclared AADL property set
  with PulseOx_Properties;     --property set holding ICE-specific properties
  with PulseOx_Types;      --package holding data components used as types for pulse oximeters
--  with PulseOx_Types;          --package data types used by ICE components
  with ICE_Display;        --package holding flat-panel display showing image of control panels
  with BLESS;              --package defining BLESS::Assertion to be a string
  with BLESS_Types;        --predeclared types used by BLESS
--  with Communication_Properties;
--  with Timing_Properties;
--  with Thread_Properties;

annex Unit
{**  --create 'percent' unit
	base [ unitless ] u , < ratio times one hundred > percent * 100 ;
**};
	
annex Assertion 
{** 
ghost variables
  def SENSOR_CONNECTED~boolean
  def MOTION_ARTIFACT~boolean
  def SPO2~quantity percent
  def SPO2_LOWER_LIMIT~quantity percent
  def SPO2_LOWER_LIMIT_ADJ~quantity percent
  def MAX_SPO2_DECLINE~quantity percent
  def HEART_RATE~quantity Hz
  def HEART_RATE_LOWER_LIMIT~quantity Hz
  def HEART_RATE_UPPER_LIMIT~quantity Hz
  def SPO2_MOVING_AVERAGE_WINDOW_SAMPLES~quantity whole
  def SUPPL_OXY_ALARM_ENABLED~boolean
  def ADULT_RAPID_DECLINE_ALARM_ENABLED~boolean
  def SPO2_HISTORY~array[1 .. #PulseOx_Properties::Max_Window_Samples] of quantity percent
  def HEART_RATE_HISTORY~array[1 .. #PulseOx_Properties::Max_Window_Samples] of quantity Hz
  def NUM_SAMPLES~quantity whole
  
  
  <<SPO2_LOWER_LIMIT_ALARM: :SENSOR_CONNECTED and not MOTION_ARTIFACT and (SPO2 < SPO2_LOWER_LIMIT)>>	
  <<HEART_RATE_LOWER_LIMIT_ALARM: :SENSOR_CONNECTED and not MOTION_ARTIFACT and (HEART_RATE < HEART_RATE_LOWER_LIMIT)>>	
  <<HEART_RATE_UPPER_LIMIT_ALARM: :SENSOR_CONNECTED and not MOTION_ARTIFACT and (HEART_RATE > HEART_RATE_UPPER_LIMIT)>>
  <<SPO2_AVERAGE: returns quantity percent :=
     --the sum of good SpO2 measurements
      (sum i~quantity whole in -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 of 
      	 (if SENSOR_CONNECTED^(i) and not MOTION_ARTIFACT^(i) then  SPO2^(i) else 0))
      /  --divided by the number of good SpO2 measurements
      (numberof i~quantity whole in -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
      	that (SENSOR_CONNECTED^(i) and not MOTION_ARTIFACT^(i)))>>
  <<SUPPL_O2_ALARM: :SUPPL_OXY_ALARM_ENABLED^0 and (SPO2_AVERAGE())^0 < (SPO2_LOWER_LIMIT^0+SPO2_LOWER_LIMIT_ADJ^0)>>
  <<RAPID_DECLINE_ALARM: :ADULT_RAPID_DECLINE_ALARM_ENABLED  and
      (exists j~quantity whole in 1 .. #PulseOx_Properties::Max_Window_Samples that (SPO2 <= (SPO2^(-j) - MAX_SPO2_DECLINE)))>>
  <<MOTION_ARTIFACT_ALARM: :all j~quantity whole 
        in 0 .. #PulseOx_Properties::Motion_Artifact_Sample_Limit are (MOTION_ARTIFACT^(-j) or not SENSOR_CONNECTED^(-j))>>      
  <<SPO2_TREND: : all s~quantity whole in 1 ..NUM_SAMPLES 
         are SPO2_HISTORY[s]=(if MOTION_ARTIFACT^(-s) or not SENSOR_CONNECTED^(-s) then 0 else SPO2^(-s))>>
  <<HR_TREND: : all s~quantity whole in 1 ..NUM_SAMPLES 
         are HEART_RATE_HISTORY[s]=(if MOTION_ARTIFACT^(-s) or not SENSOR_CONNECTED^(-s) then 0 else HEART_RATE^(-s))>>
  <<AXIOM_CR: : (NUM_SAMPLES - 2) < (NUM_SAMPLES - 1)>>
**};

system ICEpoSystem
  --may add probe connected to Pulse Oximeter device
  --may add output to ICE data logger
  --may add output to electronic health record
  --  properties
 --   	Communication_Properties::Timing => immediate applies to probe_off_alarm, sensor_connected;
end ICEpoSystem;

system implementation ICEpoSystem.imp
  subcomponents
    po : device ICEpoInterface.imp;   --pulse oximeter
    app : process ICEpoAppProcess.imp;  --coordinating app
    ui : process ICEpoUIprocess.imp;    --user interface to nurse
    screen : device ICE_Display::Screen;	--ICE display touch screen
    piezo : device ICE_Display::Speaker;    --audible ICE alarm
  connections
    --====================
    --== SpO2 Sensor inputs and alarm configuration
    --====================
    spo2 : port po.SpO2 -> app.SpO2 {  --current SpO2 % from interface to app 
       	--Communication_Properties::
       	Timing => immediate;
      	--Communication_Properties::
      	Latency => 100 ms .. 300 ms;
      };
    spo2_ui : port po.SpO2 -> ui.SpO2 {  --current SpO2 % from interface to ui 
        --Communication_Properties::
        Timing => immediate;
      	--Communication_Properties::
        Latency => 100 ms .. 300 ms;
      };
    spo2_lower_limit : port ui.SpO2LowerLimit <-> po.SpO2LowerLimit {
    	--Communication_Properties::
        Timing => immediate;
      	--Communication_Properties::
        Latency => 100 ms .. 300 ms;
      };
    spo2_lower_limit_violated : port po.SpO2LowerLimitViolated -> ui.SpO2LowerLimitViolated {
    	--Communication_Properties::
        Timing => immediate;
      	--Communication_Properties::
        Latency => 100 ms .. 300 ms;
      };
      
      -- Ideally all port connections will have (as a default) the timing and latency properties specified
      -- for the first four connections.  Unfortunately, my understanding of AADL (and possibly AADL itself)
      -- won't allow defaults to be specified in a global, inheritable manner.  As a backup, each connection
      -- can be specified in the above manner.      
      
    --====================
    --== Heart Rate Sensor inputs and alarm configuration
    --====================
    heart_rate : port po.HeartRate -> ui.HeartRate;  --current heart rate from interface to ui
    heart_rate_app : port po.HeartRate -> app.HeartRate;  --current heart rate from interface to app
    heart_rate_lower_limit : port ui.HeartRateLowerLimit <-> po.HeartRateLowerLimit;  --bidirectional between interface and ui
    heart_rate_lower_limit_violated : port po.HeartRateLowerLimitViolated -> ui.HeartRateLowerLimitViolated  --interface to ui
      {--Communication_Properties::
        Timing=>immediate;};
    heart_rate_upper_limit : port ui.HeartRateUpperLimit <-> po.HeartRateUpperLimit;  --bidirectional between interface and ui
    heart_rate_upper_limit_violated : port po.HeartRateUpperLimitViolated -> ui.HeartRateUpperLimitViolated  --interface to ui
      {--Communication_Properties::
        Timing=>immediate;};
    heart_rate_trend : port app.HeartRateTrend -> ui.HeartRateTrend;  --heart rate trend data from app to up
    --====================
    --== App Suppl Oxygen Derived Alarm I/O and configuration
    --====================
    supplemental_oxygen : port ui.SupplOxyAlarmEnabled -> app.SupplOxyAlarmEnabled;
    supplemental_oxygen_adjustment : port ui.SpO2LevelAdj -> app.SpO2LevelAdj;
    supplemental_oxygen_alarm : port app.SpO2DerivedLowerLimitAlarm -> ui.SpO2DerivedLowerLimitAlarm;
    --====================
    --== App Adult Rapid SpO2 Decline Derived Alarm I/O and configuration
    --====================    
    adult_patient : port ui.AdultRapidDeclineAlarmEnabled -> app.AdultRapidDeclineAlarmEnabled;
    rapid_spo2_decline_percent : port ui.MaxSpO2Decline -> app.MaxSpO2Decline;    
    rapid_spo2_decline_alarm : port app.RapidSpO2DeclineAlarm -> ui.RapidSpO2DeclineAlarm
      {--Communication_Properties::
        Timing=>immediate;};
    --====================
    --== Indications of SpO2 measurement anamolies
    --====================
    sensor_connected : port po.SensorConnected -> app.SensorConnected;
    motion_artifact : port po.MotionArtifact -> app.MotionArtifact;
    probe_off_alarm : port po.ProbeOff -> ui.ProbeOff  --probe fell off alarm
      {--Communication_Properties::
        Timing=>immediate;};
    motion_artifact_alarm : port app.MotionArtifactAlarm -> ui.MotionArtifactAlarm
      {--Communication_Properties::
        Timing=>immediate;};
    --====================
    --== Data for SpO2 trending display
    --====================
    spO2_Trend : port app.SpO2Trend -> ui.SpO2Trend;
    --====================  
    --== display, touch screen, and alarm buzzer
    --====================  
    po_image : port ui.Image -> screen.Image;  --image to display
    po_touch : port screen.Touch -> ui.Touch;  --touch from display
    sound : port ui.Sound -> piezo.Sound;  --audible alarm
end ICEpoSystem.imp;


device ICEpoInterface 
  --ICE Interface that must be met by an ICE-compliant pulse oximeter
  features
    --====================
    --== SpO2 Sensor
    --====================
    -- SpO2 sensor metric
    SpO2 : out event data port PulseOx_Types::Percent {
        --Communication_Properties::
        Fan_Out_Policy=>Broadcast;
        --Communication_Properties::
        Output_Rate => [
          	Value_Range => 2.0 .. 2.0; -- 500 ms (2x per second)
          	Rate_Unit => PerSecond;
          	Rate_Distribution => Fixed;
          ];
          -- MIDAS requires a 20 ms deadline, omitted because
          -- sensor is unspecified
      };
    -- SpO2 sensor lower limit alarm
    SpO2LowerLimit : in out event data port PulseOx_Types::Percent { -- lower limit attribute can be both read and written by clients
        --Communication_Properties::
        Fan_Out_Policy=>Broadcast;
        -- the default output rate of 1.0 per dispatch is suffcient
      };	
    SpO2LowerLimitViolated : out event port { -- alarm event published when patient SpO2 below lower limit
--      BLESS::Assertion=>"<<SPO2_LOWER_LIMIT_ALARM()>>";
      --Communication_Properties::
        Fan_Out_Policy => Broadcast;
      --Communication_Properties::
        Latency => 0 ms .. 5 ms;
    };
    --====================
    --== Heart Rate Sensor
    --====================
    -- Heart Rate sensor metric
    HeartRate : out data port PulseOx_Types::Heart_Rate {  -- periodic publishing of heart rate from pulse oximeter
        --Communication_Properties::
        Fan_Out_Policy=>Broadcast;
        --Communication_Properties::
        Output_Rate => [
          Value_Range => 2.0 .. 2.0; -- 500 ms (2x per second)
          Rate_Unit => PerSecond;
          Rate_Distribution => Fixed;
        ];
      };	
    -- Heart Rate sensor lower limit alarm
    HeartRateLowerLimit : in out event data port PulseOx_Types::Heart_Rate { -- minimum heart rate
    	--Communication_Properties::
        Fan_Out_Policy=>Broadcast;
        -- the default output rate of 1.0 per dispatch is suffcient
      };
    HeartRateLowerLimitViolated : out event port {  -- alarm event published when patient HR below lower limit
      BLESS::Assertion=>"<<HEART_RATE_LOWER_LIMIT_ALARM()>>";
      --Communication_Properties::
        Fan_Out_Policy => Broadcast;
      --Communication_Properties::
        Latency => 0 ms .. 5 ms;
    };
    -- Heart Rate sensor upper limit alarm
    HeartRateUpperLimit : in out event data port PulseOx_Types::Heart_Rate {   -- maximum heart rate
    	--Communication_Properties::
        Fan_Out_Policy=>Broadcast;
        -- the default output rate of 1.0 per dispatch is suffcient
    };
    HeartRateUpperLimitViolated : out event port { -- alarm event published when patient HR above upper limit
      BLESS::Assertion=>"<<HEART_RATE_UPPER_LIMIT_ALARM()>>";
      --Communication_Properties::
        Fan_Out_Policy => Broadcast;
      --Communication_Properties::
        Latency => 0 ms .. 5 ms;
    };
    --====================
    --== Probe Sensor
    --====================
    SensorConnected : out data port BLESS_Types::Boolean {  --sensor is attached to patient
        --Communication_Properties::
        Fan_Out_Policy=>Broadcast;
        --Communication_Properties::
        Output_Rate => [
          Value_Range => 2.0 .. 2.0; -- 500 ms (2x per second)
          Rate_Unit => PerSecond;
          Rate_Distribution => Fixed;
        ];
      };	
    ProbeOff : out event port;  -- alarm indicating sensor became detatched from the patient
    MotionArtifact : out data port BLESS_Types::Boolean {     -- indication of motion noise in sensor reading
        --Communication_Properties::
        Fan_Out_Policy=>Broadcast; -- this is not an alarm, but an indication that
        --Communication_Properties::
        Output_Rate => [           -- the SpO2 reading is corrupted by motion
          Value_Range => 2.0 .. 2.0; -- 500 ms (2x per second)
          Rate_Unit => PerSecond;
          Rate_Distribution => Fixed;
        ];
    };
    
    -- This device (ICEpoInterface) has an example of how we would like defaults for publishers
    -- and alarms to look.  By default, publishers will broadcast their data twice a second (every
    -- 500ms) and alarms will broadcast within 5ms of their dispatch condition occurring.
    
  properties
    --Thread_Properties::
        Dispatch_Protocol => Periodic;
    ----Timing_Properties::
        
        Period => PulseOx_Properties::SpO2_Sampling_Period;
end ICEpoInterface;

device implementation ICEpoInterface.imp
--an implementation of the ICE interface by some pulse oximeterproperties
end ICEpoInterface.imp;

process ICEpoUIprocess
--holds ICEpoUI thread which provides the supervisor user interface
  features
    --====================  
    --== display, touch screen, and alarm buzzer
    --====================  
    Image : out data port;  --user interface image sent to ICE terminal
    Touch : in event data port;  --XY coordinates of center of touch-screen contact
    Sound : out data port;  --audible alarm at ICE terminal
    --====================
    --== SpO2 Sensor inputs and alarm configuration
    --====================
    SpO2 : in event data port PulseOx_Types::Percent { --oxygen saturation from pulse oximeter
        --Communication_Properties::
        Fan_Out_Policy=>Broadcast;
        --Communication_Properties::
        Input_Rate => [
          Value_Range => 2.0 .. 4.0; -- 250 - 500 ms (2-4x per second)
          Rate_Unit => PerSecond;
          Rate_Distribution => Fixed;
        ];
      };
    SpO2LowerLimit : in out event data port PulseOx_Types::Percent { --minimum allowed SpO2
        --Communication_Properties::
        Fan_Out_Policy=>Broadcast;    	
    };
    SpO2LowerLimitViolated : in event port
          {BLESS::Assertion=>"<<SPO2_LOWER_LIMIT_ALARM()>>";}
    ;  --patient SpO2 below lower limit

    --====================
    --== Heart Rate Sensor inputs and alarm configuration
    --====================
    HeartRate : in data port PulseOx_Types::Heart_Rate { -- patient's heart rate
        --Communication_Properties::
        Fan_Out_Policy=>Broadcast;
        --Communication_Properties::
        Input_Rate => [
          Value_Range => 2.0 .. 4.0; -- 250 - 500 ms (2-4x per second)
          Rate_Unit => PerSecond;
          Rate_Distribution => Fixed;
        ];
      };
    HeartRateLowerLimit : in out event data port PulseOx_Types::Heart_Rate { -- minimum heart rate
        --Communication_Properties::
        Fan_Out_Policy=>Broadcast;    	
      };
    HeartRateLowerLimitViolated : in event port  -- heart too slow
      {BLESS::Assertion=>"<<HEART_RATE_LOWER_LIMIT_ALARM()>>";}
      ;
    HeartRateUpperLimit : in out event data port PulseOx_Types::Heart_Rate { -- maximum heart rate
        --Communication_Properties::
        Fan_Out_Policy=>Broadcast;
      };
    HeartRateUpperLimitViolated : in event port  -- heart too fast
      {BLESS::Assertion=>"<<HEART_RATE_UPPER_LIMIT_ALARM()>>";}
      ;
    HeartRateTrend : in data port PulseOx_Types::HeartRateSamples
      {BLESS::Assertion=>"<<HR_TREND()>>";}
      ;  
    --====================
    --== Average SpO2 reading
    --====================
    SpO2MovingAvgWindowSamples : out data port PulseOx_Types::Second_Count{ --user may enter time in minutes and/or seconds, implementation must convert to number of seconds
        --Communication_Properties::
        Fan_Out_Policy=>Broadcast;
      };
      
    SpO2Avg : in data port PulseOx_Types::Percent  --PulseOx_Properties::SpO2_Averaging_Duration average, not including current measurment
      {BLESS::Assertion=>"<<SPO2_AVERAGE()>>";}
      ;
    --====================
    --== App Suppl Oxygen Derived Alarm I/O and configuration
    --====================
    SupplOxyAlarmEnabled : out data port BLESS_Types::Boolean { --patient is using bottled oxygen
      --Communication_Properties::
        Fan_Out_Policy=>Broadcast;
    };  
    SpO2LevelAdj : out data port PulseOx_Types::Percent { -- value used to decrease SpO2 level to obtain "derived" parameter
      --Communication_Properties::
        Fan_Out_Policy=>Broadcast;
    };
    SpO2DerivedLowerLimitAlarm : in event port  -- alarm triggered when patient SpO2  is below average level by SpO2LevelAdj
      {BLESS::Assertion=>"<<SUPPL_O2_ALARM()>>";}
      ;
    --====================
    --== App Adult Rapid SpO2 Decline Derived Alarm I/O and configuration
    --====================
    AdultRapidDeclineAlarmEnabled : out data port BLESS_Types::Boolean { --patient is an adult
      --Communication_Properties::
        Fan_Out_Policy=>Broadcast; --user may enter time in minutes and/or seconds, implementation must convert to number of seconds
    };  
      
    MaxSpO2Decline : out data port PulseOx_Types::Percent {
      --Communication_Properties::
        Fan_Out_Policy=>Broadcast;
    };
    
    RapidSpO2DeclineAlarm : in event port	-- decreasing SpO2 in adult alarm
      {BLESS::Assertion=>"<<RAPID_DECLINE_ALARM()>>";}
      ; --that had higher SpO2	than the rapid decline %
    --====================
    --== Indications of SpO2 measurement anamolies
    --====================
    ProbeOff : in event port;  -- alarm indicating sensor is not connected to patient
    MotionArtifactAlarm : in event data port  --motion artifact longer than PulseOx_Properties::Motion_Artifact_Duration_Limit
      {BLESS::Assertion=>"<<MOTION_ARTIFACT_ALARM()>>";}
      ;
    --====================
    --== Data for SpO2 trending display
    --====================
    SpO2Trend : in data port PulseOx_Types::SpO2Samples
      {BLESS::Assertion=>"<<SPO2_TREND()>>";}
      ;
      
      
    -- This process (ICEpoUIprocess) has an example of how we would like defaults for subscribers
    -- to look.  By default, subscribers will tolerate input rates varying from 4 to 2 times a second
    -- (that is, from every 250 to 400ms) 
    
end ICEpoUIprocess;

process implementation ICEpoUIprocess.imp
  --process implementation holds thread that performs supervisor user interface actions
  subcomponents
    ui : thread ICEpoUI.imp;   --only subcomponent is a thread that runs the user interface
  connections
    ui_image : port ui.Image -> Image;
    ui_touch : port Touch -> ui.Touch;
    ui_sound : port ui.Sound -> Sound;
    ui_spo2 : port SpO2 -> ui.SpO2;
    ui_spo2_ll : port SpO2LowerLimit -> ui.SpO2LowerLimit;
    ui_spo2_llv : port SpO2LowerLimitViolated -> ui.SpO2LowerLimitViolated;
    ui_heartrate : port HeartRate -> ui.HeartRate;
    ui_heartrate_ll : port HeartRateLowerLimit -> ui.HeartRateLowerLimit;
    ui_heartrate_llv : port HeartRateLowerLimitViolated -> ui.HeartRateLowerLimitViolated;
    ui_heartrate_ul : port HeartRateUpperLimit -> ui.HeartRateUpperLimit;
    ui_heartrate_ulv : port HeartRateUpperLimitViolated -> ui.HeartRateUpperLimitViolated;
    ui_heartrate_trend : port HeartRateTrend -> ui.HeartRateTrend;
    ui_suploxyalarmenabled : port ui.SupplOxyAlarmEnabled -> SupplOxyAlarmEnabled;
    ui_spo2leveladj : port ui.SpO2LevelAdj -> SpO2LevelAdj;
    ui_spo2derived_lla : port SpO2DerivedLowerLimitAlarm -> ui.SpO2DerivedLowerLimitAlarm;
    ui_spo2movingaverage : port ui.SpO2MovingAvgWindowSamples -> SpO2MovingAvgWindowSamples;
    ui_spo2avg : port SpO2Avg -> ui.SpO2Avg;
    ui_ardae : port ui.AdultRapidDeclineAlarmEnabled -> AdultRapidDeclineAlarmEnabled;
    ui_maxspo2decline : port ui.MaxSpO2Decline -> MaxSpO2Decline;
    ui_rapiddeclinealarm : port RapidSpO2DeclineAlarm -> ui.RapidSpO2DeclineAlarm;
    ui_probeoff : port ProbeOff -> ui.ProbeOff;
    ui_motionartifactalarm : port MotionArtifactAlarm -> ui.MotionArtifactAlarm;
    ui_spo2trend : port SpO2Trend -> ui.SpO2Trend;
end ICEpoUIprocess.imp;


thread ICEpoUI
--graphical user interface for ICE pulse oximeter
  features
    --====================  
    --== display, touch screen, and alarm buzzer
    --====================  
    Image : out data port;  --user interface image sent to ICE terminal
    Touch : in event data port;  --XY coordinates of center of touch-screen contact
    Sound : out data port;  --audible alarm at ICE terminal
    --====================
    --== SpO2 Sensor inputs and alarm configuration
    --====================
    SpO2 : in event data port PulseOx_Types::Percent;	--oxygen saturation from pulse oximater
    SpO2LowerLimit : in out event data port PulseOx_Types::Percent;  --minimum allowed SpO2
    SpO2LowerLimitViolated : in event port  --patient SpO2 below lower limit
      {BLESS::Assertion=>"<<SPO2_LOWER_LIMIT_ALARM()>>";}
      ;
    --====================
    --== Heart Rate Sensor inputs and alarm configuration
    --====================
    HeartRate : in data port PulseOx_Types::Heart_Rate;  -- patient's heart rate
    HeartRateLowerLimit : in out event data port PulseOx_Types::Heart_Rate;  -- minimum heart rate
    HeartRateLowerLimitViolated : in event port  -- heart too slow
      {BLESS::Assertion=>"<<HEART_RATE_LOWER_LIMIT_ALARM()>>";}
      ;
    HeartRateUpperLimit : in out event data port PulseOx_Types::Heart_Rate;  -- maximum heart rate
    HeartRateUpperLimitViolated : in event port  -- heart too fast
      {BLESS::Assertion=>"<<HEART_RATE_UPPER_LIMIT_ALARM()>>";}
      ;
    HeartRateTrend : in data port PulseOx_Types::HeartRateSamples
      {BLESS::Assertion=>"<<HR_TREND()>>";}
      ;  
    --====================
    --== App Suppl Oxygen Derived Alarm I/O and configuration
    --====================
    SupplOxyAlarmEnabled : out data port BLESS_Types::Boolean;  --patient is using bottled oxygen
    SpO2LevelAdj : out data port PulseOx_Types::Percent;  -- value used to decrease SpO2 level to obtain "derived" parameter
    SpO2DerivedLowerLimitAlarm : in event port  -- alarm triggered when derived patient SpO2 average level is below SpO2LowerLimit
      {BLESS::Assertion=>"<<SUPPL_O2_ALARM()>>";}
      ;
    --====================
    --== Average SpO2 reading
    --====================
    SpO2MovingAvgWindowSamples : out data port PulseOx_Types::Second_Count;
    SpO2Avg : in data port PulseOx_Types::Percent --PulseOx_Properties::SpO2_Averaging_Duration average, not including current measurment
      {BLESS::Assertion=>"<<SPO2_AVERAGE()>>";}
      ;      	
    --====================
    --== App Adult Rapid SpO2 Decline Derived Alarm I/O and configuration
    --====================
    AdultRapidDeclineAlarmEnabled : out data port BLESS_Types::Boolean;  --patient is an adult
    MaxSpO2Decline : out data port PulseOx_Types::Percent;
    RapidSpO2DeclineAlarm : in event port	-- decreasing SpO2 in adult alarm
      {BLESS::Assertion=>"<<RAPID_DECLINE_ALARM()>>";}
      ; --that had higher SpO2	than the rapid decline %
    --====================
    --== Indications of SpO2 measurement anamolies
    --====================
    ProbeOff : in event port;  -- alarm indicating sensor is not connected to patient
    MotionArtifactAlarm : in event data port  --motion artifact longer than PulseOx_Properties::Motion_Artifact_Duration_Limit
      {BLESS::Assertion=>"<<MOTION_ARTIFACT_ALARM()>>";}
      ;
    --====================
    --== Data for SpO2 trending display
    --====================
    SpO2Trend : in data port PulseOx_Types::SpO2Samples
      {BLESS::Assertion=>"<<SPO2_TREND()>>";}
      ;  --for which sample s was the patient's SpO2
  properties
    --Thread_Properties::
        Dispatch_Protocol => Periodic;
    ----Timing_Properties::
        
        Period => PulseOx_Properties::SpO2_Sampling_Period;
end ICEpoUI;

thread implementation ICEpoUI.imp
  --user interface implementation, 
  --usually just reference to source code that implements the user interface
end ICEpoUI.imp;

process ICEpoAppProcess
  --the process holds ICEpoApp thread group which performs "App" functions
  features
    --====================
    --== SpO2 Sensor inputs and alarm configuration
    --====================
    SpO2 : in event data port PulseOx_Types::Percent;	--oxygen saturation from pulse oximater device
    SpO2LowerLimit : in event data port PulseOx_Types::Percent;  -- minimum allowed SpO2 to/from device
    --====================
    --== Heart Rate Sensor inputs and Heart Rate Trending Data
    --====================
    HeartRate : in data port PulseOx_Types::Heart_Rate;  -- patient's heart rate
    HeartRateTrend : out data port PulseOx_Types::HeartRateSamples
      {BLESS::Assertion=>"<<HR_TREND()>>";}
      ;  
    --====================
    --== Indications of SpO2 measurement anamolies
    --====================
    SensorConnected : in data port BLESS_Types::Boolean;  --sensor is attached to patient
    MotionArtifact : in data port BLESS_Types::Boolean;  -- indication of motion noise in sensor reading
    MotionArtifactAlarm : out event data port  --motion artifact longer than PulseOx_Properties::Motion_Artifact_Duration_Limit
      {BLESS::Assertion=>"<<MOTION_ARTIFACT_ALARM()>>";}
      ;
    --====================
    --== Average SpO2 reading
    --====================
    SpO2MovingAvgWindowSamples : in data port PulseOx_Types::Second_Count;
    SpO2Avg : out data port PulseOx_Types::Percent  --PulseOx_Properties::SpO2_Averaging_Duration average, not including current measurment
      {BLESS::Assertion=>"<<SPO2_AVERAGE()>>";}
      ;      	
    --====================
    --== App Suppl Oxygen Derived Alarm I/O and configuration
    --====================
    SupplOxyAlarmEnabled : in data port BLESS_Types::Boolean;   -- enable derived alarm for patient using supplementary oxygen
    SpO2LevelAdj : in data port PulseOx_Types::Percent;  -- value used to decrease SpO2 level to obtain "derived" parameter
    SpO2DerivedLowerLimitAlarm : out event port  -- alarm triggered when derived patient SpO2 average level is below SpO2LowerLimit
      {BLESS::Assertion=>"<<SUPPL_O2_ALARM()>>";}
      ;
    --====================
    --== App Adult Rapid SpO2 Decline Derived Alarm I/O and configuration
    --====================
    AdultRapidDeclineAlarmEnabled : in data port BLESS_Types::Boolean;  -- enabled derived alarm for rapid SpO2 decline in adult patient 
    MaxSpO2Decline : in data port PulseOx_Types::Percent;
    RapidSpO2DeclineAlarm : out event port	-- decreasing SpO2 in adult alarm
      {BLESS::Assertion=>"<<RAPID_DECLINE_ALARM()>>";}
      ; --that had higher SpO2	than the rapid decline %
    --====================
    --== Data for SpO2 trending display
    --====================
    SpO2Trend : out data port PulseOx_Types::SpO2Samples  --one SpO2 reading each minute for the past hour
      {BLESS::Assertion=>"<<SPO2_TREND()>>";}
      ;  
end ICEpoAppProcess;

process implementation ICEpoAppProcess.imp
  --the process holds the thread group which performs "App" functions
  subcomponents
    app : thread group ICEpoApp.imp;
  connections
    ap_spo2 : port SpO2 -> app.SpO2;
    ap_spo2_ll : port SpO2LowerLimit -> app.SpO2LowerLimit;
    ap_heartrate : port HeartRate -> app.HeartRate;
    ap_heartrate_trend : port app.HeartRateTrend -> HeartRateTrend;
    ap_sc : port SensorConnected -> app.SensorConnected;
    ap_ma : port MotionArtifact -> app.MotionArtifact;
    ap_maa : port app.MotionArtifactAlarm -> MotionArtifactAlarm;
    ap_soae : port SupplOxyAlarmEnabled -> app.SupplOxyAlarmEnabled;
    ap_spo2leveladj : port SpO2LevelAdj -> app.SpO2LevelAdj;
    ap_spo2derived_lla : port app.SpO2DerivedLowerLimitAlarm -> SpO2DerivedLowerLimitAlarm;
    ap_ardae : port AdultRapidDeclineAlarmEnabled -> app.AdultRapidDeclineAlarmEnabled;
    ap_maxspo2decline : port MaxSpO2Decline -> app.MaxSpO2Decline;
    ap_rda : port app.RapidSpO2DeclineAlarm -> RapidSpO2DeclineAlarm;
    ap_spo2trend : port app.SpO2Trend -> SpO2Trend;
end ICEpoAppProcess.imp;

thread group ICEpoApp
  --this is the ICE App that controls a pulse oximeter through an ICE interface
  --it has 6 thread components; one each for MotionArtifactThread, SpO2DerivedLowerLimitThread
  -- RapidSpO2DeclineThread, HeartRateTrendThread, SpO2AverageThread and SpO2TrendThread
  features  --same features as containing process ICEpoAppProcess
    --====================
    --== SpO2 Sensor inputs and alarm configuration
    --====================
    SpO2 : in event data port PulseOx_Types::Percent	--oxygen saturation from pulse oximater device
    {
    	  --Communication_Properties::
        Input_Rate => [
    	  	Value_Range => 1.667 .. 3.333; -- 600ms to 300ms
    	  	Rate_Unit => PerSecond;
    	  	Rate_Distribution => Fixed;
    	  ];
    };
    
    SpO2LowerLimit : in event data port PulseOx_Types::Percent;  -- minimum allowed SpO2 to/from device
    --====================
    --== Heart Rate Sensor inputs and Heart Rate Trending Data
    --====================
    HeartRate : in data port PulseOx_Types::Heart_Rate;  -- patient's heart rate
    HeartRateTrend : out data port PulseOx_Types::HeartRateSamples
      {BLESS::Assertion=>"<<HR_TREND()>>";}
      ;  
    --====================
    --== Indications of SpO2 measurement anamolies
    --====================
    SensorConnected : in data port BLESS_Types::Boolean;  --sensor is attached to patient
    MotionArtifact : in data port BLESS_Types::Boolean;  -- indication of motion noise in sensor reading
    MotionArtifactAlarm : out event data port  --motion artifact longer than PulseOx_Properties::Motion_Artifact_Duration_Limit
      {BLESS::Assertion=>"<<MOTION_ARTIFACT_ALARM()>>";}
      ;
    --====================
    --== Average SpO2 reading
    --====================
    SpO2MovingAvgWindowSamples : in data port PulseOx_Types::Second_Count;
    SpO2Avg : out data port PulseOx_Types::Percent  --PulseOx_Properties::SpO2_Averaging_Duration average, not including current measurment
      {BLESS::Assertion=>"<<:=SPO2_AVERAGE()>>";}
      ;      	
    --====================
    --== App Suppl Oxygen Derived Alarm I/O and configuration
    --====================
    SupplOxyAlarmEnabled : in data port BLESS_Types::Boolean;   -- enable derived alarm for patient using supplementary oxygen
    SpO2LevelAdj : in data port PulseOx_Types::Percent;  -- value used to decrease SpO2 level to obtain "derived" parameter
    SpO2DerivedLowerLimitAlarm : out event port  -- alarm triggered when derived patient SpO2 average level is below SpO2LowerLimit
      {BLESS::Assertion=>"<<SUPPL_O2_ALARM()>>";}
      ;
    --====================
    --== App Adult Rapid SpO2 Decline Derived Alarm I/O and configuration
    --====================
    AdultRapidDeclineAlarmEnabled : in data port BLESS_Types::Boolean;  -- enabled derived alarm for rapid SpO2 decline in adult patient 
    MaxSpO2Decline : in data port PulseOx_Types::Percent;
    RapidSpO2DeclineAlarm : out event port	-- decreasing SpO2 in adult alarm
      {BLESS::Assertion=>"<<RAPID_DECLINE_ALARM()>>";}
      ; 
    --====================
    --== Data for SpO2 trending display
    --====================
    SpO2Trend : out data port PulseOx_Types::SpO2Samples  --one SpO2 reading each minute for the past hour
      {BLESS::Assertion=>"<<SPO2_TREND()>>";}
      ;  
end ICEpoApp;

thread group implementation ICEpoApp.imp
  subcomponents
    ma : thread MotionArtifactThread.imp;
    so : thread SupplemetalOxygenThread.imp;
    rd : thread RapidDeclineThread.imp;
    tr : thread SpO2TrendThread.imp;
    hrt : thread HeartRateTrendThread.imp;
    av : thread SpO2AverageThread.imp;
  connections
    scma : port SensorConnected -> ma.SensorConnected;
    scrd : port SensorConnected -> rd.SensorConnected;
    sctr : port SensorConnected -> tr.SensorConnected;
    schr : port SensorConnected -> hrt.SensorConnected;
--    scav : port SensorConnected -> ma.SensorConnected;
    mama : port MotionArtifact -> ma.MotionArtifact;
    mard : port MotionArtifact -> rd.MotionArtifact;
    matr : port MotionArtifact -> tr.MotionArtifact;
    mahr : port MotionArtifact -> hrt.MotionArtifact;
    maav : port MotionArtifact -> av.MotionArtifact;
    maa  : port ma.MotionArtifactAlarm -> MotionArtifactAlarm;
    sptr : port SpO2 -> tr.SpO2;
    sprd : port SpO2 -> rd.SpO2;
    spav : port SpO2 -> av.SpO2;
    avout : port av.SpO2Avg -> SpO2Avg;
    avso : port av.SpO2Avg -> so.SpO2Avg;
    llso : port SpO2LowerLimit -> so.SpO2LowerLimit;
    suso : port SupplOxyAlarmEnabled -> so.SupplOxyAlarmEnabled;
    laso : port SpO2LevelAdj -> so.SpO2LevelAdj;
    soalarm : port so.SpO2DerivedLowerLimitAlarm -> SpO2DerivedLowerLimitAlarm;
    aprd : port AdultRapidDeclineAlarmEnabled -> rd.AdultRapidDeclineAlarmEnabled;
    mxrd : port MaxSpO2Decline -> rd.MaxSpO2Decline;
    rdalarm : port rd.RapidSpO2DeclineAlarm -> RapidSpO2DeclineAlarm;
    sptrend : port tr.SpO2Trend -> SpO2Trend;
    hrpo : port HeartRate -> hrt.HeartRate;
    hrtr : port hrt.HeartRateTrend -> HeartRateTrend;
new_connection: port SpO2MovingAvgWindowSamples -> av.SpO2MovingAvgWindowSamples;
new_connection2: port av.SpO2Avg -> rd.AverageSpO2;
new_connection3: port SensorConnected -> av.SensorConnected;
end ICEpoApp.imp;

thread MotionArtifactThread
  features
    SensorConnected : in data port BLESS_Types::Boolean;  --sensor is attached to patient
    MotionArtifact : in data port BLESS_Types::Boolean;  -- indication of motion noise in sensor reading
    MotionArtifactAlarm : out event data port  --motion artifact longer than PulseOx_Properties::Motion_Artifact_Duration_Limit
      {BLESS::Assertion=>"<<MOTION_ARTIFACT_ALARM()>>";}
      ;
  properties
    --Thread_Properties::
        Dispatch_Protocol => Periodic;  
    ----Timing_Properties::
        
        Period => PulseOx_Properties::SpO2_Sampling_Period;
    ----Timing_Properties::
        
        Deadline => PulseOx_Properties::SpO2_Sampling_Period;
    --Timing_Properties::
        Compute_Execution_Time => 0 ms .. 5 ms;
    -- This is the default set of properties we expect a thread to have.  Note the period is equal to the deadline,
    -- and the execution time is quite short.
end MotionArtifactThread;

thread implementation MotionArtifactThread.imp
annex BLESS 
{**
assert
  <<NUMBAD: :all j~quantity whole in 0 .. (numBadReadings - 1) are MOTION_ARTIFACT^(-j) or not SENSOR_CONNECTED^(-j)>>	
invariant   
  <<MOINV: :all j~quantity whole 
        in 1 ..numBadReadings are MOTION_ARTIFACT^(-j) or not SENSOR_CONNECTED^(-j)>>      
variables numBadReadings~quantity whole := 0;  
states
  start : initial state <<numBadReadings=0>>;
  run : complete state <<MOINV()>>;
  halt : final state;
transitions
  mat0 : start-[ ]->run{};
  mat1 : run-[on dispatch]->run
    { <<MOINV()>> 
    if 
      --good SpO2 reading, reset counter
      (SensorConnected? and not MotionArtifact?)~>
      <<SensorConnected^0 and not MotionArtifact^0>>
      numBadReadings := 0 
      <<NUMBAD()>>
    []  --bad SpO2, not enough bad reading to alarm
      (MotionArtifact? or not SensorConnected?)~>
      <<all j~quantity whole in 0 .. numBadReadings are MotionArtifact^(-j) or not SensorConnected^(-j)>> 
      numBadReadings :=numBadReadings+1 
      <<NUMBAD()>>
    fi
    <<NUMBAD()>>
    ;
    if
    ((numBadReadings - 1) < #PulseOx_Properties::Motion_Artifact_Sample_Limit)~>
      <<NUMBAD()>> skip <<NUMBAD()>>
    [] --bad SpO2 and more than enough to alarm
      ((numBadReadings - 1) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit)~>
         <<NUMBAD() and ((numBadReadings - 1) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit)>>
        MotionArtifactAlarm!  
         <<NUMBAD()>>
    fi  
    <<NUMBAD()>>
    }; 
  mat2 : run-[on dispatch stop]->halt{};
**};
end MotionArtifactThread.imp;

thread SpO2AverageThread
  features
    SpO2 : in data port PulseOx_Types::Percent;  --oxygen saturation from pulse oximeter device
    SensorConnected : in data port BLESS_Types::Boolean;  --sensor is attached to patient
    MotionArtifact : in data port BLESS_Types::Boolean;  -- indication of motion noise in sensor reading
    SpO2MovingAvgWindowSamples : in data port PulseOx_Types::Second_Count
      {BLESS::Assertion=>"<<SpO2MovingAvgWindowSamples>1>>";}
      ;
    SpO2Avg : out data port PulseOx_Types::Percent  
      {BLESS::Assertion=>"<<:=SPO2_AVERAGE()>>";}
      ;
    Error : out event port;		--an error occurred  
  properties
    --Thread_Properties::
        Dispatch_Protocol => Periodic;
    --Timing_Properties::
        Deadline => 50 ms;
    --Timing_Properties::
        Period => PulseOx_Properties::SpO2_Sampling_Period;
    --Timing_Properties::
        Compute_Execution_Time => 0 ms .. 5 ms;
end SpO2AverageThread;


thread implementation SpO2AverageThread.imp
annex BLESS 
{**
  assert
    --shorthand used for conditional expression of SpO2 sample quality used often
    <<SSQ:x~quantity whole returns quantity percent := (if SensorConnected^(x) and 
    	not MotionArtifact^(x) then SpO2^(x) else 0)>>
    <<AXIOM_LB: :lb<(lb+1)>>  --used to contract universal quantification
----    <<AXIOM_UB: :ub=(lb+SpO2MovingAvgWindowSamples)>>	
	<<AXIOM_K2I: :((sum k~quantity whole in lb .. (ub - 1) of (if SensorConnected^(k-ub) and not MotionArtifact^(k-ub) then SpO2^(k-ub) else 0))/
		(numberof k~quantity whole in lb .. (ub - 1) that (SensorConnected^(k-ub) and not MotionArtifact^(k-ub))))
	  = ((sum i~quantity whole in -SpO2MovingAvgWindowSamples .. -1 of (if SensorConnected^i and not MotionArtifact^i then SpO2^i else 0))/
		(numberof i~quantity whole in -SpO2MovingAvgWindowSamples .. -1 that (SensorConnected^(i) and not MotionArtifact^(i))))>> 
   invariant
    <<INV_AV: :WINDOW() and TOTAL_SPO2() and GOOD() and GS()>>
  variables
--  --    max_samples~quantity whole := (#PulseOx_Properties::Max_Window_Samples - 1); 
    window_size~quantity whole := SpO2MovingAvgWindowSamples 
      <<AXIOM_WS: :window_size=SpO2MovingAvgWindowSamples>>;
    spo2_hist ~ array [0 .. #PulseOx_Properties::Max_Window_Samples] of quantity whole  --holds SpO2 history
      <<WINDOW: : all k~quantity whole in lb .. (ub - 1) 
    	  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub))>>;
    goodSamp ~  array [0 .. #PulseOx_Properties::Max_Window_Samples] of boolean --holds whether previous sample was valid
      <<GS: :all k~quantity whole in lb .. (ub - 1) 
    	  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff
    	   (SensorConnected^(k-ub) and not MotionArtifact^(k-ub))>>;
    ub~quantity whole :=0;  --location of most recent SpO2 reading, upper bound of range of average and storage
    lb~quantity whole :=0;  --location of oldest sample in window
    totalSpO2~quantity whole :=0  --running total
      <<TOTAL_SPO2: :totalSpO2=(sum k~quantity whole in lb .. (ub - 1) of SSQ(k - ub))>>;
    goodCount~quantity whole :=0  --count of good SpO2 in the window
      <<GOOD: :goodCount=(numberof k~quantity whole in lb .. (ub - 1) 
      	that (SensorConnected^(k-ub) and not MotionArtifact^(k-ub)))>>;
    numSamplesInWindow~quantity whole := 0;
    oldestSample~quantity whole := 0;
  states
    start : initial state
      <<(numSamplesInWindow=0) and (ub=0) and (oldestSample=0) 
       and (totalSpO2=0) and (lb=0) and (goodCount=0)>>;
    fillingWindow : complete state 
      <<FW: :((ub-lb)<window_size) and INV_AV() >>;
    chooseToRun : state 
      <<CTR: :(all k~quantity whole in lb..(ub - 1) 
    	  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k-(ub - 1))) and
    	(totalSpO2=(sum k~quantity whole in lb..(ub - 1) of SSQ(k-(ub- 1)))) and
    	(goodCount=(numberof k~quantity whole in lb..(ub - 1) 
      	  that (SensorConnected^(k-(ub- 1)) and not MotionArtifact^(k-(ub- 1))))) and
      	(all k~quantity whole in lb..(ub - 1) 
    	  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff
    	   (SensorConnected^(k-(ub- 1)) and not MotionArtifact^(k-(ub- 1))))>>;
    run : complete state
      <<RUN_AV: :INV_AV()  and ((ub-lb)=window_size)>>;
    halt : final state;  --normal termination
    fail : final state;  --failure termination
  transitions
    SpAT0: start-[(ub-lb)<window_size]->fillingWindow
      {|ub',lb',window_size':=ub,lb,window_size|};  --copy current values to next period
    SpAT0a: start-[(ub-lb)>=window_size]->fail
      {|ub',lb',window_size':=ub,lb,window_size|};  --copy current values to next period
    SpAT1: fillingWindow-[on dispatch]->chooseToRun
      { <<FW()>> 
      {
    	<<FW()>>
    	--store current sample
    	spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] := 
    	  (if SensorConnected? and not MotionArtifact? then SpO2? else 0)
    	  <<WINDOW() and (spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x:0))>>  --add parameter to SSQ because for some reason it won't substitute with 0
    	&  --update total
    	totalSpO2:=totalSpO2+(if SensorConnected? and not MotionArtifact? then SpO2? else 0)
    	  <<totalSpO2=(SSQ(x:0)+(sum k~quantity whole in lb..(ub - 1) of SSQ(k-ub) ))>>
    	&  --update count of valid SpO2 readings
    	goodCount:=(goodCount+(if SensorConnected? and not MotionArtifact? then 1 else 0))
    	  <<goodCount=((if SensorConnected^0 and not MotionArtifact^0 then 1 else 0)+
    	  	(numberof k~quantity whole in lb..(ub - 1) 
      	      that (SensorConnected^(k-ub) and not MotionArtifact^(k-ub))))>>
      	&  --store whether current SpO2 reading is valid
      	goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := 
      	   (SensorConnected? and not MotionArtifact?)
      	  <<(goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (SensorConnected^0 and not MotionArtifact^0))
      	    and GS()>>  
      } 
        <<(all k~quantity whole in lb..ub 
    		are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k-ub)) and
    	(totalSpO2=(sum k~quantity whole in lb..ub of SSQ(k-ub))) and
    	(goodCount=(numberof k~quantity whole in lb..ub 
      	  that (SensorConnected^(k-ub) and not MotionArtifact^(k-ub)))) and
      	(all k~quantity whole in lb..ub 
    	  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff
    	   (SensorConnected^(k-ub) and not MotionArtifact^(k-ub)))>>
      ;
      --increment upper bound
      ub := ub+1 
        <<(all k~quantity whole in lb..(ub - 1) 
    	  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k-(ub- 1))) and
    	(totalSpO2=(sum k~quantity whole in lb..(ub - 1) of SSQ(k-(ub- 1)))) and
    	(goodCount=(numberof k~quantity whole in lb..(ub - 1) 
      	  that (SensorConnected^(k-(ub- 1)) and not MotionArtifact^(k-(ub- 1))))) and
      	(all k~quantity whole in lb..(ub - 1) 
    	  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff
    	   (SensorConnected^(k-(ub- 1)) and not MotionArtifact^(k-(ub- 1))))>>
      };  --end of SpAt1
    SpAT2: chooseToRun-[(ub-lb)<window_size]->fillingWindow  --still fewer samples than window size
      {|ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist'
      	  :=ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|};
    SpAT3: chooseToRun-[(ub-lb)=window_size]->run  --enough samples to fill window
      {|ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist'
      	  :=ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|};
    SpAT3a: chooseToRun-[(ub-lb)>window_size]->fail  --error
      {|ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist'
      	  :=ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|};
    SpAt4: run-[on dispatch]->run
      {   <<RUN_AV()>>
      if  --output average if there have been valid SpO2 readings
      (goodCount>0)~>
      	  <<RUN_AV() and (goodCount>0) and AXIOM_K2I()>>
        SpO2Avg!(totalSpO2/goodCount)
            <<RUN_AV()>>
      []  --otherwise skip
      (goodCount<=0)~> <<RUN_AV()>> skip <<RUN_AV()>>
      fi        
      ;	    
          <<RUN_AV() and AXIOM_LB()>>
      {
    	  <<all k~quantity whole in (lb+1) ..(ub - 1) 
    	    are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k-ub)>>	
    	--store current sample
    	spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] := 
    	   (if SensorConnected? and not MotionArtifact? then SpO2? else 0)
    	  <<(all k~quantity whole in (lb+1) ..(ub - 1) 
    	      are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k-ub)) and
    	    (spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x:0))>>
    	&  --update total
    	  <<(totalSpO2=(SSQ(lb-ub)+(sum k~quantity whole in (lb+1) ..(ub - 1) of SSQ(k-ub)))) and
    	    (spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] = SSQ(lb-ub)) and 
    	    ((ub-lb)=window_size)>>
    	totalSpO2 := (totalSpO2+(if SensorConnected? and not MotionArtifact? then SpO2? else 0))
    	     -spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
    	  <<(totalSpO2=(SSQ(x:0)+(sum k~quantity whole in (lb+1) ..(ub - 1) of SSQ(k-ub)))) and ((ub-lb)=window_size)>>
    	&  --update count of valid SpO2 readings
    	  <<(goodCount=((if SensorConnected^(lb-ub) and not MotionArtifact^(lb-ub) then 1 else 0)+
    	  	(numberof k~quantity whole in (lb+1) ..(ub - 1) 
      	      that (SensorConnected^(k-ub) and not MotionArtifact^(k-ub))))) and
      	    ((SensorConnected^(lb-ub) and not MotionArtifact^(lb-ub)) iff 
      	    	goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples])  >>
    	goodCount := (goodCount + (if (SensorConnected? and not MotionArtifact?) then 1 else 0))
    	     -(if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] then 1 else 0)
    	  <<goodCount=(((if SensorConnected^0 and not MotionArtifact^0 then 1 else 0)+
    	  	(numberof k~quantity whole in lb..(ub - 1) 
      	      that (SensorConnected^(k-ub) and not MotionArtifact^(k-ub))))
      	      -(if SensorConnected^(lb-ub) and not MotionArtifact^(lb-ub) then 1 else 0))>>
      	&  --store whether current SpO2 reading is valid
      	  <<GS()>>
      	goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := 
      	   (SensorConnected? and not MotionArtifact?)
      	  <<(goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (SensorConnected^0 and not MotionArtifact^0))
      	    and GS() and AXIOM_LB()>>  
      } 
        <<(all k~quantity whole in (lb+1) ..ub 
    		are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k-ub)) and
    	  (totalSpO2=(sum k~quantity whole in (lb+1) ..ub of SSQ(k-ub))) and ((ub-lb)=window_size) and
    	  (goodCount=(numberof k~quantity whole in (lb+1) ..ub that (SensorConnected^(k-ub) and not MotionArtifact^(k-ub)))) and
    	  (all k~quantity whole in (lb+1) ..ub 
    	    are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff
    	      (SensorConnected^(k-ub) and not MotionArtifact^(k-ub)))>>
      ;
      --increment upper bound and lower bound, copy window size, total SpO2, and count of good samples
      |ub,lb,window_size',totalSpO2',goodCount':=ub+1,lb+1,window_size,totalSpO2,goodCount|
        <<(all k~quantity whole in lb..(ub - 1) 
    	  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k-(ub- 1))) and
    	  (totalSpO2'=(sum k~quantity whole in lb..(ub - 1) of SSQ(k-(ub- 1))))  and (((ub- 1) - (lb- 1))=window_size') and
    	  (goodCount'=(numberof k~quantity whole in lb .. (ub - 1) that 
    	  	(SensorConnected^(k-(ub- 1)) and not MotionArtifact^(k-(ub- 1)))
    	  )) and
    	  (all k~quantity whole in lb..(ub - 1) 
    	    are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff
    	      (SensorConnected^(k-(ub- 1)) and not MotionArtifact^(k-(ub- 1))))>>
      ;
      |spo2_hist',goodSamp',ub',lb':=spo2_hist,goodSamp,ub,lb|
        <<(all k~quantity whole in lb..(ub - 1) 
    	  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' = SSQ(k-(ub- 1))) and
    	  (totalSpO2' = (sum k~quantity whole in lb..(ub - 1) of SSQ(k-(ub- 1))))  and (((ub'- 1) - (lb'- 1))=window_size') and
    	  (goodCount' =(numberof k~quantity whole in lb .. (ub - 1) that (SensorConnected^(k-(ub- 1)) and not MotionArtifact^(k-(ub- 1))))) and
    	  (all k~quantity whole in lb..(ub - 1) 
    	    are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]' iff
    	      (SensorConnected^(k-(ub- 1)) and not MotionArtifact^(k-(ub- 1))))>>
      };  --end of SpAt4     
    SpATstop: fillingWindow,run-[on dispatch stop]->halt{};     
**};
end SpO2AverageThread.imp;

thread SupplemetalOxygenThread
  features
    SpO2Avg : in data port PulseOx_Types::Percent	--oxygen saturation average from SpO2AverageThread
      {BLESS::Assertion=>"<<:=SPO2_AVERAGE()>>";}
      ;
    SpO2LowerLimit : in event data port PulseOx_Types::Percent;  -- minimum allowed SpO2 to/from device
    SupplOxyAlarmEnabled : in data port BLESS_Types::Boolean;   -- enable derived alarm for patient using supplementary oxygen
    SpO2LevelAdj : in data port PulseOx_Types::Percent;  -- value used to decrease SpO2 level to obtain "derived" parameter
    SpO2DerivedLowerLimitAlarm : out event port  -- alarm triggered when derived patient SpO2 level is below SpO2LowerLimit
      {BLESS::Assertion=>"<<SUPPL_O2_ALARM()>>";}
      ;
  properties
    --Thread_Properties::
        Dispatch_Protocol => Periodic;  
    --Timing_Properties::
        Period => PulseOx_Properties::SpO2_Sampling_Period;
end SupplemetalOxygenThread;

thread implementation SupplemetalOxygenThread.imp
annex BLESS 
{**
  invariant <<true>>  --there is no persistent state
  states
    start : initial state;
    run : complete state;
    check : state;
    halt : final state;  --normal termination
  transitions
    so0: start-[ ]->run{};
    so1: run-[on dispatch]->check{};
    so2: check-[SupplOxyAlarmEnabled? and (SpO2Avg? < (SpO2LowerLimit?+SpO2LevelAdj?))]->run
      {<<SUPPL_O2_ALARM()>> SpO2DerivedLowerLimitAlarm!};
    so3: check-[not SupplOxyAlarmEnabled? or (SpO2Avg? >= (SpO2LowerLimit?+SpO2LevelAdj?))]->run{};
    so4: run-[on dispatch stop]->halt{};
**};
end SupplemetalOxygenThread.imp;


thread RapidDeclineThread
  features
    SpO2 : in data port PulseOx_Types::Percent;  --oxygen saturation from pulse oximater device
    SensorConnected : in data port BLESS_Types::Boolean;  --sensor is attached to patient
    MotionArtifact : in data port BLESS_Types::Boolean;  -- indication of motion noise in sensor reading
    AdultRapidDeclineAlarmEnabled : in data port BLESS_Types::Boolean;  -- enabled derived alarm for rapid SpO2 decline in adult patient 
    MaxSpO2Decline : in data port PulseOx_Types::Percent;
    AverageSpO2 : in data port PulseOx_Types::Percent
      {BLESS::Assertion=>"<<:=SPO2_AVERAGE()>>";};
    RapidSpO2DeclineAlarm : out event port	-- decreasing SpO2 in adult alarm
      {BLESS::Assertion=>"<<RAPID_DECLINE_ALARM()>>";}
      ; --that had higher SpO2	than the rapid decline %
  properties
    --Thread_Properties::
        Dispatch_Protocol => Periodic;  
    --Timing_Properties::
        Period => PulseOx_Properties::SpO2_Sampling_Period;
end RapidDeclineThread;

thread implementation RapidDeclineThread.imp
annex BLESS 
{**
  assert
    <<HOLD_RD:n~quantity whole:all s~quantity whole in 1 ..n --holds current values for SpO2; spo2[1]=SpO2^0
         are spo2[s]=SpO2^(1-s)>>
  invariant 
    <<SpO2_RD: :all s~quantity whole in 1 ..num_samples 
         are spo2[s]=SpO2^(-s)>>  
  variables
    nts~quantity whole := #PulseOx_Properties::Max_Window_Samples;
    spo2 ~  array [1 .. #PulseOx_Properties::Max_Window_Samples] of quantity percent;  --:=0;  --holds SpO2 history
    spo2_nxt ~ array [1 .. #PulseOx_Properties::Max_Window_Samples] of quantity percent; --:=0;  --temporary copy of trend for next output
    num_samples~quantity whole:=0;  --counts samples while filling      
  states
    start : initial state 
      <<(num_samples<#PulseOx_Properties::Max_Window_Samples) and (num_samples=0)>>;
    fill : complete state  --loading spo2
      <<SpO2_RD() and (num_samples < #PulseOx_Properties::Max_Window_Samples)>>;    
    check : state  --check if full
      <<HOLD_RD(num_samples)>>;
    run : complete state    
      <<SpO2_RD() and (num_samples = #PulseOx_Properties::Max_Window_Samples)>>;    
    halt : final state;  
  transitions
    rdt0: start -[ ]-> fill{|spo2',num_samples':=spo2,num_samples|};
    rdt1: fill-[on dispatch]->check
    {
      <<SpO2_RD() and (num_samples < #PulseOx_Properties::Max_Window_Samples)>>
      forall i in 1 .. num_samples
        {
          <<spo2[i]=SpO2^(-i)>>
        spo2_nxt[i+1]:=spo2[i] --shift old samples
          <<spo2_nxt[i+1]=SpO2^(-i)>>
        }
      <<SHFT_RD: :all i~quantity whole in 1 ..num_samples 
         are spo2_nxt[i+1]=SpO2^(-i)>>
      ;  
          spo2_nxt[1]:=SpO2?
        <<(spo2_nxt[1]=SpO2^0) and
          (all i~quantity whole in 2 ..(num_samples+1) are spo2_nxt[i]=SpO2^(1-i))>>
      ;    
      num_samples:=num_samples+1  --increment count of samples
      <<all i~quantity whole in 1 ..num_samples are spo2_nxt[i]=SpO2^(1-i)>>
      ;
      forall i in 1 ..num_samples
        {
          <<spo2_nxt[i]=SpO2^(1-i)>>
        spo2[i]:=spo2_nxt[i] --copy back
          <<spo2[i]=SpO2^(1-i)>>
        }
      <<all i~quantity whole in 1 ..num_samples are spo2[i]=SpO2^(1-i)>>
      };
   chk: check -[num_samples < #PulseOx_Properties::Max_Window_Samples]-> fill
     {|spo2',num_samples':=spo2,num_samples|};  
   chk2: check -[num_samples = #PulseOx_Properties::Max_Window_Samples]-> run
     {|spo2',num_samples':=spo2,num_samples|}; 
   chk3: check -[num_samples > #PulseOx_Properties::Max_Window_Samples]-> halt{};
   
--  rdt1: run -[on dispatch]-> run
--    {
--    if
--    (AdultRapidDeclineAlarmEnabled? and SensorConnected? and not MotionArtifact?
--      and ((SpO2? + MaxSpO2Decline?) < AverageSpO2?))~> 
--        <<RAPID_DECLINE_ALARM()>>
--      RapidSpO2DeclineAlarm! 
--    []
--    (not (AdultRapidDeclineAlarmEnabled? and SensorConnected? and not MotionArtifact?
--      and ((SpO2? + MaxSpO2Decline?) < AverageSpO2?)) )~>
--      skip
--    fi
--    };
--  rdt2: run -[on dispatch stop]-> halt{};
**};
end RapidDeclineThread.imp;

thread SpO2TrendThread
  features
    SpO2 : in event data port PulseOx_Types::Percent;	--oxygen saturation from pulse oximeter device
    SensorConnected : in data port BLESS_Types::Boolean;  --sensor is attached to patient
    MotionArtifact : in data port BLESS_Types::Boolean;  -- indication of motion noise in sensor reading
    SpO2Trend : out data port PulseOx_Types::SpO2Samples  --one SpO2 reading each minute for the past hour
      {BLESS::Assertion=>"<<SPO2_TREND()>>";}
         ;  
    NumSamples : out data port BLESS_Types::Integer
      {BLESS::Assertion=>"<<:=num_samples>>";}
      ;
  properties
    --Thread_Properties::
        Dispatch_Protocol => Periodic;  
    --Timing_Properties::
        Period => PulseOx_Properties::Time_Between_Trending_Samples;
end SpO2TrendThread;

thread implementation SpO2TrendThread.imp
annex BLESS 
{**
  assert
    <<HOLD:n~quantity whole: all s~quantity whole in 1 ..n --holds current values for SpO2; spo2[1]=SpO2^0
         are spo2[s]=(if MotionArtifact^(1-s) or not SensorConnected^(1-s) then 0 else SpO2^(1-s))>>
  invariant 
    <<SpO2_INV: :all s~quantity whole in 1 ..num_samples 
         are spo2[s]=(if MotionArtifact^(-s) or not SensorConnected^(-s) then 0 else SpO2^(-s))>>  
  variables
    nts~quantity whole :=#PulseOx_Properties::Num_Trending_Samples;
    spo2 ~  array [1 .. #PulseOx_Properties::Num_Trending_Samples] of quantity percent; -- := 0;  --holds SpO2 history
    spo2_nxt ~ array [1 .. #PulseOx_Properties::Num_Trending_Samples] of quantity percent; -- := 0;  --temporary copy of trend for next output
    num_samples~quantity whole := 0;  --counts samples while filling
  states
    start : initial state
      <<(num_samples<#PulseOx_Properties::Num_Trending_Samples) and (num_samples=0) and
        (all s~quantity whole in (num_samples+1) .. #PulseOx_Properties::Num_Trending_Samples
         	are not SensorConnected^(-s))>>;
    loading : complete state  --loading spo2
      <<SpO2_INV() and (num_samples<#PulseOx_Properties::Num_Trending_Samples)>>;    
    check : state  --check if full
      <<HOLD(num_samples)>>;
    run : complete state   --full spo2
      <<SpO2_INV() and (num_samples=#PulseOx_Properties::Num_Trending_Samples)>>;    
    halt : final state;  --normal termination
    fail : final state;  --error termination
  transitions
    sptt0: start-[ ]->loading{};
    sptt1: loading-[on dispatch]->check
      {
        <<SpO2_INV() and (num_samples < #PulseOx_Properties::Num_Trending_Samples)>>
      SpO2Trend!(spo2)  --put out new SpO2 trend for ui
      ;
        <<SpO2_INV() and (num_samples < #PulseOx_Properties::Num_Trending_Samples)>>
      NumSamples!(num_samples)
      ;
        <<SpO2_INV() and (num_samples < #PulseOx_Properties::Num_Trending_Samples)>>
      forall i in 1 ..num_samples
        {
          <<spo2[i]=(if MotionArtifact^(-i) or not SensorConnected^(-i) then 0 else SpO2^(-i))>>
        spo2_nxt[i+1]:=spo2[i] --shift old samples
          <<spo2_nxt[i+1]=(if MotionArtifact^(-i) or not SensorConnected^(-i) then 0 else SpO2^(-i))>>
        }
      <<SHFT: :all i~quantity whole in 1 ..num_samples 
         are spo2_nxt[i+1]=(if MotionArtifact^(-i) or not SensorConnected^(-i) then 0 else SpO2^(-i))>>
      ;  
      if
        (MotionArtifact? or not SensorConnected?)~>
            <<SHFT() and (MotionArtifact^0 or not SensorConnected^0)>>
          spo2_nxt[1]:=0  --bad sample
            <<SHFT() and (MotionArtifact^0 or not SensorConnected^0)
               and (spo2_nxt[1]=(if MotionArtifact^0 or not SensorConnected^0 then 0 else SpO2^0))>>
      []
        (not (MotionArtifact? or not SensorConnected?))~>
             <<SHFT() and not (MotionArtifact^0 or not SensorConnected^0)>>
          spo2_nxt[1]:=SpO2?  --add current sample
            <<SHFT() and not (MotionArtifact^0 or not SensorConnected^0)
               and (spo2_nxt[1]=(if MotionArtifact^0 or not SensorConnected^0 then 0 else SpO2^0))>>
      fi    
        <<(spo2_nxt[1]=(if MotionArtifact^0 or not SensorConnected^0 then 0 else SpO2^0)) and
          (all i~quantity whole in 2 .. (num_samples+1) are 
          	spo2_nxt[i]=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else SpO2^(1-i)))>>
      ;    
      num_samples:=num_samples+1  --increment count of samples
      <<all i~quantity whole in 1 ..num_samples are spo2_nxt[i]=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else SpO2^(1-i))>>
      ;
      forall i in 1 ..num_samples
        {
          <<spo2_nxt[i]=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else SpO2^(1-i))>>
        spo2[i]:=spo2_nxt[i] --copy back
          <<spo2[i]=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else SpO2^(1-i))>>
        }
      <<all i~quantity whole in 1 ..num_samples are spo2[i]=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else SpO2^(1-i))>>
      };
    sptt2a: check-[num_samples<#PulseOx_Properties::Num_Trending_Samples]->loading
      {|spo2',num_samples':=spo2,num_samples|};
    sptt2b: check-[num_samples=#PulseOx_Properties::Num_Trending_Samples]->run
      {|spo2',num_samples':=spo2,num_samples|};
    sptt2c: check-[num_samples>#PulseOx_Properties::Num_Trending_Samples]->fail{};
    sptt3: run-[on dispatch]->run
      {
        <<SpO2_INV() and (num_samples=#PulseOx_Properties::Num_Trending_Samples)>>
      SpO2Trend!(spo2)  --put out new SpO2 trend for ui
      ;
        <<SpO2_INV() and (num_samples=#PulseOx_Properties::Num_Trending_Samples)>>
      NumSamples!(num_samples)
      ;
        <<SpO2_INV() and (num_samples=#PulseOx_Properties::Num_Trending_Samples)
          and AXIOM_CR()>>
      forall i in 1 .. (num_samples - 1)
        {
          <<spo2[i]=(if MotionArtifact^(-i) or not SensorConnected^(-i) then 0 else SpO2^(-i))>>
        spo2_nxt[i+1]:=spo2[i] --shift old samples
          <<spo2_nxt[i+1]=(if MotionArtifact^(-i) or not SensorConnected^(-i) then 0 else SpO2^(-i))>>
        }
        <<SHFTR: :(all i~quantity whole in 1 .. (num_samples - 1) 
        	are spo2_nxt[i+1]=(if MotionArtifact^(-i) or not SensorConnected^(-i) then 0 else SpO2^(-i)))
          and (num_samples=#PulseOx_Properties::Num_Trending_Samples)>>
      ;  
      if
        (MotionArtifact? or not SensorConnected?)~>
            <<SHFTR() and (MotionArtifact^0 or not SensorConnected^0)>>
          spo2_nxt[1]:=0  --bad sample
            <<SHFTR() and (MotionArtifact^0 or not SensorConnected^0)
               and (spo2_nxt[1]=(if MotionArtifact^0 or not SensorConnected^0 then 0 else SpO2^0))>>
      []
        (not (MotionArtifact? or not SensorConnected?))~>
             <<SHFTR() and not (MotionArtifact^0 or not SensorConnected^0)>>
          spo2_nxt[1]:=SpO2?  --add current sample
            <<SHFTR() and not (MotionArtifact^0 or not SensorConnected^0)
               and (spo2_nxt[1]=(if MotionArtifact^0 or not SensorConnected^0 then 0 else SpO2^0))>>
      fi    
        <<(spo2_nxt[1]=(if MotionArtifact^0 or not SensorConnected^0 then 0 else SpO2^0)) and 
          (num_samples=#PulseOx_Properties::Num_Trending_Samples) and
          (all i~quantity whole in 2 ..num_samples 
          	 are spo2_nxt[i]=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else SpO2^(1-i)))>>
      ;
      forall i in 1 ..num_samples
        {
          <<spo2_nxt[i]=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else SpO2^(1-i))>>
        spo2[i]':=spo2_nxt[i] --copy back
          <<spo2[i]'=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else SpO2^(1-i))>>
        }
      <<(all i~quantity whole in 1 ..num_samples 
      	  are spo2[i]'=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else SpO2^(1-i)))
         and (num_samples=#PulseOx_Properties::Num_Trending_Samples)>> 
      ;
      num_samples':=num_samples  	
      <<(all i~quantity whole in 1 ..num_samples 
      	  are spo2[i]'=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else SpO2^(1-i)))
         and (num_samples'=#PulseOx_Properties::Num_Trending_Samples)>> 
      };
    sptt4: loading,run-[on dispatch stop]->halt{};    
**};
end SpO2TrendThread.imp;

thread HeartRateTrendThread
  features
    HeartRate : in data port PulseOx_Types::Heart_Rate;	--oxygen saturation from pulse oximater device
    SensorConnected : in data port BLESS_Types::Boolean;  --sensor is attached to patient
    MotionArtifact : in data port BLESS_Types::Boolean;  -- indication of motion noise in sensor reading
    HeartRateTrend : out data port PulseOx_Types::HeartRateSamples  --one HeartRate reading each minute for the past half-hour
      {BLESS::Assertion=>"<<HR_TREND()>>";}
         ;  
    NumSamples : out data port Base_Types::Integer
      {BLESS::Assertion=>"<<:= NUM_SAMPLES>>";};
  properties
    --Thread_Properties::
        Dispatch_Protocol => Periodic;
    --Timing_Properties::
        Period => PulseOx_Properties::Time_Between_Trending_Samples;
end HeartRateTrendThread;

thread implementation HeartRateTrendThread.imp
annex BLESS 
{**
  assert
    <<HOLD_HR:n~quantity whole:all s~quantity whole in 1 ..n --holds current values for HeartRate; heart_rate[1]=HeartRate^0
         are heart_rate[s]=(if MotionArtifact^(1-s) or not SensorConnected^(1-s) then 0 else HeartRate^(1-s))>>
  invariant 
    <<INV_HR: :all s~quantity whole in 1 ..num_samples 
         are heart_rate[s]=(if MotionArtifact^(-s) or not SensorConnected^(-s) then 0 else HeartRate^(-s))>>  
  variables
    nts~quantity whole:=#PulseOx_Properties::Num_Trending_Samples;
    heart_rate ~ array [1 .. #PulseOx_Properties::Num_Trending_Samples] of quantity percent; --:=0;  --holds HeartRate history
    hr_nxt ~ array [1 .. #PulseOx_Properties::Num_Trending_Samples] of quantity percent;  --:=0;  --temporary copy of trend for next output
    num_samples ~quantity whole:=0;  --counts samples while filling
  states
    start : initial state
      <<(num_samples<#PulseOx_Properties::Num_Trending_Samples) and (num_samples=0) and
        (all s~quantity whole in (num_samples+1) .. #PulseOx_Properties::Num_Trending_Samples
         	are not SensorConnected^(-s))>>;
    fill : complete state  --loading heart_rate
      <<INV_HR() and (num_samples<#PulseOx_Properties::Num_Trending_Samples)>>;    
    check : state  --check if full
      <<HOLD_HR(num_samples)>>;
    run : complete state   --full heart_rate
      <<INV_HR() and (num_samples=#PulseOx_Properties::Num_Trending_Samples)>>;    
    halt : final state;  --normal termination
    fail : final state;  --error termination
  transitions
    hrtt0: start-[ ]->fill{|nts',heart_rate',hr_nxt',num_samples':=nts,heart_rate,hr_nxt,num_samples|};
    hrtt1: fill-[on dispatch]->check
      {
        <<INV_HR() and (num_samples<#PulseOx_Properties::Num_Trending_Samples)>>
      HeartRateTrend!(heart_rate)  --put out new HeartRate trend for ui
      ;
        <<INV_HR() and (num_samples<#PulseOx_Properties::Num_Trending_Samples)>>
      NumSamples!(num_samples)
      ;
        <<INV_HR() and (num_samples<#PulseOx_Properties::Num_Trending_Samples)>>
      forall i in 1 ..num_samples
        {
          <<heart_rate[i]=(if MotionArtifact^(-i) or not SensorConnected^(-i) then 0 else HeartRate^(-i))>>
        hr_nxt[i+1]:=heart_rate[i] --shift old samples
          <<hr_nxt[i+1]=(if MotionArtifact^(-i) or not SensorConnected^(-i) then 0 else HeartRate^(-i))>>
        }
        <<SHFT_HR: :all i~quantity whole in 1 ..num_samples 
         are hr_nxt[i+1]=(if MotionArtifact^(-i) or not SensorConnected^(-i) then 0 else HeartRate^(-i))>>
      ;  
      if
        (MotionArtifact? or not SensorConnected?)~>
            <<SHFT_HR() and (MotionArtifact^0 or not SensorConnected^0)>>
          hr_nxt[1]:=0  --bad sample
            <<SHFT_HR() and (hr_nxt[1]=(if MotionArtifact^0 or not SensorConnected^0 then 0 else HeartRate^0))>>
      []
        (not (MotionArtifact? or not SensorConnected?))~>
             <<SHFT_HR() and not (MotionArtifact^0 or not SensorConnected^0)>>
          hr_nxt[1]:=HeartRate?  --add current sample
            <<SHFT_HR() and (hr_nxt[1]=(if MotionArtifact^0 or not SensorConnected^0 then 0 else HeartRate^0))>>
      fi    
        <<(hr_nxt[1]=(if MotionArtifact^0 or not SensorConnected^0 then 0 else HeartRate^0)) and
          (all i~quantity whole in 2 .. (num_samples+1) 
          	are hr_nxt[i]=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else HeartRate^(1-i)))>>
      ;    
      num_samples:=num_samples+1  --increment count of samples
      <<all i~quantity whole in 1 ..num_samples 
        are hr_nxt[i]=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else HeartRate^(1-i))>>
      ;
      forall i in 1 ..num_samples
        {
          <<hr_nxt[i]=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else HeartRate^(1-i))>>
        heart_rate[i]:=hr_nxt[i] --copy back
          <<heart_rate[i]=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else HeartRate^(1-i))>>
        }
      <<all i~quantity whole in 1 ..num_samples 
        are heart_rate[i]=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else HeartRate^(1-i))>>
      };
    hrtt2a: check-[num_samples<#PulseOx_Properties::Num_Trending_Samples]->fill
       {|nts',heart_rate',hr_nxt',num_samples':=nts,heart_rate,hr_nxt,num_samples|};
    hrtt2b: check-[num_samples=#PulseOx_Properties::Num_Trending_Samples]->run
       {|nts',heart_rate',hr_nxt',num_samples':=nts,heart_rate,hr_nxt,num_samples|};
    hrtt2c: check-[num_samples>#PulseOx_Properties::Num_Trending_Samples]->fail{};
    hrtt3: run-[on dispatch]->run
      {
        <<INV_HR() and (num_samples=#PulseOx_Properties::Num_Trending_Samples)>>
      HeartRateTrend!(heart_rate)  --put out new HeartRate trend for ui
      ;
        <<INV_HR() and (num_samples=#PulseOx_Properties::Num_Trending_Samples)>>
      NumSamples!(num_samples)
      ;
        <<INV_HR() and (num_samples=#PulseOx_Properties::Num_Trending_Samples)
          and AXIOM_CR()>>
      forall i in 1 .. (num_samples - 1)
        {
          <<heart_rate[i]=(if MotionArtifact^(-i) or not SensorConnected^(-i) then 0 else HeartRate^(-i))>>
        hr_nxt[i+1]:=heart_rate[i] --shift old samples
          <<hr_nxt[i+1]=(if MotionArtifact^(-i) or not SensorConnected^(-i) then 0 else HeartRate^(-i))>>
        }
        <<SHFTR_HR: :(all i~quantity whole in 1 .. (num_samples - 1) 
        	are hr_nxt[i+1]=(if MotionArtifact^(-i) or not SensorConnected^(-i) then 0 else HeartRate^(-i)))
          and (num_samples= #PulseOx_Properties::Num_Trending_Samples)>>
      ;  
      if
        (MotionArtifact? or not SensorConnected?)~>
            <<SHFTR_HR() and (MotionArtifact^0 or not SensorConnected^0)>>
          hr_nxt[1]:=0  --bad sample
            <<SHFTR_HR() and (hr_nxt[1]=(if MotionArtifact^0 or not SensorConnected^0 then 0 else HeartRate^0))>>
      []
        (not (MotionArtifact? or not SensorConnected?))~>
             <<SHFTR_HR() and not (MotionArtifact^0 or not SensorConnected^0)>>
          hr_nxt[1]:=HeartRate?  --add current sample
            <<SHFTR_HR() and (hr_nxt[1]=(if MotionArtifact^0 or not SensorConnected^0 then 0 else HeartRate^0))>>
      fi    
        <<(hr_nxt[1]=(if MotionArtifact^0 or not SensorConnected^0 then 0 else HeartRate^0)) and 
          (num_samples=#PulseOx_Properties::Num_Trending_Samples) and
          (all i~quantity whole in 2 .. num_samples 
          	are hr_nxt[i]=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else HeartRate^(1-i)))>>
      ;
      forall i in 1 ..num_samples
        {
          <<hr_nxt[i]=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else HeartRate^(1-i))>>
        heart_rate[i]:=hr_nxt[i] --copy back
          <<heart_rate[i]=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else HeartRate^(1-i))>>
        }
      <<(all i~quantity whole in 1 ..num_samples 
      	  are heart_rate[i]=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else HeartRate^(1-i)))
         and (num_samples=#PulseOx_Properties::Num_Trending_Samples)>>   	
      ;
      |heart_rate',num_samples':=heart_rate,num_samples|
      <<(all i~quantity whole in 1 ..num_samples 
      	  are heart_rate[i]'=(if MotionArtifact^(1-i) or not SensorConnected^(1-i) then 0 else HeartRate^(1-i)))
         and (num_samples'=#PulseOx_Properties::Num_Trending_Samples)>>   	

      };
    hrtt4: fill,run-[on dispatch stop]->halt{};  
**};
end HeartRateTrendThread.imp;


end PO;
