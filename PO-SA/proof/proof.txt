This file, proof.txt, was produced the BLESS Proof Assistant v3.2.2
  at Thu Jan 25 02:04:17 CST 2024 by brianlarson

Theorem (1)                               [serial 1003] 
P [37] << true >>
S [34] ->
Q [34] << true >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by: Anything Implies True (a1tru): P->true

Theorem (2)                               [serial 1004] 
P [36] << true >>
S [36] ->
Q [36] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by: Anything Implies True (a1tru): P->true

Theorem (3)                               [serial 1096] 
P [36] << true >>
S [39] ->
Q [37] << true >>
Why created:    normalization of [serial 1005]
Solved by: Anything Implies True (a1tru): P->true

Theorem (4)                               [serial 1005] 
P [36] << true >>
S [39] ->
Q [37] << ( true )^1  >>
Why created:   <<M(start)>> -> <<M(run)>> for rdt0: start-[ ]->run{};
Solved by: null and theorem 3:
Theorem (3) [serial 1096] used for:
    normalization of [serial 1005] 


Theorem (5)                               [serial 1103] 
P [37] << true >>
S [42] ->
Q [42] << ( MAX_SPO2_DECLINE^0  + SPO2^0  < SPO2_AVERAGE()^0 
  and ADULT_RAPID_DECLINE_ALARM_ENABLED^0 
  and SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) or not ( MAX_SPO2_DECLINE^0  + SPO2^0  < SPO2_AVERAGE()^0 
  and ADULT_RAPID_DECLINE_ALARM_ENABLED^0 
  and SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) >>
Why created:    normalization of [serial 1098]
  Using: (bl.addcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (6)                               [serial 1098] 
P [37] << true >>
S [42] ->
Q [42] << ( ADULT_RAPID_DECLINE_ALARM_ENABLED^0 
  and SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0 
  and SPO2^0  + MAX_SPO2_DECLINE^0  < SPO2_AVERAGE()^0  ) or ( not ( ADULT_RAPID_DECLINE_ALARM_ENABLED^0 
  and SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0 
  and SPO2^0  + MAX_SPO2_DECLINE^0  < SPO2_AVERAGE()^0  ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1097]
Solved by: Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 5:
Theorem (5) [serial 1103] used for:
    normalization of [serial 1098] 


Theorem (7)                               [serial 1105] 
P [42] << ( MAX_SPO2_DECLINE^0  + SPO2^0  < SPO2_AVERAGE()^0 
  and ADULT_RAPID_DECLINE_ALARM_ENABLED^0 
  and SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  )
  and true >>
S [42] ->
Q [45] << RAPID_DECLINE_ALARM() >>
Why created:    normalization of [serial 1099]
  Using: (bl.addcom) (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (8)                               [serial 1099] 
P [42] << true
  and ( ADULT_RAPID_DECLINE_ALARM_ENABLED^0 
  and SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0 
  and SPO2^0  + MAX_SPO2_DECLINE^0  < SPO2_AVERAGE()^0  ) >>
S [42] ->
Q [45] << RAPID_DECLINE_ALARM() >>
Why created:    <<P and B0>> -> <<P0>> in alternative for [serial 1097]
Solved by: Addition Commutes. (bl.addcom) Conjunction Commutes. (bl.ancom) and theorem 7:
Theorem (7) [serial 1105] used for:
    normalization of [serial 1099] 


Theorem (9)                               [serial 1113] 
P [45] << RAPID_DECLINE_ALARM() >>
S [46] ->
Q [22] << RAPID_DECLINE_ALARM() >>
Why created:  applied port output <<pre>> -> <<M[RapidSpO2DeclineAlarm]>> [serial 1107]
Solved by: Identity (id):  P->P is tautology

Theorem (10)                               [serial 1114] 
P [46] << ( RAPID_DECLINE_ALARM() )
  and RapidSpO2DeclineAlarm^0  >>
S [46] ->
Q [37] << true >>
Why created:  applied port output <<pre and M[RapidSpO2DeclineAlarm]^0>> -> <<post>> [serial 1107]
Solved by: Anything Implies True (a1tru): P->true

Theorem (11)                               [serial 1107] 
P [45] << RAPID_DECLINE_ALARM() >>
S [46] RapidSpO2DeclineAlarm!
Q [37] << true >>
Why created:    normalization of [serial 1100]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 9 10:
Theorem (9) [serial 1113] used for:
  applied port output <<pre>> -> <<M[RapidSpO2DeclineAlarm]>> [serial 1107] 
Theorem (10) [serial 1114] used for:
  applied port output <<pre and M[RapidSpO2DeclineAlarm]^0>> -> <<post>> [serial 1107] 


Theorem (12)                               [serial 1100] 
P [45] << RAPID_DECLINE_ALARM() >>
S [46] RapidSpO2DeclineAlarm!
Q [37] << ( true )^1  >>
Why created:    <<P0>> S0 <<Q>> in alternative for [serial 1097]
Solved by: null and theorem 11:
Theorem (11) [serial 1107] used for:
    normalization of [serial 1100] 


Theorem (13)                               [serial 1109] 
P [42] << not ( MAX_SPO2_DECLINE^0  + SPO2^0  < SPO2_AVERAGE()^0 
  and ADULT_RAPID_DECLINE_ALARM_ENABLED^0 
  and SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  )
  and true >>
S [50] skip
Q [37] << true >>
Why created:    normalization of [serial 1101]
  Using: (bl.addcom) (l.caretintro) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (14)                               [serial 1101] 
P [42] << true
  and ( not ( ADULT_RAPID_DECLINE_ALARM_ENABLED^0 
  and SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0 
  and SPO2^0  + MAX_SPO2_DECLINE^0  < SPO2_AVERAGE()^0  ) ) >>
S [50] skip
Q [37] << ( true )^1  >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1097]
Solved by: Addition Commutes. (bl.addcom) null [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 13:
Theorem (13) [serial 1109] used for:
    normalization of [serial 1101] 


Theorem (15)                               [serial 1097] 
P [37] << true >>
S [42]   if 
    (AdultRapidDeclineAlarmEnabled?
    and SensorConnected?
    and not MotionArtifact?
    and SpO2? + MaxSpO2Decline? < AverageSpO2?)~> 
      << RAPID_DECLINE_ALARM() >>
      RapidSpO2DeclineAlarm! 
  []
    (not ( AdultRapidDeclineAlarmEnabled?
    and SensorConnected?
    and not MotionArtifact?
    and SpO2? + MaxSpO2Decline? < AverageSpO2? ))~> 
      skip 
  fi
Q [37] << ( true )^1  >>
Why created:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1006]
Solved by: [Convert asseertion to port value.] and theorems 6 8 12 14:
Theorem (6) [serial 1098] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1097] 
Theorem (8) [serial 1099] used for:
    <<P and B0>> -> <<P0>> in alternative for [serial 1097] 
Theorem (12) [serial 1100] used for:
    <<P0>> S0 <<Q>> in alternative for [serial 1097] 
Theorem (14) [serial 1101] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1097] 


Theorem (16)                               [serial 1006] 
P [37] << true >>
S [42]   if 
    (AdultRapidDeclineAlarmEnabled?
    and SensorConnected?
    and not MotionArtifact?
    and SpO2? + MaxSpO2Decline? < AverageSpO2?)~> 
      << RAPID_DECLINE_ALARM() >>
      RapidSpO2DeclineAlarm! 
  []
    (not ( AdultRapidDeclineAlarmEnabled?
    and SensorConnected?
    and not MotionArtifact?
    and SpO2? + MaxSpO2Decline? < AverageSpO2? ))~> 
      skip 
  fi
Q [37] << ( true )^1  >>
Why created:   <<M(run) and x>> A <<M(run)>> for rdt1: run-[x]->run{A};
Solved by: null and theorem 15:
Theorem (15) [serial 1097] used for:
  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1006] 


Theorem (17)                               [serial 1002] 
P [34] <<   >>
S [34] ->
Q [34] << RapidDeclineThread.imp proof obligations >>
Why created:  Initial proof obligations for RapidDeclineThread.imp
Solved by:  Component verification conditions
 and theorems 1 2 4 16:
Theorem (1) [serial 1003] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (2) [serial 1004] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (4) [serial 1005] used for:
   <<M(start)>> -> <<M(run)>> for rdt0: start-[ ]->run{}; 
Theorem (16) [serial 1006] used for:
   <<M(run) and x>> A <<M(run)>> for rdt1: run-[x]->run{A}; 


Theorem (18)                               [serial 1122] 
P [53] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [36] ->
Q [36] << all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  >>
Why created:    normalization of [serial 1120]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (19)                               [serial 1120] 
P [53] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
S [36] ->
Q [36] << all s ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s ))  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1008]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 18:
Theorem (18) [serial 1122] used for:
    normalization of [serial 1120] 


Theorem (20)                               [serial 1008] 
P [53] << INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
S [36] ->
Q [36] << all s ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s ))  >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 19:
Theorem (19) [serial 1120] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1008] 


Theorem (21)                               [serial 1125] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [36] ->
Q [36] << all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  >>
Why created:    normalization of [serial 1123]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (22)                               [serial 1123] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s ))  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [36] ->
Q [36] << all s ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s ))  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1009]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 21:
Theorem (21) [serial 1125] used for:
    normalization of [serial 1123] 


Theorem (23)                               [serial 1009] 
P [49] << INV_HR()
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [36] ->
Q [36] << all s ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s ))  >>
Why created:  <<M(fill)>> -> <<I>> from invariant I when complete state fill has Assertion <<M(fill)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 22:
Theorem (22) [serial 1123] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1009] 


Theorem (24)                               [serial 1010] 
P [45] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and num_samples = 0 
  and ( all s ~ quantity whole 
  in ( num_samples + 1  ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  ) >>
S [45] ->
Q [45] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by: Anything Implies True (a1tru): P->true

Theorem (25)                               [serial 1127] 
P [51] << HOLD_HR(num_samples) >>
S [51] ->
Q [51] << #PulseOx_Properties::Num_Trending_Samples  < num_samples or num_samples < #PulseOx_Properties::Num_Trending_Samples  or 
#PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:    normalization of [serial 1011]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeGreaterThanToLessThan (bl.orcom) 
Solved by: Trichotomy law for 'less than'. (lttri4)

Theorem (26)                               [serial 1011] 
P [51] << HOLD_HR(num_samples) >>
S [51] ->
Q [51] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples  ) or ( num_samples = #PulseOx_Properties::Num_Trending_Samples  ) or 
( num_samples > #PulseOx_Properties::Num_Trending_Samples  ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state check, <<M(check)>> -> <<e1 or e2 or . . . en>>
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>B to B<A] Disjunction Commutes. (bl.orcom) and theorem 25:
Theorem (25) [serial 1127] used for:
    normalization of [serial 1011] 


Theorem (27)                               [serial 1153] 
P [45] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [58] ->
Q [49] << ( all s ~ quantity whole 
  in 1  .. 0  
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]  )
  and 0  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  Guided Substitution of Equals 
 replacing "num_samples" with its = "0 " in its postcondition [serial 1152]
Solved by: Empty closed interval (icc0)

Theorem (28)                               [serial 1154] 
P [45] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [58] ->
Q [49] << ( all s ~ quantity whole 
  in 1  .. 0  
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]  )
  and 0  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "num_samples" with its = "0 " in its postcondition [serial 1152]
Solved by: Empty closed interval (icc0)

Theorem (29)                               [serial 1152] 
P [45] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [58] ->
Q [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  applied wp for simultaneous assignment [serial 1150]
Solved by:  Guided Substitution of Equals
  Guided Substitution of Equals
 and theorems 27 28:
Theorem (27) [serial 1153] used for:
  Guided Substitution of Equals 
 replacing "num_samples" with its = "0 " in its postcondition [serial 1152] 
Theorem (28) [serial 1154] used for:
  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "num_samples" with its = "0 " in its postcondition [serial 1152] 


Theorem (30)                               [serial 1150] 
P [45] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    normalization of [serial 1148]
  Using: (df-bl.tsdis) (bl.addcom) ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Simultaneous Assignment
 and theorem 29:
Theorem (29) [serial 1152] used for:
  applied wp for simultaneous assignment [serial 1150] 


Theorem (31)                               [serial 1148] 
P [45] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if not ( SENSOR_CONNECTED^( - s ) )^1  or MOTION_ARTIFACT^( 1  + 
      - s ) then 0.0 Hz else HEART_RATE^( 1  + - s )) = heart_rate_store[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  Distribute ^ over complement. (bl.tsnot)
   [serial 1147]
Solved by: Time shift distributes. (df-bl.tsdis)(df-bl.tsdisc) Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 30:
Theorem (30) [serial 1150] used for:
    normalization of [serial 1148] 


Theorem (32)                               [serial 1147] 
P [45] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( not SENSOR_CONNECTED^( - s ) )^1  or MOTION_ARTIFACT^( 1  + 
      - s ) then 0.0 Hz else HEART_RATE^( 1  + - s )) = heart_rate_store[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    normalization of [serial 1145]
  Using: (bl.addcom) ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Distribute ^ over complement. (bl.tsnot) and theorem 31:
Theorem (31) [serial 1148] used for:
  Distribute ^ over complement. (bl.tsnot)
   [serial 1147] 


Theorem (33)                               [serial 1145] 
P [45] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( MOTION_ARTIFACT^( ( - s ) + 1  ) or ( not SENSOR_CONNECTED^( - s ) )^1  ) then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3)
   [serial 1144]
Solved by: Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 32:
Theorem (32) [serial 1147] used for:
    normalization of [serial 1145] 


Theorem (34)                               [serial 1144] 
P [45] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1  then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    normalization of [serial 1142]
  Using: (bl.addcom) (l.caretintro) ADD_UNNECESSARY_PARETHESES 
Solved by: Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3) and theorem 33:
Theorem (33) [serial 1145] used for:
  Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3)
   [serial 1144] 


Theorem (35)                               [serial 1142] 
P [45] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1  then ( 0.0 Hz )^1  else HEART_RATE^( 
      ( - s ) + 1  )) = heart_rate_store[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  Distribute ^ over conditonal expression. (bl.tsqq)
   [serial 1141]
Solved by: Addition Commutes. (bl.addcom) null [Add unnecessary parentheses] and theorem 34:
Theorem (34) [serial 1144] used for:
    normalization of [serial 1142] 


Theorem (36)                               [serial 1141] 
P [45] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s ))^1  = heart_rate_store[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    normalization of [serial 1139]
Solved by: Distribute ^ over conditonal expression. (bl.tsqq) and theorem 35:
Theorem (35) [serial 1142] used for:
  Distribute ^ over conditonal expression. (bl.tsqq)
   [serial 1141] 


Theorem (37)                               [serial 1139] 
P [45] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s ))^1  = ( heart_rate_store[s] )^1  )  )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  Distribute ^ over relation. (bl.tsrel)
   [serial 1138]
Solved by: [Add unnecessary parentheses] and theorem 36:
Theorem (36) [serial 1141] used for:
    normalization of [serial 1139] 


Theorem (38)                               [serial 1138] 
P [45] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s )) = heart_rate_store[s] )^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    normalization of [serial 1136]
  Using: (l.caretintro) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Distribute ^ over relation. (bl.tsrel) and theorem 37:
Theorem (37) [serial 1139] used for:
  Distribute ^ over relation. (bl.tsrel)
   [serial 1138] 


Theorem (39)                               [serial 1136] 
P [45] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( ( num_samples )^1  < ( #PulseOx_Properties::Num_Trending_Samples  )^1  )
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s )) = heart_rate_store[s] )^1   ) >>
Why created:  Distribute ^ over relation. (bl.tsrel)
  Distribute ^ over universal quantification. (bl.tsal)
   [serial 1135]
Solved by: null [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 38:
Theorem (38) [serial 1138] used for:
    normalization of [serial 1136] 


Theorem (40)                               [serial 1135] 
P [45] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )^1 
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  )^1  >>
Why created:    normalization of [serial 1133]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Distribute ^ over relation. (bl.tsrel) Distribute ^ over universal quantification. (bl.tsal) and theorem 39:
Theorem (39) [serial 1136] used for:
  Distribute ^ over relation. (bl.tsrel)
  Distribute ^ over universal quantification. (bl.tsal)
   [serial 1135] 


Theorem (41)                               [serial 1133] 
P [45] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  )^1 
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )^1  ) >>
Why created:  Distribute ^ over conjunction. (bl.tsan)(df-bl.tsan2)(bl.tsan3)
   [serial 1131]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 40:
Theorem (40) [serial 1135] used for:
    normalization of [serial 1133] 


Theorem (42)                               [serial 1131] 
P [45] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  )^1  >>
Why created:    normalization of [serial 1129]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Distribute ^ over conjunction. (bl.tsan)(df-bl.tsan2)(bl.tsan3) and theorem 41:
Theorem (41) [serial 1133] used for:
  Distribute ^ over conjunction. (bl.tsan)(df-bl.tsan2)(bl.tsan3)
   [serial 1131] 


Theorem (43)                               [serial 1129] 
P [45] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and num_samples = 0 
  and ( all s ~ quantity whole 
  in ( num_samples + 1  ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  ) >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( ( all s ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s ))  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  )^1  >>
Why created:  Substituted assertions' predicates for labels  [serial 1012]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 42:
Theorem (42) [serial 1131] used for:
    normalization of [serial 1129] 


Theorem (44)                               [serial 1012] 
P [45] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and num_samples = 0 
  and ( all s ~ quantity whole 
  in ( num_samples + 1  ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  ) >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( INV_HR()
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  )^1  >>
Why created:   <<M(start)>> A <<M(fill)>> for hrtt0: start-[ ]->fill{A};
Solved by: Predicate Invocation. (PI) and theorem 43:
Theorem (43) [serial 1129] used for:
  Substituted assertions' predicates for labels  [serial 1012] 


Theorem (45)                               [serial 1233] 
P [49] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and INV_HR() >>
S [49] ->
Q [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and true
  and INV_HR() >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (46)                               [serial 1233] 
P [49] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and INV_HR() >>
S [49] ->
Q [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and true
  and INV_HR() >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (47)                               [serial 1173] 
P [49] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and INV_HR() >>
S [49] ->
Q [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_HRT()
  and INV_HR() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1172]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 46 46:
Theorem (46) [serial 1233] used for:
   add user-defined "givens" to postcondition 
Theorem (46) [serial 1233] used for:
   add user-defined "givens" to postcondition 


Theorem (48)                               [serial 1236] 
P [103] << all #0# ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - #0# ) or not SENSOR_CONNECTED^( 1  - #0# ) then 0.0 Hz else HEART_RATE^( 1  - #0# )) = heart_rate_store[#0#]  >>
S [51] ->
Q [51] << all #1# ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - #1# ) or not SENSOR_CONNECTED^( 1  - #1# ) then 0.0 Hz else HEART_RATE^( 1  - #1# )) = heart_rate_store[#1#]  >>
Why created:  Substitution of variable in universal quantifier. (sb8)
  Equality Commutes. (eqcom)
  [Add unnecessary parentheses]
   [serial 1235]
Solved by: Identity (id):  P->P is tautology

Theorem (49)                               [serial 1235] 
P [103] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]  >>
S [51] ->
Q [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s ))  ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1174]
Solved by: Substitution of variable in universal quantifier. (sb8) Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 48:
Theorem (48) [serial 1236] used for:
  Substitution of variable in universal quantifier. (sb8)
  Equality Commutes. (eqcom)
  [Add unnecessary parentheses]
   [serial 1235] 


Theorem (50)                               [serial 1174] 
P [103] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]  >>
S [51] ->
Q [51] << HOLD_HR(num_samples) >>
Why created:  <<Q6>> -> <<Q>> in sequential composition for [serial 1172]
Solved by: Predicate Invocation. (PI) and theorem 49:
Theorem (49) [serial 1235] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1174] 


Theorem (51)                               [serial 1284] 
P [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and ( num_samples = NUM_SAMPLES
  and heart_rate_store = HEART_RATE_HISTORY
  and HEART_RATE_HISTORY = HeartRateTrend )
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s ))  ) >>
S [63] ->
Q [63] << HEART_RATE_HISTORY = heart_rate_store >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1206]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (52)                               [serial 1206] 
P [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_HRT()
  and INV_HR() >>
S [63] ->
Q [63] << HEART_RATE_HISTORY = heart_rate_store >>
Why created:    normalization of [serial 1194]
Solved by: Predicate Invocation. (PI) and theorem 51:
Theorem (51) [serial 1284] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1206] 


Theorem (53)                               [serial 1194] 
P [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_HRT()
  and INV_HR() >>
S [63] ->
Q [63] << heart_rate_store = HEART_RATE_HISTORY >>
Why created:  applied port output of value <<pre>> -> <<M(HeartRateTrend)[HeartRateTrend|heart_rate_store]>> [serial 1175]
Solved by: Equality Commutes. (eqcom) and theorem 52:
Theorem (52) [serial 1206] used for:
    normalization of [serial 1194] 


Theorem (54)                               [serial 1208] 
P [63] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_HRT()
  and INV_HR() )
  and ( HEART_RATE_HISTORY = heart_rate_store )^0  >>
S [63] ->
Q [65] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_HRT()
  and INV_HR() >>
Why created:    normalization of [serial 1195]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (55)                               [serial 1195] 
P [63] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_HRT()
  and INV_HR() )
  and ( heart_rate_store = HEART_RATE_HISTORY )^0  >>
S [63] ->
Q [65] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_HRT()
  and INV_HR() >>
Why created:  applied port output <<pre and (heart_rate_store = HEART_RATE_HISTORY)^0>> -> <<post>> [serial 1175]
Solved by: Equality Commutes. (eqcom) and theorem 54:
Theorem (54) [serial 1208] used for:
    normalization of [serial 1195] 


Theorem (56)                               [serial 1175] 
P [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_HRT()
  and INV_HR() >>
S [63] HeartRateTrend!(heart_rate_store)
Q [65] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_HRT()
  and INV_HR() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1172]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 53 55:
Theorem (53) [serial 1194] used for:
  applied port output of value <<pre>> -> <<M(HeartRateTrend)[HeartRateTrend|heart_rate_store]>> [serial 1175] 
Theorem (55) [serial 1195] used for:
  applied port output <<pre and (heart_rate_store = HEART_RATE_HISTORY)^0>> -> <<post>> [serial 1175] 


Theorem (57)                               [serial 1288] 
P [65] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and ( num_samples = NUM_SAMPLES
  and heart_rate_store = HEART_RATE_HISTORY
  and HEART_RATE_HISTORY = HeartRateTrend )
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s ))  ) >>
S [66] ->
Q [66] << NUM_SAMPLES = num_samples >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1210]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (58)                               [serial 1210] 
P [65] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_HRT()
  and INV_HR() >>
S [66] ->
Q [66] << NUM_SAMPLES = num_samples >>
Why created:    normalization of [serial 1196]
Solved by: Predicate Invocation. (PI) and theorem 57:
Theorem (57) [serial 1288] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1210] 


Theorem (59)                               [serial 1196] 
P [65] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_HRT()
  and INV_HR() >>
S [66] ->
Q [66] << num_samples = NUM_SAMPLES >>
Why created:  applied port output of value <<pre>> -> <<M(NumSamples)[NumSamples|num_samples]>> [serial 1176]
Solved by: Equality Commutes. (eqcom) and theorem 58:
Theorem (58) [serial 1210] used for:
    normalization of [serial 1196] 


Theorem (60)                               [serial 1212] 
P [66] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_HRT()
  and INV_HR() )
  and ( NUM_SAMPLES = num_samples )^0  >>
S [66] ->
Q [68] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and INV_HR() >>
Why created:    normalization of [serial 1197]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (61)                               [serial 1197] 
P [66] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_HRT()
  and INV_HR() )
  and ( num_samples = NUM_SAMPLES )^0  >>
S [66] ->
Q [68] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and INV_HR() >>
Why created:  applied port output <<pre and (num_samples = NUM_SAMPLES)^0>> -> <<post>> [serial 1176]
Solved by: Equality Commutes. (eqcom) and theorem 60:
Theorem (60) [serial 1212] used for:
    normalization of [serial 1197] 


Theorem (62)                               [serial 1176] 
P [65] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_HRT()
  and INV_HR() >>
S [66] NumSamples!(num_samples)
Q [68] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and INV_HR() >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1172]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 59 61:
Theorem (59) [serial 1196] used for:
  applied port output of value <<pre>> -> <<M(NumSamples)[NumSamples|num_samples]>> [serial 1176] 
Theorem (61) [serial 1197] used for:
  applied port output <<pre and (num_samples = NUM_SAMPLES)^0>> -> <<post>> [serial 1176] 


Theorem (63)                               [serial 1198] 
P [71] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = heart_rate_store[i] >>
S [72] ->
Q [73] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = heart_rate_store[i] >>
Why created:  applied wp for assignment [serial 1181]
Solved by: Identity (id):  P->P is tautology

Theorem (64)                               [serial 1181] 
P [71] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = heart_rate_store[i] >>
S [72] hr_nxt[1  + i] := heart_rate_store[i]
Q [73] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
1  + i] >>
Why created:  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1177]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 63:
Theorem (63) [serial 1198] used for:
  applied wp for assignment [serial 1181] 


Theorem (65)                               [serial 1295] 
P [68] << ( all #2# ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - #2# ) or not SENSOR_CONNECTED^( - #2# ) then 0.0 Hz else HEART_RATE^( - #2# )) = heart_rate_store[#2#]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [69] ->
Q [19] << all #3# ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - #3# ) or not SENSOR_CONNECTED^( - #3# ) then 0.0 Hz else HEART_RATE^( - #3# )) = heart_rate_store[#3#]  >>
Why created:  Substitution of variable in universal quantifier. (sb8)
  [Add unnecessary parentheses]
   [serial 1294]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (66)                               [serial 1294] 
P [68] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [69] ->
Q [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = heart_rate_store[i]  >>
Why created:    normalization of [serial 1292]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Substitution of variable in universal quantifier. (sb8) [Add unnecessary parentheses] and theorem 65:
Theorem (65) [serial 1295] used for:
  Substitution of variable in universal quantifier. (sb8)
  [Add unnecessary parentheses]
   [serial 1294] 


Theorem (67)                               [serial 1292] 
P [68] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s ))  ) >>
S [69] ->
Q [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = heart_rate_store[i]  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1214]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 66:
Theorem (66) [serial 1294] used for:
    normalization of [serial 1292] 


Theorem (68)                               [serial 1214] 
P [68] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and INV_HR() >>
S [69] ->
Q [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = heart_rate_store[i]  >>
Why created:    normalization of [serial 1182]
  Using: (df-bl.lan1) ADD_UNNECESSARY_PARETHESES 
Solved by: Predicate Invocation. (PI) and theorem 67:
Theorem (67) [serial 1292] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1214] 


Theorem (69)                               [serial 1182] 
P [68] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and INV_HR() ) >>
S [69] ->
Q [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = heart_rate_store[i]  >>
Why created:    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1177]
Solved by: Just one wff in the wff-list for conjunction. (df-bl.lan1) [Add unnecessary parentheses] and theorem 68:
Theorem (68) [serial 1214] used for:
    normalization of [serial 1182] 


Theorem (70)                               [serial 1183] 
P [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  >>
S [69] ->
Q [75] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  >>
Why created:    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1177]
Solved by: Identity (id):  P->P is tautology

Theorem (71)                               [serial 1177] 
P [68] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and INV_HR() >>
S [69] forall i in 1  .. num_samples
    {
    << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = heart_rate_store[i] >>
    hr_nxt[1  + i] := heart_rate_store[i]
    << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
    1  + i] >>
    }  
Q [75] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1172]
Solved by:  Forall Rule (fa):
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any
 and theorems 64 69 70:
Theorem (64) [serial 1181] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1177] 
Theorem (69) [serial 1182] used for:
    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1177] 
Theorem (70) [serial 1183] used for:
    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1177] 


Theorem (72)                               [serial 1218] 
P [75] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  >>
S [78] ->
Q [78] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) or not ( MOTION_ARTIFACT^0  or 
not SENSOR_CONNECTED^0  ) >>
Why created:    normalization of [serial 1184]
  Using: ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (73)                               [serial 1184] 
P [75] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  >>
S [78] ->
Q [78] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) or ( not ( MOTION_ARTIFACT^0  or 
not SENSOR_CONNECTED^0  ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1178]
Solved by: [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 72:
Theorem (72) [serial 1218] used for:
    normalization of [serial 1184] 


Theorem (74)                               [serial 1238] 
P [78] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  )
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [78] ->
Q [80] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1237]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (75)                               [serial 1240] 
P [78] << ( all i ~ quantity whole 
  in 0  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( -1  + - i ) or not SENSOR_CONNECTED^( -1  + 
      - i ) then 0.0 Hz else HEART_RATE^( -1  + - i )) = hr_nxt[( 1  + i ) + 
      1 ]  )
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [78] ->
Q [75] << all i ~ quantity whole 
  in 0  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( -1  + - i ) or not SENSOR_CONNECTED^( -1  + 
      - i ) then 0.0 Hz else HEART_RATE^( -1  + - i )) = hr_nxt[( 1  + i ) + 
      1 ]  >>
Why created:  null
   [serial 1239]
Solved by: Addition associativity (bl.add3i)(bl.add4i)

Theorem (76)                               [serial 1239] 
P [78] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  )
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [78] ->
Q [75] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are hr_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i ))  ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1237]
Solved by: null and theorem 75:
Theorem (75) [serial 1240] used for:
  null
   [serial 1239] 


Theorem (77)                               [serial 1237] 
P [78] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  )
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [78] ->
Q [80] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and ( all i ~ quantity whole 
  in 1  .. num_samples 
  are hr_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i ))  ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1185]
Solved by: Join consequents with conjunction. (3jca) and theorems 74 76:
Theorem (74) [serial 1238] used for:
  Join consequents with conjunction. (3jca)
   [serial 1237] 
Theorem (76) [serial 1239] used for:
  Join consequents with conjunction. (3jca)
   [serial 1237] 


Theorem (78)                               [serial 1185] 
P [78] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  )
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [78] ->
Q [80] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and SHFT_HR() >>
Why created:    <<P and B0>> -> <<P0>> in alternative for [serial 1178]
Solved by: Predicate Invocation. (PI) and theorem 77:
Theorem (77) [serial 1237] used for:
  Substituted assertions' predicates for labels  [serial 1185] 


Theorem (79)                               [serial 1250] 
P [80] << ( MOTION_ARTIFACT or not SENSOR_CONNECTED )
  and SHFT_HR() >>
S [81] ->
Q [82] << 0.0 Hz = 0.0 Hz >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1249]
Solved by: Law of identity. (eqid) Caret Introduction: if a predicate is always true it's true when time shifted (bl.caretintro) 
   or if a value is constant its value when time shifted is the same (bl.caretintrov) 

Theorem (80)                               [serial 1249] 
P [80] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and SHFT_HR() >>
S [81] ->
Q [82] << 0.0 Hz = 0.0 Hz >>
Why created:  no reason Value of the conditional operator when its first argument is true. (iftrue)
  [Add unnecessary parentheses]
   [serial 1247]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 79:
Theorem (79) [serial 1250] used for:
  Assume Present:  P = P@now = P^0   [serial 1249] 


Theorem (81)                               [serial 1247] 
P [80] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and SHFT_HR() >>
S [81] ->
Q [82] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = 0.0 Hz >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1199]
Solved by: Value of the conditional operator when its first argument is true. (iftrue) [Add unnecessary parentheses] and theorem 80:
Theorem (80) [serial 1249] used for:
  no reason Value of the conditional operator when its first argument is true. (iftrue)
  [Add unnecessary parentheses]
   [serial 1247] 


Theorem (82)                               [serial 1248] 
P [80] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and SHFT_HR() >>
S [81] ->
Q [82] << SHFT_HR() >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1199]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (83)                               [serial 1199] 
P [80] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and SHFT_HR() >>
S [81] ->
Q [82] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = 0.0 Hz
  and SHFT_HR() >>
Why created:  applied wp for assignment [serial 1186]
Solved by: Join consequents with conjunction. (3jca) and theorems 81 82:
Theorem (81) [serial 1247] used for:
  Join consequents with conjunction. (3jca)
   [serial 1199] 
Theorem (82) [serial 1248] used for:
  Join consequents with conjunction. (3jca)
   [serial 1199] 


Theorem (84)                               [serial 1186] 
P [80] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and SHFT_HR() >>
S [81] hr_nxt[1 ] := 0.0 Hz
Q [82] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
  and SHFT_HR() >>
Why created:    <<P0>> S0 <<Q0>> in alternative for [serial 1178]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 83:
Theorem (83) [serial 1199] used for:
  applied wp for assignment [serial 1186] 


Theorem (85)                               [serial 1260] 
P [82] << ( all i ~ quantity whole 
  in 0  .. ( -1  + num_samples ) 
  are (if MOTION_ARTIFACT^( -1  + - i ) or not SENSOR_CONNECTED^( -1  + 
      - i ) then 0.0 Hz else HEART_RATE^( -1  + - i )) = hr_nxt[( 1  + i ) + 
      1 ]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ] >>
S [78] ->
Q [90] << all i ~ quantity whole 
  in 0  .. ( -1  + num_samples ) 
  are (if MOTION_ARTIFACT^( ( -2  + - i ) + 1  ) or not SENSOR_CONNECTED^( 
      ( -2  + - i ) + 1  ) then 0.0 Hz else HEART_RATE^( ( -2  + - i ) + 
      1  )) = hr_nxt[2  + i]  >>
Why created:    normalization of [serial 1258]
  Using: (bl.addcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Addition associativity (bl.add3i)(bl.add4i)

Theorem (86)                               [serial 1258] 
P [82] << ( all i ~ quantity whole 
  in 0  .. ( num_samples + - 1  ) 
  are (if MOTION_ARTIFACT^( -1  + - i ) or not SENSOR_CONNECTED^( -1  + 
      - i ) then 0.0 Hz else HEART_RATE^( -1  + - i )) = hr_nxt[( 1  + i ) + 
      1 ]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ] >>
S [78] ->
Q [90] << all i ~ quantity whole 
  in 0  .. ( ( - 2  + 1  + num_samples ) ) 
  are (if MOTION_ARTIFACT^( 1  + -(2  + i) ) or not SENSOR_CONNECTED^( 1  + 
      -(2  + i) ) then 0.0 Hz else HEART_RATE^( 1  + -(2  + i) )) = hr_nxt[
      2  + i]  >>
Why created:   changing adding negation to subtraction  [serial 1257]
Solved by: Addition Commutes. (bl.addcom) [Add unnecessary parentheses] and theorem 85:
Theorem (85) [serial 1260] used for:
    normalization of [serial 1258] 


Theorem (87)                               [serial 1257] 
P [82] << ( all i ~ quantity whole 
  in 0  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( -1  + - i ) or not SENSOR_CONNECTED^( -1  + 
      - i ) then 0.0 Hz else HEART_RATE^( -1  + - i )) = hr_nxt[( 1  + i ) + 
      1 ]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ] >>
S [78] ->
Q [90] << all i ~ quantity whole 
  in 0  .. ( ( 1  + num_samples ) - 2  ) 
  are (if MOTION_ARTIFACT^( 1  - ( 2  + i ) ) or not SENSOR_CONNECTED^( 1  - ( 
      2  + i ) ) then 0.0 Hz else HEART_RATE^( 1  - ( 2  + i ) )) = hr_nxt[
      2  + i]  >>
Why created:  null
   [serial 1256]
Solved by: Relationship between subtraction and negative. (negsub) and theorem 86:
Theorem (86) [serial 1258] used for:
   changing adding negation to subtraction  [serial 1257] 


Theorem (88)                               [serial 1256] 
P [82] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ] >>
S [78] ->
Q [90] << all i ~ quantity whole 
  in 2  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  >>
Why created:    normalization of [serial 1254]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: null and theorem 87:
Theorem (87) [serial 1257] used for:
  null
   [serial 1256] 


Theorem (89)                               [serial 1254] 
P [82] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
  and ( all i ~ quantity whole 
  in 1  .. num_samples 
  are hr_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i ))  ) >>
S [78] ->
Q [90] << ( all i ~ quantity whole 
  in 2  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1252]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 88:
Theorem (88) [serial 1256] used for:
    normalization of [serial 1254] 


Theorem (90)                               [serial 1252] 
P [82] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
  and SHFT_HR() >>
S [78] ->
Q [90] << ( all i ~ quantity whole 
  in 2  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1187]
Solved by: Predicate Invocation. (PI) and theorem 89:
Theorem (89) [serial 1254] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1252] 


Theorem (91)                               [serial 1253] 
P [82] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
  and SHFT_HR() >>
S [78] ->
Q [89] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ] >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1187]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (92)                               [serial 1187] 
P [82] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
  and SHFT_HR() >>
S [78] ->
Q [89] << ( all i ~ quantity whole 
  in 2  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ] >>
Why created:    <<Q0>> -> <<Q>> in alternative  for [serial 1178]
Solved by: Join consequents with conjunction. (3jca) and theorems 90 91:
Theorem (90) [serial 1252] used for:
  Join consequents with conjunction. (3jca)
   [serial 1187] 
Theorem (91) [serial 1253] used for:
  Join consequents with conjunction. (3jca)
   [serial 1187] 


Theorem (93)                               [serial 1298] 
P [78] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  )
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [78] ->
Q [85] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  )
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
Why created:    normalization of [serial 1296]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Identity (id):  P->P is tautology

Theorem (94)                               [serial 1296] 
P [78] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  )
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [78] ->
Q [85] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are hr_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i ))  )
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1223]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 93:
Theorem (93) [serial 1298] used for:
    normalization of [serial 1296] 


Theorem (95)                               [serial 1223] 
P [78] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  )
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [78] ->
Q [85] << SHFT_HR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
Why created:    normalization of [serial 1188]
Solved by: Predicate Invocation. (PI) and theorem 94:
Theorem (94) [serial 1296] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1223] 


Theorem (96)                               [serial 1188] 
P [78] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  )
  and ( not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) ) >>
S [78] ->
Q [85] << SHFT_HR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
Why created:    <<P and B1>> -> <<P1>> in alternative for [serial 1178]
Solved by: [Add unnecessary parentheses] and theorem 95:
Theorem (95) [serial 1223] used for:
    normalization of [serial 1188] 


Theorem (97)                               [serial 1268] 
P [85] << SHFT_HR()
  and not ( MOTION_ARTIFACT or not SENSOR_CONNECTED ) >>
S [86] ->
Q [87] << HEART_RATE = HEART_RATE >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1267]
Solved by: Law of identity. (eqid) Caret Introduction: if a predicate is always true it's true when time shifted (bl.caretintro) 
   or if a value is constant its value when time shifted is the same (bl.caretintrov) 

Theorem (98)                               [serial 1267] 
P [85] << SHFT_HR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [86] ->
Q [87] << HEART_RATE = HEART_RATE^0  >>
Why created:  Replacing port names with BLESS::Value properties  [serial 1265]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 97:
Theorem (97) [serial 1268] used for:
  Assume Present:  P = P@now = P^0   [serial 1267] 


Theorem (99)                               [serial 1265] 
P [85] << SHFT_HR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [86] ->
Q [87] << HeartRate = HEART_RATE^0  >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1264]
Solved by:  Replacing port names with BLESS::Value properties
 and theorem 98:
Theorem (98) [serial 1267] used for:
  Replacing port names with BLESS::Value properties  [serial 1265] 


Theorem (100)                               [serial 1266] 
P [85] << SHFT_HR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [86] ->
Q [87] << SHFT_HR() >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1264]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (101)                               [serial 1264] 
P [85] << SHFT_HR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [86] ->
Q [87] << HeartRate = HEART_RATE^0 
  and SHFT_HR() >>
Why created:  no reason Equality Commutes. (eqcom)
  Value of the conditional operator when its first argument is false. (iffalse)
  [Add unnecessary parentheses]
   [serial 1200]
Solved by: Join consequents with conjunction. (3jca) and theorems 99 100:
Theorem (99) [serial 1265] used for:
  Join consequents with conjunction. (3jca)
   [serial 1264] 
Theorem (100) [serial 1266] used for:
  Join consequents with conjunction. (3jca)
   [serial 1264] 


Theorem (102)                               [serial 1200] 
P [85] << SHFT_HR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [86] ->
Q [87] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = HeartRate
  and SHFT_HR() >>
Why created:  applied wp for assignment [serial 1189]
Solved by: Equality Commutes. (eqcom) Value of the conditional operator when its first argument is false. (iffalse) [Add unnecessary parentheses] and theorem 101:
Theorem (101) [serial 1264] used for:
  no reason Equality Commutes. (eqcom)
  Value of the conditional operator when its first argument is false. (iffalse)
  [Add unnecessary parentheses]
   [serial 1200] 


Theorem (103)                               [serial 1189] 
P [85] << SHFT_HR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [86] hr_nxt[1 ] := HeartRate
Q [87] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
  and SHFT_HR() >>
Why created:    <<P1>> S1 <<Q1>> in alternative for [serial 1178]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 102:
Theorem (102) [serial 1200] used for:
  applied wp for assignment [serial 1189] 


Theorem (104)                               [serial 1278] 
P [87] << ( all i ~ quantity whole 
  in 0  .. ( -1  + num_samples ) 
  are (if MOTION_ARTIFACT^( -1  + - i ) or not SENSOR_CONNECTED^( -1  + 
      - i ) then 0.0 Hz else HEART_RATE^( -1  + - i )) = hr_nxt[( 1  + i ) + 
      1 ]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ] >>
S [78] ->
Q [90] << all i ~ quantity whole 
  in 0  .. ( -1  + num_samples ) 
  are (if MOTION_ARTIFACT^( ( -2  + - i ) + 1  ) or not SENSOR_CONNECTED^( 
      ( -2  + - i ) + 1  ) then 0.0 Hz else HEART_RATE^( ( -2  + - i ) + 
      1  )) = hr_nxt[2  + i]  >>
Why created:    normalization of [serial 1276]
  Using: (bl.addcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Addition associativity (bl.add3i)(bl.add4i)

Theorem (105)                               [serial 1276] 
P [87] << ( all i ~ quantity whole 
  in 0  .. ( num_samples + - 1  ) 
  are (if MOTION_ARTIFACT^( -1  + - i ) or not SENSOR_CONNECTED^( -1  + 
      - i ) then 0.0 Hz else HEART_RATE^( -1  + - i )) = hr_nxt[( 1  + i ) + 
      1 ]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ] >>
S [78] ->
Q [90] << all i ~ quantity whole 
  in 0  .. ( ( - 2  + 1  + num_samples ) ) 
  are (if MOTION_ARTIFACT^( 1  + -(2  + i) ) or not SENSOR_CONNECTED^( 1  + 
      -(2  + i) ) then 0.0 Hz else HEART_RATE^( 1  + -(2  + i) )) = hr_nxt[
      2  + i]  >>
Why created:   changing adding negation to subtraction  [serial 1275]
Solved by: Addition Commutes. (bl.addcom) [Add unnecessary parentheses] and theorem 104:
Theorem (104) [serial 1278] used for:
    normalization of [serial 1276] 


Theorem (106)                               [serial 1275] 
P [87] << ( all i ~ quantity whole 
  in 0  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( -1  + - i ) or not SENSOR_CONNECTED^( -1  + 
      - i ) then 0.0 Hz else HEART_RATE^( -1  + - i )) = hr_nxt[( 1  + i ) + 
      1 ]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ] >>
S [78] ->
Q [90] << all i ~ quantity whole 
  in 0  .. ( ( 1  + num_samples ) - 2  ) 
  are (if MOTION_ARTIFACT^( 1  - ( 2  + i ) ) or not SENSOR_CONNECTED^( 1  - ( 
      2  + i ) ) then 0.0 Hz else HEART_RATE^( 1  - ( 2  + i ) )) = hr_nxt[
      2  + i]  >>
Why created:  null
   [serial 1273]
Solved by: Relationship between subtraction and negative. (negsub) and theorem 105:
Theorem (105) [serial 1276] used for:
   changing adding negation to subtraction  [serial 1275] 


Theorem (107)                               [serial 1273] 
P [87] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ] >>
S [78] ->
Q [90] << ( all i ~ quantity whole 
  in 2  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1272]
Solved by: null and theorem 106:
Theorem (106) [serial 1275] used for:
  null
   [serial 1273] 


Theorem (108)                               [serial 1274] 
P [87] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ] >>
S [78] ->
Q [89] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ] >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1272]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (109)                               [serial 1272] 
P [87] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ] >>
S [78] ->
Q [89] << ( all i ~ quantity whole 
  in 2  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ] >>
Why created:    normalization of [serial 1270]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 107 108:
Theorem (107) [serial 1273] used for:
  Join consequents with conjunction. (3jca)
   [serial 1272] 
Theorem (108) [serial 1274] used for:
  Join consequents with conjunction. (3jca)
   [serial 1272] 


Theorem (110)                               [serial 1270] 
P [87] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
  and ( all i ~ quantity whole 
  in 1  .. num_samples 
  are hr_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i ))  ) >>
S [78] ->
Q [89] << ( all i ~ quantity whole 
  in 2  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ] >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1190]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 109:
Theorem (109) [serial 1272] used for:
    normalization of [serial 1270] 


Theorem (111)                               [serial 1190] 
P [87] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
  and SHFT_HR() >>
S [78] ->
Q [89] << ( all i ~ quantity whole 
  in 2  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ] >>
Why created:    <<Q1>> -> <<Q>> in alternative  for [serial 1178]
Solved by: Predicate Invocation. (PI) and theorem 110:
Theorem (110) [serial 1270] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1190] 


Theorem (112)                               [serial 1178] 
P [75] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  >>
S [78]   if 
    (MotionArtifact? or not SensorConnected?)~> 
      << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
        and SHFT_HR() >>
      hr_nxt[1 ] := 0.0 Hz
      << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
        and SHFT_HR() >> 
  []
    (not ( MotionArtifact? or not SensorConnected? ))~> 
      << SHFT_HR()
        and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
      hr_nxt[1 ] := HeartRate
      << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
        and SHFT_HR() >> 
  fi
Q [89] << ( all i ~ quantity whole 
  in 2  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ] >>
Why created:  <<Q3 and P4>> S4 <<Q4 and P5>> in sequential composition for [serial 1172]
Solved by: [Convert asseertion to port value.] and theorems 73 78 84 92 96 103 111:
Theorem (73) [serial 1184] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1178] 
Theorem (78) [serial 1185] used for:
    <<P and B0>> -> <<P0>> in alternative for [serial 1178] 
Theorem (84) [serial 1186] used for:
    <<P0>> S0 <<Q0>> in alternative for [serial 1178] 
Theorem (92) [serial 1187] used for:
    <<Q0>> -> <<Q>> in alternative  for [serial 1178] 
Theorem (96) [serial 1188] used for:
    <<P and B1>> -> <<P1>> in alternative for [serial 1178] 
Theorem (103) [serial 1189] used for:
    <<P1>> S1 <<Q1>> in alternative for [serial 1178] 
Theorem (111) [serial 1190] used for:
    <<Q1>> -> <<Q>> in alternative  for [serial 1178] 


Theorem (113)                               [serial 1283] 
P [89] << ( all i ~ quantity whole 
  in 1  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ] >>
S [93] ->
Q [94] << all i ~ quantity whole 
  in 1  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  >>
Why created:  [Add unnecessary parentheses]
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1201]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (114)                               [serial 1201] 
P [89] << ( all i ~ quantity whole 
  in 2  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ] >>
S [93] ->
Q [94] << all i ~ quantity whole 
  in 1  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  >>
Why created:  applied wp for assignment [serial 1179]
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
 [Add unnecessary parentheses] and theorem 113:
Theorem (113) [serial 1283] used for:
  [Add unnecessary parentheses]
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1201] 


Theorem (115)                               [serial 1179] 
P [89] << ( all i ~ quantity whole 
  in 2  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ] >>
S [93] num_samples := 1  + num_samples
Q [94] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  >>
Why created:  <<Q4 and P5>> S5 <<Q5 and P6>> in sequential composition for [serial 1172]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 114:
Theorem (114) [serial 1201] used for:
  applied wp for assignment [serial 1179] 


Theorem (116)                               [serial 1202] 
P [99] << (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i] >>
S [100] ->
Q [101] << (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i] >>
Why created:  applied wp for assignment [serial 1191]
Solved by: Identity (id):  P->P is tautology

Theorem (117)                               [serial 1191] 
P [99] << (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i] >>
S [100] heart_rate_store[i] := hr_nxt[i]
Q [101] << (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i] >>
Why created:  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1180]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 116:
Theorem (116) [serial 1202] used for:
  applied wp for assignment [serial 1191] 


Theorem (118)                               [serial 1228] 
P [94] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  >>
S [97] ->
Q [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  >>
Why created:    normalization of [serial 1192]
  Using: (df-bl.lan1) ADD_UNNECESSARY_PARETHESES 
Solved by: Identity (id):  P->P is tautology

Theorem (119)                               [serial 1192] 
P [94] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  ) >>
S [97] ->
Q [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  >>
Why created:    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1180]
Solved by: Just one wff in the wff-list for conjunction. (df-bl.lan1) [Add unnecessary parentheses] and theorem 118:
Theorem (118) [serial 1228] used for:
    normalization of [serial 1192] 


Theorem (120)                               [serial 1193] 
P [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]  >>
S [97] ->
Q [103] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]  >>
Why created:    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1180]
Solved by: Identity (id):  P->P is tautology

Theorem (121)                               [serial 1180] 
P [94] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  >>
S [97] forall i in 1  .. num_samples
    {
    << (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i] >>
    heart_rate_store[i] := hr_nxt[i]
    << (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i] >>
    }  
Q [103] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]  >>
Why created:  <<Q5 and P6>> S6 <<Q6>> in sequential composition for [serial 1172]
Solved by:  Forall Rule (fa):
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any
 and theorems 117 119 120:
Theorem (117) [serial 1191] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1180] 
Theorem (119) [serial 1192] used for:
    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1180] 
Theorem (120) [serial 1193] used for:
    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1180] 


Theorem (122)                               [serial 1172] 
P [49] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and INV_HR() >>
S [62]   << num_samples < #PulseOx_Properties::Num_Trending_Samples 
    and AXIOM_HRT()
    and INV_HR() >>
  HeartRateTrend!(heart_rate_store)
  ;
  << num_samples < #PulseOx_Properties::Num_Trending_Samples 
    and AXIOM_HRT()
    and INV_HR() >>
  NumSamples!(num_samples)
  ;
  << num_samples < #PulseOx_Properties::Num_Trending_Samples 
    and INV_HR() >>
  forall i in 1  .. num_samples
      {
      << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = heart_rate_store[i] >>
      hr_nxt[1  + i] := heart_rate_store[i]
      << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i] >>
      }  
  <<SHFT_HR: :all i ~ quantity whole 
    in 1  .. num_samples 
    are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
        1  + i]  >>
  ;
    if 
      (MotionArtifact? or not SensorConnected?)~> 
        << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
          and SHFT_HR() >>
        hr_nxt[1 ] := 0.0 Hz
        << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
          and SHFT_HR() >> 
    []
      (not ( MotionArtifact? or not SensorConnected? ))~> 
        << SHFT_HR()
          and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
        hr_nxt[1 ] := HeartRate
        << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
          and SHFT_HR() >> 
    fi
  << ( all i ~ quantity whole 
    in 2  .. ( 1  + num_samples ) 
    are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  )
    and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ] >>
  ;
  num_samples := 1  + num_samples
  << all i ~ quantity whole 
    in 1  .. num_samples 
    are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  >>
  ;
  forall i in 1  .. num_samples
      {
      << (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i] >>
      heart_rate_store[i] := hr_nxt[i]
      << (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i] >>
      }  
  << all i ~ quantity whole 
    in 1  .. num_samples 
    are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]  >> 
Q [51] << HOLD_HR(num_samples) >>
Why created:    normalization of [serial 1013]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 47 50 56 62 71 112 115 121:
Theorem (47) [serial 1173] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1172] 
Theorem (50) [serial 1174] used for:
  <<Q6>> -> <<Q>> in sequential composition for [serial 1172] 
Theorem (56) [serial 1175] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1172] 
Theorem (62) [serial 1176] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1172] 
Theorem (71) [serial 1177] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1172] 
Theorem (112) [serial 1178] used for:
  <<Q3 and P4>> S4 <<Q4 and P5>> in sequential composition for [serial 1172] 
Theorem (115) [serial 1179] used for:
  <<Q4 and P5>> S5 <<Q5 and P6>> in sequential composition for [serial 1172] 
Theorem (121) [serial 1180] used for:
  <<Q5 and P6>> S6 <<Q6>> in sequential composition for [serial 1172] 


Theorem (123)                               [serial 1013] 
P [49] << INV_HR()
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [62]   << INV_HR()
    and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
    and AXIOM_HRT() >>
  HeartRateTrend!(heart_rate_store)
  ;
  << INV_HR()
    and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
    and AXIOM_HRT() >>
  NumSamples!(num_samples)
  ;
  << INV_HR()
    and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  ) >>
  forall i in 1  .. num_samples
      {
      << heart_rate_store[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) >>
      hr_nxt[i + 1 ] := heart_rate_store[i]
      << hr_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) >>
      }  
  <<SHFT_HR: :all i ~ quantity whole 
    in 1  .. num_samples 
    are hr_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i ))  >>
  ;
    if 
      (MotionArtifact? or not SensorConnected?)~> 
        << SHFT_HR()
          and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
        hr_nxt[1 ] := 0.0 Hz
        << SHFT_HR()
          and hr_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) >> 
    []
      (not ( MotionArtifact? or not SensorConnected? ))~> 
        << SHFT_HR()
          and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
        hr_nxt[1 ] := HeartRate
        << SHFT_HR()
          and hr_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) >> 
    fi
  << hr_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 )
    and ( all i ~ quantity whole 
    in 2  .. ( num_samples + 1  ) 
    are hr_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))  ) >>
  ;
  num_samples := num_samples + 1 
  << all i ~ quantity whole 
    in 1  .. num_samples 
    are hr_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))  >>
  ;
  forall i in 1  .. num_samples
      {
      << hr_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) >>
      heart_rate_store[i] := hr_nxt[i]
      << heart_rate_store[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) >>
      }  
  << all i ~ quantity whole 
    in 1  .. num_samples 
    are heart_rate_store[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))  >> 
Q [51] << HOLD_HR(num_samples) >>
Why created:   <<M(fill) and x>> A <<M(check)>> for hrtt1: fill-[x]->check{A};
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 122:
Theorem (122) [serial 1172] used for:
    normalization of [serial 1013] 


Theorem (124)                               [serial 1322] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [107] ->
Q [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:   changing adding negation to subtraction  [serial 1321]
Solved by: Identity (id):  P->P is tautology

Theorem (125)                               [serial 1323] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [107] ->
Q [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:   changing adding negation to subtraction  [serial 1321]
Solved by: Identity (id):  P->P is tautology

Theorem (126)                               [serial 1321] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [107] ->
Q [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  applied wp for simultaneous assignment [serial 1319]
Solved by: Relationship between subtraction and negative. (negsub) and theorems 124 125:
Theorem (124) [serial 1322] used for:
   changing adding negation to subtraction  [serial 1321] 
Theorem (125) [serial 1323] used for:
   changing adding negation to subtraction  [serial 1321] 


Theorem (127)                               [serial 1319] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    normalization of [serial 1317]
  Using: (df-bl.tsdis) (bl.addcom) ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Simultaneous Assignment
 and theorem 126:
Theorem (126) [serial 1321] used for:
  applied wp for simultaneous assignment [serial 1319] 


Theorem (128)                               [serial 1317] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if not ( SENSOR_CONNECTED^( - s ) )^1  or MOTION_ARTIFACT^( 1  + 
      - s ) then 0.0 Hz else HEART_RATE^( 1  + - s )) = heart_rate_store[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  Distribute ^ over complement. (bl.tsnot)
   [serial 1316]
Solved by: Time shift distributes. (df-bl.tsdis)(df-bl.tsdisc) Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 127:
Theorem (127) [serial 1319] used for:
    normalization of [serial 1317] 


Theorem (129)                               [serial 1316] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( not SENSOR_CONNECTED^( - s ) )^1  or MOTION_ARTIFACT^( 1  + 
      - s ) then 0.0 Hz else HEART_RATE^( 1  + - s )) = heart_rate_store[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    normalization of [serial 1314]
  Using: (bl.addcom) ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Distribute ^ over complement. (bl.tsnot) and theorem 128:
Theorem (128) [serial 1317] used for:
  Distribute ^ over complement. (bl.tsnot)
   [serial 1316] 


Theorem (130)                               [serial 1314] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( MOTION_ARTIFACT^( ( - s ) + 1  ) or ( not SENSOR_CONNECTED^( - s ) )^1  ) then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3)
   [serial 1313]
Solved by: Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 129:
Theorem (129) [serial 1316] used for:
    normalization of [serial 1314] 


Theorem (131)                               [serial 1313] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1  then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    normalization of [serial 1311]
  Using: (bl.addcom) (l.caretintro) ADD_UNNECESSARY_PARETHESES 
Solved by: Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3) and theorem 130:
Theorem (130) [serial 1314] used for:
  Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3)
   [serial 1313] 


Theorem (132)                               [serial 1311] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1  then ( 0.0 Hz )^1  else HEART_RATE^( 
      ( - s ) + 1  )) = heart_rate_store[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  Distribute ^ over conditonal expression. (bl.tsqq)
   [serial 1310]
Solved by: Addition Commutes. (bl.addcom) null [Add unnecessary parentheses] and theorem 131:
Theorem (131) [serial 1313] used for:
    normalization of [serial 1311] 


Theorem (133)                               [serial 1310] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s ))^1  = heart_rate_store[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    normalization of [serial 1308]
Solved by: Distribute ^ over conditonal expression. (bl.tsqq) and theorem 132:
Theorem (132) [serial 1311] used for:
  Distribute ^ over conditonal expression. (bl.tsqq)
   [serial 1310] 


Theorem (134)                               [serial 1308] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s ))^1  = ( heart_rate_store[s] )^1  )  )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  Distribute ^ over relation. (bl.tsrel)
   [serial 1307]
Solved by: [Add unnecessary parentheses] and theorem 133:
Theorem (133) [serial 1310] used for:
    normalization of [serial 1308] 


Theorem (135)                               [serial 1307] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s )) = heart_rate_store[s] )^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    normalization of [serial 1305]
  Using: (l.caretintro) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Distribute ^ over relation. (bl.tsrel) and theorem 134:
Theorem (134) [serial 1308] used for:
  Distribute ^ over relation. (bl.tsrel)
   [serial 1307] 


Theorem (136)                               [serial 1305] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( ( num_samples )^1  < ( #PulseOx_Properties::Num_Trending_Samples  )^1  )
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s )) = heart_rate_store[s] )^1   ) >>
Why created:  Distribute ^ over relation. (bl.tsrel)
  Distribute ^ over universal quantification. (bl.tsal)
   [serial 1304]
Solved by: null [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 135:
Theorem (135) [serial 1307] used for:
    normalization of [serial 1305] 


Theorem (137)                               [serial 1304] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )^1 
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  )^1  >>
Why created:    normalization of [serial 1302]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Distribute ^ over relation. (bl.tsrel) Distribute ^ over universal quantification. (bl.tsal) and theorem 136:
Theorem (136) [serial 1305] used for:
  Distribute ^ over relation. (bl.tsrel)
  Distribute ^ over universal quantification. (bl.tsal)
   [serial 1304] 


Theorem (138)                               [serial 1302] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  )^1 
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )^1  ) >>
Why created:  Distribute ^ over conjunction. (bl.tsan)(df-bl.tsan2)(bl.tsan3)
   [serial 1301]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 137:
Theorem (137) [serial 1304] used for:
    normalization of [serial 1302] 


Theorem (139)                               [serial 1301] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  )^1  >>
Why created:    normalization of [serial 1299]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Distribute ^ over conjunction. (bl.tsan)(df-bl.tsan2)(bl.tsan3) and theorem 138:
Theorem (138) [serial 1302] used for:
  Distribute ^ over conjunction. (bl.tsan)(df-bl.tsan2)(bl.tsan3)
   [serial 1301] 


Theorem (140)                               [serial 1299] 
P [51] << ( ( all s ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s ))  ) )
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  ) >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( ( all s ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s ))  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  )^1  >>
Why created:  Substituted assertions' predicates for labels  [serial 1014]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 139:
Theorem (139) [serial 1301] used for:
    normalization of [serial 1299] 


Theorem (141)                               [serial 1014] 
P [51] << ( HOLD_HR(num_samples) )
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  ) >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( INV_HR()
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  )^1  >>
Why created:   <<M(check) and x>> A <<M(fill)>> for hrtt2a: check-[x]->fill{A};
Solved by: Predicate Invocation. (PI) and theorem 140:
Theorem (140) [serial 1299] used for:
  Substituted assertions' predicates for labels  [serial 1014] 


Theorem (142)                               [serial 1345] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [109] ->
Q [53] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:   changing adding negation to subtraction  [serial 1344]
Solved by: Identity (id):  P->P is tautology

Theorem (143)                               [serial 1346] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [109] ->
Q [53] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:   changing adding negation to subtraction  [serial 1344]
Solved by: Identity (id):  P->P is tautology

Theorem (144)                               [serial 1344] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [109] ->
Q [53] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:  applied wp for simultaneous assignment [serial 1342]
Solved by: Relationship between subtraction and negative. (negsub) and theorems 142 143:
Theorem (142) [serial 1345] used for:
   changing adding negation to subtraction  [serial 1344] 
Theorem (143) [serial 1346] used for:
   changing adding negation to subtraction  [serial 1344] 


Theorem (145)                               [serial 1342] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:    normalization of [serial 1340]
  Using: (df-bl.tsdis) (bl.addcom) ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Simultaneous Assignment
 and theorem 144:
Theorem (144) [serial 1344] used for:
  applied wp for simultaneous assignment [serial 1342] 


Theorem (146)                               [serial 1340] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if not ( SENSOR_CONNECTED^( - s ) )^1  or MOTION_ARTIFACT^( 1  + 
      - s ) then 0.0 Hz else HEART_RATE^( 1  + - s )) = heart_rate_store[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:  Distribute ^ over complement. (bl.tsnot)
   [serial 1339]
Solved by: Time shift distributes. (df-bl.tsdis)(df-bl.tsdisc) Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 145:
Theorem (145) [serial 1342] used for:
    normalization of [serial 1340] 


Theorem (147)                               [serial 1339] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( not SENSOR_CONNECTED^( - s ) )^1  or MOTION_ARTIFACT^( 1  + 
      - s ) then 0.0 Hz else HEART_RATE^( 1  + - s )) = heart_rate_store[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:    normalization of [serial 1337]
  Using: (bl.addcom) ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Distribute ^ over complement. (bl.tsnot) and theorem 146:
Theorem (146) [serial 1340] used for:
  Distribute ^ over complement. (bl.tsnot)
   [serial 1339] 


Theorem (148)                               [serial 1337] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( MOTION_ARTIFACT^( ( - s ) + 1  ) or ( not SENSOR_CONNECTED^( - s ) )^1  ) then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:  Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3)
   [serial 1336]
Solved by: Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 147:
Theorem (147) [serial 1339] used for:
    normalization of [serial 1337] 


Theorem (149)                               [serial 1336] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1  then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:    normalization of [serial 1334]
  Using: (bl.addcom) (l.caretintro) ADD_UNNECESSARY_PARETHESES 
Solved by: Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3) and theorem 148:
Theorem (148) [serial 1337] used for:
  Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3)
   [serial 1336] 


Theorem (150)                               [serial 1334] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1  then ( 0.0 Hz )^1  else HEART_RATE^( 
      ( - s ) + 1  )) = heart_rate_store[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:  Distribute ^ over conditonal expression. (bl.tsqq)
   [serial 1333]
Solved by: Addition Commutes. (bl.addcom) null [Add unnecessary parentheses] and theorem 149:
Theorem (149) [serial 1336] used for:
    normalization of [serial 1334] 


Theorem (151)                               [serial 1333] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s ))^1  = heart_rate_store[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:    normalization of [serial 1331]
Solved by: Distribute ^ over conditonal expression. (bl.tsqq) and theorem 150:
Theorem (150) [serial 1334] used for:
  Distribute ^ over conditonal expression. (bl.tsqq)
   [serial 1333] 


Theorem (152)                               [serial 1331] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s ))^1  = ( heart_rate_store[s] )^1  )  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:  Distribute ^ over relation. (bl.tsrel)
   [serial 1330]
Solved by: [Add unnecessary parentheses] and theorem 151:
Theorem (151) [serial 1333] used for:
    normalization of [serial 1331] 


Theorem (153)                               [serial 1330] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s )) = heart_rate_store[s] )^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:    normalization of [serial 1328]
  Using: (l.caretintro) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Distribute ^ over relation. (bl.tsrel) and theorem 152:
Theorem (152) [serial 1331] used for:
  Distribute ^ over relation. (bl.tsrel)
   [serial 1330] 


Theorem (154)                               [serial 1328] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( ( #PulseOx_Properties::Num_Trending_Samples  )^1  = ( num_samples )^1  )
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s )) = heart_rate_store[s] )^1   ) >>
Why created:  Distribute ^ over relation. (bl.tsrel)
  Distribute ^ over universal quantification. (bl.tsal)
   [serial 1327]
Solved by: null [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 153:
Theorem (153) [serial 1330] used for:
    normalization of [serial 1328] 


Theorem (155)                               [serial 1327] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( #PulseOx_Properties::Num_Trending_Samples  = num_samples )^1 
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  )^1  >>
Why created:    normalization of [serial 1325]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Distribute ^ over relation. (bl.tsrel) Distribute ^ over universal quantification. (bl.tsal) and theorem 154:
Theorem (154) [serial 1328] used for:
  Distribute ^ over relation. (bl.tsrel)
  Distribute ^ over universal quantification. (bl.tsal)
   [serial 1327] 


Theorem (156)                               [serial 1325] 
P [51] << ( ( all s ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s ))  ) )
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  ) >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( ( all s ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s ))  )^1 
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  )^1  ) >>
Why created:  Distribute ^ over conjunction. (bl.tsan)(df-bl.tsan2)(bl.tsan3)
   [serial 1324]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 155:
Theorem (155) [serial 1327] used for:
    normalization of [serial 1325] 


Theorem (157)                               [serial 1324] 
P [51] << ( ( all s ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 Hz else HEART_RATE^( 1  - s ))  ) )
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  ) >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( ( all s ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  )^1  >>
Why created:  Substituted assertions' predicates for labels  [serial 1015]
Solved by: Distribute ^ over conjunction. (bl.tsan)(df-bl.tsan2)(bl.tsan3) and theorem 156:
Theorem (156) [serial 1325] used for:
  Distribute ^ over conjunction. (bl.tsan)(df-bl.tsan2)(bl.tsan3)
   [serial 1324] 


Theorem (158)                               [serial 1015] 
P [51] << ( HOLD_HR(num_samples) )
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  ) >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  )^1  >>
Why created:   <<M(check) and x>> A <<M(run)>> for hrtt2b: check-[x]->run{A};
Solved by: Predicate Invocation. (PI) and theorem 157:
Theorem (157) [serial 1324] used for:
  Substituted assertions' predicates for labels  [serial 1015] 


Theorem (159)                               [serial 1016] 
P [51] << ( HOLD_HR(num_samples) )
  and ( num_samples > #PulseOx_Properties::Num_Trending_Samples  ) >>
S [110] ->
Q [55] << true >>
Why created:   <<M(check) and x>> -> <<M(fail)>> for hrtt2c: check-[x]->fail{};
Solved by: Anything Implies True (a1tru): P->true

Theorem (160)                               [serial 1426] 
P [53] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and INV_HR() >>
S [53] ->
Q [113] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and true
  and INV_HR() >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (161)                               [serial 1426] 
P [53] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and INV_HR() >>
S [53] ->
Q [113] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and true
  and INV_HR() >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (162)                               [serial 1369] 
P [53] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and INV_HR() >>
S [53] ->
Q [113] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and AXIOM_HRT()
  and INV_HR() >>
Why created:    normalization of [serial 1347]
  Using: (eqcom) (bl.ancom) 
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 161 161:
Theorem (161) [serial 1426] used for:
   add user-defined "givens" to postcondition 
Theorem (161) [serial 1426] used for:
   add user-defined "givens" to postcondition 


Theorem (163)                               [serial 1347] 
P [53] << INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
S [53] ->
Q [113] << INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_HRT() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1017]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 162:
Theorem (162) [serial 1369] used for:
    normalization of [serial 1347] 


Theorem (164)                               [serial 1455] 
P [161] << ( all #4# ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - #4# ) or not SENSOR_CONNECTED^( 1  + 
      - #4# ) then 0.0 Hz else HEART_RATE^( 1  + - #4# )) = heart_rate_store[#4#]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [53] ->
Q [36] << all #5# ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - #5# ) or not SENSOR_CONNECTED^( 1  + 
      - #5# ) then 0.0 Hz else HEART_RATE^( 1  + - #5# )) = heart_rate_store[#5#]^1   >>
Why created:   changing adding negation to subtraction  [serial 1454]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (165)                               [serial 1454] 
P [161] << ( all #4# ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - #4# ) or not SENSOR_CONNECTED^( 1  - #4# ) then 0.0 Hz else HEART_RATE^( 1  - #4# )) = heart_rate_store[#4#]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [53] ->
Q [36] << all #5# ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - #5# ) or not SENSOR_CONNECTED^( 1  + 
      - #5# ) then 0.0 Hz else HEART_RATE^( 1  + - #5# )) = heart_rate_store[#5#]^1   >>
Why created:  Substitution of variable in universal quantifier. (sb8)
  Addition Commutes. (bl.addcom)
  [Add unnecessary parentheses]
   [serial 1452]
Solved by: Relationship between subtraction and negative. (negsub) and theorem 164:
Theorem (164) [serial 1455] used for:
   changing adding negation to subtraction  [serial 1454] 


Theorem (166)                               [serial 1452] 
P [161] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [53] ->
Q [36] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]^1   ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1450]
Solved by: Substitution of variable in universal quantifier. (sb8) Addition Commutes. (bl.addcom) [Add unnecessary parentheses] and theorem 165:
Theorem (165) [serial 1454] used for:
  Substitution of variable in universal quantifier. (sb8)
  Addition Commutes. (bl.addcom)
  [Add unnecessary parentheses]
   [serial 1452] 


Theorem (167)                               [serial 1453] 
P [161] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [53] ->
Q [53] << #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1450]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (168)                               [serial 1450] 
P [161] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [53] ->
Q [16] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:    normalization of [serial 1448]
  Using: (df-bl.tsdis) (bl.addcom) ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 166 167:
Theorem (166) [serial 1452] used for:
  Join consequents with conjunction. (3jca)
   [serial 1450] 
Theorem (167) [serial 1453] used for:
  Join consequents with conjunction. (3jca)
   [serial 1450] 


Theorem (169)                               [serial 1448] 
P [161] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [53] ->
Q [16] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if not ( SENSOR_CONNECTED^( - s ) )^1  or MOTION_ARTIFACT^( 1  + 
      - s ) then 0.0 Hz else HEART_RATE^( 1  + - s )) = heart_rate_store[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:  Distribute ^ over complement. (bl.tsnot)
   [serial 1447]
Solved by: Time shift distributes. (df-bl.tsdis)(df-bl.tsdisc) Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 168:
Theorem (168) [serial 1450] used for:
    normalization of [serial 1448] 


Theorem (170)                               [serial 1447] 
P [161] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [53] ->
Q [16] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( not SENSOR_CONNECTED^( - s ) )^1  or MOTION_ARTIFACT^( 1  + 
      - s ) then 0.0 Hz else HEART_RATE^( 1  + - s )) = heart_rate_store[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:    normalization of [serial 1445]
  Using: (bl.addcom) ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Distribute ^ over complement. (bl.tsnot) and theorem 169:
Theorem (169) [serial 1448] used for:
  Distribute ^ over complement. (bl.tsnot)
   [serial 1447] 


Theorem (171)                               [serial 1445] 
P [161] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [53] ->
Q [16] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( MOTION_ARTIFACT^( ( - s ) + 1  ) or ( not SENSOR_CONNECTED^( - s ) )^1  ) then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:  Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3)
   [serial 1444]
Solved by: Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 170:
Theorem (170) [serial 1447] used for:
    normalization of [serial 1445] 


Theorem (172)                               [serial 1444] 
P [161] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [53] ->
Q [16] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1  then 0.0 Hz else HEART_RATE^( 
      1  + - s )) = heart_rate_store[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:    normalization of [serial 1442]
  Using: (bl.addcom) (l.caretintro) ADD_UNNECESSARY_PARETHESES 
Solved by: Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3) and theorem 171:
Theorem (171) [serial 1445] used for:
  Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3)
   [serial 1444] 


Theorem (173)                               [serial 1442] 
P [161] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [53] ->
Q [16] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1  then ( 0.0 Hz )^1  else HEART_RATE^( 
      ( - s ) + 1  )) = heart_rate_store[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:  Distribute ^ over conditonal expression. (bl.tsqq)
   [serial 1441]
Solved by: Addition Commutes. (bl.addcom) null [Add unnecessary parentheses] and theorem 172:
Theorem (172) [serial 1444] used for:
    normalization of [serial 1442] 


Theorem (174)                               [serial 1441] 
P [161] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [53] ->
Q [16] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s ))^1  = heart_rate_store[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:    normalization of [serial 1439]
Solved by: Distribute ^ over conditonal expression. (bl.tsqq) and theorem 173:
Theorem (173) [serial 1442] used for:
  Distribute ^ over conditonal expression. (bl.tsqq)
   [serial 1441] 


Theorem (175)                               [serial 1439] 
P [161] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [53] ->
Q [16] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s ))^1  = ( heart_rate_store[s] )^1  )  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:  Distribute ^ over relation. (bl.tsrel)
   [serial 1438]
Solved by: [Add unnecessary parentheses] and theorem 174:
Theorem (174) [serial 1441] used for:
    normalization of [serial 1439] 


Theorem (176)                               [serial 1438] 
P [161] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [53] ->
Q [16] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s )) = heart_rate_store[s] )^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:    normalization of [serial 1436]
  Using: (l.caretintro) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Distribute ^ over relation. (bl.tsrel) and theorem 175:
Theorem (175) [serial 1439] used for:
  Distribute ^ over relation. (bl.tsrel)
   [serial 1438] 


Theorem (177)                               [serial 1436] 
P [161] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [53] ->
Q [16] << ( ( #PulseOx_Properties::Num_Trending_Samples  )^1  = ( num_samples )^1  )
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s )) = heart_rate_store[s] )^1   ) >>
Why created:  Distribute ^ over relation. (bl.tsrel)
  Distribute ^ over universal quantification. (bl.tsal)
   [serial 1435]
Solved by: null [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 176:
Theorem (176) [serial 1438] used for:
    normalization of [serial 1436] 


Theorem (178)                               [serial 1435] 
P [161] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [53] ->
Q [16] << ( #PulseOx_Properties::Num_Trending_Samples  = num_samples )^1 
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  )^1  >>
Why created:    normalization of [serial 1433]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Distribute ^ over relation. (bl.tsrel) Distribute ^ over universal quantification. (bl.tsal) and theorem 177:
Theorem (177) [serial 1436] used for:
  Distribute ^ over relation. (bl.tsrel)
  Distribute ^ over universal quantification. (bl.tsal)
   [serial 1435] 


Theorem (179)                               [serial 1433] 
P [161] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[i]^1  = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))  )
  and num_samples^1  = #PulseOx_Properties::Num_Trending_Samples  >>
S [53] ->
Q [16] << ( ( #PulseOx_Properties::Num_Trending_Samples  = num_samples )^1 
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s ))  )^1  ) >>
Why created:  x' is x^1 (df-bl.tick)
  Distribute ^ over conjunction. (bl.tsan)(df-bl.tsan2)(bl.tsan3)
   [serial 1432]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 178:
Theorem (178) [serial 1435] used for:
    normalization of [serial 1433] 


Theorem (180)                               [serial 1432] 
P [161] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))  )
  and num_samples' = #PulseOx_Properties::Num_Trending_Samples  >>
S [53] ->
Q [16] << ( #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s ))  ) )^1  >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1371]
Solved by: x' is x^1 (df-bl.tick) Distribute ^ over conjunction. (bl.tsan)(df-bl.tsan2)(bl.tsan3) and theorem 179:
Theorem (179) [serial 1433] used for:
  x' is x^1 (df-bl.tick)
  Distribute ^ over conjunction. (bl.tsan)(df-bl.tsan2)(bl.tsan3)
   [serial 1432] 


Theorem (181)                               [serial 1371] 
P [161] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))  )
  and num_samples' = #PulseOx_Properties::Num_Trending_Samples  >>
S [53] ->
Q [16] << ( #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and INV_HR() )^1  >>
Why created:    normalization of [serial 1348]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 180:
Theorem (180) [serial 1432] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1371] 


Theorem (182)                               [serial 1348] 
P [161] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))  )
  and num_samples' = #PulseOx_Properties::Num_Trending_Samples  >>
S [53] ->
Q [16] << ( INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  )^1  >>
Why created:  <<Q6>> -> <<Q>> in sequential composition for [serial 1017]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 181:
Theorem (181) [serial 1371] used for:
    normalization of [serial 1348] 


Theorem (183)                               [serial 1427] 
P [113] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and AXIOM_HRT()
  and INV_HR() >>
S [114] HeartRateTrend!(heart_rate_store)
Q [116] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and true
  and INV_HR() >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (184)                               [serial 1427] 
P [113] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and AXIOM_HRT()
  and INV_HR() >>
S [114] HeartRateTrend!(heart_rate_store)
Q [116] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and true
  and INV_HR() >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (185)                               [serial 1373] 
P [113] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and AXIOM_HRT()
  and INV_HR() >>
S [114] HeartRateTrend!(heart_rate_store)
Q [116] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and AXIOM_HRT()
  and INV_HR() >>
Why created:    normalization of [serial 1349]
  Using: (eqcom) (bl.ancom) 
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 184 184:
Theorem (184) [serial 1427] used for:
   add user-defined "givens" to postcondition 
Theorem (184) [serial 1427] used for:
   add user-defined "givens" to postcondition 


Theorem (186)                               [serial 1349] 
P [113] << INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_HRT() >>
S [114] HeartRateTrend!(heart_rate_store)
Q [116] << INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_HRT() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1017]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 185:
Theorem (185) [serial 1373] used for:
    normalization of [serial 1349] 


Theorem (187)                               [serial 1428] 
P [116] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and AXIOM_HRT()
  and INV_HR() >>
S [117] NumSamples!(num_samples)
Q [119] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and true
  and INV_HR() >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (188)                               [serial 1428] 
P [116] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and AXIOM_HRT()
  and INV_HR() >>
S [117] NumSamples!(num_samples)
Q [119] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and true
  and INV_HR() >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (189)                               [serial 1375] 
P [116] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and AXIOM_HRT()
  and INV_HR() >>
S [117] NumSamples!(num_samples)
Q [119] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and AXIOM_CR()
  and INV_HR() >>
Why created:    normalization of [serial 1350]
  Using: (eqcom) (bl.ancom) 
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 188 188:
Theorem (188) [serial 1428] used for:
   add user-defined "givens" to postcondition 
Theorem (188) [serial 1428] used for:
   add user-defined "givens" to postcondition 


Theorem (190)                               [serial 1350] 
P [116] << INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_HRT() >>
S [117] NumSamples!(num_samples)
Q [119] << INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_CR() >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1017]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 189:
Theorem (189) [serial 1375] used for:
    normalization of [serial 1350] 


Theorem (191)                               [serial 1468] 
P [122] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = heart_rate_store[i]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [124] ->
Q [125] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = heart_rate_store[i]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:  applied wp for assignment [serial 1381]
Solved by: Identity (id):  P->P is tautology

Theorem (192)                               [serial 1381] 
P [122] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = heart_rate_store[i]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [124] hr_nxt[1  + i] := heart_rate_store[i]
Q [125] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
1  + i]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:    normalization of [serial 1355]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 191:
Theorem (191) [serial 1468] used for:
  applied wp for assignment [serial 1381] 


Theorem (193)                               [serial 1355] 
P [122] << heart_rate_store[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i ))
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
S [124] hr_nxt[i + 1 ] := heart_rate_store[i]
Q [125] << hr_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i ))
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1351]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 192:
Theorem (192) [serial 1381] used for:
    normalization of [serial 1355] 


Theorem (194)                               [serial 1460] 
P [119] << ( all #6# ~ quantity whole 
  in 0  .. ( num_samples - 2  ) 
  are (if MOTION_ARTIFACT^( -1  + - #6# ) or not SENSOR_CONNECTED^( -1  + 
      - #6# ) then 0.0 Hz else HEART_RATE^( -1  + - #6# )) = heart_rate_store[
      1  + #6#]  )
  and num_samples - 2  < num_samples - 1 
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [120] ->
Q [19] << ( all #7# ~ quantity whole 
  in 0  .. ( num_samples - 2  ) 
  are (if MOTION_ARTIFACT^( -1  + - #7# ) or not SENSOR_CONNECTED^( -1  + 
      - #7# ) then 0.0 Hz else HEART_RATE^( -1  + - #7# )) = heart_rate_store[
      1  + #7#]  )
  and ( all #7# ~ quantity whole 
  in 0  .. ( num_samples - 2  ) 
  are #PulseOx_Properties::Num_Trending_Samples  = num_samples  ) >>
Why created:  Universal quantification of conjunction is conjunction of universal quantification. (r19.26)
   [serial 1459]
Solved by: Axiom of Distinctness. (ax-5)

Theorem (195)                               [serial 1459] 
P [119] << ( all #6# ~ quantity whole 
  in 0  .. ( num_samples - 2  ) 
  are (if MOTION_ARTIFACT^( -1  + - #6# ) or not SENSOR_CONNECTED^( -1  + 
      - #6# ) then 0.0 Hz else HEART_RATE^( -1  + - #6# )) = heart_rate_store[
      1  + #6#]  )
  and num_samples - 2  < num_samples - 1 
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [120] ->
Q [19] << all #7# ~ quantity whole 
  in 0  .. ( num_samples - 2  ) 
  are (if MOTION_ARTIFACT^( -1  + - #7# ) or not SENSOR_CONNECTED^( -1  + 
      - #7# ) then 0.0 Hz else HEART_RATE^( -1  + - #7# )) = heart_rate_store[
      1  + #7#]
        and #PulseOx_Properties::Num_Trending_Samples  = num_samples  >>
Why created:  Substitution of variable in universal quantifier. (sb8)
  Addition Commutes. (bl.addcom)
  [Add unnecessary parentheses]
   [serial 1458]
Solved by: Universal quantification of conjunction is conjunction of universal quantification. (r19.26) and theorem 194:
Theorem (194) [serial 1460] used for:
  Universal quantification of conjunction is conjunction of universal quantification. (r19.26)
   [serial 1459] 


Theorem (196)                               [serial 1458] 
P [119] << ( all s ~ quantity whole 
  in 0  .. ( num_samples - 2  ) 
  are (if MOTION_ARTIFACT^( -1  + - s ) or not SENSOR_CONNECTED^( -1  + 
      - s ) then 0.0 Hz else HEART_RATE^( -1  + - s )) = heart_rate_store[
      1  + s]  )
  and num_samples - 2  < num_samples - 1 
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [120] ->
Q [19] << all i ~ quantity whole 
  in 0  .. ( num_samples - 2  ) 
  are (if MOTION_ARTIFACT^( -1  + - i ) or not SENSOR_CONNECTED^( -1  + 
      - i ) then 0.0 Hz else HEART_RATE^( -1  + - i )) = heart_rate_store[
      1  + i]
        and #PulseOx_Properties::Num_Trending_Samples  = num_samples  >>
Why created:  Contract universal quantification, lower bound.  (bl.cuqlb)
   [serial 1457]
Solved by: Substitution of variable in universal quantifier. (sb8) Addition Commutes. (bl.addcom) [Add unnecessary parentheses] and theorem 195:
Theorem (195) [serial 1459] used for:
  Substitution of variable in universal quantifier. (sb8)
  Addition Commutes. (bl.addcom)
  [Add unnecessary parentheses]
   [serial 1458] 


Theorem (197)                               [serial 1457] 
P [119] << ( all s ~ quantity whole 
  in 0  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( -1  + - s ) or not SENSOR_CONNECTED^( -1  + 
      - s ) then 0.0 Hz else HEART_RATE^( -1  + - s )) = heart_rate_store[
      1  + s]  )
  and num_samples - 2  < num_samples - 1 
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [120] ->
Q [19] << all i ~ quantity whole 
  in 0  .. ( num_samples - 2  ) 
  are (if MOTION_ARTIFACT^( -1  + - i ) or not SENSOR_CONNECTED^( -1  + 
      - i ) then 0.0 Hz else HEART_RATE^( -1  + - i )) = heart_rate_store[
      1  + i]
        and #PulseOx_Properties::Num_Trending_Samples  = num_samples  >>
Why created:  null
   [serial 1456]
Solved by: Contract universal quantification, lower bound.  (bl.cuqlb) and theorem 196:
Theorem (196) [serial 1458] used for:
  Contract universal quantification, lower bound.  (bl.cuqlb)
   [serial 1457] 


Theorem (198)                               [serial 1456] 
P [119] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and ( num_samples - 2  < num_samples - 1  )
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 Hz else HEART_RATE^( - s ))  ) >>
S [120] ->
Q [19] << all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = heart_rate_store[i]
        and #PulseOx_Properties::Num_Trending_Samples  = num_samples  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1377]
Solved by: null and theorem 197:
Theorem (197) [serial 1457] used for:
  null
   [serial 1456] 


Theorem (199)                               [serial 1377] 
P [119] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and AXIOM_CR()
  and INV_HR() >>
S [120] ->
Q [19] << all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = heart_rate_store[i]
        and #PulseOx_Properties::Num_Trending_Samples  = num_samples  >>
Why created:    normalization of [serial 1356]
  Using: (df-bl.lan1) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 198:
Theorem (198) [serial 1456] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1377] 


Theorem (200)                               [serial 1356] 
P [119] << ( INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_CR() ) >>
S [120] ->
Q [19] << all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are heart_rate_store[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples   >>
Why created:    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1351]
Solved by: Just one wff in the wff-list for conjunction. (df-bl.lan1) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 199:
Theorem (199) [serial 1377] used for:
    normalization of [serial 1356] 


Theorem (201)                               [serial 1464] 
P [19] << ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  )
  and ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are #PulseOx_Properties::Num_Trending_Samples  = num_samples  ) >>
S [120] ->
Q [128] << ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:  Universal quantification of conjunction is conjunction of universal quantification. (r19.26)
   [serial 1379]
Solved by: Axiom of Distinctness. (ax-5)

Theorem (202)                               [serial 1379] 
P [19] << all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]
        and #PulseOx_Properties::Num_Trending_Samples  = num_samples  >>
S [120] ->
Q [128] << ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:    normalization of [serial 1357]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Universal quantification of conjunction is conjunction of universal quantification. (r19.26) and theorem 201:
Theorem (201) [serial 1464] used for:
  Universal quantification of conjunction is conjunction of universal quantification. (r19.26)
   [serial 1379] 


Theorem (203)                               [serial 1357] 
P [19] << all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are hr_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples   >>
S [120] ->
Q [128] << ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are hr_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1351]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 202:
Theorem (202) [serial 1379] used for:
    normalization of [serial 1357] 


Theorem (204)                               [serial 1351] 
P [119] << INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_CR() >>
S [120] forall i in 1  .. ( num_samples - 1  )
    {
    << heart_rate_store[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i ))
      and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
    hr_nxt[i + 1 ] := heart_rate_store[i]
    << hr_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i ))
      and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
    }  
Q [128] << ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are hr_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1017]
Solved by:  Forall Rule (fa):
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any
 and theorems 193 200 203:
Theorem (193) [serial 1355] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1351] 
Theorem (200) [serial 1356] used for:
    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1351] 
Theorem (203) [serial 1357] used for:
    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1351] 


Theorem (205)                               [serial 1383] 
P [128] << ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [132] ->
Q [132] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) or not ( MOTION_ARTIFACT^0  or 
not SENSOR_CONNECTED^0  ) >>
Why created:    normalization of [serial 1358]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (206)                               [serial 1358] 
P [128] << ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are hr_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
S [132] ->
Q [132] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) or ( not ( MOTION_ARTIFACT^0  or 
not SENSOR_CONNECTED^0  ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1352]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 205:
Theorem (205) [serial 1383] used for:
    normalization of [serial 1358] 


Theorem (207)                               [serial 1385] 
P [132] << ( ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples )
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [132] ->
Q [134] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and SHFTR_HR() >>
Why created:    normalization of [serial 1359]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (208)                               [serial 1359] 
P [132] << ( ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are hr_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  )
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [132] ->
Q [134] << SHFTR_HR()
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
Why created:    <<P and B0>> -> <<P0>> in alternative for [serial 1352]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 207:
Theorem (207) [serial 1385] used for:
    normalization of [serial 1359] 


Theorem (209)                               [serial 1472] 
P [134] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and SHFTR_HR() >>
S [135] ->
Q [136] << 0.0 Hz = 0.0 Hz >>
Why created:  no reason Value of the conditional operator when its first argument is true. (iftrue)
  [Add unnecessary parentheses]
   [serial 1470]
Solved by: Law of identity. (eqid)

Theorem (210)                               [serial 1470] 
P [134] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and SHFTR_HR() >>
S [135] ->
Q [136] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = 0.0 Hz >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1469]
Solved by: Value of the conditional operator when its first argument is true. (iftrue) [Add unnecessary parentheses] and theorem 209:
Theorem (209) [serial 1472] used for:
  no reason Value of the conditional operator when its first argument is true. (iftrue)
  [Add unnecessary parentheses]
   [serial 1470] 


Theorem (211)                               [serial 1471] 
P [134] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and SHFTR_HR() >>
S [135] ->
Q [136] << SHFTR_HR() >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1469]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (212)                               [serial 1469] 
P [134] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and SHFTR_HR() >>
S [135] ->
Q [136] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = 0.0 Hz
  and SHFTR_HR() >>
Why created:  applied wp for assignment [serial 1387]
Solved by: Join consequents with conjunction. (3jca) and theorems 210 211:
Theorem (210) [serial 1470] used for:
  Join consequents with conjunction. (3jca)
   [serial 1469] 
Theorem (211) [serial 1471] used for:
  Join consequents with conjunction. (3jca)
   [serial 1469] 


Theorem (213)                               [serial 1387] 
P [134] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and SHFTR_HR() >>
S [135] hr_nxt[1 ] := 0.0 Hz
Q [136] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
  and SHFTR_HR() >>
Why created:    normalization of [serial 1360]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 212:
Theorem (212) [serial 1469] used for:
  applied wp for assignment [serial 1387] 


Theorem (214)                               [serial 1360] 
P [134] << SHFTR_HR()
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [135] hr_nxt[1 ] := 0.0 Hz
Q [136] << SHFTR_HR()
  and ( hr_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) ) >>
Why created:    <<P0>> S0 <<Q0>> in alternative for [serial 1352]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 213:
Theorem (213) [serial 1387] used for:
    normalization of [serial 1360] 


Theorem (215)                               [serial 1476] 
P [136] << ( ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ] >>
S [132] ->
Q [143] << ( all i ~ quantity whole 
  in 2  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:    normalization of [serial 1474]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (216)                               [serial 1474] 
P [136] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
  and ( ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are hr_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  ) >>
S [132] ->
Q [143] << ( all i ~ quantity whole 
  in 2  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1389]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 215:
Theorem (215) [serial 1476] used for:
    normalization of [serial 1474] 


Theorem (217)                               [serial 1389] 
P [136] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
  and SHFTR_HR() >>
S [132] ->
Q [143] << ( all i ~ quantity whole 
  in 2  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:    normalization of [serial 1361]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 216:
Theorem (216) [serial 1474] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1389] 


Theorem (218)                               [serial 1361] 
P [136] << SHFTR_HR()
  and ( hr_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) ) >>
S [132] ->
Q [143] << hr_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples 
  and ( all i ~ quantity whole 
  in 2  .. num_samples 
  are hr_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))  ) >>
Why created:    <<Q0>> -> <<Q>> in alternative  for [serial 1352]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 217:
Theorem (217) [serial 1389] used for:
    normalization of [serial 1361] 


Theorem (219)                               [serial 1391] 
P [132] << ( ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1  + i]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples )
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [132] ->
Q [139] << SHFTR_HR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
Why created:    normalization of [serial 1362]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (220)                               [serial 1362] 
P [132] << ( ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are hr_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  )
  and ( not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) ) >>
S [132] ->
Q [139] << SHFTR_HR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
Why created:    <<P and B1>> -> <<P1>> in alternative for [serial 1352]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 219:
Theorem (219) [serial 1391] used for:
    normalization of [serial 1362] 


Theorem (221)                               [serial 1494] 
P [139] << SHFTR_HR()
  and not ( MOTION_ARTIFACT or not SENSOR_CONNECTED ) >>
S [140] ->
Q [141] << HEART_RATE = HEART_RATE
  and SHFTR_HR() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1493]
Solved by: Law of identity. (eqid) Caret Introduction: if a predicate is always true it's true when time shifted (bl.caretintro) 
   or if a value is constant its value when time shifted is the same (bl.caretintrov) 

Theorem (222)                               [serial 1493] 
P [139] << SHFTR_HR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [140] ->
Q [141] << HEART_RATE = HEART_RATE^0 
  and SHFTR_HR() >>
Why created:  Replacing port names with BLESS::Value properties  [serial 1492]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 221:
Theorem (221) [serial 1494] used for:
  Assume Present:  P = P@now = P^0   [serial 1493] 


Theorem (223)                               [serial 1492] 
P [139] << SHFTR_HR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [140] ->
Q [141] << HeartRate = HEART_RATE^0 
  and SHFTR_HR() >>
Why created:  no reason Equality Commutes. (eqcom)
  Value of the conditional operator when its first argument is false. (iffalse)
  [Add unnecessary parentheses]
   [serial 1491]
Solved by:  Replacing port names with BLESS::Value properties
 and theorem 222:
Theorem (222) [serial 1493] used for:
  Replacing port names with BLESS::Value properties  [serial 1492] 


Theorem (224)                               [serial 1491] 
P [139] << SHFTR_HR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [140] ->
Q [141] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = HeartRate
  and SHFTR_HR() >>
Why created:  applied wp for assignment [serial 1393]
Solved by: Equality Commutes. (eqcom) Value of the conditional operator when its first argument is false. (iffalse) [Add unnecessary parentheses] and theorem 223:
Theorem (223) [serial 1492] used for:
  no reason Equality Commutes. (eqcom)
  Value of the conditional operator when its first argument is false. (iffalse)
  [Add unnecessary parentheses]
   [serial 1491] 


Theorem (225)                               [serial 1393] 
P [139] << SHFTR_HR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [140] hr_nxt[1 ] := HeartRate
Q [141] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
  and SHFTR_HR() >>
Why created:    normalization of [serial 1363]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 224:
Theorem (224) [serial 1491] used for:
  applied wp for assignment [serial 1393] 


Theorem (226)                               [serial 1363] 
P [139] << SHFTR_HR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [140] hr_nxt[1 ] := HeartRate
Q [141] << SHFTR_HR()
  and ( hr_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) ) >>
Why created:    <<P1>> S1 <<Q1>> in alternative for [serial 1352]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 225:
Theorem (225) [serial 1393] used for:
    normalization of [serial 1363] 


Theorem (227)                               [serial 1502] 
P [141] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
  and ( ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are hr_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  ) >>
S [132] ->
Q [143] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1501]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (228)                               [serial 1501] 
P [141] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
  and SHFTR_HR() >>
S [132] ->
Q [143] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:  [Add unnecessary parentheses]
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1395]
Solved by: Predicate Invocation. (PI) and theorem 227:
Theorem (227) [serial 1502] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1501] 


Theorem (229)                               [serial 1395] 
P [141] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
  and SHFTR_HR() >>
S [132] ->
Q [143] << ( all i ~ quantity whole 
  in 2  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:    normalization of [serial 1364]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
 [Add unnecessary parentheses] and theorem 228:
Theorem (228) [serial 1501] used for:
  [Add unnecessary parentheses]
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1395] 


Theorem (230)                               [serial 1364] 
P [141] << SHFTR_HR()
  and ( hr_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) ) >>
S [132] ->
Q [143] << hr_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples 
  and ( all i ~ quantity whole 
  in 2  .. num_samples 
  are hr_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))  ) >>
Why created:    <<Q1>> -> <<Q>> in alternative  for [serial 1352]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 229:
Theorem (229) [serial 1395] used for:
    normalization of [serial 1364] 


Theorem (231)                               [serial 1352] 
P [128] << ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are hr_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
S [132]   if 
    (MotionArtifact? or not SensorConnected?)~> 
      << SHFTR_HR()
        and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
      hr_nxt[1 ] := 0.0 Hz
      << SHFTR_HR()
        and ( hr_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) ) >> 
  []
    (not ( MotionArtifact? or not SensorConnected? ))~> 
      << SHFTR_HR()
        and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
      hr_nxt[1 ] := HeartRate
      << SHFTR_HR()
        and ( hr_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) ) >> 
  fi
Q [143] << hr_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples 
  and ( all i ~ quantity whole 
  in 2  .. num_samples 
  are hr_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))  ) >>
Why created:  <<Q3 and P4>> S4 <<Q4 and P5>> in sequential composition for [serial 1017]
Solved by: [Convert asseertion to port value.] and theorems 206 208 214 218 220 226 230:
Theorem (206) [serial 1358] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1352] 
Theorem (208) [serial 1359] used for:
    <<P and B0>> -> <<P0>> in alternative for [serial 1352] 
Theorem (214) [serial 1360] used for:
    <<P0>> S0 <<Q0>> in alternative for [serial 1352] 
Theorem (218) [serial 1361] used for:
    <<Q0>> -> <<Q>> in alternative  for [serial 1352] 
Theorem (220) [serial 1362] used for:
    <<P and B1>> -> <<P1>> in alternative for [serial 1352] 
Theorem (226) [serial 1363] used for:
    <<P1>> S1 <<Q1>> in alternative for [serial 1352] 
Theorem (230) [serial 1364] used for:
    <<Q1>> -> <<Q>> in alternative  for [serial 1352] 


Theorem (232)                               [serial 1516] 
P [150] << (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [152] ->
Q [153] << (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:  applied wp for assignment [serial 1401]
Solved by: Identity (id):  P->P is tautology

Theorem (233)                               [serial 1401] 
P [150] << (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [152] heart_rate_store[i] := hr_nxt[i]
Q [153] << (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:    normalization of [serial 1365]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 232:
Theorem (232) [serial 1516] used for:
  applied wp for assignment [serial 1401] 


Theorem (234)                               [serial 1365] 
P [150] << hr_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
S [152] heart_rate_store[i] := hr_nxt[i]
Q [153] << heart_rate_store[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1353]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 233:
Theorem (233) [serial 1401] used for:
    normalization of [serial 1365] 


Theorem (235)                               [serial 1512] 
P [143] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [148] ->
Q [19] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  )
  and ( all i ~ quantity whole 
  in 1  .. num_samples 
  are #PulseOx_Properties::Num_Trending_Samples  = num_samples  ) >>
Why created:  Universal quantification of conjunction is conjunction of universal quantification. (r19.26)
   [serial 1511]
Solved by: Axiom of Distinctness. (ax-5)

Theorem (236)                               [serial 1511] 
P [143] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [148] ->
Q [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]
        and #PulseOx_Properties::Num_Trending_Samples  = num_samples  >>
Why created:  [Add unnecessary parentheses]
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1397]
Solved by: Universal quantification of conjunction is conjunction of universal quantification. (r19.26) and theorem 235:
Theorem (235) [serial 1512] used for:
  Universal quantification of conjunction is conjunction of universal quantification. (r19.26)
   [serial 1511] 


Theorem (237)                               [serial 1397] 
P [143] << ( all i ~ quantity whole 
  in 2  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) = hr_nxt[1 ]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [148] ->
Q [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = hr_nxt[i]
        and #PulseOx_Properties::Num_Trending_Samples  = num_samples  >>
Why created:    normalization of [serial 1366]
  Using: (df-bl.lan1) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
 [Add unnecessary parentheses] and theorem 236:
Theorem (236) [serial 1511] used for:
  [Add unnecessary parentheses]
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1397] 


Theorem (238)                               [serial 1366] 
P [143] << ( hr_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples 
  and ( all i ~ quantity whole 
  in 2  .. num_samples 
  are hr_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))  ) ) >>
S [148] ->
Q [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are hr_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples   >>
Why created:    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1353]
Solved by: Just one wff in the wff-list for conjunction. (df-bl.lan1) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 237:
Theorem (237) [serial 1397] used for:
    normalization of [serial 1366] 


Theorem (239)                               [serial 1514] 
P [19] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]  )
  and ( all i ~ quantity whole 
  in 1  .. num_samples 
  are #PulseOx_Properties::Num_Trending_Samples  = num_samples  ) >>
S [148] ->
Q [156] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:  Universal quantification of conjunction is conjunction of universal quantification. (r19.26)
   [serial 1399]
Solved by: Axiom of Distinctness. (ax-5)

Theorem (240)                               [serial 1399] 
P [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]
        and #PulseOx_Properties::Num_Trending_Samples  = num_samples  >>
S [148] ->
Q [156] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:    normalization of [serial 1367]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Universal quantification of conjunction is conjunction of universal quantification. (r19.26) and theorem 239:
Theorem (239) [serial 1514] used for:
  Universal quantification of conjunction is conjunction of universal quantification. (r19.26)
   [serial 1399] 


Theorem (241)                               [serial 1367] 
P [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples   >>
S [148] ->
Q [156] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1353]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 240:
Theorem (240) [serial 1399] used for:
    normalization of [serial 1367] 


Theorem (242)                               [serial 1353] 
P [143] << hr_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples 
  and ( all i ~ quantity whole 
  in 2  .. num_samples 
  are hr_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))  ) >>
S [148] forall i in 1  .. num_samples
    {
    << hr_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))
      and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
    heart_rate_store[i] := hr_nxt[i]
    << heart_rate_store[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))
      and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
    }  
Q [156] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  <<Q4 and P5>> S5 <<Q5 and P6>> in sequential composition for [serial 1017]
Solved by:  Forall Rule (fa):
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any
 and theorems 234 238 241:
Theorem (234) [serial 1365] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1353] 
Theorem (238) [serial 1366] used for:
    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1353] 
Theorem (241) [serial 1367] used for:
    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1353] 


Theorem (243)                               [serial 1519] 
P [156] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [160] ->
Q [161] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:    normalization of [serial 1517]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Identity (id):  P->P is tautology

Theorem (244)                               [serial 1521] 
P [156] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [160] ->
Q [161] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:    normalization of [serial 1517]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Identity (id):  P->P is tautology

Theorem (245)                               [serial 1517] 
P [156] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [160] ->
Q [161] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  applied wp for simultaneous assignment [serial 1403]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorems 243 244:
Theorem (243) [serial 1519] used for:
    normalization of [serial 1517] 
Theorem (244) [serial 1521] used for:
    normalization of [serial 1517] 


Theorem (246)                               [serial 1403] 
P [156] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i )) = heart_rate_store[i]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [160] |heart_rate_store',num_samples' := heart_rate_store,num_samples|  
Q [161] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))  )
  and num_samples' = #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    normalization of [serial 1354]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by:  Simultaneous Assignment
 and theorem 245:
Theorem (245) [serial 1517] used for:
  applied wp for simultaneous assignment [serial 1403] 


Theorem (247)                               [serial 1354] 
P [156] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
S [160] |heart_rate_store',num_samples' := heart_rate_store,num_samples|  
Q [161] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are heart_rate_store[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))  )
  and num_samples' = #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  <<Q5 and P6>> S6 <<Q6>> in sequential composition for [serial 1017]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 246:
Theorem (246) [serial 1403] used for:
    normalization of [serial 1354] 


Theorem (248)                               [serial 1017] 
P [53] << INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
S [113]   << INV_HR()
    and num_samples = #PulseOx_Properties::Num_Trending_Samples 
    and AXIOM_HRT() >>
  HeartRateTrend!(heart_rate_store)
  ;
  << INV_HR()
    and num_samples = #PulseOx_Properties::Num_Trending_Samples 
    and AXIOM_HRT() >>
  NumSamples!(num_samples)
  ;
  << INV_HR()
    and num_samples = #PulseOx_Properties::Num_Trending_Samples 
    and AXIOM_CR() >>
  forall i in 1  .. ( num_samples - 1  )
      {
      << heart_rate_store[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
      hr_nxt[i + 1 ] := heart_rate_store[i]
      << hr_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
      }  
  <<SHFTR_HR: :( all i ~ quantity whole 
    in 1  .. ( num_samples - 1  ) 
    are hr_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 Hz else HEART_RATE^( - i ))  )
    and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
  ;
    if 
      (MotionArtifact? or not SensorConnected?)~> 
        << SHFTR_HR()
          and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
        hr_nxt[1 ] := 0.0 Hz
        << SHFTR_HR()
          and ( hr_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) ) >> 
    []
      (not ( MotionArtifact? or not SensorConnected? ))~> 
        << SHFTR_HR()
          and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
        hr_nxt[1 ] := HeartRate
        << SHFTR_HR()
          and ( hr_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 ) ) >> 
    fi
  << hr_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 Hz else HEART_RATE^0 )
    and num_samples = #PulseOx_Properties::Num_Trending_Samples 
    and ( all i ~ quantity whole 
    in 2  .. num_samples 
    are hr_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))  ) >>
  ;
  forall i in 1  .. num_samples
      {
      << hr_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
      heart_rate_store[i] := hr_nxt[i]
      << heart_rate_store[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
      }  
  << ( all i ~ quantity whole 
    in 1  .. num_samples 
    are heart_rate_store[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))  )
    and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
  ;
  |heart_rate_store',num_samples' := heart_rate_store,num_samples|  
  << ( all i ~ quantity whole 
    in 1  .. num_samples 
    are heart_rate_store[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 Hz else HEART_RATE^( 1  - i ))  )
    and num_samples' = #PulseOx_Properties::Num_Trending_Samples  >> 
Q [53] << ( INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  )^1  >>
Why created:   <<M(run) and x>> A <<M(run)>> for hrtt3: run-[x]->run{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 163 182 186 190 204 231 242 247:
Theorem (163) [serial 1347] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1017] 
Theorem (182) [serial 1348] used for:
  <<Q6>> -> <<Q>> in sequential composition for [serial 1017] 
Theorem (186) [serial 1349] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1017] 
Theorem (190) [serial 1350] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1017] 
Theorem (204) [serial 1351] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1017] 
Theorem (231) [serial 1352] used for:
  <<Q3 and P4>> S4 <<Q4 and P5>> in sequential composition for [serial 1017] 
Theorem (242) [serial 1353] used for:
  <<Q4 and P5>> S5 <<Q5 and P6>> in sequential composition for [serial 1017] 
Theorem (247) [serial 1354] used for:
  <<Q5 and P6>> S6 <<Q6>> in sequential composition for [serial 1017] 


Theorem (249)                               [serial 1007] 
P [28] <<   >>
S [36] ->
Q [28] << HeartRateTrendThread.imp proof obligations >>
Why created:  Initial proof obligations for HeartRateTrendThread.imp
Solved by:  Component verification conditions
 and theorems 20 23 24 26 44 123 141 158 159 248:
Theorem (20) [serial 1008] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (23) [serial 1009] used for:
  <<M(fill)>> -> <<I>> from invariant I when complete state fill has Assertion <<M(fill)>> in its definition. 
Theorem (24) [serial 1010] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (26) [serial 1011] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state check, <<M(check)>> -> <<e1 or e2 or . . . en>> 
Theorem (44) [serial 1012] used for:
   <<M(start)>> A <<M(fill)>> for hrtt0: start-[ ]->fill{A}; 
Theorem (123) [serial 1013] used for:
   <<M(fill) and x>> A <<M(check)>> for hrtt1: fill-[x]->check{A}; 
Theorem (141) [serial 1014] used for:
   <<M(check) and x>> A <<M(fill)>> for hrtt2a: check-[x]->fill{A}; 
Theorem (158) [serial 1015] used for:
   <<M(check) and x>> A <<M(run)>> for hrtt2b: check-[x]->run{A}; 
Theorem (159) [serial 1016] used for:
   <<M(check) and x>> -> <<M(fail)>> for hrtt2c: check-[x]->fail{}; 
Theorem (248) [serial 1017] used for:
   <<M(run) and x>> A <<M(run)>> for hrtt3: run-[x]->run{A}; 


Theorem (250)                               [serial 1542] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [33] ->
Q [33] << all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s )) = spo2_a[s]  >>
Why created:    normalization of [serial 1540]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (251)                               [serial 1540] 
P [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))  )
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  ) >>
S [33] ->
Q [33] << all s ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1019]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 250:
Theorem (250) [serial 1542] used for:
    normalization of [serial 1540] 


Theorem (252)                               [serial 1019] 
P [51] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  ) >>
S [33] ->
Q [33] << all s ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))  >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 251:
Theorem (251) [serial 1540] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1019] 


Theorem (253)                               [serial 1545] 
P [47] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [33] ->
Q [33] << all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s )) = spo2_a[s]  >>
Why created:    normalization of [serial 1543]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (254)                               [serial 1543] 
P [47] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))  )
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  ) >>
S [33] ->
Q [33] << all s ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1020]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 253:
Theorem (253) [serial 1545] used for:
    normalization of [serial 1543] 


Theorem (255)                               [serial 1020] 
P [47] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  ) >>
S [33] ->
Q [33] << all s ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))  >>
Why created:  <<M(loading)>> -> <<I>> from invariant I when complete state loading has Assertion <<M(loading)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 254:
Theorem (254) [serial 1543] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1020] 


Theorem (256)                               [serial 1021] 
P [43] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
  and ( num_samples = 0  )
  and ( all s ~ quantity whole 
  in ( num_samples + 1  ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  ) >>
S [43] ->
Q [43] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by: Anything Implies True (a1tru): P->true

Theorem (257)                               [serial 1547] 
P [49] << HOLD(num_samples) >>
S [49] ->
Q [49] << #PulseOx_Properties::Num_Trending_Samples  < num_samples or num_samples < #PulseOx_Properties::Num_Trending_Samples  or 
#PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:    normalization of [serial 1022]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeGreaterThanToLessThan (bl.orcom) 
Solved by: Trichotomy law for 'less than'. (lttri4)

Theorem (258)                               [serial 1022] 
P [49] << HOLD(num_samples) >>
S [49] ->
Q [49] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples  ) or ( num_samples = #PulseOx_Properties::Num_Trending_Samples  ) or 
( num_samples > #PulseOx_Properties::Num_Trending_Samples  ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state check, <<M(check)>> -> <<e1 or e2 or . . . en>>
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>B to B<A] Disjunction Commutes. (bl.orcom) and theorem 257:
Theorem (257) [serial 1547] used for:
    normalization of [serial 1022] 


Theorem (259)                               [serial 1576] 
P [43] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [55] ->
Q [33] << all s ~ quantity whole 
  in 1  .. 0  
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]^1   >>
Why created:  Guided Substitution of Equals 
 replacing "num_samples" with its = "0 " in its postcondition [serial 1575]
Solved by: Empty closed interval (icc0)

Theorem (260)                               [serial 1575] 
P [43] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [55] ->
Q [33] << all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]^1   >>
Why created:    normalization of [serial 1572]
  Using: (bl.addcom) ADD_UNNECESSARY_PARETHESES 
Solved by:  Guided Substitution of Equals
 and theorem 259:
Theorem (259) [serial 1576] used for:
  Guided Substitution of Equals 
 replacing "num_samples" with its = "0 " in its postcondition [serial 1575] 


Theorem (261)                               [serial 1572] 
P [43] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [55] ->
Q [33] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]^1   ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1571]
Solved by: Addition Commutes. (bl.addcom) [Add unnecessary parentheses] and theorem 260:
Theorem (260) [serial 1575] used for:
    normalization of [serial 1572] 


Theorem (262)                               [serial 1573] 
P [43] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [55] ->
Q [47] << num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1571]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (263)                               [serial 1571] 
P [43] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [55] ->
Q [47] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]^1   )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  applied wp for assignment [serial 1569]
Solved by: Join consequents with conjunction. (3jca) and theorems 261 262:
Theorem (261) [serial 1572] used for:
  Join consequents with conjunction. (3jca)
   [serial 1571] 
Theorem (262) [serial 1573] used for:
  Join consequents with conjunction. (3jca)
   [serial 1571] 


Theorem (264)                               [serial 1569] 
P [43] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    normalization of [serial 1567]
  Using: (df-bl.tsdis) (bl.addcom) ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 263:
Theorem (263) [serial 1571] used for:
  applied wp for assignment [serial 1569] 


Theorem (265)                               [serial 1567] 
P [43] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if not ( SENSOR_CONNECTED^( - s ) )^1  or MOTION_ARTIFACT^( 1  + 
      - s ) then 0.0 percent else SPO2^( 1  + - s )) = spo2_a[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  Distribute ^ over complement. (bl.tsnot)
   [serial 1566]
Solved by: Time shift distributes. (df-bl.tsdis)(df-bl.tsdisc) Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 264:
Theorem (264) [serial 1569] used for:
    normalization of [serial 1567] 


Theorem (266)                               [serial 1566] 
P [43] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( not SENSOR_CONNECTED^( - s ) )^1  or MOTION_ARTIFACT^( 1  + 
      - s ) then 0.0 percent else SPO2^( 1  + - s )) = spo2_a[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    normalization of [serial 1564]
  Using: (bl.addcom) ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Distribute ^ over complement. (bl.tsnot) and theorem 265:
Theorem (265) [serial 1567] used for:
  Distribute ^ over complement. (bl.tsnot)
   [serial 1566] 


Theorem (267)                               [serial 1564] 
P [43] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( MOTION_ARTIFACT^( ( - s ) + 1  ) or ( not SENSOR_CONNECTED^( - s ) )^1  ) then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3)
   [serial 1563]
Solved by: Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 266:
Theorem (266) [serial 1566] used for:
    normalization of [serial 1564] 


Theorem (268)                               [serial 1563] 
P [43] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1  then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    normalization of [serial 1561]
  Using: (bl.addcom) (l.caretintro) ADD_UNNECESSARY_PARETHESES 
Solved by: Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3) and theorem 267:
Theorem (267) [serial 1564] used for:
  Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3)
   [serial 1563] 


Theorem (269)                               [serial 1561] 
P [43] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1  then ( 0.0 percent )^1  else SPO2^( 
      ( - s ) + 1  )) = spo2_a[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  Distribute ^ over conditonal expression. (bl.tsqq)
   [serial 1560]
Solved by: Addition Commutes. (bl.addcom) null [Add unnecessary parentheses] and theorem 268:
Theorem (268) [serial 1563] used for:
    normalization of [serial 1561] 


Theorem (270)                               [serial 1560] 
P [43] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))^1  = spo2_a[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    normalization of [serial 1558]
Solved by: Distribute ^ over conditonal expression. (bl.tsqq) and theorem 269:
Theorem (269) [serial 1561] used for:
  Distribute ^ over conditonal expression. (bl.tsqq)
   [serial 1560] 


Theorem (271)                               [serial 1558] 
P [43] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))^1  = ( spo2_a[s] )^1  )  )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  Distribute ^ over relation. (bl.tsrel)
   [serial 1557]
Solved by: [Add unnecessary parentheses] and theorem 270:
Theorem (270) [serial 1560] used for:
    normalization of [serial 1558] 


Theorem (272)                               [serial 1557] 
P [43] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s )) = spo2_a[s] )^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    normalization of [serial 1555]
  Using: (l.caretintro) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Distribute ^ over relation. (bl.tsrel) and theorem 271:
Theorem (271) [serial 1558] used for:
  Distribute ^ over relation. (bl.tsrel)
   [serial 1557] 


Theorem (273)                               [serial 1555] 
P [43] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( ( num_samples )^1  < ( #PulseOx_Properties::Num_Trending_Samples  )^1  )
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s )) = spo2_a[s] )^1   ) >>
Why created:  Distribute ^ over relation. (bl.tsrel)
  Distribute ^ over universal quantification. (bl.tsal)
   [serial 1554]
Solved by: null [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 272:
Theorem (272) [serial 1557] used for:
    normalization of [serial 1555] 


Theorem (274)                               [serial 1554] 
P [43] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )^1 
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s )) = spo2_a[s]  )^1  >>
Why created:    normalization of [serial 1552]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Distribute ^ over relation. (bl.tsrel) Distribute ^ over universal quantification. (bl.tsal) and theorem 273:
Theorem (273) [serial 1555] used for:
  Distribute ^ over relation. (bl.tsrel)
  Distribute ^ over universal quantification. (bl.tsal)
   [serial 1554] 


Theorem (275)                               [serial 1552] 
P [43] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s )) = spo2_a[s]  )^1 
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )^1  ) >>
Why created:  Distribute ^ over conjunction. (bl.tsan)(df-bl.tsan2)(bl.tsan3)
   [serial 1551]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 274:
Theorem (274) [serial 1554] used for:
    normalization of [serial 1552] 


Theorem (276)                               [serial 1551] 
P [43] << ( all s ~ quantity whole 
  in ( 1  + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and 0  = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  )^1  >>
Why created:    normalization of [serial 1549]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Distribute ^ over conjunction. (bl.tsan)(df-bl.tsan2)(bl.tsan3) and theorem 275:
Theorem (275) [serial 1552] used for:
  Distribute ^ over conjunction. (bl.tsan)(df-bl.tsan2)(bl.tsan3)
   [serial 1551] 


Theorem (277)                               [serial 1549] 
P [43] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
  and ( num_samples = 0  )
  and ( all s ~ quantity whole 
  in ( num_samples + 1  ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  ) >>
S [55] num_samples' := num_samples
Q [47] << ( ( all s ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))  )
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  ) )^1  >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1023]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 276:
Theorem (276) [serial 1551] used for:
    normalization of [serial 1549] 


Theorem (278)                               [serial 1023] 
P [43] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
  and ( num_samples = 0  )
  and ( all s ~ quantity whole 
  in ( num_samples + 1  ) .. #PulseOx_Properties::Num_Trending_Samples  
  are not SENSOR_CONNECTED^( - s )  ) >>
S [55] num_samples' := num_samples
Q [47] << ( SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  ) )^1  >>
Why created:   <<M(start)>> A <<M(loading)>> for sptt0: start-[ ]->loading{A};
Solved by: Predicate Invocation. (PI) and theorem 277:
Theorem (277) [serial 1549] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1023] 


Theorem (279)                               [serial 1646] 
P [47] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and SpO2_INV() >>
S [47] ->
Q [58] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and SpO2_INV()
  and true >>
Why created:    normalization of [serial 1600]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (280)                               [serial 1600] 
P [47] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  ) >>
S [47] ->
Q [58] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 279:
Theorem (279) [serial 1646] used for:
    normalization of [serial 1600] 


Theorem (281)                               [serial 1646] 
P [47] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and SpO2_INV() >>
S [47] ->
Q [58] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and SpO2_INV()
  and true >>
Why created:    normalization of [serial 1600]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (282)                               [serial 1600] 
P [47] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  ) >>
S [47] ->
Q [58] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 281:
Theorem (281) [serial 1646] used for:
    normalization of [serial 1600] 


Theorem (283)                               [serial 1579] 
P [47] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  ) >>
S [47] ->
Q [58] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
  and AXIOM_NS() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1024]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 282 282:
Theorem (282) [serial 1600] used for:
   add user-defined "givens" to postcondition 
Theorem (282) [serial 1600] used for:
   add user-defined "givens" to postcondition 


Theorem (284)                               [serial 1658] 
P [102] << all #8# ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - #8# ) or not SENSOR_CONNECTED^( 1  - #8# ) then 0.0 percent else SPO2^( 1  - #8# )) = spo2_a[#8#]  >>
S [49] ->
Q [49] << all #9# ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - #9# ) or not SENSOR_CONNECTED^( 1  - #9# ) then 0.0 percent else SPO2^( 1  - #9# )) = spo2_a[#9#]  >>
Why created:  Substitution of variable in universal quantifier. (sb8)
  [Add unnecessary parentheses]
   [serial 1657]
Solved by: Identity (id):  P->P is tautology

Theorem (285)                               [serial 1657] 
P [102] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_a[i]  >>
S [49] ->
Q [49] << all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  >>
Why created:    normalization of [serial 1655]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Substitution of variable in universal quantifier. (sb8) [Add unnecessary parentheses] and theorem 284:
Theorem (284) [serial 1658] used for:
  Substitution of variable in universal quantifier. (sb8)
  [Add unnecessary parentheses]
   [serial 1657] 


Theorem (286)                               [serial 1655] 
P [102] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_a[i]  >>
S [49] ->
Q [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s ))  ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1612]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 285:
Theorem (285) [serial 1657] used for:
    normalization of [serial 1655] 


Theorem (287)                               [serial 1612] 
P [102] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_a[i]  >>
S [49] ->
Q [49] << HOLD(num_samples) >>
Why created:    normalization of [serial 1580]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Predicate Invocation. (PI) and theorem 286:
Theorem (286) [serial 1655] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1612] 


Theorem (288)                               [serial 1580] 
P [102] << all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  >>
S [49] ->
Q [49] << HOLD(num_samples) >>
Why created:  <<Q6>> -> <<Q>> in sequential composition for [serial 1024]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 287:
Theorem (287) [serial 1612] used for:
    normalization of [serial 1580] 


Theorem (289)                               [serial 1707] 
P [58] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and ( num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY )
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))  ) >>
S [60] ->
Q [15] << ( all s ~ quantity whole 
  in 1  .. NUM_SAMPLES 
  are SPO2_HISTORY[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))  ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1648]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (290)                               [serial 1648] 
P [58] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_NS()
  and SpO2_INV() >>
S [60] ->
Q [15] << SPO2_TREND() >>
Why created:    normalization of [serial 1609]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 289:
Theorem (289) [serial 1707] used for:
  Substituted assertions' predicates for labels  [serial 1648] 


Theorem (291)                               [serial 1609] 
P [58] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
  and AXIOM_NS() >>
S [60] ->
Q [15] << SPO2_TREND() >>
Why created:  applied port output of value <<pre>> -> <<M(SpO2Trend)[SpO2Trend|spo2_a]>> [serial 1601]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 290:
Theorem (290) [serial 1648] used for:
    normalization of [serial 1609] 


Theorem (292)                               [serial 1650] 
P [60] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_NS()
  and SpO2_INV() )
  and SPO2_TREND()^0  >>
S [60] ->
Q [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and SpO2_INV()
  and true >>
Why created:    normalization of [serial 1610]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (293)                               [serial 1610] 
P [60] << ( SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
  and AXIOM_NS() )
  and ( SPO2_TREND() )^0  >>
S [60] ->
Q [62] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
  and true >>
Why created:  applied port output <<pre and (SPO2_TREND())^0>> -> <<post>> [serial 1601]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 292:
Theorem (292) [serial 1650] used for:
    normalization of [serial 1610] 


Theorem (294)                               [serial 1601] 
P [58] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
  and AXIOM_NS() >>
S [60] SpO2Trend!(spo2_a)
Q [62] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 291 293:
Theorem (291) [serial 1609] used for:
  applied port output of value <<pre>> -> <<M(SpO2Trend)[SpO2Trend|spo2_a]>> [serial 1601] 
Theorem (293) [serial 1610] used for:
  applied port output <<pre and (SPO2_TREND())^0>> -> <<post>> [serial 1601] 


Theorem (295)                               [serial 1707] 
P [58] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and ( num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY )
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))  ) >>
S [60] ->
Q [15] << ( all s ~ quantity whole 
  in 1  .. NUM_SAMPLES 
  are SPO2_HISTORY[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))  ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1648]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (296)                               [serial 1648] 
P [58] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_NS()
  and SpO2_INV() >>
S [60] ->
Q [15] << SPO2_TREND() >>
Why created:    normalization of [serial 1609]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 295:
Theorem (295) [serial 1707] used for:
  Substituted assertions' predicates for labels  [serial 1648] 


Theorem (297)                               [serial 1609] 
P [58] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
  and AXIOM_NS() >>
S [60] ->
Q [15] << SPO2_TREND() >>
Why created:  applied port output of value <<pre>> -> <<M(SpO2Trend)[SpO2Trend|spo2_a]>> [serial 1601]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 296:
Theorem (296) [serial 1648] used for:
    normalization of [serial 1609] 


Theorem (298)                               [serial 1650] 
P [60] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_NS()
  and SpO2_INV() )
  and SPO2_TREND()^0  >>
S [60] ->
Q [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and SpO2_INV()
  and true >>
Why created:    normalization of [serial 1610]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (299)                               [serial 1610] 
P [60] << ( SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
  and AXIOM_NS() )
  and ( SPO2_TREND() )^0  >>
S [60] ->
Q [62] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
  and true >>
Why created:  applied port output <<pre and (SPO2_TREND())^0>> -> <<post>> [serial 1601]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 298:
Theorem (298) [serial 1650] used for:
    normalization of [serial 1610] 


Theorem (300)                               [serial 1601] 
P [58] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
  and AXIOM_NS() >>
S [60] SpO2Trend!(spo2_a)
Q [62] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 297 299:
Theorem (297) [serial 1609] used for:
  applied port output of value <<pre>> -> <<M(SpO2Trend)[SpO2Trend|spo2_a]>> [serial 1601] 
Theorem (299) [serial 1610] used for:
  applied port output <<pre and (SPO2_TREND())^0>> -> <<post>> [serial 1601] 


Theorem (301)                               [serial 1581] 
P [58] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
  and AXIOM_NS() >>
S [60] SpO2Trend!(spo2_a)
Q [62] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
  and AXIOM_NS() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1024]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 300 300:
Theorem (300) [serial 1601] used for:
   add user-defined "givens" to postcondition 
Theorem (300) [serial 1601] used for:
   add user-defined "givens" to postcondition 


Theorem (302)                               [serial 1659] 
P [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and ( num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY )
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))  ) >>
S [64] ->
Q [64] << NUM_SAMPLES = num_samples >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1614]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (303)                               [serial 1614] 
P [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_NS()
  and SpO2_INV() >>
S [64] ->
Q [64] << NUM_SAMPLES = num_samples >>
Why created:    normalization of [serial 1602]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 302:
Theorem (302) [serial 1659] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1614] 


Theorem (304)                               [serial 1602] 
P [62] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
  and AXIOM_NS() >>
S [64] ->
Q [64] << num_samples = NUM_SAMPLES >>
Why created:  applied port output of value <<pre>> -> <<M(NumSamples)[NumSamples|num_samples]>> [serial 1582]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 303:
Theorem (303) [serial 1614] used for:
    normalization of [serial 1602] 


Theorem (305)                               [serial 1616] 
P [64] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and AXIOM_NS()
  and SpO2_INV() )
  and ( NUM_SAMPLES = num_samples )^0  >>
S [64] ->
Q [66] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and SpO2_INV() >>
Why created:    normalization of [serial 1603]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (306)                               [serial 1603] 
P [64] << ( SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
  and AXIOM_NS() )
  and ( num_samples = NUM_SAMPLES )^0  >>
S [64] ->
Q [66] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  ) >>
Why created:  applied port output <<pre and (num_samples = NUM_SAMPLES)^0>> -> <<post>> [serial 1582]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 305:
Theorem (305) [serial 1616] used for:
    normalization of [serial 1603] 


Theorem (307)                               [serial 1582] 
P [62] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
  and AXIOM_NS() >>
S [64] NumSamples!(num_samples)
Q [66] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  ) >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1024]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 304 306:
Theorem (304) [serial 1602] used for:
  applied port output of value <<pre>> -> <<M(NumSamples)[NumSamples|num_samples]>> [serial 1582] 
Theorem (306) [serial 1603] used for:
  applied port output <<pre and (num_samples = NUM_SAMPLES)^0>> -> <<post>> [serial 1582] 


Theorem (308)                               [serial 1622] 
P [69] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_a[i] >>
S [70] ->
Q [71] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_a[i] >>
Why created:    normalization of [serial 1604]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Identity (id):  P->P is tautology

Theorem (309)                               [serial 1604] 
P [69] << spo2_a[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) >>
S [70] ->
Q [71] << spo2_a[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) >>
Why created:  applied wp for assignment [serial 1587]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 308:
Theorem (308) [serial 1622] used for:
    normalization of [serial 1604] 


Theorem (310)                               [serial 1587] 
P [69] << spo2_a[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) >>
S [70] spo2_nxt[i + 1 ] := spo2_a[i]
Q [71] << spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) >>
Why created:  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1583]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 309:
Theorem (309) [serial 1604] used for:
  applied wp for assignment [serial 1587] 


Theorem (311)                               [serial 1666] 
P [66] << ( all #10# ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - #10# ) or not SENSOR_CONNECTED^( - #10# ) then 0.0 percent else SPO2^( - #10# )) = spo2_a[#10#]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [67] ->
Q [19] << all #11# ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - #11# ) or not SENSOR_CONNECTED^( - #11# ) then 0.0 percent else SPO2^( - #11# )) = spo2_a[#11#]  >>
Why created:  Substitution of variable in universal quantifier. (sb8)
  [Add unnecessary parentheses]
   [serial 1665]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (312)                               [serial 1665] 
P [66] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [67] ->
Q [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_a[i]  >>
Why created:    normalization of [serial 1663]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Substitution of variable in universal quantifier. (sb8) [Add unnecessary parentheses] and theorem 311:
Theorem (311) [serial 1666] used for:
  Substitution of variable in universal quantifier. (sb8)
  [Add unnecessary parentheses]
   [serial 1665] 


Theorem (313)                               [serial 1663] 
P [66] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))  ) >>
S [67] ->
Q [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_a[i]  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1618]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 312:
Theorem (312) [serial 1665] used for:
    normalization of [serial 1663] 


Theorem (314)                               [serial 1618] 
P [66] << num_samples < #PulseOx_Properties::Num_Trending_Samples 
  and SpO2_INV() >>
S [67] ->
Q [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_a[i]  >>
Why created:    normalization of [serial 1588]
  Using: (df-bl.lan1) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 313:
Theorem (313) [serial 1663] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1618] 


Theorem (315)                               [serial 1588] 
P [66] << ( SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  ) ) >>
S [67] ->
Q [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))  >>
Why created:    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1583]
Solved by: Just one wff in the wff-list for conjunction. (df-bl.lan1) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 314:
Theorem (314) [serial 1618] used for:
    normalization of [serial 1588] 


Theorem (316)                               [serial 1620] 
P [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  >>
S [67] ->
Q [73] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  >>
Why created:    normalization of [serial 1589]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Identity (id):  P->P is tautology

Theorem (317)                               [serial 1589] 
P [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))  >>
S [67] ->
Q [73] << all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))  >>
Why created:    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1583]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 316:
Theorem (316) [serial 1620] used for:
    normalization of [serial 1589] 


Theorem (318)                               [serial 1583] 
P [66] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  ) >>
S [67] forall i in 1  .. num_samples
    {
    << spo2_a[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) >>
    spo2_nxt[i + 1 ] := spo2_a[i]
    << spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) >>
    }  
Q [73] << all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))  >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1024]
Solved by:  Forall Rule (fa):
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any
 and theorems 310 315 317:
Theorem (310) [serial 1587] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1583] 
Theorem (315) [serial 1588] used for:
    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1583] 
Theorem (317) [serial 1589] used for:
    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1583] 


Theorem (319)                               [serial 1624] 
P [73] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  >>
S [76] ->
Q [76] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) or not ( MOTION_ARTIFACT^0  or 
not SENSOR_CONNECTED^0  ) >>
Why created:    normalization of [serial 1590]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (320)                               [serial 1590] 
P [73] << all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))  >>
S [76] ->
Q [76] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) or ( not ( MOTION_ARTIFACT^0  or 
not SENSOR_CONNECTED^0  ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1584]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 319:
Theorem (319) [serial 1624] used for:
    normalization of [serial 1590] 


Theorem (321)                               [serial 1667] 
P [76] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  )
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [76] ->
Q [78] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1626]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (322)                               [serial 1671] 
P [76] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  )
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [76] ->
Q [78] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  >>
Why created:    normalization of [serial 1669]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (323)                               [serial 1669] 
P [76] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  )
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [76] ->
Q [78] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))  ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1668]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 322:
Theorem (322) [serial 1671] used for:
    normalization of [serial 1669] 


Theorem (324)                               [serial 1668] 
P [76] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  )
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [76] ->
Q [78] << SHFT() >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1626]
Solved by: Predicate Invocation. (PI) and theorem 323:
Theorem (323) [serial 1669] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1668] 


Theorem (325)                               [serial 1626] 
P [76] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  )
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [76] ->
Q [78] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and SHFT() >>
Why created:    normalization of [serial 1591]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 321 324:
Theorem (321) [serial 1667] used for:
  Join consequents with conjunction. (3jca)
   [serial 1626] 
Theorem (324) [serial 1668] used for:
  Join consequents with conjunction. (3jca)
   [serial 1626] 


Theorem (326)                               [serial 1591] 
P [76] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))  )
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [76] ->
Q [78] << SHFT()
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
Why created:    <<P and B0>> -> <<P0>> in alternative for [serial 1584]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 325:
Theorem (325) [serial 1626] used for:
    normalization of [serial 1591] 


Theorem (327)                               [serial 1672] 
P [78] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and SHFT() >>
S [79] ->
Q [80] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and 0.0 percent = 0.0 percent
  and SHFT() >>
Why created:  no reason Value of the conditional operator when its first argument is true. (iftrue)
  [Add unnecessary parentheses]
   [serial 1628]
Solved by: Law of identity. (eqid)

Theorem (328)                               [serial 1628] 
P [78] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and SHFT() >>
S [79] ->
Q [80] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = 0.0 percent
  and SHFT() >>
Why created:    normalization of [serial 1605]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Value of the conditional operator when its first argument is true. (iftrue) [Add unnecessary parentheses] and theorem 327:
Theorem (327) [serial 1672] used for:
  no reason Value of the conditional operator when its first argument is true. (iftrue)
  [Add unnecessary parentheses]
   [serial 1628] 


Theorem (329)                               [serial 1605] 
P [78] << SHFT()
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [79] ->
Q [80] << SHFT()
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and ( 0.0 percent = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) ) >>
Why created:  applied wp for assignment [serial 1592]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 328:
Theorem (328) [serial 1628] used for:
    normalization of [serial 1605] 


Theorem (330)                               [serial 1592] 
P [78] << SHFT()
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [79] spo2_nxt[1 ] := 0.0 percent
Q [80] << SHFT()
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and ( spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) ) >>
Why created:    <<P0>> S0 <<Q0>> in alternative for [serial 1584]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 329:
Theorem (329) [serial 1605] used for:
  applied wp for assignment [serial 1592] 


Theorem (331)                               [serial 1680] 
P [80] << ( all i ~ quantity whole 
  in 0  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( -1  + - i ) or not SENSOR_CONNECTED^( -1  + 
      - i ) then 0.0 percent else SPO2^( -1  + - i )) = spo2_nxt[( 1  + 
      i ) + 1 ]  )
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ] >>
S [76] ->
Q [90] << all i ~ quantity whole 
  in 0  .. ( ( 1  + num_samples ) - 2  ) 
  are (if MOTION_ARTIFACT^( 1  - ( 2  + i ) ) or not SENSOR_CONNECTED^( 1  - ( 
      2  + i ) ) then 0.0 percent else SPO2^( 1  - ( 2  + i ) )) = spo2_nxt[
      2  + i]  >>
Why created:  null
   [serial 1678]
Solved by: Addition associativity (bl.add3i)(bl.add4i)

Theorem (332)                               [serial 1678] 
P [80] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ]
  and ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))  ) >>
S [76] ->
Q [90] << ( all i ~ quantity whole 
  in 2  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]  ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1677]
Solved by: null and theorem 331:
Theorem (331) [serial 1680] used for:
  null
   [serial 1678] 


Theorem (333)                               [serial 1679] 
P [80] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ]
  and ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))  ) >>
S [76] ->
Q [89] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ] >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1677]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (334)                               [serial 1677] 
P [80] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ]
  and ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))  ) >>
S [76] ->
Q [89] << ( all i ~ quantity whole 
  in 2  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ] >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1630]
Solved by: Join consequents with conjunction. (3jca) and theorems 332 333:
Theorem (332) [serial 1678] used for:
  Join consequents with conjunction. (3jca)
   [serial 1677] 
Theorem (333) [serial 1679] used for:
  Join consequents with conjunction. (3jca)
   [serial 1677] 


Theorem (335)                               [serial 1630] 
P [80] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ]
  and SHFT() >>
S [76] ->
Q [89] << ( all i ~ quantity whole 
  in 2  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ] >>
Why created:    normalization of [serial 1593]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 334:
Theorem (334) [serial 1677] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1630] 


Theorem (336)                               [serial 1593] 
P [80] << SHFT()
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and ( spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) ) >>
S [76] ->
Q [89] << ( spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) )
  and ( all i ~ quantity whole 
  in 2  .. ( num_samples + 1  ) 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  ) >>
Why created:    <<Q0>> -> <<Q>> in alternative  for [serial 1584]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 335:
Theorem (335) [serial 1630] used for:
    normalization of [serial 1593] 


Theorem (337)                               [serial 1694] 
P [76] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  )
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [76] ->
Q [84] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  >>
Why created:    normalization of [serial 1692]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (338)                               [serial 1692] 
P [76] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  )
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [76] ->
Q [84] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))  ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1690]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 337:
Theorem (337) [serial 1694] used for:
    normalization of [serial 1692] 


Theorem (339)                               [serial 1690] 
P [76] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  )
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [76] ->
Q [84] << SHFT() >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1632]
Solved by: Predicate Invocation. (PI) and theorem 338:
Theorem (338) [serial 1692] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1690] 


Theorem (340)                               [serial 1691] 
P [76] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  )
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [76] ->
Q [84] << not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1632]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (341)                               [serial 1632] 
P [76] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  )
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [76] ->
Q [84] << SHFT()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
Why created:    normalization of [serial 1594]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Join consequents with conjunction. (3jca) and theorems 339 340:
Theorem (339) [serial 1690] used for:
  Join consequents with conjunction. (3jca)
   [serial 1632] 
Theorem (340) [serial 1691] used for:
  Join consequents with conjunction. (3jca)
   [serial 1632] 


Theorem (342)                               [serial 1594] 
P [76] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))  )
  and ( not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) ) >>
S [76] ->
Q [84] << SHFT()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
Why created:    <<P and B1>> -> <<P1>> in alternative for [serial 1584]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 341:
Theorem (341) [serial 1632] used for:
    normalization of [serial 1594] 


Theorem (343)                               [serial 1700] 
P [84] << SHFT()
  and not ( MOTION_ARTIFACT or not SENSOR_CONNECTED ) >>
S [85] ->
Q [87] << SPO2 = SPO2 >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1699]
Solved by: Law of identity. (eqid) Caret Introduction: if a predicate is always true it's true when time shifted (bl.caretintro) 
   or if a value is constant its value when time shifted is the same (bl.caretintrov) 

Theorem (344)                               [serial 1699] 
P [84] << SHFT()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [85] ->
Q [87] << SPO2 = SPO2^0  >>
Why created:  Replacing port names with BLESS::Value properties  [serial 1698]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 343:
Theorem (343) [serial 1700] used for:
  Assume Present:  P = P@now = P^0   [serial 1699] 


Theorem (345)                               [serial 1698] 
P [84] << SHFT()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [85] ->
Q [87] << SpO2 = SPO2^0  >>
Why created:  no reason Equality Commutes. (eqcom)
  Value of the conditional operator when its first argument is false. (iffalse)
  [Add unnecessary parentheses]
   [serial 1695]
Solved by:  Replacing port names with BLESS::Value properties
 and theorem 344:
Theorem (344) [serial 1699] used for:
  Replacing port names with BLESS::Value properties  [serial 1698] 


Theorem (346)                               [serial 1695] 
P [84] << SHFT()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [85] ->
Q [87] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = SpO2 >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1634]
Solved by: Equality Commutes. (eqcom) Value of the conditional operator when its first argument is false. (iffalse) [Add unnecessary parentheses] and theorem 345:
Theorem (345) [serial 1698] used for:
  no reason Equality Commutes. (eqcom)
  Value of the conditional operator when its first argument is false. (iffalse)
  [Add unnecessary parentheses]
   [serial 1695] 


Theorem (347)                               [serial 1696] 
P [84] << SHFT()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [85] ->
Q [86] << SHFT() >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1634]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (348)                               [serial 1697] 
P [84] << SHFT()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [85] ->
Q [86] << not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1634]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (349)                               [serial 1634] 
P [84] << SHFT()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [85] ->
Q [86] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = SpO2
  and SHFT()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
Why created:    normalization of [serial 1606]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 346 347 348:
Theorem (346) [serial 1695] used for:
  Join consequents with conjunction. (3jca)
   [serial 1634] 
Theorem (347) [serial 1696] used for:
  Join consequents with conjunction. (3jca)
   [serial 1634] 
Theorem (348) [serial 1697] used for:
  Join consequents with conjunction. (3jca)
   [serial 1634] 


Theorem (350)                               [serial 1606] 
P [84] << SHFT()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [85] ->
Q [86] << SHFT()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and ( SpO2 = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) ) >>
Why created:  applied wp for assignment [serial 1595]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 349:
Theorem (349) [serial 1634] used for:
    normalization of [serial 1606] 


Theorem (351)                               [serial 1595] 
P [84] << SHFT()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [85] spo2_nxt[1 ] := SpO2
Q [86] << SHFT()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and ( spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) ) >>
Why created:    <<P1>> S1 <<Q1>> in alternative for [serial 1584]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 350:
Theorem (350) [serial 1606] used for:
  applied wp for assignment [serial 1595] 


Theorem (352)                               [serial 1705] 
P [86] << ( all i ~ quantity whole 
  in 0  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ]
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [76] ->
Q [89] << ( all i ~ quantity whole 
  in 0  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ] >>
Why created:  null
   [serial 1704]
Solved by: And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

Theorem (353)                               [serial 1704] 
P [86] << ( all i ~ quantity whole 
  in 0  .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ]
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [76] ->
Q [89] << ( all i ~ quantity whole 
  in 1  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ] >>
Why created:  Addition Commutes. (bl.addcom)
  Equality Commutes. (eqcom)
  [Add unnecessary parentheses]
  Conjunction Commutes. (bl.ancom)
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1703]
Solved by: null and theorem 352:
Theorem (352) [serial 1705] used for:
  null
   [serial 1704] 


Theorem (354)                               [serial 1703] 
P [86] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ]
  and ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))  )
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [76] ->
Q [89] << ( all i ~ quantity whole 
  in 1  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ] >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1702]
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
 Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 353:
Theorem (353) [serial 1704] used for:
  Addition Commutes. (bl.addcom)
  Equality Commutes. (eqcom)
  [Add unnecessary parentheses]
  Conjunction Commutes. (bl.ancom)
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1703] 


Theorem (355)                               [serial 1702] 
P [86] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ]
  and SHFT()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [76] ->
Q [89] << ( all i ~ quantity whole 
  in 1  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ] >>
Why created:  [Add unnecessary parentheses]
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1636]
Solved by: Predicate Invocation. (PI) and theorem 354:
Theorem (354) [serial 1703] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1702] 


Theorem (356)                               [serial 1636] 
P [86] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ]
  and SHFT()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [76] ->
Q [89] << ( all i ~ quantity whole 
  in 2  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ] >>
Why created:    normalization of [serial 1596]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
 [Add unnecessary parentheses] and theorem 355:
Theorem (355) [serial 1702] used for:
  [Add unnecessary parentheses]
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1636] 


Theorem (357)                               [serial 1596] 
P [86] << SHFT()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and ( spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) ) >>
S [76] ->
Q [89] << ( spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) )
  and ( all i ~ quantity whole 
  in 2  .. ( num_samples + 1  ) 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  ) >>
Why created:    <<Q1>> -> <<Q>> in alternative  for [serial 1584]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 356:
Theorem (356) [serial 1636] used for:
    normalization of [serial 1596] 


Theorem (358)                               [serial 1584] 
P [73] << all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))  >>
S [76]   if 
    (MotionArtifact? or not SensorConnected?)~> 
      << SHFT()
        and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
      spo2_nxt[1 ] := 0.0 percent
      << SHFT()
        and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
        and ( spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) ) >> 
  []
    (not ( MotionArtifact? or not SensorConnected? ))~> 
      << SHFT()
        and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
      spo2_nxt[1 ] := SpO2
      << SHFT()
        and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
        and ( spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) ) >> 
  fi
Q [89] << ( spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) )
  and ( all i ~ quantity whole 
  in 2  .. ( num_samples + 1  ) 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  ) >>
Why created:  <<Q3 and P4>> S4 <<Q4 and P5>> in sequential composition for [serial 1024]
Solved by: [Convert asseertion to port value.] and theorems 320 326 330 336 342 351 357:
Theorem (320) [serial 1590] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1584] 
Theorem (326) [serial 1591] used for:
    <<P and B0>> -> <<P0>> in alternative for [serial 1584] 
Theorem (330) [serial 1592] used for:
    <<P0>> S0 <<Q0>> in alternative for [serial 1584] 
Theorem (336) [serial 1593] used for:
    <<Q0>> -> <<Q>> in alternative  for [serial 1584] 
Theorem (342) [serial 1594] used for:
    <<P and B1>> -> <<P1>> in alternative for [serial 1584] 
Theorem (351) [serial 1595] used for:
    <<P1>> S1 <<Q1>> in alternative for [serial 1584] 
Theorem (357) [serial 1596] used for:
    <<Q1>> -> <<Q>> in alternative  for [serial 1584] 


Theorem (359)                               [serial 1706] 
P [89] << ( all i ~ quantity whole 
  in 1  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ] >>
S [93] ->
Q [94] << all i ~ quantity whole 
  in 1  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]  >>
Why created:  [Add unnecessary parentheses]
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1638]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (360)                               [serial 1638] 
P [89] << ( all i ~ quantity whole 
  in 2  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ] >>
S [93] ->
Q [94] << all i ~ quantity whole 
  in 1  .. ( 1  + num_samples ) 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]  >>
Why created:    normalization of [serial 1607]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
 [Add unnecessary parentheses] and theorem 359:
Theorem (359) [serial 1706] used for:
  [Add unnecessary parentheses]
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1638] 


Theorem (361)                               [serial 1607] 
P [89] << ( spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) )
  and ( all i ~ quantity whole 
  in 2  .. ( num_samples + 1  ) 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  ) >>
S [93] ->
Q [94] << all i ~ quantity whole 
  in 1  .. ( num_samples + 1  ) 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  >>
Why created:  applied wp for assignment [serial 1585]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 360:
Theorem (360) [serial 1638] used for:
    normalization of [serial 1607] 


Theorem (362)                               [serial 1585] 
P [89] << ( spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) )
  and ( all i ~ quantity whole 
  in 2  .. ( num_samples + 1  ) 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  ) >>
S [93] num_samples := num_samples + 1 
Q [94] << all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  >>
Why created:  <<Q4 and P5>> S5 <<Q5 and P6>> in sequential composition for [serial 1024]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 361:
Theorem (361) [serial 1607] used for:
  applied wp for assignment [serial 1585] 


Theorem (363)                               [serial 1644] 
P [98] << (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i] >>
S [99] ->
Q [100] << (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i] >>
Why created:    normalization of [serial 1608]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Identity (id):  P->P is tautology

Theorem (364)                               [serial 1608] 
P [98] << spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) >>
S [99] ->
Q [100] << spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) >>
Why created:  applied wp for assignment [serial 1597]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 363:
Theorem (363) [serial 1644] used for:
    normalization of [serial 1608] 


Theorem (365)                               [serial 1597] 
P [98] << spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) >>
S [99] spo2_a[i] := spo2_nxt[i]
Q [100] << spo2_a[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) >>
Why created:  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1586]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 364:
Theorem (364) [serial 1608] used for:
  applied wp for assignment [serial 1597] 


Theorem (366)                               [serial 1640] 
P [94] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]  >>
S [96] ->
Q [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]  >>
Why created:    normalization of [serial 1598]
  Using: (df-bl.lan1) (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Identity (id):  P->P is tautology

Theorem (367)                               [serial 1598] 
P [94] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  ) >>
S [96] ->
Q [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  >>
Why created:    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1586]
Solved by: Just one wff in the wff-list for conjunction. (df-bl.lan1) Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 366:
Theorem (366) [serial 1640] used for:
    normalization of [serial 1598] 


Theorem (368)                               [serial 1642] 
P [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_a[i]  >>
S [96] ->
Q [102] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_a[i]  >>
Why created:    normalization of [serial 1599]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Identity (id):  P->P is tautology

Theorem (369)                               [serial 1599] 
P [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  >>
S [96] ->
Q [102] << all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  >>
Why created:    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1586]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 368:
Theorem (368) [serial 1642] used for:
    normalization of [serial 1599] 


Theorem (370)                               [serial 1586] 
P [94] << all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  >>
S [96] forall i in 1  .. num_samples
    {
    << spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) >>
    spo2_a[i] := spo2_nxt[i]
    << spo2_a[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) >>
    }  
Q [102] << all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  >>
Why created:  <<Q5 and P6>> S6 <<Q6>> in sequential composition for [serial 1024]
Solved by:  Forall Rule (fa):
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any
 and theorems 365 367 369:
Theorem (365) [serial 1597] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1586] 
Theorem (367) [serial 1598] used for:
    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1586] 
Theorem (369) [serial 1599] used for:
    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1586] 


Theorem (371)                               [serial 1024] 
P [47] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  ) >>
S [58]   << SpO2_INV()
    and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
    and AXIOM_NS() >>
  SpO2Trend!(spo2_a)
  ;
  << SpO2_INV()
    and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )
    and AXIOM_NS() >>
  NumSamples!(num_samples)
  ;
  << SpO2_INV()
    and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  ) >>
  forall i in 1  .. num_samples
      {
      << spo2_a[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) >>
      spo2_nxt[i + 1 ] := spo2_a[i]
      << spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) >>
      }  
  <<SHFT: :all i ~ quantity whole 
    in 1  .. num_samples 
    are spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))  >>
  ;
    if 
      (MotionArtifact? or not SensorConnected?)~> 
        << SHFT()
          and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
        spo2_nxt[1 ] := 0.0 percent
        << SHFT()
          and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
          and ( spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) ) >> 
    []
      (not ( MotionArtifact? or not SensorConnected? ))~> 
        << SHFT()
          and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
        spo2_nxt[1 ] := SpO2
        << SHFT()
          and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
          and ( spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) ) >> 
    fi
  << ( spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) )
    and ( all i ~ quantity whole 
    in 2  .. ( num_samples + 1  ) 
    are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  ) >>
  ;
  num_samples := num_samples + 1 
  << all i ~ quantity whole 
    in 1  .. num_samples 
    are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  >>
  ;
  forall i in 1  .. num_samples
      {
      << spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) >>
      spo2_a[i] := spo2_nxt[i]
      << spo2_a[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) >>
      }  
  << all i ~ quantity whole 
    in 1  .. num_samples 
    are spo2_a[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  >> 
Q [49] << HOLD(num_samples) >>
Why created:   <<M(loading) and x>> A <<M(check)>> for sptt1: loading-[x]->check{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 283 288 301 307 318 358 362 370:
Theorem (283) [serial 1579] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1024] 
Theorem (288) [serial 1580] used for:
  <<Q6>> -> <<Q>> in sequential composition for [serial 1024] 
Theorem (301) [serial 1581] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1024] 
Theorem (307) [serial 1582] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1024] 
Theorem (318) [serial 1583] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1024] 
Theorem (358) [serial 1584] used for:
  <<Q3 and P4>> S4 <<Q4 and P5>> in sequential composition for [serial 1024] 
Theorem (362) [serial 1585] used for:
  <<Q4 and P5>> S5 <<Q5 and P6>> in sequential composition for [serial 1024] 
Theorem (370) [serial 1586] used for:
  <<Q5 and P6>> S6 <<Q6>> in sequential composition for [serial 1024] 


Theorem (372)                               [serial 1761] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [105] ->
Q [47] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:   changing adding negation to subtraction  [serial 1760]
Solved by: Identity (id):  P->P is tautology

Theorem (373)                               [serial 1762] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [105] ->
Q [47] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:   changing adding negation to subtraction  [serial 1760]
Solved by: Identity (id):  P->P is tautology

Theorem (374)                               [serial 1760] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [105] ->
Q [47] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  applied wp for simultaneous assignment [serial 1758]
Solved by: Relationship between subtraction and negative. (negsub) and theorems 372 373:
Theorem (372) [serial 1761] used for:
   changing adding negation to subtraction  [serial 1760] 
Theorem (373) [serial 1762] used for:
   changing adding negation to subtraction  [serial 1760] 


Theorem (375)                               [serial 1758] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    normalization of [serial 1756]
  Using: (df-bl.tsdis) (bl.addcom) ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Simultaneous Assignment
 and theorem 374:
Theorem (374) [serial 1760] used for:
  applied wp for simultaneous assignment [serial 1758] 


Theorem (376)                               [serial 1756] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if not ( SENSOR_CONNECTED^( - s ) )^1  or MOTION_ARTIFACT^( 1  + 
      - s ) then 0.0 percent else SPO2^( 1  + - s )) = spo2_a[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  Distribute ^ over complement. (bl.tsnot)
   [serial 1755]
Solved by: Time shift distributes. (df-bl.tsdis)(df-bl.tsdisc) Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 375:
Theorem (375) [serial 1758] used for:
    normalization of [serial 1756] 


Theorem (377)                               [serial 1755] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( not SENSOR_CONNECTED^( - s ) )^1  or MOTION_ARTIFACT^( 1  + 
      - s ) then 0.0 percent else SPO2^( 1  + - s )) = spo2_a[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    normalization of [serial 1753]
  Using: (bl.addcom) ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Distribute ^ over complement. (bl.tsnot) and theorem 376:
Theorem (376) [serial 1756] used for:
  Distribute ^ over complement. (bl.tsnot)
   [serial 1755] 


Theorem (378)                               [serial 1753] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( MOTION_ARTIFACT^( ( - s ) + 1  ) or ( not SENSOR_CONNECTED^( - s ) )^1  ) then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3)
   [serial 1752]
Solved by: Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 377:
Theorem (377) [serial 1755] used for:
    normalization of [serial 1753] 


Theorem (379)                               [serial 1752] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1  then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    normalization of [serial 1750]
  Using: (bl.addcom) (l.caretintro) ADD_UNNECESSARY_PARETHESES 
Solved by: Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3) and theorem 378:
Theorem (378) [serial 1753] used for:
  Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3)
   [serial 1752] 


Theorem (380)                               [serial 1750] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1  then ( 0.0 percent )^1  else SPO2^( 
      ( - s ) + 1  )) = spo2_a[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  Distribute ^ over conditonal expression. (bl.tsqq)
   [serial 1749]
Solved by: Addition Commutes. (bl.addcom) null [Add unnecessary parentheses] and theorem 379:
Theorem (379) [serial 1752] used for:
    normalization of [serial 1750] 


Theorem (381)                               [serial 1749] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))^1  = spo2_a[s]^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    normalization of [serial 1747]
Solved by: Distribute ^ over conditonal expression. (bl.tsqq) and theorem 380:
Theorem (380) [serial 1750] used for:
  Distribute ^ over conditonal expression. (bl.tsqq)
   [serial 1749] 


Theorem (382)                               [serial 1747] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))^1  = ( spo2_a[s] )^1  )  )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  Distribute ^ over relation. (bl.tsrel)
   [serial 1746]
Solved by: [Add unnecessary parentheses] and theorem 381:
Theorem (381) [serial 1749] used for:
    normalization of [serial 1747] 


Theorem (383)                               [serial 1746] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s )) = spo2_a[s] )^1   )
  and num_samples^1  < #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    normalization of [serial 1744]
  Using: (l.caretintro) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Distribute ^ over relation. (bl.tsrel) and theorem 382:
Theorem (382) [serial 1747] used for:
  Distribute ^ over relation. (bl.tsrel)
   [serial 1746] 


Theorem (384)                               [serial 1744] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( ( num_samples )^1  < ( #PulseOx_Properties::Num_Trending_Samples  )^1  )
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s )) = spo2_a[s] )^1   ) >>
Why created:  Distribute ^ over relation. (bl.tsrel)
  Distribute ^ over universal quantification. (bl.tsal)
   [serial 1743]
Solved by: null [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 383:
Theorem (383) [serial 1746] used for:
    normalization of [serial 1744] 


Theorem (385)                               [serial 1743] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )^1 
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s )) = spo2_a[s]  )^1  >>
Why created:    normalization of [serial 1741]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Distribute ^ over relation. (bl.tsrel) Distribute ^ over universal quantification. (bl.tsal) and theorem 384:
Theorem (384) [serial 1744] used for:
  Distribute ^ over relation. (bl.tsrel)
  Distribute ^ over universal quantification. (bl.tsal)
   [serial 1743] 


Theorem (386)                               [serial 1741] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s )) = spo2_a[s]  )^1 
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  )^1  ) >>
Why created:  Distribute ^ over conjunction. (bl.tsan)(df-bl.tsan2)(bl.tsan3)
   [serial 1739]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 385:
Theorem (385) [serial 1743] used for:
    normalization of [serial 1741] 


Theorem (387)                               [serial 1739] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples  )^1  >>
Why created:    normalization of [serial 1737]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Distribute ^ over conjunction. (bl.tsan)(df-bl.tsan2)(bl.tsan3) and theorem 386:
Theorem (386) [serial 1741] used for:
  Distribute ^ over conjunction. (bl.tsan)(df-bl.tsan2)(bl.tsan3)
   [serial 1739] 


Theorem (388)                               [serial 1737] 
P [49] << ( ( all s ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s ))  ) )
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  ) >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( ( all s ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))  )
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  ) )^1  >>
Why created:  Substituted assertions' predicates for labels  [serial 1025]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 387:
Theorem (387) [serial 1739] used for:
    normalization of [serial 1737] 


Theorem (389)                               [serial 1025] 
P [49] << ( HOLD(num_samples) )
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  ) >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples  ) )^1  >>
Why created:   <<M(check) and x>> A <<M(loading)>> for sptt2a: check-[x]->loading{A};
Solved by: Predicate Invocation. (PI) and theorem 388:
Theorem (388) [serial 1737] used for:
  Substituted assertions' predicates for labels  [serial 1025] 


Theorem (390)                               [serial 1787] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [107] ->
Q [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:   changing adding negation to subtraction  [serial 1786]
Solved by: Identity (id):  P->P is tautology

Theorem (391)                               [serial 1788] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [107] ->
Q [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:   changing adding negation to subtraction  [serial 1786]
Solved by: Identity (id):  P->P is tautology

Theorem (392)                               [serial 1786] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [107] ->
Q [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:  applied wp for simultaneous assignment [serial 1784]
Solved by: Relationship between subtraction and negative. (negsub) and theorems 390 391:
Theorem (390) [serial 1787] used for:
   changing adding negation to subtraction  [serial 1786] 
Theorem (391) [serial 1788] used for:
   changing adding negation to subtraction  [serial 1786] 


Theorem (393)                               [serial 1784] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:    normalization of [serial 1782]
  Using: (df-bl.tsdis) (bl.addcom) ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Simultaneous Assignment
 and theorem 392:
Theorem (392) [serial 1786] used for:
  applied wp for simultaneous assignment [serial 1784] 


Theorem (394)                               [serial 1782] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if not ( SENSOR_CONNECTED^( - s ) )^1  or MOTION_ARTIFACT^( 1  + 
      - s ) then 0.0 percent else SPO2^( 1  + - s )) = spo2_a[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:  Distribute ^ over complement. (bl.tsnot)
   [serial 1781]
Solved by: Time shift distributes. (df-bl.tsdis)(df-bl.tsdisc) Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 393:
Theorem (393) [serial 1784] used for:
    normalization of [serial 1782] 


Theorem (395)                               [serial 1781] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( not SENSOR_CONNECTED^( - s ) )^1  or MOTION_ARTIFACT^( 1  + 
      - s ) then 0.0 percent else SPO2^( 1  + - s )) = spo2_a[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:    normalization of [serial 1779]
  Using: (bl.addcom) ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Distribute ^ over complement. (bl.tsnot) and theorem 394:
Theorem (394) [serial 1782] used for:
  Distribute ^ over complement. (bl.tsnot)
   [serial 1781] 


Theorem (396)                               [serial 1779] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( MOTION_ARTIFACT^( ( - s ) + 1  ) or ( not SENSOR_CONNECTED^( - s ) )^1  ) then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:  Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3)
   [serial 1778]
Solved by: Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 395:
Theorem (395) [serial 1781] used for:
    normalization of [serial 1779] 


Theorem (397)                               [serial 1778] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1  then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:    normalization of [serial 1776]
  Using: (bl.addcom) (l.caretintro) ADD_UNNECESSARY_PARETHESES 
Solved by: Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3) and theorem 396:
Theorem (396) [serial 1779] used for:
  Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3)
   [serial 1778] 


Theorem (398)                               [serial 1776] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1  then ( 0.0 percent )^1  else SPO2^( 
      ( - s ) + 1  )) = spo2_a[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:  Distribute ^ over conditonal expression. (bl.tsqq)
   [serial 1775]
Solved by: Addition Commutes. (bl.addcom) null [Add unnecessary parentheses] and theorem 397:
Theorem (397) [serial 1778] used for:
    normalization of [serial 1776] 


Theorem (399)                               [serial 1775] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))^1  = spo2_a[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:    normalization of [serial 1773]
Solved by: Distribute ^ over conditonal expression. (bl.tsqq) and theorem 398:
Theorem (398) [serial 1776] used for:
  Distribute ^ over conditonal expression. (bl.tsqq)
   [serial 1775] 


Theorem (400)                               [serial 1773] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))^1  = ( spo2_a[s] )^1  )  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:  Distribute ^ over relation. (bl.tsrel)
   [serial 1772]
Solved by: [Add unnecessary parentheses] and theorem 399:
Theorem (399) [serial 1775] used for:
    normalization of [serial 1773] 


Theorem (401)                               [serial 1772] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s )) = spo2_a[s] )^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:    normalization of [serial 1770]
  Using: (l.caretintro) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Distribute ^ over relation. (bl.tsrel) and theorem 400:
Theorem (400) [serial 1773] used for:
  Distribute ^ over relation. (bl.tsrel)
   [serial 1772] 


Theorem (402)                               [serial 1770] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( ( #PulseOx_Properties::Num_Trending_Samples  )^1  = ( num_samples )^1  )
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s )) = spo2_a[s] )^1   ) >>
Why created:  Distribute ^ over relation. (bl.tsrel)
  Distribute ^ over universal quantification. (bl.tsal)
   [serial 1769]
Solved by: null [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 401:
Theorem (401) [serial 1772] used for:
    normalization of [serial 1770] 


Theorem (403)                               [serial 1769] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( #PulseOx_Properties::Num_Trending_Samples  = num_samples )^1 
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s )) = spo2_a[s]  )^1  >>
Why created:    normalization of [serial 1767]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Distribute ^ over relation. (bl.tsrel) Distribute ^ over universal quantification. (bl.tsal) and theorem 402:
Theorem (402) [serial 1770] used for:
  Distribute ^ over relation. (bl.tsrel)
  Distribute ^ over universal quantification. (bl.tsal)
   [serial 1769] 


Theorem (404)                               [serial 1767] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s )) = spo2_a[s]  )^1 
  and ( #PulseOx_Properties::Num_Trending_Samples  = num_samples )^1  ) >>
Why created:  Distribute ^ over conjunction. (bl.tsan)(df-bl.tsan2)(bl.tsan3)
   [serial 1765]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 403:
Theorem (403) [serial 1769] used for:
    normalization of [serial 1767] 


Theorem (405)                               [serial 1765] 
P [49] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples )^1  >>
Why created:    normalization of [serial 1763]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Distribute ^ over conjunction. (bl.tsan)(df-bl.tsan2)(bl.tsan3) and theorem 404:
Theorem (404) [serial 1767] used for:
  Distribute ^ over conjunction. (bl.tsan)(df-bl.tsan2)(bl.tsan3)
   [serial 1765] 


Theorem (406)                               [serial 1763] 
P [49] << ( ( all s ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( 1  - s ) or not SENSOR_CONNECTED^( 1  - s ) then 0.0 percent else SPO2^( 1  - s ))  ) )
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  ) >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( ( all s ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))  )
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  ) )^1  >>
Why created:  Substituted assertions' predicates for labels  [serial 1026]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 405:
Theorem (405) [serial 1765] used for:
    normalization of [serial 1763] 


Theorem (407)                               [serial 1026] 
P [49] << ( HOLD(num_samples) )
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  ) >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  ) )^1  >>
Why created:   <<M(check) and x>> A <<M(run)>> for sptt2b: check-[x]->run{A};
Solved by: Predicate Invocation. (PI) and theorem 406:
Theorem (406) [serial 1763] used for:
  Substituted assertions' predicates for labels  [serial 1026] 


Theorem (408)                               [serial 1027] 
P [49] << ( HOLD(num_samples) )
  and ( num_samples > #PulseOx_Properties::Num_Trending_Samples  ) >>
S [108] ->
Q [53] << true >>
Why created:   <<M(check) and x>> -> <<M(fail)>> for sptt2c: check-[x]->fail{};
Solved by: Anything Implies True (a1tru): P->true

Theorem (409)                               [serial 1844] 
P [51] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and SpO2_INV() >>
S [51] ->
Q [111] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and SpO2_INV()
  and true >>
Why created:    normalization of [serial 1810]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (410)                               [serial 1810] 
P [51] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  ) >>
S [51] ->
Q [111] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  )
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 409:
Theorem (409) [serial 1844] used for:
    normalization of [serial 1810] 


Theorem (411)                               [serial 1844] 
P [51] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and SpO2_INV() >>
S [51] ->
Q [111] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and SpO2_INV()
  and true >>
Why created:    normalization of [serial 1810]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (412)                               [serial 1810] 
P [51] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  ) >>
S [51] ->
Q [111] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  )
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 411:
Theorem (411) [serial 1844] used for:
    normalization of [serial 1810] 


Theorem (413)                               [serial 1789] 
P [51] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  ) >>
S [51] ->
Q [111] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  )
  and AXIOM_NS() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1028]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 412 412:
Theorem (412) [serial 1810] used for:
   add user-defined "givens" to postcondition 
Theorem (412) [serial 1810] used for:
   add user-defined "givens" to postcondition 


Theorem (414)                               [serial 1895] 
P [164] << ( all #12# ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - #12# ) or not SENSOR_CONNECTED^( 1  + 
      - #12# ) then 0.0 percent else SPO2^( 1  + - #12# )) = spo2_a[#12#]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [51] ->
Q [16] << ( all #13# ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - #13# ) or not SENSOR_CONNECTED^( 1  + 
      - #13# ) then 0.0 percent else SPO2^( 1  + - #13# )) = spo2_a[#13#]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:   changing adding negation to subtraction  [serial 1894]
Solved by: Identity (id):  P->P is tautology

Theorem (415)                               [serial 1894] 
P [164] << ( all #12# ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - #12# ) or not SENSOR_CONNECTED^( 1  - #12# ) then 0.0 percent else SPO2^( 1  - #12# )) = spo2_a[#12#]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [51] ->
Q [16] << ( all #13# ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - #13# ) or not SENSOR_CONNECTED^( 1  + 
      - #13# ) then 0.0 percent else SPO2^( 1  + - #13# )) = spo2_a[#13#]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:  Substitution of variable in universal quantifier. (sb8)
  Addition Commutes. (bl.addcom)
  [Add unnecessary parentheses]
   [serial 1892]
Solved by: Relationship between subtraction and negative. (negsub) and theorem 414:
Theorem (414) [serial 1895] used for:
   changing adding negation to subtraction  [serial 1894] 


Theorem (416)                               [serial 1892] 
P [164] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_a[i]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [51] ->
Q [16] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  + - s ) or not SENSOR_CONNECTED^( 1  + - s ) then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:    normalization of [serial 1890]
  Using: (df-bl.tsdis) (bl.addcom) ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Substitution of variable in universal quantifier. (sb8) Addition Commutes. (bl.addcom) [Add unnecessary parentheses] and theorem 415:
Theorem (415) [serial 1894] used for:
  Substitution of variable in universal quantifier. (sb8)
  Addition Commutes. (bl.addcom)
  [Add unnecessary parentheses]
   [serial 1892] 


Theorem (417)                               [serial 1890] 
P [164] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_a[i]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [51] ->
Q [16] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if not ( SENSOR_CONNECTED^( - s ) )^1  or MOTION_ARTIFACT^( 1  + 
      - s ) then 0.0 percent else SPO2^( 1  + - s )) = spo2_a[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:  Distribute ^ over complement. (bl.tsnot)
   [serial 1889]
Solved by: Time shift distributes. (df-bl.tsdis)(df-bl.tsdisc) Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 416:
Theorem (416) [serial 1892] used for:
    normalization of [serial 1890] 


Theorem (418)                               [serial 1889] 
P [164] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_a[i]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [51] ->
Q [16] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( not SENSOR_CONNECTED^( - s ) )^1  or MOTION_ARTIFACT^( 1  + 
      - s ) then 0.0 percent else SPO2^( 1  + - s )) = spo2_a[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:    normalization of [serial 1887]
  Using: (bl.addcom) ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Distribute ^ over complement. (bl.tsnot) and theorem 417:
Theorem (417) [serial 1890] used for:
  Distribute ^ over complement. (bl.tsnot)
   [serial 1889] 


Theorem (419)                               [serial 1887] 
P [164] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_a[i]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [51] ->
Q [16] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( MOTION_ARTIFACT^( ( - s ) + 1  ) or ( not SENSOR_CONNECTED^( - s ) )^1  ) then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:  Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3)
   [serial 1886]
Solved by: Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 418:
Theorem (418) [serial 1889] used for:
    normalization of [serial 1887] 


Theorem (420)                               [serial 1886] 
P [164] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_a[i]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [51] ->
Q [16] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1  then 0.0 percent else SPO2^( 
      1  + - s )) = spo2_a[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:    normalization of [serial 1884]
  Using: (bl.addcom) (l.caretintro) ADD_UNNECESSARY_PARETHESES 
Solved by: Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3) and theorem 419:
Theorem (419) [serial 1887] used for:
  Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3)
   [serial 1886] 


Theorem (421)                               [serial 1884] 
P [164] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_a[i]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [51] ->
Q [16] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1  then ( 0.0 percent )^1  else SPO2^( 
      ( - s ) + 1  )) = spo2_a[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:  Distribute ^ over conditonal expression. (bl.tsqq)
   [serial 1883]
Solved by: Addition Commutes. (bl.addcom) null [Add unnecessary parentheses] and theorem 420:
Theorem (420) [serial 1886] used for:
    normalization of [serial 1884] 


Theorem (422)                               [serial 1883] 
P [164] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_a[i]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [51] ->
Q [16] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))^1  = spo2_a[s]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:    normalization of [serial 1881]
Solved by: Distribute ^ over conditonal expression. (bl.tsqq) and theorem 421:
Theorem (421) [serial 1884] used for:
  Distribute ^ over conditonal expression. (bl.tsqq)
   [serial 1883] 


Theorem (423)                               [serial 1881] 
P [164] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_a[i]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [51] ->
Q [16] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))^1  = ( spo2_a[s] )^1  )  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:  Distribute ^ over relation. (bl.tsrel)
   [serial 1880]
Solved by: [Add unnecessary parentheses] and theorem 422:
Theorem (422) [serial 1883] used for:
    normalization of [serial 1881] 


Theorem (424)                               [serial 1880] 
P [164] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_a[i]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [51] ->
Q [16] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s )) = spo2_a[s] )^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
Why created:    normalization of [serial 1878]
  Using: (l.caretintro) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Distribute ^ over relation. (bl.tsrel) and theorem 423:
Theorem (423) [serial 1881] used for:
  Distribute ^ over relation. (bl.tsrel)
   [serial 1880] 


Theorem (425)                               [serial 1878] 
P [164] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_a[i]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [51] ->
Q [16] << ( ( #PulseOx_Properties::Num_Trending_Samples  )^1  = ( num_samples )^1  )
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s )) = spo2_a[s] )^1   ) >>
Why created:  Distribute ^ over relation. (bl.tsrel)
  Distribute ^ over universal quantification. (bl.tsal)
   [serial 1877]
Solved by: null [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 424:
Theorem (424) [serial 1880] used for:
    normalization of [serial 1878] 


Theorem (426)                               [serial 1877] 
P [164] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_a[i]^1   )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples^1  >>
S [51] ->
Q [16] << ( #PulseOx_Properties::Num_Trending_Samples  = num_samples )^1 
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s )) = spo2_a[s]  )^1  >>
Why created:    normalization of [serial 1875]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Distribute ^ over relation. (bl.tsrel) Distribute ^ over universal quantification. (bl.tsal) and theorem 425:
Theorem (425) [serial 1878] used for:
  Distribute ^ over relation. (bl.tsrel)
  Distribute ^ over universal quantification. (bl.tsal)
   [serial 1877] 


Theorem (427)                               [serial 1875] 
P [164] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[i]^1  = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  )
  and num_samples^1  = #PulseOx_Properties::Num_Trending_Samples  >>
S [51] ->
Q [16] << ( ( #PulseOx_Properties::Num_Trending_Samples  = num_samples )^1 
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))  )^1  ) >>
Why created:  x' is x^1 (df-bl.tick)
  Distribute ^ over conjunction. (bl.tsan)(df-bl.tsan2)(bl.tsan3)
   [serial 1874]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 426:
Theorem (426) [serial 1877] used for:
    normalization of [serial 1875] 


Theorem (428)                               [serial 1874] 
P [164] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  )
  and num_samples' = #PulseOx_Properties::Num_Trending_Samples  >>
S [51] ->
Q [16] << ( #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))  ) )^1  >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1814]
Solved by: x' is x^1 (df-bl.tick) Distribute ^ over conjunction. (bl.tsan)(df-bl.tsan2)(bl.tsan3) and theorem 427:
Theorem (427) [serial 1875] used for:
  x' is x^1 (df-bl.tick)
  Distribute ^ over conjunction. (bl.tsan)(df-bl.tsan2)(bl.tsan3)
   [serial 1874] 


Theorem (429)                               [serial 1814] 
P [164] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  )
  and num_samples' = #PulseOx_Properties::Num_Trending_Samples  >>
S [51] ->
Q [16] << ( #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and SpO2_INV() )^1  >>
Why created:    normalization of [serial 1790]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 428:
Theorem (428) [serial 1874] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1814] 


Theorem (430)                               [serial 1790] 
P [164] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  )
  and num_samples' = #PulseOx_Properties::Num_Trending_Samples  >>
S [51] ->
Q [16] << ( SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  ) )^1  >>
Why created:  <<Q6>> -> <<Q>> in sequential composition for [serial 1028]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 429:
Theorem (429) [serial 1814] used for:
    normalization of [serial 1790] 


Theorem (431)                               [serial 1846] 
P [111] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and AXIOM_NS()
  and SpO2_INV() >>
S [113] SpO2Trend!(spo2_a)
Q [115] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and SpO2_INV()
  and true >>
Why created:    normalization of [serial 1811]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (432)                               [serial 1811] 
P [111] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  )
  and AXIOM_NS() >>
S [113] SpO2Trend!(spo2_a)
Q [115] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  )
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 431:
Theorem (431) [serial 1846] used for:
    normalization of [serial 1811] 


Theorem (433)                               [serial 1846] 
P [111] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and AXIOM_NS()
  and SpO2_INV() >>
S [113] SpO2Trend!(spo2_a)
Q [115] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and SpO2_INV()
  and true >>
Why created:    normalization of [serial 1811]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (434)                               [serial 1811] 
P [111] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  )
  and AXIOM_NS() >>
S [113] SpO2Trend!(spo2_a)
Q [115] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  )
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 433:
Theorem (433) [serial 1846] used for:
    normalization of [serial 1811] 


Theorem (435)                               [serial 1791] 
P [111] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  )
  and AXIOM_NS() >>
S [113] SpO2Trend!(spo2_a)
Q [115] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  )
  and AXIOM_NS() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 434 434:
Theorem (434) [serial 1811] used for:
   add user-defined "givens" to postcondition 
Theorem (434) [serial 1811] used for:
   add user-defined "givens" to postcondition 


Theorem (436)                               [serial 1848] 
P [115] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and AXIOM_NS()
  and SpO2_INV() >>
S [117] NumSamples!(num_samples)
Q [119] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and SpO2_INV()
  and true >>
Why created:    normalization of [serial 1812]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (437)                               [serial 1812] 
P [115] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  )
  and AXIOM_NS() >>
S [117] NumSamples!(num_samples)
Q [119] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  )
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 436:
Theorem (436) [serial 1848] used for:
    normalization of [serial 1812] 


Theorem (438)                               [serial 1848] 
P [115] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and AXIOM_NS()
  and SpO2_INV() >>
S [117] NumSamples!(num_samples)
Q [119] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and SpO2_INV()
  and true >>
Why created:    normalization of [serial 1812]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (439)                               [serial 1812] 
P [115] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  )
  and AXIOM_NS() >>
S [117] NumSamples!(num_samples)
Q [119] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  )
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 438:
Theorem (438) [serial 1848] used for:
    normalization of [serial 1812] 


Theorem (440)                               [serial 1792] 
P [115] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  )
  and AXIOM_NS() >>
S [117] NumSamples!(num_samples)
Q [119] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  )
  and AXIOM_CR2() >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 439 439:
Theorem (439) [serial 1812] used for:
   add user-defined "givens" to postcondition 
Theorem (439) [serial 1812] used for:
   add user-defined "givens" to postcondition 


Theorem (441)                               [serial 1913] 
P [123] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_a[i]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [125] ->
Q [126] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_a[i]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:  applied wp for assignment [serial 1820]
Solved by: Identity (id):  P->P is tautology

Theorem (442)                               [serial 1820] 
P [123] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_a[i]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [125] spo2_nxt[1  + i] := spo2_a[i]
Q [126] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
1  + i]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:    normalization of [serial 1797]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 441:
Theorem (441) [serial 1913] used for:
  applied wp for assignment [serial 1820] 


Theorem (443)                               [serial 1797] 
P [123] << spo2_a[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  ) >>
S [125] spo2_nxt[i + 1 ] := spo2_a[i]
Q [126] << spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1793]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 442:
Theorem (442) [serial 1820] used for:
    normalization of [serial 1797] 


Theorem (444)                               [serial 1906] 
P [119] << ( all #14# ~ quantity whole 
  in 0  .. ( -2  + num_samples ) 
  are (if MOTION_ARTIFACT^( -1  + - #14# ) or not SENSOR_CONNECTED^( -1  + 
      - #14# ) then 0.0 percent else SPO2^( -1  + - #14# )) = spo2_a[1  + 
      #14#]  )
  and -2  + num_samples < -1  + num_samples
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [121] ->
Q [19] << ( all #15# ~ quantity whole 
  in 0  .. ( -2  + num_samples ) 
  are (if MOTION_ARTIFACT^( -1  + - #15# ) or not SENSOR_CONNECTED^( -1  + 
      - #15# ) then 0.0 percent else SPO2^( -1  + - #15# )) = spo2_a[1  + 
      #15#]  ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1905]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (445)                               [serial 1907] 
P [119] << ( all #14# ~ quantity whole 
  in 0  .. ( -2  + num_samples ) 
  are (if MOTION_ARTIFACT^( -1  + - #14# ) or not SENSOR_CONNECTED^( -1  + 
      - #14# ) then 0.0 percent else SPO2^( -1  + - #14# )) = spo2_a[1  + 
      #14#]  )
  and -2  + num_samples < -1  + num_samples
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [121] ->
Q [19] << ( all #15# ~ quantity whole 
  in 0  .. ( -2  + num_samples ) 
  are #PulseOx_Properties::Num_Trending_Samples  = num_samples  ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1905]
Solved by: Axiom of Distinctness. (ax-5)

Theorem (446)                               [serial 1905] 
P [119] << ( all #14# ~ quantity whole 
  in 0  .. ( -2  + num_samples ) 
  are (if MOTION_ARTIFACT^( -1  + - #14# ) or not SENSOR_CONNECTED^( -1  + 
      - #14# ) then 0.0 percent else SPO2^( -1  + - #14# )) = spo2_a[1  + 
      #14#]  )
  and -2  + num_samples < -1  + num_samples
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [121] ->
Q [19] << ( all #15# ~ quantity whole 
  in 0  .. ( -2  + num_samples ) 
  are (if MOTION_ARTIFACT^( -1  + - #15# ) or not SENSOR_CONNECTED^( -1  + 
      - #15# ) then 0.0 percent else SPO2^( -1  + - #15# )) = spo2_a[1  + 
      #15#]  )
  and ( all #15# ~ quantity whole 
  in 0  .. ( -2  + num_samples ) 
  are #PulseOx_Properties::Num_Trending_Samples  = num_samples  ) >>
Why created:  Universal quantification of conjunction is conjunction of universal quantification. (r19.26)
   [serial 1904]
Solved by: Join consequents with conjunction. (3jca) and theorems 444 445:
Theorem (444) [serial 1906] used for:
  Join consequents with conjunction. (3jca)
   [serial 1905] 
Theorem (445) [serial 1907] used for:
  Join consequents with conjunction. (3jca)
   [serial 1905] 


Theorem (447)                               [serial 1904] 
P [119] << ( all #14# ~ quantity whole 
  in 0  .. ( -2  + num_samples ) 
  are (if MOTION_ARTIFACT^( -1  + - #14# ) or not SENSOR_CONNECTED^( -1  + 
      - #14# ) then 0.0 percent else SPO2^( -1  + - #14# )) = spo2_a[1  + 
      #14#]  )
  and -2  + num_samples < -1  + num_samples
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [121] ->
Q [19] << all #15# ~ quantity whole 
  in 0  .. ( -2  + num_samples ) 
  are (if MOTION_ARTIFACT^( -1  + - #15# ) or not SENSOR_CONNECTED^( -1  + 
      - #15# ) then 0.0 percent else SPO2^( -1  + - #15# )) = spo2_a[1  + 
      #15#]
        and #PulseOx_Properties::Num_Trending_Samples  = num_samples  >>
Why created:  Substitution of variable in universal quantifier. (sb8)
  Addition Commutes. (bl.addcom)
  [Add unnecessary parentheses]
   [serial 1903]
Solved by: Universal quantification of conjunction is conjunction of universal quantification. (r19.26) and theorem 446:
Theorem (446) [serial 1905] used for:
  Universal quantification of conjunction is conjunction of universal quantification. (r19.26)
   [serial 1904] 


Theorem (448)                               [serial 1903] 
P [119] << ( all s ~ quantity whole 
  in 0  .. ( -2  + num_samples ) 
  are (if MOTION_ARTIFACT^( -1  + - s ) or not SENSOR_CONNECTED^( -1  + 
      - s ) then 0.0 percent else SPO2^( -1  + - s )) = spo2_a[1  + s]  )
  and -2  + num_samples < -1  + num_samples
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [121] ->
Q [19] << all i ~ quantity whole 
  in 0  .. ( -2  + num_samples ) 
  are (if MOTION_ARTIFACT^( -1  + - i ) or not SENSOR_CONNECTED^( -1  + 
      - i ) then 0.0 percent else SPO2^( -1  + - i )) = spo2_a[1  + i]
        and #PulseOx_Properties::Num_Trending_Samples  = num_samples  >>
Why created:  Contract universal quantification, lower bound.  (bl.cuqlb)
   [serial 1902]
Solved by: Substitution of variable in universal quantifier. (sb8) Addition Commutes. (bl.addcom) [Add unnecessary parentheses] and theorem 447:
Theorem (447) [serial 1904] used for:
  Substitution of variable in universal quantifier. (sb8)
  Addition Commutes. (bl.addcom)
  [Add unnecessary parentheses]
   [serial 1903] 


Theorem (449)                               [serial 1902] 
P [119] << ( all s ~ quantity whole 
  in 0  .. ( -1  + num_samples ) 
  are (if MOTION_ARTIFACT^( -1  + - s ) or not SENSOR_CONNECTED^( -1  + 
      - s ) then 0.0 percent else SPO2^( -1  + - s )) = spo2_a[1  + s]  )
  and -2  + num_samples < -1  + num_samples
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [121] ->
Q [19] << all i ~ quantity whole 
  in 0  .. ( -2  + num_samples ) 
  are (if MOTION_ARTIFACT^( -1  + - i ) or not SENSOR_CONNECTED^( -1  + 
      - i ) then 0.0 percent else SPO2^( -1  + - i )) = spo2_a[1  + i]
        and #PulseOx_Properties::Num_Trending_Samples  = num_samples  >>
Why created:    normalization of [serial 1900]
  Using: (bl.addcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Contract universal quantification, lower bound.  (bl.cuqlb) and theorem 448:
Theorem (448) [serial 1903] used for:
  Contract universal quantification, lower bound.  (bl.cuqlb)
   [serial 1902] 


Theorem (450)                               [serial 1900] 
P [119] << ( all s ~ quantity whole 
  in 0  .. ( num_samples + - 1  ) 
  are (if MOTION_ARTIFACT^( -1  + - s ) or not SENSOR_CONNECTED^( -1  + 
      - s ) then 0.0 percent else SPO2^( -1  + - s )) = spo2_a[1  + s]  )
  and num_samples + - 2  < num_samples + - 1 
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [121] ->
Q [19] << all i ~ quantity whole 
  in 0  .. ( num_samples + - 2  ) 
  are (if MOTION_ARTIFACT^( -1  + - i ) or not SENSOR_CONNECTED^( -1  + 
      - i ) then 0.0 percent else SPO2^( -1  + - i )) = spo2_a[1  + i]
        and #PulseOx_Properties::Num_Trending_Samples  = num_samples  >>
Why created:   changing adding negation to subtraction  [serial 1899]
Solved by: Addition Commutes. (bl.addcom) [Add unnecessary parentheses] and theorem 449:
Theorem (449) [serial 1902] used for:
    normalization of [serial 1900] 


Theorem (451)                               [serial 1899] 
P [119] << ( all s ~ quantity whole 
  in 0  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( -1  + - s ) or not SENSOR_CONNECTED^( -1  + 
      - s ) then 0.0 percent else SPO2^( -1  + - s )) = spo2_a[1  + s]  )
  and num_samples - 2  < num_samples - 1 
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [121] ->
Q [19] << all i ~ quantity whole 
  in 0  .. ( num_samples - 2  ) 
  are (if MOTION_ARTIFACT^( -1  + - i ) or not SENSOR_CONNECTED^( -1  + 
      - i ) then 0.0 percent else SPO2^( -1  + - i )) = spo2_a[1  + i]
        and #PulseOx_Properties::Num_Trending_Samples  = num_samples  >>
Why created:  null
   [serial 1898]
Solved by: Relationship between subtraction and negative. (negsub) and theorem 450:
Theorem (450) [serial 1900] used for:
   changing adding negation to subtraction  [serial 1899] 


Theorem (452)                               [serial 1898] 
P [119] << ( all s ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s )) = spo2_a[s]  )
  and num_samples - 2  < num_samples - 1 
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [121] ->
Q [19] << all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_a[i]
        and #PulseOx_Properties::Num_Trending_Samples  = num_samples  >>
Why created:    normalization of [serial 1896]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: null and theorem 451:
Theorem (451) [serial 1899] used for:
  null
   [serial 1898] 


Theorem (453)                               [serial 1896] 
P [119] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and ( ( num_samples - 2  ) < ( num_samples - 1  ) )
  and ( all s ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0.0 percent else SPO2^( - s ))  ) >>
S [121] ->
Q [19] << all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_a[i]
        and #PulseOx_Properties::Num_Trending_Samples  = num_samples  >>
Why created:  Substituted assertions' predicates for labels  [serial 1816]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 452:
Theorem (452) [serial 1898] used for:
    normalization of [serial 1896] 


Theorem (454)                               [serial 1816] 
P [119] << #PulseOx_Properties::Num_Trending_Samples  = num_samples
  and AXIOM_CR2()
  and SpO2_INV() >>
S [121] ->
Q [19] << all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_a[i]
        and #PulseOx_Properties::Num_Trending_Samples  = num_samples  >>
Why created:    normalization of [serial 1798]
  Using: (df-bl.lan1) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 453:
Theorem (453) [serial 1896] used for:
  Substituted assertions' predicates for labels  [serial 1816] 


Theorem (455)                               [serial 1798] 
P [119] << ( SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  )
  and AXIOM_CR2() ) >>
S [121] ->
Q [19] << all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are spo2_a[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))
        and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  )  >>
Why created:    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1793]
Solved by: Just one wff in the wff-list for conjunction. (df-bl.lan1) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 454:
Theorem (454) [serial 1816] used for:
    normalization of [serial 1798] 


Theorem (456)                               [serial 1911] 
P [19] << ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  )
  and ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are #PulseOx_Properties::Num_Trending_Samples  = num_samples  ) >>
S [121] ->
Q [129] << ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:  Universal quantification of conjunction is conjunction of universal quantification. (r19.26)
   [serial 1818]
Solved by: Axiom of Distinctness. (ax-5)

Theorem (457)                               [serial 1818] 
P [19] << all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]
        and #PulseOx_Properties::Num_Trending_Samples  = num_samples  >>
S [121] ->
Q [129] << ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:    normalization of [serial 1799]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Universal quantification of conjunction is conjunction of universal quantification. (r19.26) and theorem 456:
Theorem (456) [serial 1911] used for:
  Universal quantification of conjunction is conjunction of universal quantification. (r19.26)
   [serial 1818] 


Theorem (458)                               [serial 1799] 
P [19] << all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples   >>
S [121] ->
Q [129] << ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1793]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 457:
Theorem (457) [serial 1818] used for:
    normalization of [serial 1799] 


Theorem (459)                               [serial 1793] 
P [119] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  )
  and AXIOM_CR2() >>
S [121] forall i in 1  .. ( num_samples - 1  )
    {
    << spo2_a[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))
      and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  ) >>
    spo2_nxt[i + 1 ] := spo2_a[i]
    << spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))
      and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
    }  
Q [129] << ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1028]
Solved by:  Forall Rule (fa):
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any
 and theorems 443 455 458:
Theorem (443) [serial 1797] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1793] 
Theorem (455) [serial 1798] used for:
    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1793] 
Theorem (458) [serial 1799] used for:
    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1793] 


Theorem (460)                               [serial 1822] 
P [129] << ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [133] ->
Q [133] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) or not ( MOTION_ARTIFACT^0  or 
not SENSOR_CONNECTED^0  ) >>
Why created:    normalization of [serial 1800]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (461)                               [serial 1800] 
P [129] << ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
S [133] ->
Q [133] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) or ( not ( MOTION_ARTIFACT^0  or 
not SENSOR_CONNECTED^0  ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1794]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 460:
Theorem (460) [serial 1822] used for:
    normalization of [serial 1800] 


Theorem (462)                               [serial 1824] 
P [133] << ( ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples )
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [133] ->
Q [135] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and SHFTR() >>
Why created:    normalization of [serial 1801]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (463)                               [serial 1801] 
P [133] << ( ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  )
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [133] ->
Q [135] << SHFTR()
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
Why created:    <<P and B0>> -> <<P0>> in alternative for [serial 1794]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 462:
Theorem (462) [serial 1824] used for:
    normalization of [serial 1801] 


Theorem (464)                               [serial 1916] 
P [135] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and SHFTR() >>
S [136] ->
Q [137] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1915]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (465)                               [serial 1919] 
P [135] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and SHFTR() >>
S [136] ->
Q [138] << 0.0  = 0.0  >>
Why created:  [Remove Units]
   [serial 1917]
Solved by: Law of identity. (eqid)

Theorem (466)                               [serial 1917] 
P [135] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and SHFTR() >>
S [136] ->
Q [138] << 0.0 percent = 0.0 percent >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1915]
Solved by: [Remove Units] and theorem 465:
Theorem (465) [serial 1919] used for:
  [Remove Units]
   [serial 1917] 


Theorem (467)                               [serial 1918] 
P [135] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and SHFTR() >>
S [136] ->
Q [137] << SHFTR() >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1915]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (468)                               [serial 1915] 
P [135] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and SHFTR() >>
S [136] ->
Q [137] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and 0.0 percent = 0.0 percent
  and SHFTR() >>
Why created:  no reason Value of the conditional operator when its first argument is true. (iftrue)
  [Add unnecessary parentheses]
   [serial 1914]
Solved by: Join consequents with conjunction. (3jca) and theorems 464 466 467:
Theorem (464) [serial 1916] used for:
  Join consequents with conjunction. (3jca)
   [serial 1915] 
Theorem (466) [serial 1917] used for:
  Join consequents with conjunction. (3jca)
   [serial 1915] 
Theorem (467) [serial 1918] used for:
  Join consequents with conjunction. (3jca)
   [serial 1915] 


Theorem (469)                               [serial 1914] 
P [135] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and SHFTR() >>
S [136] ->
Q [137] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = 0.0 percent
  and SHFTR() >>
Why created:  applied wp for assignment [serial 1826]
Solved by: Value of the conditional operator when its first argument is true. (iftrue) [Add unnecessary parentheses] and theorem 468:
Theorem (468) [serial 1915] used for:
  no reason Value of the conditional operator when its first argument is true. (iftrue)
  [Add unnecessary parentheses]
   [serial 1914] 


Theorem (470)                               [serial 1826] 
P [135] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and SHFTR() >>
S [136] spo2_nxt[1 ] := 0.0 percent
Q [137] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ]
  and SHFTR() >>
Why created:    normalization of [serial 1802]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 469:
Theorem (469) [serial 1914] used for:
  applied wp for assignment [serial 1826] 


Theorem (471)                               [serial 1802] 
P [135] << SHFTR()
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [136] spo2_nxt[1 ] := 0.0 percent
Q [137] << SHFTR()
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and ( spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) ) >>
Why created:    <<P0>> S0 <<Q0>> in alternative for [serial 1794]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 470:
Theorem (470) [serial 1826] used for:
    normalization of [serial 1802] 


Theorem (472)                               [serial 1924] 
P [137] << ( ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples )
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ] >>
S [133] ->
Q [148] << ( all i ~ quantity whole 
  in 2  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]  ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1923]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (473)                               [serial 1925] 
P [137] << ( ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples )
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ] >>
S [133] ->
Q [146] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ] >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1923]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (474)                               [serial 1926] 
P [137] << ( ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples )
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ] >>
S [133] ->
Q [147] << #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1923]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (475)                               [serial 1923] 
P [137] << ( ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples )
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ] >>
S [133] ->
Q [146] << ( all i ~ quantity whole 
  in 2  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:    normalization of [serial 1921]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 472 473 474:
Theorem (472) [serial 1924] used for:
  Join consequents with conjunction. (3jca)
   [serial 1923] 
Theorem (473) [serial 1925] used for:
  Join consequents with conjunction. (3jca)
   [serial 1923] 
Theorem (474) [serial 1926] used for:
  Join consequents with conjunction. (3jca)
   [serial 1923] 


Theorem (476)                               [serial 1921] 
P [137] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ]
  and ( ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  ) >>
S [133] ->
Q [146] << ( all i ~ quantity whole 
  in 2  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1828]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 475:
Theorem (475) [serial 1923] used for:
    normalization of [serial 1921] 


Theorem (477)                               [serial 1828] 
P [137] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ]
  and SHFTR() >>
S [133] ->
Q [146] << ( all i ~ quantity whole 
  in 2  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:    normalization of [serial 1803]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 476:
Theorem (476) [serial 1921] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1828] 


Theorem (478)                               [serial 1803] 
P [137] << SHFTR()
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and ( spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) ) >>
S [133] ->
Q [146] << spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples 
  and ( all i ~ quantity whole 
  in 2  .. num_samples 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  ) >>
Why created:    <<Q0>> -> <<Q>> in alternative  for [serial 1794]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 477:
Theorem (477) [serial 1828] used for:
    normalization of [serial 1803] 


Theorem (479)                               [serial 1830] 
P [133] << ( ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i )) = spo2_nxt[
      1  + i]  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples )
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [133] ->
Q [141] << SHFTR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
Why created:    normalization of [serial 1804]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (480)                               [serial 1804] 
P [133] << ( ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  )
  and ( not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) ) >>
S [133] ->
Q [141] << SHFTR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
Why created:    <<P and B1>> -> <<P1>> in alternative for [serial 1794]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 479:
Theorem (479) [serial 1830] used for:
    normalization of [serial 1804] 


Theorem (481)                               [serial 1946] 
P [141] << SHFTR()
  and not ( MOTION_ARTIFACT or not SENSOR_CONNECTED ) >>
S [142] ->
Q [144] << SPO2 = SPO2 >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1945]
Solved by: Law of identity. (eqid) Caret Introduction: if a predicate is always true it's true when time shifted (bl.caretintro) 
   or if a value is constant its value when time shifted is the same (bl.caretintrov) 

Theorem (482)                               [serial 1945] 
P [141] << SHFTR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [142] ->
Q [144] << SPO2 = SPO2^0  >>
Why created:  Replacing port names with BLESS::Value properties  [serial 1942]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 481:
Theorem (481) [serial 1946] used for:
  Assume Present:  P = P@now = P^0   [serial 1945] 


Theorem (483)                               [serial 1942] 
P [141] << SHFTR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [142] ->
Q [144] << SpO2 = SPO2^0  >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1941]
Solved by:  Replacing port names with BLESS::Value properties
 and theorem 482:
Theorem (482) [serial 1945] used for:
  Replacing port names with BLESS::Value properties  [serial 1942] 


Theorem (484)                               [serial 1943] 
P [141] << SHFTR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [142] ->
Q [143] << SHFTR() >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1941]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (485)                               [serial 1944] 
P [141] << SHFTR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [142] ->
Q [143] << not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1941]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (486)                               [serial 1941] 
P [141] << SHFTR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [142] ->
Q [143] << SpO2 = SPO2^0 
  and SHFTR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
Why created:  no reason Equality Commutes. (eqcom)
  Value of the conditional operator when its first argument is false. (iffalse)
  [Add unnecessary parentheses]
   [serial 1940]
Solved by: Join consequents with conjunction. (3jca) and theorems 483 484 485:
Theorem (483) [serial 1942] used for:
  Join consequents with conjunction. (3jca)
   [serial 1941] 
Theorem (484) [serial 1943] used for:
  Join consequents with conjunction. (3jca)
   [serial 1941] 
Theorem (485) [serial 1944] used for:
  Join consequents with conjunction. (3jca)
   [serial 1941] 


Theorem (487)                               [serial 1940] 
P [141] << SHFTR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [142] ->
Q [143] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = SpO2
  and SHFTR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
Why created:  applied wp for assignment [serial 1832]
Solved by: Equality Commutes. (eqcom) Value of the conditional operator when its first argument is false. (iffalse) [Add unnecessary parentheses] and theorem 486:
Theorem (486) [serial 1941] used for:
  no reason Equality Commutes. (eqcom)
  Value of the conditional operator when its first argument is false. (iffalse)
  [Add unnecessary parentheses]
   [serial 1940] 


Theorem (488)                               [serial 1832] 
P [141] << SHFTR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [142] spo2_nxt[1 ] := SpO2
Q [143] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ]
  and SHFTR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
Why created:    normalization of [serial 1805]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 487:
Theorem (487) [serial 1940] used for:
  applied wp for assignment [serial 1832] 


Theorem (489)                               [serial 1805] 
P [141] << SHFTR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [142] spo2_nxt[1 ] := SpO2
Q [143] << SHFTR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and ( spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) ) >>
Why created:    <<P1>> S1 <<Q1>> in alternative for [serial 1794]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 488:
Theorem (488) [serial 1832] used for:
    normalization of [serial 1805] 


Theorem (490)                               [serial 1948] 
P [143] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ]
  and ( ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  )
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [133] ->
Q [146] << ( all i ~ quantity whole 
  in 2  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1834]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (491)                               [serial 1834] 
P [143] << (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ]
  and SHFTR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [133] ->
Q [146] << ( all i ~ quantity whole 
  in 2  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:    normalization of [serial 1806]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 490:
Theorem (490) [serial 1948] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1834] 


Theorem (492)                               [serial 1806] 
P [143] << SHFTR()
  and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and ( spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) ) >>
S [133] ->
Q [146] << spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples 
  and ( all i ~ quantity whole 
  in 2  .. num_samples 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  ) >>
Why created:    <<Q1>> -> <<Q>> in alternative  for [serial 1794]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 491:
Theorem (491) [serial 1834] used for:
    normalization of [serial 1806] 


Theorem (493)                               [serial 1794] 
P [129] << ( all i ~ quantity whole 
  in 1  .. ( num_samples - 1  ) 
  are spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
S [133]   if 
    (MotionArtifact? or not SensorConnected?)~> 
      << SHFTR()
        and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
      spo2_nxt[1 ] := 0.0 percent
      << SHFTR()
        and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
        and ( spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) ) >> 
  []
    (not ( MotionArtifact? or not SensorConnected? ))~> 
      << SHFTR()
        and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
      spo2_nxt[1 ] := SpO2
      << SHFTR()
        and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
        and ( spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) ) >> 
  fi
Q [146] << spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples 
  and ( all i ~ quantity whole 
  in 2  .. num_samples 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  ) >>
Why created:  <<Q3 and P4>> S4 <<Q4 and P5>> in sequential composition for [serial 1028]
Solved by: [Convert asseertion to port value.] and theorems 461 463 471 478 480 489 492:
Theorem (461) [serial 1800] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1794] 
Theorem (463) [serial 1801] used for:
    <<P and B0>> -> <<P0>> in alternative for [serial 1794] 
Theorem (471) [serial 1802] used for:
    <<P0>> S0 <<Q0>> in alternative for [serial 1794] 
Theorem (478) [serial 1803] used for:
    <<Q0>> -> <<Q>> in alternative  for [serial 1794] 
Theorem (480) [serial 1804] used for:
    <<P and B1>> -> <<P1>> in alternative for [serial 1794] 
Theorem (489) [serial 1805] used for:
    <<P1>> S1 <<Q1>> in alternative for [serial 1794] 
Theorem (492) [serial 1806] used for:
    <<Q1>> -> <<Q>> in alternative  for [serial 1794] 


Theorem (494)                               [serial 1970] 
P [153] << (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [155] ->
Q [156] << (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:    normalization of [serial 1968]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Identity (id):  P->P is tautology

Theorem (495)                               [serial 1968] 
P [153] << (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [155] ->
Q [156] << spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:  applied wp for assignment [serial 1840]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 494:
Theorem (494) [serial 1970] used for:
    normalization of [serial 1968] 


Theorem (496)                               [serial 1840] 
P [153] << (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [155] spo2_a[i]' := spo2_nxt[i]
Q [156] << spo2_a[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:    normalization of [serial 1807]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 495:
Theorem (495) [serial 1968] used for:
  applied wp for assignment [serial 1840] 


Theorem (497)                               [serial 1807] 
P [153] << spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
S [155] spo2_a[i]' := spo2_nxt[i]
Q [156] << spo2_a[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1795]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 496:
Theorem (496) [serial 1840] used for:
    normalization of [serial 1807] 


Theorem (498)                               [serial 1964] 
P [146] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [151] ->
Q [19] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]  )
  and ( all i ~ quantity whole 
  in 1  .. num_samples 
  are #PulseOx_Properties::Num_Trending_Samples  = num_samples  ) >>
Why created:  Universal quantification of conjunction is conjunction of universal quantification. (r19.26)
   [serial 1963]
Solved by: Axiom of Distinctness. (ax-5)

Theorem (499)                               [serial 1963] 
P [146] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [151] ->
Q [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]
        and #PulseOx_Properties::Num_Trending_Samples  = num_samples  >>
Why created:  [Add unnecessary parentheses]
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1836]
Solved by: Universal quantification of conjunction is conjunction of universal quantification. (r19.26) and theorem 498:
Theorem (498) [serial 1964] used for:
  Universal quantification of conjunction is conjunction of universal quantification. (r19.26)
   [serial 1963] 


Theorem (500)                               [serial 1836] 
P [146] << ( all i ~ quantity whole 
  in 2  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) = spo2_nxt[1 ]
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [151] ->
Q [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i )) = spo2_nxt[i]
        and #PulseOx_Properties::Num_Trending_Samples  = num_samples  >>
Why created:    normalization of [serial 1808]
  Using: (df-bl.lan1) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
 [Add unnecessary parentheses] and theorem 499:
Theorem (499) [serial 1963] used for:
  [Add unnecessary parentheses]
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1836] 


Theorem (501)                               [serial 1808] 
P [146] << ( spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples 
  and ( all i ~ quantity whole 
  in 2  .. num_samples 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  ) ) >>
S [151] ->
Q [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples   >>
Why created:    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1795]
Solved by: Just one wff in the wff-list for conjunction. (df-bl.lan1) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 500:
Theorem (500) [serial 1836] used for:
    normalization of [serial 1808] 


Theorem (502)                               [serial 1966] 
P [19] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  )
  and ( all i ~ quantity whole 
  in 1  .. num_samples 
  are #PulseOx_Properties::Num_Trending_Samples  = num_samples  ) >>
S [151] ->
Q [159] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:  Universal quantification of conjunction is conjunction of universal quantification. (r19.26)
   [serial 1838]
Solved by: Axiom of Distinctness. (ax-5)

Theorem (503)                               [serial 1838] 
P [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))
        and #PulseOx_Properties::Num_Trending_Samples  = num_samples  >>
S [151] ->
Q [159] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:    normalization of [serial 1809]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Universal quantification of conjunction is conjunction of universal quantification. (r19.26) and theorem 502:
Theorem (502) [serial 1966] used for:
  Universal quantification of conjunction is conjunction of universal quantification. (r19.26)
   [serial 1838] 


Theorem (504)                               [serial 1809] 
P [19] << all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples   >>
S [151] ->
Q [159] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1795]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 503:
Theorem (503) [serial 1838] used for:
    normalization of [serial 1809] 


Theorem (505)                               [serial 1795] 
P [146] << spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples 
  and ( all i ~ quantity whole 
  in 2  .. num_samples 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  ) >>
S [151] forall i in 1  .. num_samples
    {
    << spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))
      and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
    spo2_a[i]' := spo2_nxt[i]
    << spo2_a[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))
      and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
    }  
Q [159] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  <<Q4 and P5>> S5 <<Q5 and P6>> in sequential composition for [serial 1028]
Solved by:  Forall Rule (fa):
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any
 and theorems 497 501 504:
Theorem (497) [serial 1807] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1795] 
Theorem (501) [serial 1808] used for:
    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1795] 
Theorem (504) [serial 1809] used for:
    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1795] 


Theorem (506)                               [serial 1973] 
P [159] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [163] ->
Q [164] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
Why created:    normalization of [serial 1971]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Identity (id):  P->P is tautology

Theorem (507)                               [serial 1971] 
P [159] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [163] ->
Q [164] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  applied wp for assignment [serial 1842]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 506:
Theorem (506) [serial 1973] used for:
    normalization of [serial 1971] 


Theorem (508)                               [serial 1842] 
P [159] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  )
  and #PulseOx_Properties::Num_Trending_Samples  = num_samples >>
S [163] num_samples' := num_samples
Q [164] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  )
  and num_samples' = #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    normalization of [serial 1796]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 507:
Theorem (507) [serial 1971] used for:
  applied wp for assignment [serial 1842] 


Theorem (509)                               [serial 1796] 
P [159] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
S [163] num_samples' := num_samples
Q [164] << ( all i ~ quantity whole 
  in 1  .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  )
  and num_samples' = #PulseOx_Properties::Num_Trending_Samples  >>
Why created:  <<Q5 and P6>> S6 <<Q6>> in sequential composition for [serial 1028]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 508:
Theorem (508) [serial 1842] used for:
    normalization of [serial 1796] 


Theorem (510)                               [serial 1028] 
P [51] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  ) >>
S [111]   << SpO2_INV()
    and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  )
    and AXIOM_NS() >>
  SpO2Trend!(spo2_a)
  ;
  << SpO2_INV()
    and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  )
    and AXIOM_NS() >>
  NumSamples!(num_samples)
  ;
  << SpO2_INV()
    and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  )
    and AXIOM_CR2() >>
  forall i in 1  .. ( num_samples - 1  )
      {
      << spo2_a[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))
        and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  ) >>
      spo2_nxt[i + 1 ] := spo2_a[i]
      << spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
      }  
  <<SHFTR: :( all i ~ quantity whole 
    in 1  .. ( num_samples - 1  ) 
    are spo2_nxt[i + 1 ] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0.0 percent else SPO2^( - i ))  )
    and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
  ;
    if 
      (MotionArtifact? or not SensorConnected?)~> 
        << SHFTR()
          and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
        spo2_nxt[1 ] := 0.0 percent
        << SHFTR()
          and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
          and ( spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) ) >> 
    []
      (not ( MotionArtifact? or not SensorConnected? ))~> 
        << SHFTR()
          and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
        spo2_nxt[1 ] := SpO2
        << SHFTR()
          and not ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
          and ( spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 ) ) >> 
    fi
  << spo2_nxt[1 ] = (if MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  then 0.0 percent else SPO2^0 )
    and num_samples = #PulseOx_Properties::Num_Trending_Samples 
    and ( all i ~ quantity whole 
    in 2  .. num_samples 
    are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  ) >>
  ;
  forall i in 1  .. num_samples
      {
      << spo2_nxt[i] = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
      spo2_a[i]' := spo2_nxt[i]
      << spo2_a[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
      }  
  << ( all i ~ quantity whole 
    in 1  .. num_samples 
    are spo2_a[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  )
    and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
  ;
  num_samples' := num_samples
  << ( all i ~ quantity whole 
    in 1  .. num_samples 
    are spo2_a[i]' = (if MOTION_ARTIFACT^( 1  - i ) or not SENSOR_CONNECTED^( 1  - i ) then 0.0 percent else SPO2^( 1  - i ))  )
    and num_samples' = #PulseOx_Properties::Num_Trending_Samples  >> 
Q [51] << ( SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples  ) )^1  >>
Why created:   <<M(run) and x>> A <<M(run)>> for sptt3: run-[x]->run{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 413 430 435 440 459 493 505 509:
Theorem (413) [serial 1789] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1028] 
Theorem (430) [serial 1790] used for:
  <<Q6>> -> <<Q>> in sequential composition for [serial 1028] 
Theorem (435) [serial 1791] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028] 
Theorem (440) [serial 1792] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028] 
Theorem (459) [serial 1793] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1028] 
Theorem (493) [serial 1794] used for:
  <<Q3 and P4>> S4 <<Q4 and P5>> in sequential composition for [serial 1028] 
Theorem (505) [serial 1795] used for:
  <<Q4 and P5>> S5 <<Q5 and P6>> in sequential composition for [serial 1028] 
Theorem (509) [serial 1796] used for:
  <<Q5 and P6>> S6 <<Q6>> in sequential composition for [serial 1028] 


Theorem (511)                               [serial 1018] 
P [28] <<   >>
S [33] ->
Q [28] << SpO2TrendThread.imp proof obligations >>
Why created:  Initial proof obligations for SpO2TrendThread.imp
Solved by:  Component verification conditions
 and theorems 252 255 256 258 278 371 389 407 408 510:
Theorem (252) [serial 1019] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (255) [serial 1020] used for:
  <<M(loading)>> -> <<I>> from invariant I when complete state loading has Assertion <<M(loading)>> in its definition. 
Theorem (256) [serial 1021] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (258) [serial 1022] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state check, <<M(check)>> -> <<e1 or e2 or . . . en>> 
Theorem (278) [serial 1023] used for:
   <<M(start)>> A <<M(loading)>> for sptt0: start-[ ]->loading{A}; 
Theorem (371) [serial 1024] used for:
   <<M(loading) and x>> A <<M(check)>> for sptt1: loading-[x]->check{A}; 
Theorem (389) [serial 1025] used for:
   <<M(check) and x>> A <<M(loading)>> for sptt2a: check-[x]->loading{A}; 
Theorem (407) [serial 1026] used for:
   <<M(check) and x>> A <<M(run)>> for sptt2b: check-[x]->run{A}; 
Theorem (408) [serial 1027] used for:
   <<M(check) and x>> -> <<M(fail)>> for sptt2c: check-[x]->fail{}; 
Theorem (510) [serial 1028] used for:
   <<M(run) and x>> A <<M(run)>> for sptt3: run-[x]->run{A}; 


Theorem (512)                               [serial 1999] 
P [39] << all j ~ quantity whole 
  in 1  .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [34] ->
Q [34] << all j ~ quantity whole 
  in 1  .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:    normalization of [serial 1997]
Solved by: Identity (id):  P->P is tautology

Theorem (513)                               [serial 1997] 
P [39] << ( all j ~ quantity whole 
  in 1  .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
S [34] ->
Q [34] << all j ~ quantity whole 
  in 1  .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1030]
Solved by: [Add unnecessary parentheses] and theorem 512:
Theorem (512) [serial 1999] used for:
    normalization of [serial 1997] 


Theorem (514)                               [serial 1030] 
P [39] << MOINV() >>
S [34] ->
Q [34] << all j ~ quantity whole 
  in 1  .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 513:
Theorem (513) [serial 1997] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1030] 


Theorem (515)                               [serial 1031] 
P [38] << numBadReadings = 0  >>
S [38] ->
Q [38] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by: Anything Implies True (a1tru): P->true

Theorem (516)                               [serial 2003] 
P [38] << 0  = numBadReadings >>
S [42] ->
Q [39] << ( all j ~ quantity whole 
  in 1  .. 0  
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  )^1  >>
Why created:  [Add unnecessary parentheses]
  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>> 
 replacing "numBadReadings"
 with its ="
 ( 0  )" [serial 2002]
Solved by: Empty closed interval (icc0)

Theorem (517)                               [serial 2002] 
P [38] << 0  = numBadReadings >>
S [42] ->
Q [39] << ( all j ~ quantity whole 
  in 1  .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  )^1  >>
Why created:    normalization of [serial 2000]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by:  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
 [Add unnecessary parentheses] and theorem 516:
Theorem (516) [serial 2003] used for:
  [Add unnecessary parentheses]
  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>> 
 replacing "numBadReadings"
 with its ="
 ( 0  )" [serial 2002] 


Theorem (518)                               [serial 2000] 
P [38] << numBadReadings = 0  >>
S [42] ->
Q [39] << ( ( all j ~ quantity whole 
  in 1  .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) )^1  >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1032]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 517:
Theorem (517) [serial 2002] used for:
    normalization of [serial 2000] 


Theorem (519)                               [serial 1032] 
P [38] << numBadReadings = 0  >>
S [42] ->
Q [39] << ( MOINV() )^1  >>
Why created:   <<M(start)>> -> <<M(run)>> for mat0: start-[ ]->run{};
Solved by: Predicate Invocation. (PI) and theorem 518:
Theorem (518) [serial 2000] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1032] 


Theorem (520)                               [serial 2008] 
P [39] << MOINV() >>
S [39] ->
Q [44] << MOINV() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1033]
Solved by: Identity (id):  P->P is tautology

Theorem (521)                               [serial 2138] 
P [68] << all j ~ quantity whole 
  in 0  .. ( -1  + numBadReadings ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [39] ->
Q [16] << all j ~ quantity whole 
  in 0  .. ( -1  + numBadReadings ) 
  are MOTION_ARTIFACT^( ( -1  + - j ) + 1  ) or not SENSOR_CONNECTED^( ( 
      -1  + - j ) + 1  )  >>
Why created:    normalization of [serial 2136]
Solved by: Addition associativity (bl.add3i)(bl.add4i)

Theorem (522)                               [serial 2136] 
P [68] << all j ~ quantity whole 
  in 0  .. ( numBadReadings + - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [39] ->
Q [16] << all j ~ quantity whole 
  in 0  .. ( numBadReadings + - 1  ) 
  are MOTION_ARTIFACT^( ( -1  + - j ) + 1  ) or not SENSOR_CONNECTED^( ( 
      -1  + - j ) + 1  )  >>
Why created:   changing adding negation to subtraction  [serial 2135]
Solved by: Addition Commutes. (bl.addcom) and theorem 521:
Theorem (521) [serial 2138] used for:
    normalization of [serial 2136] 


Theorem (523)                               [serial 2135] 
P [68] << all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [39] ->
Q [16] << all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( ( -1  + - j ) + 1  ) or not SENSOR_CONNECTED^( ( 
      -1  + - j ) + 1  )  >>
Why created:  null
   [serial 2133]
Solved by: Relationship between subtraction and negative. (negsub) and theorem 522:
Theorem (522) [serial 2136] used for:
   changing adding negation to subtraction  [serial 2135] 


Theorem (524)                               [serial 2133] 
P [68] << all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [39] ->
Q [16] << all j ~ quantity whole 
  in 1  .. numBadReadings 
  are MOTION_ARTIFACT^( 1  + - j ) or not SENSOR_CONNECTED^( 1  + - j )  >>
Why created:    normalization of [serial 2131]
  Using: (df-bl.tsdis) (bl.addcom) ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: null and theorem 523:
Theorem (523) [serial 2135] used for:
  null
   [serial 2133] 


Theorem (525)                               [serial 2131] 
P [68] << all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [39] ->
Q [16] << all j ~ quantity whole 
  in 1  .. numBadReadings 
  are not ( SENSOR_CONNECTED^( - j ) )^1  or MOTION_ARTIFACT^( 1  + - j )  >>
Why created:  Distribute ^ over complement. (bl.tsnot)
   [serial 2130]
Solved by: Time shift distributes. (df-bl.tsdis)(df-bl.tsdisc) Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 524:
Theorem (524) [serial 2133] used for:
    normalization of [serial 2131] 


Theorem (526)                               [serial 2130] 
P [68] << all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [39] ->
Q [16] << all j ~ quantity whole 
  in 1  .. numBadReadings 
  are ( not SENSOR_CONNECTED^( - j ) )^1  or MOTION_ARTIFACT^( 1  + - j )  >>
Why created:    normalization of [serial 2128]
  Using: (bl.addcom) ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Distribute ^ over complement. (bl.tsnot) and theorem 525:
Theorem (525) [serial 2131] used for:
  Distribute ^ over complement. (bl.tsnot)
   [serial 2130] 


Theorem (527)                               [serial 2128] 
P [68] << all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [39] ->
Q [16] << all j ~ quantity whole 
  in 1  .. numBadReadings 
  are ( MOTION_ARTIFACT^( ( - j ) + 1  ) or ( not SENSOR_CONNECTED^( - j ) )^1  )  >>
Why created:  Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3)
   [serial 2127]
Solved by: Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 526:
Theorem (526) [serial 2130] used for:
    normalization of [serial 2128] 


Theorem (528)                               [serial 2127] 
P [68] << all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [39] ->
Q [16] << all j ~ quantity whole 
  in 1  .. numBadReadings 
  are ( MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j ) )^1   >>
Why created:    normalization of [serial 2125]
Solved by: Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3) and theorem 527:
Theorem (527) [serial 2128] used for:
  Distribute ^ over disjunction. (bl.tsor)(df-bl.tsor2)(bl.tsor3)
   [serial 2127] 


Theorem (529)                               [serial 2125] 
P [68] << all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [39] ->
Q [16] << ( all j ~ quantity whole 
  in 1  .. numBadReadings 
  are ( MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j ) )^1   ) >>
Why created:  Distribute ^ over universal quantification. (bl.tsal)
   [serial 2110]
Solved by: [Add unnecessary parentheses] and theorem 528:
Theorem (528) [serial 2127] used for:
    normalization of [serial 2125] 


Theorem (530)                               [serial 2110] 
P [68] << all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [39] ->
Q [16] << ( all j ~ quantity whole 
  in 1  .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  )^1  >>
Why created:    normalization of [serial 2099]
Solved by: Distribute ^ over universal quantification. (bl.tsal) and theorem 529:
Theorem (529) [serial 2125] used for:
  Distribute ^ over universal quantification. (bl.tsal)
   [serial 2110] 


Theorem (531)                               [serial 2099] 
P [68] << ( all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
S [39] ->
Q [16] << ( all j ~ quantity whole 
  in 1  .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  )^1  >>
Why created:  Substituted assertions' predicates for labels  [serial 2072]
Solved by: [Add unnecessary parentheses] and theorem 530:
Theorem (530) [serial 2110] used for:
    normalization of [serial 2099] 


Theorem (532)                               [serial 2072] 
P [68] << NUMBAD() >>
S [39] ->
Q [16] << ( all j ~ quantity whole 
  in 1  .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  )^1  >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2028]
Solved by: Predicate Invocation. (PI) and theorem 531:
Theorem (531) [serial 2099] used for:
  Substituted assertions' predicates for labels  [serial 2072] 


Theorem (533)                               [serial 2028] 
P [68] << NUMBAD() >>
S [39] ->
Q [16] << MOINV()^1  >>
Why created:    normalization of [serial 2009]
Solved by: Predicate Invocation. (PI) and theorem 532:
Theorem (532) [serial 2072] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2028] 


Theorem (534)                               [serial 2009] 
P [68] << NUMBAD() >>
S [39] ->
Q [16] << ( MOINV() )^1  >>
Why created:  <<Q2>> -> <<Q>> in sequential composition for [serial 1033]
Solved by: [Add unnecessary parentheses] and theorem 533:
Theorem (533) [serial 2028] used for:
    normalization of [serial 2009] 


Theorem (535)                               [serial 2012] 
P [44] << MOINV() >>
S [45] ->
Q [45] << ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) or ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 2010]
Solved by: Absorb parentheses, middle term in disjunction (bl.orabpm)

Theorem (536)                               [serial 2031] 
P [45] << ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  )
  and MOINV() >>
S [45] ->
Q [48] << SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  >>
Why created:    normalization of [serial 2013]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (537)                               [serial 2013] 
P [45] << MOINV()
  and ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) >>
S [45] ->
Q [48] << SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  >>
Why created:    <<P and B0>> -> <<P0>> in alternative for [serial 2010]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 536:
Theorem (536) [serial 2031] used for:
    normalization of [serial 2013] 


Theorem (538)                               [serial 2084] 
P [48] << SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  >>
S [49] ->
Q [50] << all j ~ quantity whole 
  in 0  .. -1  
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:    normalization of [serial 2075]
Solved by: Empty closed interval (icc0)

Theorem (539)                               [serial 2075] 
P [48] << SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  >>
S [49] ->
Q [50] << ( all j ~ quantity whole 
  in 0  .. ( 0  - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
Why created:  applied wp for assignment [serial 2070]
Solved by: [Add unnecessary parentheses] and theorem 538:
Theorem (538) [serial 2084] used for:
    normalization of [serial 2075] 


Theorem (540)                               [serial 2070] 
P [48] << SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  >>
S [49] numBadReadings := 0 
Q [50] << ( all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2014]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 539:
Theorem (539) [serial 2075] used for:
  applied wp for assignment [serial 2070] 


Theorem (541)                               [serial 2014] 
P [48] << SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  >>
S [49] numBadReadings := 0 
Q [50] << NUMBAD() >>
Why created:    <<P0>> S0 <<Q0>> in alternative for [serial 2010]
Solved by: Predicate Invocation. (PI) and theorem 540:
Theorem (540) [serial 2070] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2014] 


Theorem (542)                               [serial 2015] 
P [50] << NUMBAD() >>
S [45] ->
Q [57] << NUMBAD() >>
Why created:    <<Q0>> -> <<Q>> in alternative  for [serial 2010]
Solved by: Identity (id):  P->P is tautology

Theorem (543)                               [serial 2117] 
P [45] << ( all j ~ quantity whole 
  in 0  .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  )
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [45] ->
Q [53] << all j ~ quantity whole 
  in 0  .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 2104]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (544)                               [serial 2104] 
P [45] << ( all j ~ quantity whole 
  in 1  .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  )
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [45] ->
Q [53] << all j ~ quantity whole 
  in 0  .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:    normalization of [serial 2096]
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
 and theorem 543:
Theorem (543) [serial 2117] used for:
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 2104] 


Theorem (545)                               [serial 2096] 
P [45] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and ( all j ~ quantity whole 
  in 1  .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
S [45] ->
Q [53] << all j ~ quantity whole 
  in 0  .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:  Substituted assertions' predicates for labels  [serial 2035]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 544:
Theorem (544) [serial 2104] used for:
    normalization of [serial 2096] 


Theorem (546)                               [serial 2035] 
P [45] << ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  )
  and MOINV() >>
S [45] ->
Q [53] << all j ~ quantity whole 
  in 0  .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:    normalization of [serial 2016]
Solved by: Predicate Invocation. (PI) and theorem 545:
Theorem (545) [serial 2096] used for:
  Substituted assertions' predicates for labels  [serial 2035] 


Theorem (547)                               [serial 2016] 
P [45] << MOINV()
  and ( MOTION_ARTIFACT^0  or not SENSOR_CONNECTED^0  ) >>
S [45] ->
Q [53] << all j ~ quantity whole 
  in 0  .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:    <<P and B1>> -> <<P1>> in alternative for [serial 2010]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 546:
Theorem (546) [serial 2035] used for:
    normalization of [serial 2016] 


Theorem (548)                               [serial 2089] 
P [53] << all j ~ quantity whole 
  in 0  .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [54] ->
Q [55] << all j ~ quantity whole 
  in 0  .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:    normalization of [serial 2077]
Solved by: Identity (id):  P->P is tautology

Theorem (549)                               [serial 2077] 
P [53] << all j ~ quantity whole 
  in 0  .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [54] ->
Q [55] << ( all j ~ quantity whole 
  in 0  .. ( ( 1  + numBadReadings ) - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
Why created:  applied wp for assignment [serial 2073]
Solved by: [Add unnecessary parentheses] and theorem 548:
Theorem (548) [serial 2089] used for:
    normalization of [serial 2077] 


Theorem (550)                               [serial 2073] 
P [53] << all j ~ quantity whole 
  in 0  .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [54] numBadReadings := 1  + numBadReadings
Q [55] << ( all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2037]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 549:
Theorem (549) [serial 2077] used for:
  applied wp for assignment [serial 2073] 


Theorem (551)                               [serial 2037] 
P [53] << all j ~ quantity whole 
  in 0  .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [54] numBadReadings := 1  + numBadReadings
Q [55] << NUMBAD() >>
Why created:    normalization of [serial 2017]
Solved by: Predicate Invocation. (PI) and theorem 550:
Theorem (550) [serial 2073] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2037] 


Theorem (552)                               [serial 2017] 
P [53] << all j ~ quantity whole 
  in 0  .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [54] numBadReadings := numBadReadings + 1 
Q [55] << NUMBAD() >>
Why created:    <<P1>> S1 <<Q1>> in alternative for [serial 2010]
Solved by: Addition Commutes. (bl.addcom) and theorem 551:
Theorem (551) [serial 2037] used for:
    normalization of [serial 2017] 


Theorem (553)                               [serial 2018] 
P [55] << NUMBAD() >>
S [45] ->
Q [57] << NUMBAD() >>
Why created:    <<Q1>> -> <<Q>> in alternative  for [serial 2010]
Solved by: Identity (id):  P->P is tautology

Theorem (554)                               [serial 2010] 
P [44] << MOINV() >>
S [45]   if 
    (SensorConnected?
    and not MotionArtifact?)~> 
      << SENSOR_CONNECTED^0 
        and not MOTION_ARTIFACT^0  >>
      numBadReadings := 0 
      << NUMBAD() >> 
  []
    (MotionArtifact? or not SensorConnected?)~> 
      << all j ~ quantity whole 
        in 0  .. numBadReadings 
        are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
      numBadReadings := numBadReadings + 1 
      << NUMBAD() >> 
  fi
Q [57] << NUMBAD() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1033]
Solved by: [Convert asseertion to port value.] and theorems 535 537 541 542 547 552 553:
Theorem (535) [serial 2012] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 2010] 
Theorem (537) [serial 2013] used for:
    <<P and B0>> -> <<P0>> in alternative for [serial 2010] 
Theorem (541) [serial 2014] used for:
    <<P0>> S0 <<Q0>> in alternative for [serial 2010] 
Theorem (542) [serial 2015] used for:
    <<Q0>> -> <<Q>> in alternative  for [serial 2010] 
Theorem (547) [serial 2016] used for:
    <<P and B1>> -> <<P1>> in alternative for [serial 2010] 
Theorem (552) [serial 2017] used for:
    <<P1>> S1 <<Q1>> in alternative for [serial 2010] 
Theorem (553) [serial 2018] used for:
    <<Q1>> -> <<Q>> in alternative  for [serial 2010] 


Theorem (555)                               [serial 2118] 
P [57] << all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [59] ->
Q [59] << numBadReadings - 1  < #PulseOx_Properties::Motion_Artifact_Sample_Limit  or 
( not ( numBadReadings - 1  < #PulseOx_Properties::Motion_Artifact_Sample_Limit  ) ) >>
Why created:  Replacing <= with not < of [serial 2106]
Solved by: Law of Excluded middle. (exmid)

Theorem (556)                               [serial 2106] 
P [57] << all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [59] ->
Q [59] << numBadReadings - 1  < #PulseOx_Properties::Motion_Artifact_Sample_Limit  or 
#PulseOx_Properties::Motion_Artifact_Sample_Limit  <= numBadReadings - 1  >>
Why created:    normalization of [serial 2097]
Solved by: 'Less than' expressed in terms of 'less than or equal to'. (ltnle) and theorem 555:
Theorem (555) [serial 2118] used for:
  Replacing <= with not < of [serial 2106] 


Theorem (557)                               [serial 2097] 
P [57] << ( all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
S [59] ->
Q [59] << numBadReadings - 1  < #PulseOx_Properties::Motion_Artifact_Sample_Limit  or 
#PulseOx_Properties::Motion_Artifact_Sample_Limit  <= numBadReadings - 1  >>
Why created:  Substituted assertions' predicates for labels  [serial 2040]
Solved by: [Add unnecessary parentheses] and theorem 556:
Theorem (556) [serial 2106] used for:
    normalization of [serial 2097] 


Theorem (558)                               [serial 2040] 
P [57] << NUMBAD() >>
S [59] ->
Q [59] << numBadReadings - 1  < #PulseOx_Properties::Motion_Artifact_Sample_Limit  or 
#PulseOx_Properties::Motion_Artifact_Sample_Limit  <= numBadReadings - 1  >>
Why created:    normalization of [serial 2019]
  Using: ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost 
Solved by: Predicate Invocation. (PI) and theorem 557:
Theorem (557) [serial 2097] used for:
  Substituted assertions' predicates for labels  [serial 2040] 


Theorem (559)                               [serial 2019] 
P [57] << NUMBAD() >>
S [59] ->
Q [59] << ( ( numBadReadings - 1  ) < #PulseOx_Properties::Motion_Artifact_Sample_Limit  ) or 
( ( numBadReadings - 1  ) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit  ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 2011]
Solved by: [Add unnecessary parentheses] [change A>=B to B<=A] and theorem 558:
Theorem (558) [serial 2040] used for:
    normalization of [serial 2019] 


Theorem (560)                               [serial 2042] 
P [59] << numBadReadings - 1  < #PulseOx_Properties::Motion_Artifact_Sample_Limit 
  and NUMBAD() >>
S [59] ->
Q [61] << NUMBAD() >>
Why created:    normalization of [serial 2020]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (561)                               [serial 2020] 
P [59] << NUMBAD()
  and ( ( numBadReadings - 1  ) < #PulseOx_Properties::Motion_Artifact_Sample_Limit  ) >>
S [59] ->
Q [61] << NUMBAD() >>
Why created:    <<P and B0>> -> <<P0>> in alternative for [serial 2011]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 560:
Theorem (560) [serial 2042] used for:
    normalization of [serial 2020] 


Theorem (562)                               [serial 2114] 
P [61] << all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [61] ->
Q [61] << all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:    normalization of [serial 2101]
Solved by: Identity (id):  P->P is tautology

Theorem (563)                               [serial 2101] 
P [61] << ( all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
S [61] ->
Q [61] << all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:  Substituted assertions' predicates for labels  [serial 2086]
Solved by: [Add unnecessary parentheses] and theorem 562:
Theorem (562) [serial 2114] used for:
    normalization of [serial 2101] 


Theorem (564)                               [serial 2086] 
P [61] << NUMBAD() >>
S [61] ->
Q [61] << all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:    normalization of [serial 2076]
Solved by: Predicate Invocation. (PI) and theorem 563:
Theorem (563) [serial 2101] used for:
  Substituted assertions' predicates for labels  [serial 2086] 


Theorem (565)                               [serial 2076] 
P [61] << NUMBAD() >>
S [61] ->
Q [61] << ( all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
Why created:    <<P>> -> <<Q>>
  for [serial 2071]
Solved by: [Add unnecessary parentheses] and theorem 564:
Theorem (564) [serial 2086] used for:
    normalization of [serial 2076] 


Theorem (566)                               [serial 2071] 
P [61] << NUMBAD() >>
S [61] skip
Q [61] << ( all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2021]
Solved by:  Skip Means Implication:  <<P>> skip <<Q>>  is  <<P>> -> <<Q>>
 and theorem 565:
Theorem (565) [serial 2076] used for:
    <<P>> -> <<Q>>
  for [serial 2071] 


Theorem (567)                               [serial 2021] 
P [61] << NUMBAD() >>
S [61] skip
Q [61] << NUMBAD() >>
Why created:    <<P0>> S0 <<Q0>> in alternative for [serial 2011]
Solved by: Predicate Invocation. (PI) and theorem 566:
Theorem (566) [serial 2071] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2021] 


Theorem (568)                               [serial 2022] 
P [61] << NUMBAD() >>
S [59] ->
Q [68] << NUMBAD() >>
Why created:    <<Q0>> -> <<Q>> in alternative  for [serial 2011]
Solved by: Identity (id):  P->P is tautology

Theorem (569)                               [serial 2046] 
P [59] << #PulseOx_Properties::Motion_Artifact_Sample_Limit  <= numBadReadings - 1 
  and NUMBAD() >>
S [59] ->
Q [64] << #PulseOx_Properties::Motion_Artifact_Sample_Limit  <= numBadReadings - 1 
  and NUMBAD() >>
Why created:    normalization of [serial 2023]
  Using: ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (570)                               [serial 2023] 
P [59] << NUMBAD()
  and ( ( numBadReadings - 1  ) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit  ) >>
S [59] ->
Q [64] << NUMBAD()
  and ( ( numBadReadings - 1  ) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit  ) >>
Why created:    <<P and B1>> -> <<P1>> in alternative for [serial 2011]
Solved by: [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 569:
Theorem (569) [serial 2046] used for:
    normalization of [serial 2023] 


Theorem (571)                               [serial 2142] 
P [64] << ( all j ~ quantity whole 
  in 0  .. #PulseOx_Properties::Motion_Artifact_Sample_Limit  
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  )
  and #PulseOx_Properties::Motion_Artifact_Sample_Limit  <= numBadReadings - 1  >>
S [65] ->
Q [13] << all j ~ quantity whole 
  in 0  .. #PulseOx_Properties::Motion_Artifact_Sample_Limit  
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:  Contract universal quantification, lower bound.  (bl.cuqlb)
   [serial 2112]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (572)                               [serial 2112] 
P [64] << ( all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  )
  and #PulseOx_Properties::Motion_Artifact_Sample_Limit  <= numBadReadings - 1  >>
S [65] ->
Q [13] << all j ~ quantity whole 
  in 0  .. #PulseOx_Properties::Motion_Artifact_Sample_Limit  
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:    normalization of [serial 2100]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Contract universal quantification, lower bound.  (bl.cuqlb) and theorem 571:
Theorem (571) [serial 2142] used for:
  Contract universal quantification, lower bound.  (bl.cuqlb)
   [serial 2112] 


Theorem (573)                               [serial 2100] 
P [64] << #PulseOx_Properties::Motion_Artifact_Sample_Limit  <= numBadReadings - 1 
  and ( all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
S [65] ->
Q [13] << ( all j ~ quantity whole 
  in 0  .. #PulseOx_Properties::Motion_Artifact_Sample_Limit  
  are ( MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j ) )  ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2078]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 572:
Theorem (572) [serial 2112] used for:
    normalization of [serial 2100] 


Theorem (574)                               [serial 2078] 
P [64] << #PulseOx_Properties::Motion_Artifact_Sample_Limit  <= numBadReadings - 1 
  and NUMBAD() >>
S [65] ->
Q [13] << MOTION_ARTIFACT_ALARM() >>
Why created:  applied port output <<pre>> -> <<M[MotionArtifactAlarm]>> [serial 2074]
Solved by: Predicate Invocation. (PI) and theorem 573:
Theorem (573) [serial 2100] used for:
  Substituted assertions' predicates for labels  [serial 2078] 


Theorem (575)                               [serial 2092] 
P [65] << ( #PulseOx_Properties::Motion_Artifact_Sample_Limit  <= numBadReadings - 1 
  and NUMBAD() )
  and MotionArtifactAlarm^0  >>
S [65] ->
Q [66] << all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:    normalization of [serial 2079]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (576)                               [serial 2079] 
P [65] << ( #PulseOx_Properties::Motion_Artifact_Sample_Limit  <= numBadReadings - 1 
  and NUMBAD() )
  and MotionArtifactAlarm^0  >>
S [65] ->
Q [66] << ( all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
Why created:  applied port output <<pre and M[MotionArtifactAlarm]^0>> -> <<post>> [serial 2074]
Solved by: [Add unnecessary parentheses] and theorem 575:
Theorem (575) [serial 2092] used for:
    normalization of [serial 2079] 


Theorem (577)                               [serial 2074] 
P [64] << #PulseOx_Properties::Motion_Artifact_Sample_Limit  <= numBadReadings - 1 
  and NUMBAD() >>
S [65] MotionArtifactAlarm!
Q [66] << ( all j ~ quantity whole 
  in 0  .. ( numBadReadings - 1  ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2048]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 574 576:
Theorem (574) [serial 2078] used for:
  applied port output <<pre>> -> <<M[MotionArtifactAlarm]>> [serial 2074] 
Theorem (576) [serial 2079] used for:
  applied port output <<pre and M[MotionArtifactAlarm]^0>> -> <<post>> [serial 2074] 


Theorem (578)                               [serial 2048] 
P [64] << #PulseOx_Properties::Motion_Artifact_Sample_Limit  <= numBadReadings - 1 
  and NUMBAD() >>
S [65] MotionArtifactAlarm!
Q [66] << NUMBAD() >>
Why created:    normalization of [serial 2024]
  Using: ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 577:
Theorem (577) [serial 2074] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2048] 


Theorem (579)                               [serial 2024] 
P [64] << NUMBAD()
  and ( ( numBadReadings - 1  ) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit  ) >>
S [65] MotionArtifactAlarm!
Q [66] << NUMBAD() >>
Why created:    <<P1>> S1 <<Q1>> in alternative for [serial 2011]
Solved by: [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 578:
Theorem (578) [serial 2048] used for:
    normalization of [serial 2024] 


Theorem (580)                               [serial 2025] 
P [66] << NUMBAD() >>
S [59] ->
Q [68] << NUMBAD() >>
Why created:    <<Q1>> -> <<Q>> in alternative  for [serial 2011]
Solved by: Identity (id):  P->P is tautology

Theorem (581)                               [serial 2011] 
P [57] << NUMBAD() >>
S [59]   if 
    (( numBadReadings - 1  ) < #PulseOx_Properties::Motion_Artifact_Sample_Limit )~> 
      << NUMBAD() >>
      skip
      << NUMBAD() >> 
  []
    (( numBadReadings - 1  ) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit )~> 
      << NUMBAD()
        and ( ( numBadReadings - 1  ) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit  ) >>
      MotionArtifactAlarm!
      << NUMBAD() >> 
  fi
Q [68] << NUMBAD() >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1033]
Solved by: and theorems 559 561 567 568 570 579 580:
Theorem (559) [serial 2019] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 2011] 
Theorem (561) [serial 2020] used for:
    <<P and B0>> -> <<P0>> in alternative for [serial 2011] 
Theorem (567) [serial 2021] used for:
    <<P0>> S0 <<Q0>> in alternative for [serial 2011] 
Theorem (568) [serial 2022] used for:
    <<Q0>> -> <<Q>> in alternative  for [serial 2011] 
Theorem (570) [serial 2023] used for:
    <<P and B1>> -> <<P1>> in alternative for [serial 2011] 
Theorem (579) [serial 2024] used for:
    <<P1>> S1 <<Q1>> in alternative for [serial 2011] 
Theorem (580) [serial 2025] used for:
    <<Q1>> -> <<Q>> in alternative  for [serial 2011] 


Theorem (582)                               [serial 1033] 
P [39] << MOINV() >>
S [44]   << MOINV() >>
    if 
      (SensorConnected?
      and not MotionArtifact?)~> 
        << SENSOR_CONNECTED^0 
          and not MOTION_ARTIFACT^0  >>
        numBadReadings := 0 
        << NUMBAD() >> 
    []
      (MotionArtifact? or not SensorConnected?)~> 
        << all j ~ quantity whole 
          in 0  .. numBadReadings 
          are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
        numBadReadings := numBadReadings + 1 
        << NUMBAD() >> 
    fi
  << NUMBAD() >>
  ;
    if 
      (( numBadReadings - 1  ) < #PulseOx_Properties::Motion_Artifact_Sample_Limit )~> 
        << NUMBAD() >>
        skip
        << NUMBAD() >> 
    []
      (( numBadReadings - 1  ) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit )~> 
        << NUMBAD()
          and ( ( numBadReadings - 1  ) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit  ) >>
        MotionArtifactAlarm!
        << NUMBAD() >> 
    fi
  << NUMBAD() >> 
Q [39] << ( MOINV() )^1  >>
Why created:   <<M(run) and x>> A <<M(run)>> for mat1: run-[x]->run{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 520 534 554 581:
Theorem (520) [serial 2008] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1033] 
Theorem (534) [serial 2009] used for:
  <<Q2>> -> <<Q>> in sequential composition for [serial 1033] 
Theorem (554) [serial 2010] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1033] 
Theorem (581) [serial 2011] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1033] 


Theorem (583)                               [serial 1029] 
P [31] <<   >>
S [34] ->
Q [31] << MotionArtifactThread.imp proof obligations >>
Why created:  Initial proof obligations for MotionArtifactThread.imp
Solved by:  Component verification conditions
 and theorems 514 515 519 582:
Theorem (514) [serial 1030] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (515) [serial 1031] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (519) [serial 1032] used for:
   <<M(start)>> -> <<M(run)>> for mat0: start-[ ]->run{}; 
Theorem (582) [serial 1033] used for:
   <<M(run) and x>> A <<M(run)>> for mat1: run-[x]->run{A}; 


Theorem (584)                               [serial 1035] 
P [31] << true >>
S [28] ->
Q [28] << true >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by: Anything Implies True (a1tru): P->true

Theorem (585)                               [serial 1036] 
P [30] << true >>
S [30] ->
Q [30] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by: Anything Implies True (a1tru): P->true

Theorem (586)                               [serial 2148] 
P [32] << true >>
S [32] ->
Q [32] << ( SPO2_AVERAGE()^0  < SPO2_LOWER_LIMIT^0  + SPO2_LOWER_LIMIT_ADJ^0  or 
not ( SPO2_AVERAGE()^0  < SPO2_LOWER_LIMIT^0  + SPO2_LOWER_LIMIT_ADJ^0  ) or 
not SUPPL_OXY_ALARM_ENABLED^0  or ( not ( SPO2_AVERAGE()^0  < SPO2_LOWER_LIMIT^0  + 
SPO2_LOWER_LIMIT_ADJ^0  ) or not SUPPL_OXY_ALARM_ENABLED^0  ) )
  and ( SUPPL_OXY_ALARM_ENABLED^0  or not ( SPO2_AVERAGE()^0  < SPO2_LOWER_LIMIT^0  + 
SPO2_LOWER_LIMIT_ADJ^0  ) or not SUPPL_OXY_ALARM_ENABLED^0  or ( not ( SPO2_AVERAGE()^0  < 
SPO2_LOWER_LIMIT^0  + SPO2_LOWER_LIMIT_ADJ^0  ) or not SUPPL_OXY_ALARM_ENABLED^0  ) ) >>
Why created:  Distributing Postcondition Or-Over-And [serial 2147]
Solved by: Law of Excluded middle. (exmid)

Theorem (587)                               [serial 2147] 
P [32] << true >>
S [32] ->
Q [32] << ( SPO2_AVERAGE()^0  < SPO2_LOWER_LIMIT^0  + SPO2_LOWER_LIMIT_ADJ^0 
  and SUPPL_OXY_ALARM_ENABLED^0  ) or ( not ( SPO2_AVERAGE()^0  < SPO2_LOWER_LIMIT^0  + 
SPO2_LOWER_LIMIT_ADJ^0  ) or not SUPPL_OXY_ALARM_ENABLED^0  ) >>
Why created:    normalization of [serial 2145]
Solved by: Distribution and-over-or with wff lists. (bl.dba2owl) and theorem 586:
Theorem (586) [serial 2148] used for:
  Distributing Postcondition Or-Over-And [serial 2147] 


Theorem (588)                               [serial 2145] 
P [32] << true >>
S [32] ->
Q [32] << ( SPO2_AVERAGE()^0  < SPO2_LOWER_LIMIT^0  + SPO2_LOWER_LIMIT_ADJ^0 
  and SUPPL_OXY_ALARM_ENABLED^0  ) or ( ( not ( SPO2_AVERAGE()^0  < SPO2_LOWER_LIMIT^0  + 
SPO2_LOWER_LIMIT_ADJ^0  ) ) or not SUPPL_OXY_ALARM_ENABLED^0  ) >>
Why created:  Replacing <= with not < of [serial 2144]
Solved by: [Add unnecessary parentheses] and theorem 587:
Theorem (587) [serial 2147] used for:
    normalization of [serial 2145] 


Theorem (589)                               [serial 2144] 
P [32] << true >>
S [32] ->
Q [32] << ( SPO2_AVERAGE()^0  < SPO2_LOWER_LIMIT^0  + SPO2_LOWER_LIMIT_ADJ^0 
  and SUPPL_OXY_ALARM_ENABLED^0  ) or ( SPO2_LOWER_LIMIT^0  + SPO2_LOWER_LIMIT_ADJ^0  <= SPO2_AVERAGE()^0  or 
not SUPPL_OXY_ALARM_ENABLED^0  ) >>
Why created:    normalization of [serial 1037]
  Using: changeAtLeastToAtMost (bl.ancom) (bl.orcom) 
Solved by: 'Less than' expressed in terms of 'less than or equal to'. (ltnle) and theorem 588:
Theorem (588) [serial 2145] used for:
  Replacing <= with not < of [serial 2144] 


Theorem (590)                               [serial 1037] 
P [32] << true >>
S [32] ->
Q [32] << ( SUPPL_OXY_ALARM_ENABLED^0 
  and SPO2_AVERAGE()^0  < SPO2_LOWER_LIMIT^0  + SPO2_LOWER_LIMIT_ADJ^0  ) or 
( not SUPPL_OXY_ALARM_ENABLED^0  or SPO2_AVERAGE()^0  >= SPO2_LOWER_LIMIT^0  + 
SPO2_LOWER_LIMIT_ADJ^0  ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state check, <<M(check)>> -> <<e1 or e2 or . . . en>>
Solved by: [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 589:
Theorem (589) [serial 2144] used for:
    normalization of [serial 1037] 


Theorem (591)                               [serial 2154] 
P [30] << true >>
S [35] ->
Q [31] << true >>
Why created:    normalization of [serial 1038]
Solved by: Anything Implies True (a1tru): P->true

Theorem (592)                               [serial 1038] 
P [30] << true >>
S [35] ->
Q [31] << ( true )^1  >>
Why created:   <<M(start)>> -> <<M(run)>> for so0: start-[ ]->run{};
Solved by: null and theorem 591:
Theorem (591) [serial 2154] used for:
    normalization of [serial 1038] 


Theorem (593)                               [serial 1039] 
P [31] << true >>
S [36] ->
Q [32] << true >>
Why created:   <<M(run) and x>> -> <<M(check)>> for so1: run-[x]->check{};
Solved by: Anything Implies True (a1tru): P->true

Theorem (594)                               [serial 2163] 
P [37] << SPO2_AVERAGE()^0  < SPO2_LOWER_LIMIT^0  + SPO2_LOWER_LIMIT_ADJ^0 
  and SUPPL_OXY_ALARM_ENABLED^0  >>
S [37] ->
Q [38] << SPO2_AVERAGE()^0  < SPO2_LOWER_LIMIT^0  + SPO2_LOWER_LIMIT_ADJ^0 
  and SUPPL_OXY_ALARM_ENABLED^0  >>
Why created:    normalization of [serial 2161]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (595)                               [serial 2161] 
P [37] << SPO2_AVERAGE()^0  < SPO2_LOWER_LIMIT^0  + SPO2_LOWER_LIMIT_ADJ^0 
  and SUPPL_OXY_ALARM_ENABLED^0  >>
S [37] ->
Q [38] << ( SUPPL_OXY_ALARM_ENABLED^0 
  and ( SPO2_AVERAGE() )^0  < ( SPO2_LOWER_LIMIT^0  + SPO2_LOWER_LIMIT_ADJ^0  ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2157]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 594:
Theorem (594) [serial 2163] used for:
    normalization of [serial 2161] 


Theorem (596)                               [serial 2157] 
P [37] << SPO2_AVERAGE()^0  < SPO2_LOWER_LIMIT^0  + SPO2_LOWER_LIMIT_ADJ^0 
  and SUPPL_OXY_ALARM_ENABLED^0  >>
S [37] ->
Q [38] << SUPPL_O2_ALARM() >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 2156]
Solved by: Predicate Invocation. (PI) and theorem 595:
Theorem (595) [serial 2161] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2157] 


Theorem (597)                               [serial 2159] 
P [38] << SUPPL_O2_ALARM() >>
S [38] ->
Q [17] << SUPPL_O2_ALARM() >>
Why created:  applied port output <<pre>> -> <<M[SpO2DerivedLowerLimitAlarm]>> [serial 2158]
Solved by: Identity (id):  P->P is tautology

Theorem (598)                               [serial 2160] 
P [38] << ( SUPPL_O2_ALARM() )
  and SpO2DerivedLowerLimitAlarm^0  >>
S [38] ->
Q [31] << true >>
Why created:  applied port output <<pre and M[SpO2DerivedLowerLimitAlarm]^0>> -> <<post>> [serial 2158]
Solved by: Anything Implies True (a1tru): P->true

Theorem (599)                               [serial 2158] 
P [38] << SUPPL_O2_ALARM() >>
S [38] SpO2DerivedLowerLimitAlarm!
Q [31] << true >>
Why created:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 2156]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 597 598:
Theorem (597) [serial 2159] used for:
  applied port output <<pre>> -> <<M[SpO2DerivedLowerLimitAlarm]>> [serial 2158] 
Theorem (598) [serial 2160] used for:
  applied port output <<pre and M[SpO2DerivedLowerLimitAlarm]^0>> -> <<post>> [serial 2158] 


Theorem (600)                               [serial 2156] 
P [37] << SPO2_AVERAGE()^0  < SPO2_LOWER_LIMIT^0  + SPO2_LOWER_LIMIT_ADJ^0 
  and SUPPL_OXY_ALARM_ENABLED^0  >>
S [38] << SUPPL_O2_ALARM() >>
SpO2DerivedLowerLimitAlarm!
Q [31] << true >>
Why created:    normalization of [serial 1040]
  Using: (l.caretintro) (bl.ancom) 
Solved by: null and theorems 596 599:
Theorem (596) [serial 2157] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 2156] 
Theorem (599) [serial 2158] used for:
  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 2156] 


Theorem (601)                               [serial 1040] 
P [37] << SUPPL_OXY_ALARM_ENABLED^0 
  and SPO2_AVERAGE()^0  < SPO2_LOWER_LIMIT^0  + SPO2_LOWER_LIMIT_ADJ^0  >>
S [38] << SUPPL_O2_ALARM() >>
SpO2DerivedLowerLimitAlarm!
Q [31] << ( true )^1  >>
Why created:   <<M(check) and x>> A <<M(run)>> for so2: check-[x]->run{A};
Solved by: null Conjunction Commutes. (bl.ancom) and theorem 600:
Theorem (600) [serial 2156] used for:
    normalization of [serial 1040] 


Theorem (602)                               [serial 2165] 
P [39] << SPO2_LOWER_LIMIT^0  + SPO2_LOWER_LIMIT_ADJ^0  <= SPO2_AVERAGE()^0  or 
not SUPPL_OXY_ALARM_ENABLED^0  >>
S [39] ->
Q [31] << true >>
Why created:    normalization of [serial 1041]
  Using: (l.caretintro) changeAtLeastToAtMost (bl.orcom) 
Solved by: Anything Implies True (a1tru): P->true

Theorem (603)                               [serial 1041] 
P [39] << not SUPPL_OXY_ALARM_ENABLED^0  or SPO2_AVERAGE()^0  >= SPO2_LOWER_LIMIT^0  + 
SPO2_LOWER_LIMIT_ADJ^0  >>
S [39] ->
Q [31] << ( true )^1  >>
Why created:   <<M(check) and x>> -> <<M(run)>> for so3: check-[x]->run{};
Solved by: null [change A>=B to B<=A] Disjunction Commutes. (bl.orcom) and theorem 602:
Theorem (602) [serial 2165] used for:
    normalization of [serial 1041] 


Theorem (604)                               [serial 1034] 
P [28] <<   >>
S [28] ->
Q [28] << SupplemetalOxygenThread.imp proof obligations >>
Why created:  Initial proof obligations for SupplemetalOxygenThread.imp
Solved by:  Component verification conditions
 [Convert asseertion to port value.] and theorems 584 585 590 592 593 601 603:
Theorem (584) [serial 1035] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (585) [serial 1036] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (590) [serial 1037] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state check, <<M(check)>> -> <<e1 or e2 or . . . en>> 
Theorem (592) [serial 1038] used for:
   <<M(start)>> -> <<M(run)>> for so0: start-[ ]->run{}; 
Theorem (593) [serial 1039] used for:
   <<M(run) and x>> -> <<M(check)>> for so1: run-[x]->check{}; 
Theorem (601) [serial 1040] used for:
   <<M(check) and x>> A <<M(run)>> for so2: check-[x]->run{A}; 
Theorem (603) [serial 1041] used for:
   <<M(check) and x>> -> <<M(run)>> for so3: check-[x]->run{}; 


Theorem (605)                               [serial 2168] 
P [77] << ( GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() )
  and ub - lb < window_size >>
S [51] ->
Q [51] << GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() >>
Why created:    normalization of [serial 2166]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (606)                               [serial 2166] 
P [77] << ( ( ub - lb ) < window_size )
  and ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() ) >>
S [51] ->
Q [51] << WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1043]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 605:
Theorem (605) [serial 2168] used for:
    normalization of [serial 2166] 


Theorem (607)                               [serial 1043] 
P [77] << ( ( ub - lb ) < window_size )
  and INV_AV() >>
S [51] ->
Q [51] << WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() >>
Why created:  <<M(fillingWindow)>> -> <<I>> from invariant I when complete state fillingWindow has Assertion <<M(fillingWindow)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 606:
Theorem (606) [serial 2166] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1043] 


Theorem (608)                               [serial 2171] 
P [88] << ( GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() )
  and ub - lb = window_size >>
S [51] ->
Q [51] << GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() >>
Why created:    normalization of [serial 2169]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (609)                               [serial 2169] 
P [88] << ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() )
  and ( ( ub - lb ) = window_size ) >>
S [51] ->
Q [51] << WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1044]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 608:
Theorem (608) [serial 2171] used for:
    normalization of [serial 2169] 


Theorem (610)                               [serial 1044] 
P [88] << INV_AV()
  and ( ( ub - lb ) = window_size ) >>
S [51] ->
Q [51] << WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 609:
Theorem (609) [serial 2169] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1044] 


Theorem (611)                               [serial 2173] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are SSQ(( 1  + k ) - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(( 1  + k ) - ub)  ) = totalSpO2 >>
S [79] ->
Q [79] << ub - lb < window_size or window_size < ub - lb or ub - lb = window_size >>
Why created:    normalization of [serial 1045]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) changeGreaterThanToLessThan (bl.orcom) 
Solved by: Trichotomy law for 'less than'. (lttri4)

Theorem (612)                               [serial 1045] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ( ub - 1  ))  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ( ub - 1  ))  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) >>
S [79] ->
Q [79] << ( ( ub - lb ) < window_size ) or ( ( ub - lb ) = window_size ) or ( ( ub - lb ) > window_size ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state chooseToRun, <<M(chooseToRun)>> -> <<e1 or e2 or . . . en>>
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) [change A>B to B<A] Disjunction Commutes. (bl.orcom) and theorem 611:
Theorem (611) [serial 2173] used for:
    normalization of [serial 1045] 


Theorem (613)                               [serial 2177] 
P [74] << 0  = goodCount
  and 0  = lb
  and 0  = numSamplesInWindow
  and 0  = oldestSample
  and 0  = ub
  and 0.0 percent = totalSpO2 >>
S [74] ->
Q [74] << ub - lb < window_size or ( not ( ub - lb < window_size ) ) >>
Why created:  Replacing <= with not < of [serial 2176]
Solved by: Law of Excluded middle. (exmid)

Theorem (614)                               [serial 2176] 
P [74] << 0  = goodCount
  and 0  = lb
  and 0  = numSamplesInWindow
  and 0  = oldestSample
  and 0  = ub
  and 0.0 percent = totalSpO2 >>
S [74] ->
Q [74] << ub - lb < window_size or window_size <= ub - lb >>
Why created:    normalization of [serial 1046]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) 
Solved by: 'Less than' expressed in terms of 'less than or equal to'. (ltnle) and theorem 613:
Theorem (613) [serial 2177] used for:
  Replacing <= with not < of [serial 2176] 


Theorem (615)                               [serial 1046] 
P [74] << ( numSamplesInWindow = 0  )
  and ( ub = 0  )
  and ( oldestSample = 0  )
  and ( totalSpO2 = 0.0 percent )
  and ( lb = 0  )
  and ( goodCount = 0  ) >>
S [74] ->
Q [74] << ( ( ub - lb ) < window_size ) or ( ( ub - lb ) >= window_size ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 614:
Theorem (614) [serial 2176] used for:
    normalization of [serial 1046] 


Theorem (616)                               [serial 2187] 
P [74] << ub - lb < window_size
  and 0  = goodCount
  and 0  = lb
  and 0  = numSamplesInWindow
  and 0  = oldestSample
  and 0  = ub
  and 0.0 percent = totalSpO2 >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( ( ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2 )
  and ub - lb < window_size )^1  >>
Why created:    normalization of [serial 2185]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (617)                               [serial 2185] 
P [74] << ub - lb < window_size
  and 0  = goodCount
  and 0  = lb
  and 0  = numSamplesInWindow
  and 0  = oldestSample
  and 0  = ub
  and 0.0 percent = totalSpO2 >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( ( ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) ) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) )  ) = totalSpO2 )
  and ub - lb < window_size )^1  >>
Why created:  Substituted assertions' predicates for labels  [serial 2184]
Solved by: [Add unnecessary parentheses] and theorem 616:
Theorem (616) [serial 2187] used for:
    normalization of [serial 2185] 


Theorem (618)                               [serial 2184] 
P [74] << ub - lb < window_size
  and 0  = goodCount
  and 0  = lb
  and 0  = numSamplesInWindow
  and 0  = oldestSample
  and 0  = ub
  and 0.0 percent = totalSpO2 >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( ( ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ub)  ) = totalSpO2 )
  and ub - lb < window_size )^1  >>
Why created:    normalization of [serial 2182]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 617:
Theorem (617) [serial 2185] used for:
  Substituted assertions' predicates for labels  [serial 2184] 


Theorem (619)                               [serial 2182] 
P [74] << ub - lb < window_size
  and 0  = goodCount
  and 0  = lb
  and 0  = numSamplesInWindow
  and 0  = oldestSample
  and 0  = ub
  and 0.0 percent = totalSpO2 >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( ( ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ub)  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub) )  ) )
  and ub - lb < window_size )^1  >>
Why created:  Substituted assertions' predicates for labels  [serial 2181]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 618:
Theorem (618) [serial 2184] used for:
    normalization of [serial 2182] 


Theorem (620)                               [serial 2181] 
P [74] << ub - lb < window_size
  and 0  = goodCount
  and 0  = lb
  and 0  = numSamplesInWindow
  and 0  = oldestSample
  and 0  = ub
  and 0.0 percent = totalSpO2 >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( ( GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() )
  and ub - lb < window_size )^1  >>
Why created:    normalization of [serial 2179]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 619:
Theorem (619) [serial 2182] used for:
  Substituted assertions' predicates for labels  [serial 2181] 


Theorem (621)                               [serial 2179] 
P [74] << ( numSamplesInWindow = 0  )
  and ( ub = 0  )
  and ( oldestSample = 0  )
  and ( totalSpO2 = 0.0 percent )
  and ( lb = 0  )
  and ( goodCount = 0  )
  and ( ( ub - lb ) < window_size ) >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( ( ( ub - lb ) < window_size )
  and ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() ) )^1  >>
Why created:  Substituted assertions' predicates for labels  [serial 1047]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 620:
Theorem (620) [serial 2181] used for:
    normalization of [serial 2179] 


Theorem (622)                               [serial 1047] 
P [74] << ( numSamplesInWindow = 0  )
  and ( ub = 0  )
  and ( oldestSample = 0  )
  and ( totalSpO2 = 0.0 percent )
  and ( lb = 0  )
  and ( goodCount = 0  )
  and ( ( ub - lb ) < window_size ) >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( ( ( ub - lb ) < window_size )
  and INV_AV() )^1  >>
Why created:   <<M(start) and x>> A <<M(fillingWindow)>> for SpAT0: start-[x]->fillingWindow{A};
Solved by: Predicate Invocation. (PI) and theorem 621:
Theorem (621) [serial 2179] used for:
  Substituted assertions' predicates for labels  [serial 1047] 


Theorem (623)                               [serial 2292] 
P [74] << ( numSamplesInWindow = 0  )
  and ( ub = 0  )
  and ( oldestSample = 0  )
  and ( totalSpO2 = 0.0 percent )
  and ( lb = 0  )
  and ( goodCount = 0  )
  and ( ( ub - lb ) >= window_size ) >>
S [95] ->
Q [90] << true >>
Why created:  applied wp for simultaneous assignment [serial 1048]
Solved by: Anything Implies True (a1tru): P->true

Theorem (624)                               [serial 1048] 
P [74] << ( numSamplesInWindow = 0  )
  and ( ub = 0  )
  and ( oldestSample = 0  )
  and ( totalSpO2 = 0.0 percent )
  and ( lb = 0  )
  and ( goodCount = 0  )
  and ( ( ub - lb ) >= window_size ) >>
S [95] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [90] << true >>
Why created:   <<M(start) and x>> A <<M(fail)>> for SpAT0a: start-[x]->fail{A};
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Simultaneous Assignment
 and theorem 623:
Theorem (623) [serial 2292] used for:
  applied wp for simultaneous assignment [serial 1048] 


Theorem (625)                               [serial 2340] 
P [77] << ( GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() )
  and ub - lb < window_size >>
S [77] ->
Q [77] << ub - lb < window_size >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 2339]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (626)                               [serial 2344] 
P [77] << ( GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() )
  and ub - lb < window_size >>
S [77] ->
Q [77] << GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() >>
Why created:    normalization of [serial 2342]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (627)                               [serial 2342] 
P [77] << ( GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() )
  and ub - lb < window_size >>
S [77] ->
Q [77] << ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2341]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 626:
Theorem (626) [serial 2344] used for:
    normalization of [serial 2342] 


Theorem (628)                               [serial 2341] 
P [77] << ( GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() )
  and ub - lb < window_size >>
S [77] ->
Q [77] << INV_AV() >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 2339]
Solved by: Predicate Invocation. (PI) and theorem 627:
Theorem (627) [serial 2342] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2341] 


Theorem (629)                               [serial 2339] 
P [77] << ( GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() )
  and ub - lb < window_size >>
S [77] ->
Q [97] << ub - lb < window_size
  and INV_AV() >>
Why created:    normalization of [serial 2337]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 625 628:
Theorem (625) [serial 2340] used for:
  Join consequents with conjunction. (3jca)
   [serial 2339] 
Theorem (628) [serial 2341] used for:
  Join consequents with conjunction. (3jca)
   [serial 2339] 


Theorem (630)                               [serial 2337] 
P [77] << ub - lb < window_size
  and ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() ) >>
S [77] ->
Q [97] << ( ( ( ub - lb ) < window_size )
  and INV_AV() ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2310]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 629:
Theorem (629) [serial 2339] used for:
    normalization of [serial 2337] 


Theorem (631)                               [serial 2310] 
P [77] << ub - lb < window_size
  and INV_AV() >>
S [77] ->
Q [97] << FW() >>
Why created:    normalization of [serial 2293]
Solved by: Predicate Invocation. (PI) and theorem 630:
Theorem (630) [serial 2337] used for:
  Substituted assertions' predicates for labels  [serial 2310] 


Theorem (632)                               [serial 2293] 
P [77] << ( ( ub - lb ) < window_size )
  and INV_AV() >>
S [77] ->
Q [97] << FW() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1049]
Solved by: [Add unnecessary parentheses] and theorem 631:
Theorem (631) [serial 2310] used for:
    normalization of [serial 2293] 


Theorem (633)                               [serial 2312] 
P [129] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are SSQ(( 1  + k ) - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(( 1  + k ) - ub)  ) = totalSpO2 >>
S [79] ->
Q [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are SSQ(( 1  + k ) - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(( 1  + k ) - ub)  ) = totalSpO2 >>
Why created:    normalization of [serial 2294]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (634)                               [serial 2294] 
P [129] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ( ub - 1  ))  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ( ub - 1  ))  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) >>
S [79] ->
Q [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ( ub - 1  ))  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ( ub - 1  ))  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) >>
Why created:  <<Q2>> -> <<Q>> in sequential composition for [serial 1049]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 633:
Theorem (633) [serial 2312] used for:
    normalization of [serial 2294] 


Theorem (635)                               [serial 2298] 
P [97] << FW() >>
S [99] ->
Q [99] << FW() >>
Why created:  P -> P1 in concurrent composition for [serial 2297]
Solved by: Identity (id):  P->P is tautology

Theorem (636)                               [serial 2358] 
P [99] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED
  and not MOTION_ARTIFACT ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2 >>
S [103] ->
Q [118] << all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
Why created:  Addition Commutes. (bl.addcom)
  [Add unnecessary parentheses]
  Conjunction Commutes. (bl.ancom)
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2357]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (637)                               [serial 2357] 
P [99] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED
  and not MOTION_ARTIFACT ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2 >>
S [103] ->
Q [118] << all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
Why created:    normalization of [serial 2355]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))
 Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 636:
Theorem (636) [serial 2358] used for:
  Addition Commutes. (bl.addcom)
  [Add unnecessary parentheses]
  Conjunction Commutes. (bl.ancom)
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2357] 


Theorem (638)                               [serial 2355] 
P [99] << ( ( SENSOR_CONNECTED
  and not MOTION_ARTIFACT ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) )  ) + 
( (if SENSOR_CONNECTED^( 0  )
  and not MOTION_ARTIFACT^( 0  ) then SPO2^( 0  ) else 0.0 percent) ) = totalSpO2
  and ( (if SENSOR_CONNECTED^( 0  )
  and not MOTION_ARTIFACT^( 0  ) then SPO2^( 0  ) else 0.0 percent) ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) ) )  ) >>
S [103] ->
Q [118] << all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2354]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 637:
Theorem (637) [serial 2357] used for:
    normalization of [serial 2355] 


Theorem (639)                               [serial 2354] 
P [99] << ( ( SENSOR_CONNECTED
  and not MOTION_ARTIFACT ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) )  ) + 
( (if SENSOR_CONNECTED^( 0  )
  and not MOTION_ARTIFACT^( 0  ) then SPO2^( 0  ) else 0.0 percent) ) = totalSpO2
  and ( (if SENSOR_CONNECTED^( 0  )
  and not MOTION_ARTIFACT^( 0  ) then SPO2^( 0  ) else 0.0 percent) ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub) )  ) >>
S [103] ->
Q [118] << all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2353]
Solved by: Predicate Invocation. (PI) and theorem 638:
Theorem (638) [serial 2355] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2354] 


Theorem (640)                               [serial 2353] 
P [99] << ( ( SENSOR_CONNECTED
  and not MOTION_ARTIFACT ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ub)  ) + SSQ(x : 0 ) = totalSpO2
  and SSQ(x : 0 ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and GS()
  and WINDOW() >>
S [103] ->
Q [118] << all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2352]
Solved by: Predicate Invocation. (PI) Caret Introduction: if a predicate is always true it's true when time shifted (bl.caretintro) 
   or if a value is constant its value when time shifted is the same (bl.caretintrov)  and theorem 639:
Theorem (639) [serial 2354] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2353] 


Theorem (641)                               [serial 2352] 
P [99] << ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ub)  ) + SSQ(x : 0 ) = totalSpO2
  and SSQ(x : 0 ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and GS()
  and WINDOW() >>
S [103] ->
Q [118] << all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
Why created:    normalization of [serial 2350]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 640:
Theorem (640) [serial 2353] used for:
  Assume Present:  P = P@now = P^0   [serial 2352] 


Theorem (642)                               [serial 2350] 
P [99] << ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ub)  ) + SSQ(x : 0 ) = totalSpO2
  and SSQ(x : 0 ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and GS()
  and WINDOW() >>
S [103] ->
Q [118] << ( all k ~ quantity whole 
  in lb .. ub 
  are ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) ) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2346]
Solved by: [Add unnecessary parentheses] and theorem 641:
Theorem (641) [serial 2352] used for:
    normalization of [serial 2350] 


Theorem (643)                               [serial 2346] 
P [99] << ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ub)  ) + SSQ(x : 0 ) = totalSpO2
  and SSQ(x : 0 ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and GS()
  and WINDOW() >>
S [103] ->
Q [118] << ( all k ~ quantity whole 
  in lb .. ub 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 2315]
Solved by: Predicate Invocation. (PI) and theorem 642:
Theorem (642) [serial 2350] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2346] 


Theorem (644)                               [serial 2365] 
P [99] << ( all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2 >>
S [103] ->
Q [123] << all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
Why created:  [Add unnecessary parentheses]
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2364]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (645)                               [serial 2364] 
P [99] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2 >>
S [103] ->
Q [123] << all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
Why created:    normalization of [serial 2362]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))
 [Add unnecessary parentheses] and theorem 644:
Theorem (644) [serial 2365] used for:
  [Add unnecessary parentheses]
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2364] 


Theorem (646)                               [serial 2362] 
P [99] << ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) )  ) + 
( (if SENSOR_CONNECTED^( 0  )
  and not MOTION_ARTIFACT^( 0  ) then SPO2^( 0  ) else 0.0 percent) ) = totalSpO2
  and ( (if SENSOR_CONNECTED^( 0  )
  and not MOTION_ARTIFACT^( 0  ) then SPO2^( 0  ) else 0.0 percent) ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) ) )  ) >>
S [103] ->
Q [123] << all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2361]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 645:
Theorem (645) [serial 2364] used for:
    normalization of [serial 2362] 


Theorem (647)                               [serial 2361] 
P [99] << ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) )  ) + 
( (if SENSOR_CONNECTED^( 0  )
  and not MOTION_ARTIFACT^( 0  ) then SPO2^( 0  ) else 0.0 percent) ) = totalSpO2
  and ( (if SENSOR_CONNECTED^( 0  )
  and not MOTION_ARTIFACT^( 0  ) then SPO2^( 0  ) else 0.0 percent) ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub) )  ) >>
S [103] ->
Q [123] << all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2360]
Solved by: Predicate Invocation. (PI) and theorem 646:
Theorem (646) [serial 2362] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2361] 


Theorem (648)                               [serial 2360] 
P [99] << ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ub)  ) + SSQ(x : 0 ) = totalSpO2
  and SSQ(x : 0 ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and GS()
  and WINDOW() >>
S [103] ->
Q [123] << all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
Why created:    normalization of [serial 2347]
Solved by: Predicate Invocation. (PI) and theorem 647:
Theorem (647) [serial 2361] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2360] 


Theorem (649)                               [serial 2347] 
P [99] << ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ub)  ) + SSQ(x : 0 ) = totalSpO2
  and SSQ(x : 0 ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and GS()
  and WINDOW() >>
S [103] ->
Q [123] << ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 2315]
Solved by: [Add unnecessary parentheses] and theorem 648:
Theorem (648) [serial 2360] used for:
    normalization of [serial 2347] 


Theorem (650)                               [serial 2372] 
P [99] << ( all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 ) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 )  ) = totalSpO2 >>
S [103] ->
Q [121] << ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  [Add unnecessary parentheses]
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 2371]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (651)                               [serial 2371] 
P [99] << ( all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 ) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 ) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 )  ) = totalSpO2 >>
S [103] ->
Q [121] << ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  [Remove Units]
   [serial 2370]
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
 [Add unnecessary parentheses] and theorem 650:
Theorem (650) [serial 2372] used for:
  [Add unnecessary parentheses]
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 2371] 


Theorem (652)                               [serial 2370] 
P [99] << ( all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2 >>
S [103] ->
Q [121] << ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  [Add unnecessary parentheses]
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2369]
Solved by: [Remove Units] and theorem 651:
Theorem (651) [serial 2371] used for:
  [Remove Units]
   [serial 2370] 


Theorem (653)                               [serial 2369] 
P [99] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2 >>
S [103] ->
Q [121] << ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:    normalization of [serial 2367]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))
 [Add unnecessary parentheses] and theorem 652:
Theorem (652) [serial 2370] used for:
  [Add unnecessary parentheses]
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2369] 


Theorem (654)                               [serial 2367] 
P [99] << ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) )  ) + 
( (if SENSOR_CONNECTED^( 0  )
  and not MOTION_ARTIFACT^( 0  ) then SPO2^( 0  ) else 0.0 percent) ) = totalSpO2
  and ( (if SENSOR_CONNECTED^( 0  )
  and not MOTION_ARTIFACT^( 0  ) then SPO2^( 0  ) else 0.0 percent) ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) ) )  ) >>
S [103] ->
Q [121] << ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2366]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 653:
Theorem (653) [serial 2369] used for:
    normalization of [serial 2367] 


Theorem (655)                               [serial 2366] 
P [99] << ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) )  ) + 
( (if SENSOR_CONNECTED^( 0  )
  and not MOTION_ARTIFACT^( 0  ) then SPO2^( 0  ) else 0.0 percent) ) = totalSpO2
  and ( (if SENSOR_CONNECTED^( 0  )
  and not MOTION_ARTIFACT^( 0  ) then SPO2^( 0  ) else 0.0 percent) ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub) )  ) >>
S [103] ->
Q [121] << ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2348]
Solved by: Predicate Invocation. (PI) and theorem 654:
Theorem (654) [serial 2367] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2366] 


Theorem (656)                               [serial 2348] 
P [99] << ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ub)  ) + SSQ(x : 0 ) = totalSpO2
  and SSQ(x : 0 ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and GS()
  and WINDOW() >>
S [103] ->
Q [121] << ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 2315]
Solved by: Predicate Invocation. (PI) and theorem 655:
Theorem (655) [serial 2366] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2348] 


Theorem (657)                               [serial 2379] 
P [99] << ( all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2 >>
S [103] ->
Q [120] << ( sum k ~ quantity whole 
  in lb .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2 >>
Why created:  [Add unnecessary parentheses]
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 2378]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (658)                               [serial 2378] 
P [99] << ( all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2 >>
S [103] ->
Q [120] << ( sum k ~ quantity whole 
  in lb .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2 >>
Why created:  [Add unnecessary parentheses]
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2377]
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
 [Add unnecessary parentheses] and theorem 657:
Theorem (657) [serial 2379] used for:
  [Add unnecessary parentheses]
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 2378] 


Theorem (659)                               [serial 2377] 
P [99] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2 >>
S [103] ->
Q [120] << ( sum k ~ quantity whole 
  in lb .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2 >>
Why created:    normalization of [serial 2375]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))
 [Add unnecessary parentheses] and theorem 658:
Theorem (658) [serial 2378] used for:
  [Add unnecessary parentheses]
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2377] 


Theorem (660)                               [serial 2375] 
P [99] << ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) )  ) + 
( (if SENSOR_CONNECTED^( 0  )
  and not MOTION_ARTIFACT^( 0  ) then SPO2^( 0  ) else 0.0 percent) ) = totalSpO2
  and ( (if SENSOR_CONNECTED^( 0  )
  and not MOTION_ARTIFACT^( 0  ) then SPO2^( 0  ) else 0.0 percent) ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) ) )  ) >>
S [103] ->
Q [120] << ( sum k ~ quantity whole 
  in lb .. ub 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) )  ) = totalSpO2 >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2374]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 659:
Theorem (659) [serial 2377] used for:
    normalization of [serial 2375] 


Theorem (661)                               [serial 2374] 
P [99] << ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) )  ) + 
( (if SENSOR_CONNECTED^( 0  )
  and not MOTION_ARTIFACT^( 0  ) then SPO2^( 0  ) else 0.0 percent) ) = totalSpO2
  and ( (if SENSOR_CONNECTED^( 0  )
  and not MOTION_ARTIFACT^( 0  ) then SPO2^( 0  ) else 0.0 percent) ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub) )  ) >>
S [103] ->
Q [120] << ( sum k ~ quantity whole 
  in lb .. ub 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) )  ) = totalSpO2 >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2373]
Solved by: Predicate Invocation. (PI) and theorem 660:
Theorem (660) [serial 2375] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2374] 


Theorem (662)                               [serial 2373] 
P [99] << ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ub)  ) + SSQ(x : 0 ) = totalSpO2
  and SSQ(x : 0 ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and GS()
  and WINDOW() >>
S [103] ->
Q [120] << ( sum k ~ quantity whole 
  in lb .. ub 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) )  ) = totalSpO2 >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2349]
Solved by: Predicate Invocation. (PI) and theorem 661:
Theorem (661) [serial 2374] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2373] 


Theorem (663)                               [serial 2349] 
P [99] << ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ub)  ) + SSQ(x : 0 ) = totalSpO2
  and SSQ(x : 0 ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and GS()
  and WINDOW() >>
S [103] ->
Q [120] << ( sum k ~ quantity whole 
  in lb .. ub 
  of SSQ(k - ub)  ) = totalSpO2 >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 2315]
Solved by: Predicate Invocation. (PI) and theorem 662:
Theorem (662) [serial 2373] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2349] 


Theorem (664)                               [serial 2315] 
P [99] << ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ub)  ) + SSQ(x : 0 ) = totalSpO2
  and SSQ(x : 0 ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and GS()
  and WINDOW() >>
S [103] ->
Q [118] << ( all k ~ quantity whole 
  in lb .. ub 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ub 
  of SSQ(k - ub)  ) = totalSpO2 >>
Why created:    normalization of [serial 2299]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 643 649 656 663:
Theorem (643) [serial 2346] used for:
  Join consequents with conjunction. (3jca)
   [serial 2315] 
Theorem (649) [serial 2347] used for:
  Join consequents with conjunction. (3jca)
   [serial 2315] 
Theorem (656) [serial 2348] used for:
  Join consequents with conjunction. (3jca)
   [serial 2315] 
Theorem (663) [serial 2349] used for:
  Join consequents with conjunction. (3jca)
   [serial 2315] 


Theorem (665)                               [serial 2299] 
P [99] << WINDOW()
  and ( ( spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(x : 0 ) ) )
  and ( totalSpO2 = ( SSQ(x : 0 ) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ub)  ) ) )
  and ( goodCount = ( (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) )
  and ( ( goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) ) )
  and GS() >>
S [103] ->
Q [118] << ( all k ~ quantity whole 
  in lb .. ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub)  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ub 
  of SSQ(k - ub)  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
Why created:  Q1 and Q2 and  . . . and Qn -> Q in concurrent composition for [serial 2297]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 664:
Theorem (664) [serial 2315] used for:
    normalization of [serial 2299] 


Theorem (666)                               [serial 2384] 
P [99] << ( ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ub)  ) = totalSpO2 )
  and ub - lb < window_size >>
S [101] ->
Q [103] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and (if SensorConnected
  and not MotionArtifact then SpO2 else 0.0 percent) = (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) >>
Why created:    normalization of [serial 2382]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (667)                               [serial 2382] 
P [99] << ( ( ( ub - lb ) < window_size )
  and ( ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ub)  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) ) ) >>
S [101] ->
Q [103] << (if SensorConnected
  and not MotionArtifact then SpO2 else 0.0 percent) = ( (if SENSOR_CONNECTED^( 0  )
  and not MOTION_ARTIFACT^( 0  ) then SPO2^( 0  ) else 0.0 percent) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub) )  ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2381]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 666:
Theorem (666) [serial 2384] used for:
    normalization of [serial 2382] 


Theorem (668)                               [serial 2381] 
P [99] << ( ( ( ub - lb ) < window_size )
  and ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() ) ) >>
S [101] ->
Q [103] << (if SensorConnected
  and not MotionArtifact then SpO2 else 0.0 percent) = ( (if SENSOR_CONNECTED^( 0  )
  and not MOTION_ARTIFACT^( 0  ) then SPO2^( 0  ) else 0.0 percent) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub) )  ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2380]
Solved by: Predicate Invocation. (PI) and theorem 667:
Theorem (667) [serial 2382] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2381] 


Theorem (669)                               [serial 2380] 
P [99] << ( ( ( ub - lb ) < window_size )
  and INV_AV() ) >>
S [101] ->
Q [103] << (if SensorConnected
  and not MotionArtifact then SpO2 else 0.0 percent) = ( (if SENSOR_CONNECTED^( 0  )
  and not MOTION_ARTIFACT^( 0  ) then SPO2^( 0  ) else 0.0 percent) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub) )  ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2317]
Solved by: Predicate Invocation. (PI) and theorem 668:
Theorem (668) [serial 2381] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2380] 


Theorem (670)                               [serial 2317] 
P [99] << FW() >>
S [101] ->
Q [103] << (if SensorConnected
  and not MotionArtifact then SpO2 else 0.0 percent) = SSQ(x : 0 )
  and WINDOW() >>
Why created:    normalization of [serial 2304]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 669:
Theorem (669) [serial 2380] used for:
  Substituted assertions' predicates for labels  [serial 2317] 


Theorem (671)                               [serial 2304] 
P [99] << FW() >>
S [101] ->
Q [103] << WINDOW()
  and ( ( (if SensorConnected
  and not MotionArtifact then SpO2 else 0.0 percent) ) = SSQ(x : 0 ) ) >>
Why created:  applied wp for assignment [serial 2300]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 670:
Theorem (670) [serial 2317] used for:
    normalization of [serial 2304] 


Theorem (672)                               [serial 2300] 
P [99] << FW() >>
S [101] spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ] := (if SensorConnected
  and not MotionArtifact then SpO2 else 0.0 percent)
Q [103] << WINDOW()
  and ( spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(x : 0 ) ) >>
Why created:  <<P1>> S1 <<Q1>> in concurrent composition for [serial 2297]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 671:
Theorem (671) [serial 2304] used for:
  applied wp for assignment [serial 2300] 


Theorem (673)                               [serial 2401] 
P [97] << FW() >>
S [105] ->
Q [106] << (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then SPO2 else 0.0 ) + totalSpO2 = (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then SPO2 else 0.0 ) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 )  ) >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2400]
Solved by: Cancellation law for addition. (addcan) Caret Introduction: if a predicate is always true it's true when time shifted (bl.caretintro) 
   or if a value is constant its value when time shifted is the same (bl.caretintrov) 

Theorem (674)                               [serial 2400] 
P [97] << FW() >>
S [105] ->
Q [106] << (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then SPO2 else 0.0 ) + totalSpO2 = (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 ) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 )  ) >>
Why created:  [Remove Units]
   [serial 2399]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 673:
Theorem (673) [serial 2401] used for:
  Assume Present:  P = P@now = P^0   [serial 2400] 


Theorem (675)                               [serial 2399] 
P [97] << FW() >>
S [105] ->
Q [106] << (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then SPO2 else 0.0 percent) + totalSpO2 = (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) >>
Why created:  Replacing port names with BLESS::Value properties  [serial 2398]
Solved by: [Remove Units] and theorem 674:
Theorem (674) [serial 2400] used for:
  [Remove Units]
   [serial 2399] 


Theorem (676)                               [serial 2398] 
P [97] << FW() >>
S [105] ->
Q [106] << (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then SpO2 else 0.0 percent) + totalSpO2 = (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) >>
Why created:  Replacing port names with BLESS::Assertion properties  [serial 2397]
Solved by:  Replacing port names with BLESS::Value properties
 and theorem 675:
Theorem (675) [serial 2399] used for:
  Replacing port names with BLESS::Value properties  [serial 2398] 


Theorem (677)                               [serial 2397] 
P [97] << FW() >>
S [105] ->
Q [106] << (if SensorConnected
  and not MotionArtifact then SpO2 else 0.0 percent) + totalSpO2 = (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) >>
Why created:    normalization of [serial 2395]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by:  Replacing port names with BLESS::Assertion properties
 and theorem 676:
Theorem (676) [serial 2398] used for:
  Replacing port names with BLESS::Assertion properties  [serial 2397] 


Theorem (678)                               [serial 2395] 
P [97] << FW() >>
S [105] ->
Q [106] << (if SensorConnected
  and not MotionArtifact then SpO2 else 0.0 percent) + totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) )  ) + 
( (if SENSOR_CONNECTED^( 0  )
  and not MOTION_ARTIFACT^( 0  ) then SPO2^( 0  ) else 0.0 percent) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2319]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 677:
Theorem (677) [serial 2397] used for:
    normalization of [serial 2395] 


Theorem (679)                               [serial 2319] 
P [97] << FW() >>
S [105] ->
Q [106] << (if SensorConnected
  and not MotionArtifact then SpO2 else 0.0 percent) + totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ub)  ) + SSQ(x : 0 ) >>
Why created:    normalization of [serial 2305]
  Using: (bl.addcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Predicate Invocation. (PI) and theorem 678:
Theorem (678) [serial 2395] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2319] 


Theorem (680)                               [serial 2305] 
P [97] << FW() >>
S [105] ->
Q [106] << ( totalSpO2 + (if SensorConnected
  and not MotionArtifact then SpO2 else 0.0 percent) ) = ( SSQ(x : 0 ) + 
( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ub)  ) ) >>
Why created:  applied wp for assignment [serial 2301]
Solved by: Addition Commutes. (bl.addcom) [Add unnecessary parentheses] and theorem 679:
Theorem (679) [serial 2319] used for:
    normalization of [serial 2305] 


Theorem (681)                               [serial 2301] 
P [97] << FW() >>
S [105] totalSpO2 := totalSpO2 + (if SensorConnected
  and not MotionArtifact then SpO2 else 0.0 percent)
Q [106] << totalSpO2 = ( SSQ(x : 0 ) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ub)  ) ) >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 2297]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 680:
Theorem (680) [serial 2305] used for:
  applied wp for assignment [serial 2301] 


Theorem (682)                               [serial 2416] 
P [97] << FW() >>
S [108] ->
Q [109] << (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then 1  else 0 ) + goodCount = (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2415]
Solved by: Cancellation law for addition. (addcan) Caret Introduction: if a predicate is always true it's true when time shifted (bl.caretintro) 
   or if a value is constant its value when time shifted is the same (bl.caretintrov) 

Theorem (683)                               [serial 2415] 
P [97] << FW() >>
S [108] ->
Q [109] << (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then 1  else 0 ) + goodCount = (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) >>
Why created:  Replacing port names with BLESS::Assertion properties  [serial 2321]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 682:
Theorem (682) [serial 2416] used for:
  Assume Present:  P = P@now = P^0   [serial 2415] 


Theorem (684)                               [serial 2321] 
P [97] << FW() >>
S [108] ->
Q [109] << (if SensorConnected
  and not MotionArtifact then 1  else 0 ) + goodCount = (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) >>
Why created:    normalization of [serial 2306]
  Using: (bl.addcom) ADD_UNNECESSARY_PARETHESES 
Solved by:  Replacing port names with BLESS::Assertion properties
 and theorem 683:
Theorem (683) [serial 2415] used for:
  Replacing port names with BLESS::Assertion properties  [serial 2321] 


Theorem (685)                               [serial 2306] 
P [97] << FW() >>
S [108] ->
Q [109] << ( ( goodCount + (if SensorConnected
  and not MotionArtifact then 1  else 0 ) ) ) = ( (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) >>
Why created:  applied wp for assignment [serial 2302]
Solved by: Addition Commutes. (bl.addcom) [Add unnecessary parentheses] and theorem 684:
Theorem (684) [serial 2321] used for:
    normalization of [serial 2306] 


Theorem (686)                               [serial 2302] 
P [97] << FW() >>
S [108] goodCount := ( goodCount + (if SensorConnected
  and not MotionArtifact then 1  else 0 ) )
Q [109] << goodCount = ( (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) >>
Why created:  <<P>> S3 <<Q3>> in concurrent composition for [serial 2297]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 685:
Theorem (685) [serial 2306] used for:
  applied wp for assignment [serial 2302] 


Theorem (687)                               [serial 2427] 
P [97] << FW() >>
S [113] ->
Q [115] << ( ( SENSOR_CONNECTED
  and not MOTION_ARTIFACT ) iff ( SENSOR_CONNECTED
  and not MOTION_ARTIFACT ) )
  and GS() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2426]
Solved by: Principle of identity for logical equivalence. (biid)  Caret Introduction: if a predicate is always true it's true when time shifted (bl.caretintro) 
   or if a value is constant its value when time shifted is the same (bl.caretintrov) 

Theorem (688)                               [serial 2426] 
P [97] << FW() >>
S [113] ->
Q [115] << ( ( SENSOR_CONNECTED
  and not MOTION_ARTIFACT ) iff ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) )
  and GS() >>
Why created:  Replacing port names with BLESS::Assertion properties  [serial 2323]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 687:
Theorem (687) [serial 2427] used for:
  Assume Present:  P = P@now = P^0   [serial 2426] 


Theorem (689)                               [serial 2323] 
P [97] << FW() >>
S [113] ->
Q [115] << ( ( SensorConnected
  and not MotionArtifact ) iff ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) )
  and GS() >>
Why created:    normalization of [serial 2307]
Solved by:  Replacing port names with BLESS::Assertion properties
 and theorem 688:
Theorem (688) [serial 2426] used for:
  Replacing port names with BLESS::Assertion properties  [serial 2323] 


Theorem (690)                               [serial 2307] 
P [97] << FW() >>
S [113] ->
Q [115] << ( ( ( SensorConnected
  and not MotionArtifact ) ) iff ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) )
  and GS() >>
Why created:  applied wp for assignment [serial 2303]
Solved by: [Add unnecessary parentheses] and theorem 689:
Theorem (689) [serial 2323] used for:
    normalization of [serial 2307] 


Theorem (691)                               [serial 2303] 
P [97] << FW() >>
S [113] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] := ( SensorConnected
  and not MotionArtifact )
Q [115] << ( goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) )
  and GS() >>
Why created:  <<P>> S4 <<Q4>> in concurrent composition for [serial 2297]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 690:
Theorem (690) [serial 2307] used for:
  applied wp for assignment [serial 2303] 


Theorem (692)                               [serial 2297] 
P [97] << FW() >>
S [99]   << FW() >>
  spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ] := (if SensorConnected
    and not MotionArtifact then SpO2 else 0.0 percent)
  << WINDOW()
    and ( spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(x : 0 ) ) >>
  &
  totalSpO2 := totalSpO2 + (if SensorConnected
    and not MotionArtifact then SpO2 else 0.0 percent)
  << totalSpO2 = ( SSQ(x : 0 ) + ( sum k ~ quantity whole 
    in lb .. ( ub - 1  ) 
    of SSQ(k - ub)  ) ) >>
  &
  goodCount := ( goodCount + (if SensorConnected
    and not MotionArtifact then 1  else 0 ) )
  << goodCount = ( (if SENSOR_CONNECTED^0 
    and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
    in lb .. ( ub - 1  ) 
    that ( SENSOR_CONNECTED^( k - ub )
           and not MOTION_ARTIFACT^( k - ub ) )  ) ) >>
  &
  goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] := ( SensorConnected
    and not MotionArtifact )
  << ( goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^0 
    and not MOTION_ARTIFACT^0  ) )
    and GS() >> 
Q [118] << ( all k ~ quantity whole 
  in lb .. ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub)  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ub 
  of SSQ(k - ub)  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 2295]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 635 665 672 681 686 691:
Theorem (635) [serial 2298] used for:
  P -> P1 in concurrent composition for [serial 2297] 
Theorem (665) [serial 2299] used for:
  Q1 and Q2 and  . . . and Qn -> Q in concurrent composition for [serial 2297] 
Theorem (672) [serial 2300] used for:
  <<P1>> S1 <<Q1>> in concurrent composition for [serial 2297] 
Theorem (681) [serial 2301] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 2297] 
Theorem (686) [serial 2302] used for:
  <<P>> S3 <<Q3>> in concurrent composition for [serial 2297] 
Theorem (691) [serial 2303] used for:
  <<P>> S4 <<Q4>> in concurrent composition for [serial 2297] 


Theorem (693)                               [serial 2295] 
P [97] << FW() >>
S [98]   {
    << FW() >>
    spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ] := (if SensorConnected
      and not MotionArtifact then SpO2 else 0.0 percent)
    << WINDOW()
      and ( spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(x : 0 ) ) >>
    &
    totalSpO2 := totalSpO2 + (if SensorConnected
      and not MotionArtifact then SpO2 else 0.0 percent)
    << totalSpO2 = ( SSQ(x : 0 ) + ( sum k ~ quantity whole 
      in lb .. ( ub - 1  ) 
      of SSQ(k - ub)  ) ) >>
    &
    goodCount := ( goodCount + (if SensorConnected
      and not MotionArtifact then 1  else 0 ) )
    << goodCount = ( (if SENSOR_CONNECTED^0 
      and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
      in lb .. ( ub - 1  ) 
      that ( SENSOR_CONNECTED^( k - ub )
             and not MOTION_ARTIFACT^( k - ub ) )  ) ) >>
    &
    goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] := ( SensorConnected
      and not MotionArtifact )
    << ( goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^0 
      and not MOTION_ARTIFACT^0  ) )
      and GS() >> 
  } 
Q [118] << ( all k ~ quantity whole 
  in lb .. ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub)  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ub 
  of SSQ(k - ub)  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1049]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 692:
Theorem (692) [serial 2297] used for:
  <<P>> T <<Q>> in behavior action block for [serial 2295] 


Theorem (694)                               [serial 2325] 
P [118] << ( all k ~ quantity whole 
  in lb .. ub 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ub 
  of SSQ(k - ub)  ) = totalSpO2 >>
S [128] ->
Q [129] << ( all k ~ quantity whole 
  in lb .. ub 
  are SSQ(( 1  + k ) - ( 1  + ub )) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( ( 1  + k ) - ( 1  + ub ) )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ( 1  + ub ) ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( ( 1  + k ) - ( 1  + ub ) )
         and not MOTION_ARTIFACT^( ( 1  + k ) - ( 1  + ub ) ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ub 
  of SSQ(( 1  + k ) - ( 1  + ub ))  ) = totalSpO2 >>
Why created:    normalization of [serial 2308]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Cancellation law for addition. (addcan)

Theorem (695)                               [serial 2308] 
P [118] << ( all k ~ quantity whole 
  in lb .. ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub)  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ub 
  of SSQ(k - ub)  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
S [128] ->
Q [129] << ( all k ~ quantity whole 
  in lb .. ( ( ub + 1  ) - 1  ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ( ( 
      ub + 1  ) - 1  ))  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ( ub + 1  ) - 1  ) 
  of SSQ(k - ( ( ub + 1  ) - 1  ))  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ( ub + 1  ) - 1  ) 
  that ( SENSOR_CONNECTED^( k - ( ( ub + 1  ) - 1  ) )
         and not MOTION_ARTIFACT^( k - ( ( ub + 1  ) - 1  ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ( ub + 1  ) - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ( ( 
      ub + 1  ) - 1  ) )
        and not MOTION_ARTIFACT^( k - ( ( ub + 1  ) - 1  ) ) )  ) >>
Why created:  applied wp for assignment [serial 2296]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 694:
Theorem (694) [serial 2325] used for:
    normalization of [serial 2308] 


Theorem (696)                               [serial 2296] 
P [118] << ( all k ~ quantity whole 
  in lb .. ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub)  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ub 
  of SSQ(k - ub)  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
S [128] ub := ub + 1 
Q [129] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ( ub - 1  ))  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ( ub - 1  ))  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1049]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 695:
Theorem (695) [serial 2308] used for:
  applied wp for assignment [serial 2296] 


Theorem (697)                               [serial 1049] 
P [77] << ( ( ub - lb ) < window_size )
  and INV_AV() >>
S [97]   << FW() >>
    {
      << FW() >>
      spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ] := (if SensorConnected
        and not MotionArtifact then SpO2 else 0.0 percent)
      << WINDOW()
        and ( spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(x : 0 ) ) >>
      &
      totalSpO2 := totalSpO2 + (if SensorConnected
        and not MotionArtifact then SpO2 else 0.0 percent)
      << totalSpO2 = ( SSQ(x : 0 ) + ( sum k ~ quantity whole 
        in lb .. ( ub - 1  ) 
        of SSQ(k - ub)  ) ) >>
      &
      goodCount := ( goodCount + (if SensorConnected
        and not MotionArtifact then 1  else 0 ) )
      << goodCount = ( (if SENSOR_CONNECTED^0 
        and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
        in lb .. ( ub - 1  ) 
        that ( SENSOR_CONNECTED^( k - ub )
               and not MOTION_ARTIFACT^( k - ub ) )  ) ) >>
      &
      goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] := ( SensorConnected
        and not MotionArtifact )
      << ( goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^0 
        and not MOTION_ARTIFACT^0  ) )
        and GS() >> 
    } 
  << ( all k ~ quantity whole 
    in lb .. ub 
    are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub)  )
    and ( totalSpO2 = ( sum k ~ quantity whole 
    in lb .. ub 
    of SSQ(k - ub)  ) )
    and ( goodCount = ( numberof k ~ quantity whole 
    in lb .. ub 
    that ( SENSOR_CONNECTED^( k - ub )
           and not MOTION_ARTIFACT^( k - ub ) )  ) )
    and ( all k ~ quantity whole 
    in lb .. ub 
    are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
          and not MOTION_ARTIFACT^( k - ub ) )  ) >>
  ;
  ub := ub + 1 
  << ( all k ~ quantity whole 
    in lb .. ( ub - 1  ) 
    are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ( ub - 1  ))  )
    and ( totalSpO2 = ( sum k ~ quantity whole 
    in lb .. ( ub - 1  ) 
    of SSQ(k - ( ub - 1  ))  ) )
    and ( goodCount = ( numberof k ~ quantity whole 
    in lb .. ( ub - 1  ) 
    that ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
           and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) )
    and ( all k ~ quantity whole 
    in lb .. ( ub - 1  ) 
    are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
          and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) >> 
Q [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ( ub - 1  ))  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ( ub - 1  ))  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) >>
Why created:   <<M(fillingWindow) and x>> A <<M(chooseToRun)>> for SpAT1: fillingWindow-[x]->chooseToRun{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 632 634 693 696:
Theorem (632) [serial 2293] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1049] 
Theorem (634) [serial 2294] used for:
  <<Q2>> -> <<Q>> in sequential composition for [serial 1049] 
Theorem (693) [serial 2295] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1049] 
Theorem (696) [serial 2296] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1049] 


Theorem (698)                               [serial 2447] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) then SPO2^( ( 1  + k ) - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( ( 1  + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) then SPO2^( ( 1  + k ) - ub ) else 0.0 percent)  ) = totalSpO2 >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( ( ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2 )
  and ub - lb < window_size )^1  >>
Why created:    normalization of [serial 2445]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (699)                               [serial 2445] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) then SPO2^( ( 1  + k ) - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( ( 1  + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) then SPO2^( ( 1  + k ) - ub ) else 0.0 percent)  ) = totalSpO2 >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( ( ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) ) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) )  ) = totalSpO2 )
  and ub - lb < window_size )^1  >>
Why created:  Substituted assertions' predicates for labels  [serial 2444]
Solved by: [Add unnecessary parentheses] and theorem 698:
Theorem (698) [serial 2447] used for:
    normalization of [serial 2445] 


Theorem (700)                               [serial 2444] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) then SPO2^( ( 1  + k ) - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( ( 1  + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) then SPO2^( ( 1  + k ) - ub ) else 0.0 percent)  ) = totalSpO2 >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( ( ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ub)  ) = totalSpO2 )
  and ub - lb < window_size )^1  >>
Why created:    normalization of [serial 2442]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 699:
Theorem (699) [serial 2445] used for:
  Substituted assertions' predicates for labels  [serial 2444] 


Theorem (701)                               [serial 2442] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) then SPO2^( ( 1  + k ) - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( ( 1  + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) then SPO2^( ( 1  + k ) - ub ) else 0.0 percent)  ) = totalSpO2 >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( ( ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ub)  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub) )  ) )
  and ub - lb < window_size )^1  >>
Why created:  Substituted assertions' predicates for labels  [serial 2441]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 700:
Theorem (700) [serial 2444] used for:
    normalization of [serial 2442] 


Theorem (702)                               [serial 2441] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) then SPO2^( ( 1  + k ) - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( ( 1  + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) then SPO2^( ( 1  + k ) - ub ) else 0.0 percent)  ) = totalSpO2 >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( ( GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() )
  and ub - lb < window_size )^1  >>
Why created:    normalization of [serial 2439]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 701:
Theorem (701) [serial 2442] used for:
  Substituted assertions' predicates for labels  [serial 2441] 


Theorem (703)                               [serial 2439] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = ( (if SENSOR_CONNECTED^( ( k - ( ub - 1  ) ) )
        and not MOTION_ARTIFACT^( ( k - ( ub - 1  ) ) ) then SPO2^( ( k - ( ub - 1  ) ) ) else 0.0 percent) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of ( (if SENSOR_CONNECTED^( ( k - ( ub - 1  ) ) )
       and not MOTION_ARTIFACT^( ( k - ( ub - 1  ) ) ) then SPO2^( ( k - ( ub - 1  ) ) ) else 0.0 percent) )  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  )
  and ( ( ub - lb ) < window_size ) >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( ( ( ub - lb ) < window_size )
  and ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() ) )^1  >>
Why created:  Substituted assertions' predicates for labels  [serial 1050]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 702:
Theorem (702) [serial 2441] used for:
    normalization of [serial 2439] 


Theorem (704)                               [serial 1050] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ( ub - 1  ))  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ( ub - 1  ))  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  )
  and ( ( ub - lb ) < window_size ) >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( ( ( ub - lb ) < window_size )
  and INV_AV() )^1  >>
Why created:   <<M(chooseToRun) and x>> A <<M(fillingWindow)>> for SpAT2: chooseToRun-[x]->fillingWindow{A};
Solved by: Predicate Invocation. (PI) and theorem 703:
Theorem (703) [serial 2439] used for:
  Substituted assertions' predicates for labels  [serial 1050] 


Theorem (705)                               [serial 2480] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) then SPO2^( ( 1  + k ) - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( ( 1  + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) then SPO2^( ( 1  + k ) - ub ) else 0.0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( ( ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2 )
  and ub - lb = window_size )^1  >>
Why created:    normalization of [serial 2478]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (706)                               [serial 2478] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) then SPO2^( ( 1  + k ) - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( ( 1  + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) then SPO2^( ( 1  + k ) - ub ) else 0.0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( ( ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) ) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) )  ) = totalSpO2 )
  and ub - lb = window_size )^1  >>
Why created:  Substituted assertions' predicates for labels  [serial 2477]
Solved by: [Add unnecessary parentheses] and theorem 705:
Theorem (705) [serial 2480] used for:
    normalization of [serial 2478] 


Theorem (707)                               [serial 2477] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) then SPO2^( ( 1  + k ) - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( ( 1  + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) then SPO2^( ( 1  + k ) - ub ) else 0.0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( ( ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ub)  ) = totalSpO2 )
  and ub - lb = window_size )^1  >>
Why created:    normalization of [serial 2475]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 706:
Theorem (706) [serial 2478] used for:
  Substituted assertions' predicates for labels  [serial 2477] 


Theorem (708)                               [serial 2475] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) then SPO2^( ( 1  + k ) - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( ( 1  + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) then SPO2^( ( 1  + k ) - ub ) else 0.0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( ( ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ub)  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub) )  ) )
  and ub - lb = window_size )^1  >>
Why created:  Substituted assertions' predicates for labels  [serial 2474]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 707:
Theorem (707) [serial 2477] used for:
    normalization of [serial 2475] 


Theorem (709)                               [serial 2474] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) then SPO2^( ( 1  + k ) - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( ( 1  + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) then SPO2^( ( 1  + k ) - ub ) else 0.0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( ( GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() )
  and ub - lb = window_size )^1  >>
Why created:    normalization of [serial 2472]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 708:
Theorem (708) [serial 2475] used for:
  Substituted assertions' predicates for labels  [serial 2474] 


Theorem (710)                               [serial 2472] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = ( (if SENSOR_CONNECTED^( ( k - ( ub - 1  ) ) )
        and not MOTION_ARTIFACT^( ( k - ( ub - 1  ) ) ) then SPO2^( ( k - ( ub - 1  ) ) ) else 0.0 percent) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of ( (if SENSOR_CONNECTED^( ( k - ( ub - 1  ) ) )
       and not MOTION_ARTIFACT^( ( k - ( ub - 1  ) ) ) then SPO2^( ( k - ( ub - 1  ) ) ) else 0.0 percent) )  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  )
  and ( ( ub - lb ) = window_size ) >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() )
  and ( ( ub - lb ) = window_size ) )^1  >>
Why created:  Substituted assertions' predicates for labels  [serial 1051]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 709:
Theorem (709) [serial 2474] used for:
    normalization of [serial 2472] 


Theorem (711)                               [serial 1051] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ( ub - 1  ))  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ( ub - 1  ))  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  )
  and ( ( ub - lb ) = window_size ) >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( INV_AV()
  and ( ( ub - lb ) = window_size ) )^1  >>
Why created:   <<M(chooseToRun) and x>> A <<M(run)>> for SpAT3: chooseToRun-[x]->run{A};
Solved by: Predicate Invocation. (PI) and theorem 710:
Theorem (710) [serial 2472] used for:
  Substituted assertions' predicates for labels  [serial 1051] 


Theorem (712)                               [serial 2503] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ( ub - 1  ))  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ( ub - 1  ))  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  )
  and ( ( ub - lb ) > window_size ) >>
S [145] ->
Q [90] << true >>
Why created:  applied wp for simultaneous assignment [serial 1052]
Solved by: Anything Implies True (a1tru): P->true

Theorem (713)                               [serial 1052] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ( ub - 1  ))  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ( ub - 1  ))  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  )
  and ( ( ub - lb ) > window_size ) >>
S [145] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [90] << true >>
Why created:   <<M(chooseToRun) and x>> A <<M(fail)>> for SpAT3a: chooseToRun-[x]->fail{A};
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Simultaneous Assignment
 and theorem 712:
Theorem (712) [serial 2503] used for:
  applied wp for simultaneous assignment [serial 1052] 


Theorem (714)                               [serial 2619] 
P [88] << ( GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() )
  and ub - lb = window_size >>
S [88] ->
Q [148] << ub - lb = window_size
  and INV_AV() >>
Why created:    normalization of [serial 2601]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (715)                               [serial 2601] 
P [88] << ub - lb = window_size
  and ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() ) >>
S [88] ->
Q [148] << ( INV_AV()
  and ( ( ub - lb ) = window_size ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2532]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 714:
Theorem (714) [serial 2619] used for:
    normalization of [serial 2601] 


Theorem (716)                               [serial 2532] 
P [88] << ub - lb = window_size
  and INV_AV() >>
S [88] ->
Q [148] << RUN_AV() >>
Why created:    normalization of [serial 2504]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 715:
Theorem (715) [serial 2601] used for:
  Substituted assertions' predicates for labels  [serial 2532] 


Theorem (717)                               [serial 2504] 
P [88] << INV_AV()
  and ( ( ub - lb ) = window_size ) >>
S [88] ->
Q [148] << RUN_AV() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1053]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 716:
Theorem (716) [serial 2532] used for:
    normalization of [serial 2504] 


Theorem (718)                               [serial 2534] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]' = SSQ(( 
      1  + k ) - ub)  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]' iff ( SENSOR_CONNECTED^( ( 
      1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) )  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(( 1  + k ) - ub)  )
  and window_size' = ( 1  + ub' ) - ( 1  + lb' ) >>
S [88] ->
Q [16] << ( ub - lb = window_size
  and INV_AV() )^1  >>
Why created:    normalization of [serial 2505]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Cancellation law for addition. (addcan)

Theorem (719)                               [serial 2505] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]' = SSQ(k - ( ub - 1  ))  )
  and ( totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ( ub - 1  ))  ) )
  and ( ( ( ub' - 1  ) - ( lb' - 1  ) ) = window_size' )
  and ( goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]' iff ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) >>
S [88] ->
Q [16] << ( INV_AV()
  and ( ( ub - lb ) = window_size ) )^1  >>
Why created:  <<Q4>> -> <<Q>> in sequential composition for [serial 1053]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 718:
Theorem (718) [serial 2534] used for:
    normalization of [serial 2505] 


Theorem (720)                               [serial 2689] 
P [148] << ub - lb = window_size
  and INV_AV() >>
S [149] ->
Q [149] << 0  < goodCount or not ( 0  < goodCount ) >>
Why created:    normalization of [serial 2687]
  Using: ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (721)                               [serial 2687] 
P [148] << ub - lb = window_size
  and INV_AV() >>
S [149] ->
Q [149] << 0  < goodCount or ( not ( 0  < goodCount ) ) >>
Why created:  Replacing <= with not < of [serial 2621]
Solved by: [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 720:
Theorem (720) [serial 2689] used for:
    normalization of [serial 2687] 


Theorem (722)                               [serial 2621] 
P [148] << ub - lb = window_size
  and INV_AV() >>
S [149] ->
Q [149] << 0  < goodCount or goodCount <= 0  >>
Why created:    normalization of [serial 2602]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: 'Less than' expressed in terms of 'less than or equal to'. (ltnle) and theorem 721:
Theorem (721) [serial 2687] used for:
  Replacing <= with not < of [serial 2621] 


Theorem (723)                               [serial 2602] 
P [148] << ( INV_AV()
  and ( ( ub - lb ) = window_size ) ) >>
S [149] ->
Q [149] << 0  < goodCount or goodCount <= 0  >>
Why created:  Substituted assertions' predicates for labels  [serial 2536]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 722:
Theorem (722) [serial 2621] used for:
    normalization of [serial 2602] 


Theorem (724)                               [serial 2536] 
P [148] << RUN_AV() >>
S [149] ->
Q [149] << 0  < goodCount or goodCount <= 0  >>
Why created:    normalization of [serial 2510]
  Using: ADD_UNNECESSARY_PARETHESES changeGreaterThanToLessThan 
Solved by: Predicate Invocation. (PI) and theorem 723:
Theorem (723) [serial 2602] used for:
  Substituted assertions' predicates for labels  [serial 2536] 


Theorem (725)                               [serial 2510] 
P [148] << RUN_AV() >>
S [149] ->
Q [149] << ( goodCount > 0  ) or ( goodCount <= 0  ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 2506]
Solved by: [Add unnecessary parentheses] [change A>B to B<A] and theorem 724:
Theorem (724) [serial 2536] used for:
    normalization of [serial 2510] 


Theorem (726)                               [serial 2563] 
P [149] << 0  < goodCount
  and RUN_AV() >>
S [149] ->
Q [151] << 0  < goodCount
  and RUN_AV()
  and true >>
Why created:    normalization of [serial 2527]
  Using: ADD_UNNECESSARY_PARETHESES changeGreaterThanToLessThan (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (727)                               [serial 2527] 
P [149] << RUN_AV()
  and ( goodCount > 0  ) >>
S [149] ->
Q [151] << RUN_AV()
  and ( goodCount > 0  )
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: [Add unnecessary parentheses] [change A>B to B<A] Conjunction Commutes. (bl.ancom) and theorem 726:
Theorem (726) [serial 2563] used for:
    normalization of [serial 2527] 


Theorem (728)                               [serial 2563] 
P [149] << 0  < goodCount
  and RUN_AV() >>
S [149] ->
Q [151] << 0  < goodCount
  and RUN_AV()
  and true >>
Why created:    normalization of [serial 2527]
  Using: ADD_UNNECESSARY_PARETHESES changeGreaterThanToLessThan (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (729)                               [serial 2527] 
P [149] << RUN_AV()
  and ( goodCount > 0  ) >>
S [149] ->
Q [151] << RUN_AV()
  and ( goodCount > 0  )
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: [Add unnecessary parentheses] [change A>B to B<A] Conjunction Commutes. (bl.ancom) and theorem 728:
Theorem (728) [serial 2563] used for:
    normalization of [serial 2527] 


Theorem (730)                               [serial 2511] 
P [149] << RUN_AV()
  and ( goodCount > 0  ) >>
S [149] ->
Q [151] << RUN_AV()
  and ( goodCount > 0  )
  and AXIOM_K2I() >>
Why created:    <<P and B0>> -> <<P0>> in alternative for [serial 2506]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 729 729:
Theorem (729) [serial 2527] used for:
   add user-defined "givens" to postcondition 
Theorem (729) [serial 2527] used for:
   add user-defined "givens" to postcondition 


Theorem (731)                               [serial 2623] 
P [151] << ( ub - lb = window_size
  and INV_AV() )
  and 0  < goodCount
  and ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1  
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0.0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1  
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) >>
S [152] SpO2Avg!(totalSpO2 / goodCount)
Q [153] << ub - lb = window_size
  and INV_AV() >>
Why created:    normalization of [serial 2603]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (732)                               [serial 2603] 
P [151] << 0  < goodCount
  and ( ( ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) = ( ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1  
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0.0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1  
  that ( SENSOR_CONNECTED^( i )
         and not MOTION_ARTIFACT^( i ) )  ) ) )
  and ( INV_AV()
  and ( ( ub - lb ) = window_size ) ) >>
S [152] SpO2Avg!(totalSpO2 / goodCount)
Q [153] << ( INV_AV()
  and ( ( ub - lb ) = window_size ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2538]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 731:
Theorem (731) [serial 2623] used for:
    normalization of [serial 2603] 


Theorem (733)                               [serial 2538] 
P [151] << 0  < goodCount
  and AXIOM_K2I()
  and RUN_AV() >>
S [152] SpO2Avg!(totalSpO2 / goodCount)
Q [153] << RUN_AV() >>
Why created:    normalization of [serial 2512]
  Using: ADD_UNNECESSARY_PARETHESES changeGreaterThanToLessThan (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 732:
Theorem (732) [serial 2603] used for:
  Substituted assertions' predicates for labels  [serial 2538] 


Theorem (734)                               [serial 2512] 
P [151] << RUN_AV()
  and ( goodCount > 0  )
  and AXIOM_K2I() >>
S [152] SpO2Avg!(totalSpO2 / goodCount)
Q [153] << RUN_AV() >>
Why created:    <<P0>> S0 <<Q0>> in alternative for [serial 2506]
Solved by: [Add unnecessary parentheses] [change A>B to B<A] Conjunction Commutes. (bl.ancom) and theorem 733:
Theorem (733) [serial 2538] used for:
    normalization of [serial 2512] 


Theorem (735)                               [serial 2528] 
P [153] << RUN_AV() >>
S [149] ->
Q [158] << RUN_AV()
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (736)                               [serial 2528] 
P [153] << RUN_AV() >>
S [149] ->
Q [158] << RUN_AV()
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (737)                               [serial 2513] 
P [153] << RUN_AV() >>
S [149] ->
Q [158] << RUN_AV()
  and AXIOM_LB() >>
Why created:    <<Q0>> -> <<Q>> in alternative  for [serial 2506]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 736 736:
Theorem (736) [serial 2528] used for:
   add user-defined "givens" to postcondition 
Theorem (736) [serial 2528] used for:
   add user-defined "givens" to postcondition 


Theorem (738)                               [serial 2540] 
P [149] << goodCount <= 0 
  and RUN_AV() >>
S [149] ->
Q [155] << RUN_AV() >>
Why created:    normalization of [serial 2514]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (739)                               [serial 2514] 
P [149] << RUN_AV()
  and ( goodCount <= 0  ) >>
S [149] ->
Q [155] << RUN_AV() >>
Why created:    <<P and B1>> -> <<P1>> in alternative for [serial 2506]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 738:
Theorem (738) [serial 2540] used for:
    normalization of [serial 2514] 


Theorem (740)                               [serial 2686] 
P [155] << ub - lb = window_size
  and INV_AV() >>
S [155] ->
Q [155] << ub - lb = window_size
  and INV_AV() >>
Why created:    <<P>> -> <<Q>>
  for [serial 2617]
Solved by: Identity (id):  P->P is tautology

Theorem (741)                               [serial 2617] 
P [155] << ub - lb = window_size
  and INV_AV() >>
S [155] skip
Q [155] << ub - lb = window_size
  and INV_AV() >>
Why created:    normalization of [serial 2600]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by:  Skip Means Implication:  <<P>> skip <<Q>>  is  <<P>> -> <<Q>>
 and theorem 740:
Theorem (740) [serial 2686] used for:
    <<P>> -> <<Q>>
  for [serial 2617] 


Theorem (742)                               [serial 2600] 
P [155] << ( INV_AV()
  and ( ( ub - lb ) = window_size ) ) >>
S [155] skip
Q [155] << ( INV_AV()
  and ( ( ub - lb ) = window_size ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2515]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 741:
Theorem (741) [serial 2617] used for:
    normalization of [serial 2600] 


Theorem (743)                               [serial 2515] 
P [155] << RUN_AV() >>
S [155] skip
Q [155] << RUN_AV() >>
Why created:    <<P1>> S1 <<Q1>> in alternative for [serial 2506]
Solved by: Predicate Invocation. (PI) and theorem 742:
Theorem (742) [serial 2600] used for:
  Substituted assertions' predicates for labels  [serial 2515] 


Theorem (744)                               [serial 2529] 
P [155] << RUN_AV() >>
S [149] ->
Q [158] << RUN_AV()
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (745)                               [serial 2529] 
P [155] << RUN_AV() >>
S [149] ->
Q [158] << RUN_AV()
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (746)                               [serial 2516] 
P [155] << RUN_AV() >>
S [149] ->
Q [158] << RUN_AV()
  and AXIOM_LB() >>
Why created:    <<Q1>> -> <<Q>> in alternative  for [serial 2506]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 745 745:
Theorem (745) [serial 2529] used for:
   add user-defined "givens" to postcondition 
Theorem (745) [serial 2529] used for:
   add user-defined "givens" to postcondition 


Theorem (747)                               [serial 2506] 
P [148] << RUN_AV() >>
S [149]   if 
    (goodCount > 0 )~> 
      << RUN_AV()
        and ( goodCount > 0  )
        and AXIOM_K2I() >>
      SpO2Avg!(totalSpO2 / goodCount)
      << RUN_AV() >> 
  []
    (goodCount <= 0 )~> 
      << RUN_AV() >>
      skip
      << RUN_AV() >> 
  fi
Q [158] << RUN_AV()
  and AXIOM_LB() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1053]
Solved by: and theorems 725 730 734 737 739 743 746:
Theorem (725) [serial 2510] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 2506] 
Theorem (730) [serial 2511] used for:
    <<P and B0>> -> <<P0>> in alternative for [serial 2506] 
Theorem (734) [serial 2512] used for:
    <<P0>> S0 <<Q0>> in alternative for [serial 2506] 
Theorem (737) [serial 2513] used for:
    <<Q0>> -> <<Q>> in alternative  for [serial 2506] 
Theorem (739) [serial 2514] used for:
    <<P and B1>> -> <<P1>> in alternative for [serial 2506] 
Theorem (743) [serial 2515] used for:
    <<P1>> S1 <<Q1>> in alternative for [serial 2506] 
Theorem (746) [serial 2516] used for:
    <<Q1>> -> <<Q>> in alternative  for [serial 2506] 


Theorem (748)                               [serial 2625] 
P [158] << ( ub - lb = window_size
  and INV_AV() )
  and lb < 1  + lb >>
S [160] ->
Q [160] << all k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
Why created:    normalization of [serial 2604]
  Using: (bl.addcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (749)                               [serial 2604] 
P [158] << ( lb < ( lb + 1  ) )
  and ( INV_AV()
  and ( ( ub - lb ) = window_size ) ) >>
S [160] ->
Q [160] << all k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  are ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) ) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
Why created:  Substituted assertions' predicates for labels  [serial 2543]
Solved by: Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 748:
Theorem (748) [serial 2625] used for:
    normalization of [serial 2604] 


Theorem (750)                               [serial 2543] 
P [158] << AXIOM_LB()
  and RUN_AV() >>
S [160] ->
Q [160] << all k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
Why created:    normalization of [serial 2518]
  Using: (bl.addcom) (eqcom) (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 749:
Theorem (749) [serial 2604] used for:
  Substituted assertions' predicates for labels  [serial 2543] 


Theorem (751)                               [serial 2518] 
P [158] << RUN_AV()
  and AXIOM_LB() >>
S [160] ->
Q [160] << all k ~ quantity whole 
  in ( lb + 1  ) .. ( ub - 1  ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub)  >>
Why created:  P -> P1 in concurrent composition for [serial 2517]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 750:
Theorem (750) [serial 2543] used for:
    normalization of [serial 2518] 


Theorem (752)                               [serial 2627] 
P [158] << ( ub - lb = window_size
  and INV_AV() )
  and lb < 1  + lb >>
S [169] ->
Q [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0.0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0.0 percent) + 
( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
Why created:    normalization of [serial 2605]
  Using: (bl.addcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (753)                               [serial 2605] 
P [158] << ( lb < ( lb + 1  ) )
  and ( INV_AV()
  and ( ( ub - lb ) = window_size ) ) >>
S [169] ->
Q [169] << ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) )  ) + 
( (if SENSOR_CONNECTED^( ( lb - ub ) )
  and not MOTION_ARTIFACT^( ( lb - ub ) ) then SPO2^( ( lb - ub ) ) else 0.0 percent) ) = totalSpO2
  and ub - lb = window_size
  and ( (if SENSOR_CONNECTED^( ( lb - ub ) )
  and not MOTION_ARTIFACT^( ( lb - ub ) ) then SPO2^( ( lb - ub ) ) else 0.0 percent) ) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ] >>
Why created:  Substituted assertions' predicates for labels  [serial 2545]
Solved by: Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 752:
Theorem (752) [serial 2627] used for:
    normalization of [serial 2605] 


Theorem (754)                               [serial 2545] 
P [158] << AXIOM_LB()
  and RUN_AV() >>
S [169] ->
Q [169] << ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of SSQ(k - ub)  ) + SSQ(lb - ub) = totalSpO2
  and ub - lb = window_size
  and SSQ(lb - ub) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ] >>
Why created:    normalization of [serial 2519]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 753:
Theorem (753) [serial 2605] used for:
  Substituted assertions' predicates for labels  [serial 2545] 


Theorem (755)                               [serial 2519] 
P [158] << RUN_AV()
  and AXIOM_LB() >>
S [169] ->
Q [169] << ( totalSpO2 = ( SSQ(lb - ub) + ( sum k ~ quantity whole 
  in ( lb + 1  ) .. ( ub - 1  ) 
  of SSQ(k - ub)  ) ) )
  and ( spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(lb - ub) )
  and ( ( ub - lb ) = window_size ) >>
Why created:  P -> P2 in concurrent composition for [serial 2517]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 754:
Theorem (754) [serial 2545] used for:
    normalization of [serial 2519] 


Theorem (756)                               [serial 2629] 
P [158] << ( ub - lb = window_size
  and INV_AV() )
  and lb < 1  + lb >>
S [176] ->
Q [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) + ( numberof k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:    normalization of [serial 2606]
  Using: (bl.addcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (757)                               [serial 2606] 
P [158] << ( lb < ( lb + 1  ) )
  and ( INV_AV()
  and ( ( ub - lb ) = window_size ) ) >>
S [176] ->
Q [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) + ( numberof k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Substituted assertions' predicates for labels  [serial 2547]
Solved by: Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 756:
Theorem (756) [serial 2629] used for:
    normalization of [serial 2606] 


Theorem (758)                               [serial 2547] 
P [158] << AXIOM_LB()
  and RUN_AV() >>
S [176] ->
Q [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) + ( numberof k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:    normalization of [serial 2520]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 757:
Theorem (757) [serial 2606] used for:
  Substituted assertions' predicates for labels  [serial 2547] 


Theorem (759)                               [serial 2520] 
P [158] << RUN_AV()
  and AXIOM_LB() >>
S [176] ->
Q [176] << ( goodCount = ( (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) + ( numberof k ~ quantity whole 
  in ( lb + 1  ) .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) )
  and ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] ) >>
Why created:  P -> P3 in concurrent composition for [serial 2517]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 758:
Theorem (758) [serial 2547] used for:
    normalization of [serial 2520] 


Theorem (760)                               [serial 2631] 
P [158] << ( ub - lb = window_size
  and INV_AV() )
  and lb < 1  + lb >>
S [188] ->
Q [188] << all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
Why created:    normalization of [serial 2607]
  Using: (bl.addcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) (bicom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (761)                               [serial 2607] 
P [158] << ( lb < ( lb + 1  ) )
  and ( INV_AV()
  and ( ( ub - lb ) = window_size ) ) >>
S [188] ->
Q [188] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2549]
Solved by: Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) Biconditional (iff) Commutes. (bicom) and theorem 760:
Theorem (760) [serial 2631] used for:
    normalization of [serial 2607] 


Theorem (762)                               [serial 2549] 
P [158] << AXIOM_LB()
  and RUN_AV() >>
S [188] ->
Q [188] << GS() >>
Why created:    normalization of [serial 2521]
Solved by: Predicate Invocation. (PI) and theorem 761:
Theorem (761) [serial 2607] used for:
  Substituted assertions' predicates for labels  [serial 2549] 


Theorem (763)                               [serial 2521] 
P [158] << RUN_AV()
  and AXIOM_LB() >>
S [188] ->
Q [188] << GS() >>
Why created:  P -> P4 in concurrent composition for [serial 2517]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 762:
Theorem (762) [serial 2549] used for:
    normalization of [serial 2521] 


Theorem (764)                               [serial 2696] 
P [160] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and lb < 1  + lb
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) = goodCount
  and ub - lb = window_size >>
S [165] ->
Q [194] << all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
Why created:  [Add unnecessary parentheses]
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2691]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (765)                               [serial 2691] 
P [160] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and lb < 1  + lb
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ( (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) = goodCount
  and ub - lb = window_size >>
S [165] ->
Q [194] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 2633]
Solved by:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))
 [Add unnecessary parentheses] and theorem 764:
Theorem (764) [serial 2696] used for:
  [Add unnecessary parentheses]
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2691] 


Theorem (766)                               [serial 2705] 
P [160] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and lb < 1  + lb
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and ( numberof k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [165] ->
Q [198] << all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
Why created:  Contract universal quantification, upper bound.  (bl.cuqub)
   [serial 2703]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (767)                               [serial 2703] 
P [160] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and lb < 1  + lb
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and ( numberof k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [165] ->
Q [198] << all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
Why created:  [Add unnecessary parentheses]
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 2700]
Solved by: Contract universal quantification, upper bound.  (bl.cuqub) and theorem 766:
Theorem (766) [serial 2705] used for:
  Contract universal quantification, upper bound.  (bl.cuqub)
   [serial 2703] 


Theorem (768)                               [serial 2700] 
P [160] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and lb < 1  + lb
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and ( numberof k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [165] ->
Q [198] << all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
Why created:  [Add unnecessary parentheses]
  Conjunction Commutes. (bl.ancom)
  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))  [serial 2697]
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
 [Add unnecessary parentheses] and theorem 767:
Theorem (767) [serial 2703] used for:
  [Add unnecessary parentheses]
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 2700] 


Theorem (769)                               [serial 2697] 
P [160] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and lb < 1  + lb
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) = goodCount
  and ub - lb = window_size >>
S [165] ->
Q [198] << all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
Why created:  [Add unnecessary parentheses]
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2692]
Solved by:  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))
 [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 768:
Theorem (768) [serial 2700] used for:
  [Add unnecessary parentheses]
  Conjunction Commutes. (bl.ancom)
  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))  [serial 2697] 


Theorem (770)                               [serial 2692] 
P [160] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and lb < 1  + lb
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ( (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) = goodCount
  and ub - lb = window_size >>
S [165] ->
Q [198] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 2633]
Solved by:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))
 [Add unnecessary parentheses] and theorem 769:
Theorem (769) [serial 2697] used for:
  [Add unnecessary parentheses]
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2692] 


Theorem (771)                               [serial 2701] 
P [160] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and lb < 1  + lb
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and ( numberof k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [165] ->
Q [197] << ( numberof k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  [Add unnecessary parentheses]
  Conjunction Commutes. (bl.ancom)
  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))  [serial 2698]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (772)                               [serial 2698] 
P [160] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and lb < 1  + lb
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) = goodCount
  and ub - lb = window_size >>
S [165] ->
Q [197] << ( numberof k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  [Add unnecessary parentheses]
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2693]
Solved by:  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))
 [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 771:
Theorem (771) [serial 2701] used for:
  [Add unnecessary parentheses]
  Conjunction Commutes. (bl.ancom)
  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))  [serial 2698] 


Theorem (773)                               [serial 2693] 
P [160] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and lb < 1  + lb
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ( (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) = goodCount
  and ub - lb = window_size >>
S [165] ->
Q [197] << ( numberof k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 2633]
Solved by:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))
 [Add unnecessary parentheses] and theorem 772:
Theorem (772) [serial 2698] used for:
  [Add unnecessary parentheses]
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2693] 


Theorem (774)                               [serial 2704] 
P [160] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and lb < 1  + lb
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and ( numberof k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [165] ->
Q [196] << ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2 >>
Why created:  [Add unnecessary parentheses]
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 2702]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (775)                               [serial 2702] 
P [160] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and lb < 1  + lb
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and ( numberof k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [165] ->
Q [196] << ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2 >>
Why created:  [Add unnecessary parentheses]
  Conjunction Commutes. (bl.ancom)
  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))  [serial 2699]
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
 [Add unnecessary parentheses] and theorem 774:
Theorem (774) [serial 2704] used for:
  [Add unnecessary parentheses]
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 2702] 


Theorem (776)                               [serial 2699] 
P [160] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and lb < 1  + lb
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) = goodCount
  and ub - lb = window_size >>
S [165] ->
Q [196] << ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2 >>
Why created:  [Add unnecessary parentheses]
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2694]
Solved by:  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))
 [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 775:
Theorem (775) [serial 2702] used for:
  [Add unnecessary parentheses]
  Conjunction Commutes. (bl.ancom)
  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))  [serial 2699] 


Theorem (777)                               [serial 2694] 
P [160] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and lb < 1  + lb
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ( (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) = goodCount
  and ub - lb = window_size >>
S [165] ->
Q [196] << ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2 >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 2633]
Solved by:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))
 [Add unnecessary parentheses] and theorem 776:
Theorem (776) [serial 2699] used for:
  [Add unnecessary parentheses]
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2694] 


Theorem (778)                               [serial 2695] 
P [160] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and lb < 1  + lb
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ( (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) = goodCount
  and ub - lb = window_size >>
S [165] ->
Q [196] << ub - lb = window_size >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 2633]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (779)                               [serial 2633] 
P [160] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and lb < 1  + lb
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ( (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) = goodCount
  and ub - lb = window_size >>
S [165] ->
Q [194] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
Why created:    normalization of [serial 2608]
  Using: (bl.addcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 765 770 773 777 778:
Theorem (765) [serial 2691] used for:
  Join consequents with conjunction. (3jca)
   [serial 2633] 
Theorem (770) [serial 2692] used for:
  Join consequents with conjunction. (3jca)
   [serial 2633] 
Theorem (773) [serial 2693] used for:
  Join consequents with conjunction. (3jca)
   [serial 2633] 
Theorem (777) [serial 2694] used for:
  Join consequents with conjunction. (3jca)
   [serial 2633] 
Theorem (778) [serial 2695] used for:
  Join consequents with conjunction. (3jca)
   [serial 2633] 


Theorem (780)                               [serial 2608] 
P [160] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  are ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) ) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) )  ) + 
( (if SENSOR_CONNECTED^( 0  )
  and not MOTION_ARTIFACT^( 0  ) then SPO2^( 0  ) else 0.0 percent) ) = totalSpO2
  and ( (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) = goodCount
  and ub - lb = window_size
  and ( (if SENSOR_CONNECTED^( 0  )
  and not MOTION_ARTIFACT^( 0  ) then SPO2^( 0  ) else 0.0 percent) ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and ( lb < ( lb + 1  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
S [165] ->
Q [194] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) ) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) )  ) = totalSpO2
  and ub - lb = window_size >>
Why created:  Substituted assertions' predicates for labels  [serial 2551]
Solved by: Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 779:
Theorem (779) [serial 2633] used for:
    normalization of [serial 2608] 


Theorem (781)                               [serial 2551] 
P [160] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of SSQ(k - ub)  ) + SSQ(x : 0 ) = totalSpO2
  and ( (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) = goodCount
  and ub - lb = window_size
  and SSQ(x : 0 ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ]
  and AXIOM_LB()
  and GS() >>
S [165] ->
Q [194] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  of SSQ(k - ub)  ) = totalSpO2
  and ub - lb = window_size >>
Why created:    normalization of [serial 2522]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 780:
Theorem (780) [serial 2608] used for:
  Substituted assertions' predicates for labels  [serial 2551] 


Theorem (782)                               [serial 2522] 
P [160] << ( ( all k ~ quantity whole 
  in ( lb + 1  ) .. ( ub - 1  ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub)  ) )
  and ( ( spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(x : 0 ) ) )
  and ( ( totalSpO2 = ( SSQ(x : 0 ) + ( sum k ~ quantity whole 
  in ( lb + 1  ) .. ( ub - 1  ) 
  of SSQ(k - ub)  ) ) ) )
  and ( ( ( ub - lb ) = window_size ) )
  and ( goodCount = ( ( (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) ) )
  and ( ( goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) ) )
  and GS()
  and AXIOM_LB() >>
S [165] ->
Q [194] << ( all k ~ quantity whole 
  in ( lb + 1  ) .. ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub)  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in ( lb + 1  ) .. ub 
  of SSQ(k - ub)  ) )
  and ( ( ub - lb ) = window_size )
  and ( goodCount = ( numberof k ~ quantity whole 
  in ( lb + 1  ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in ( lb + 1  ) .. ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
Why created:  Q1 and Q2 and  . . . and Qn -> Q in concurrent composition for [serial 2517]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 781:
Theorem (781) [serial 2551] used for:
    normalization of [serial 2522] 


Theorem (783)                               [serial 2708] 
P [160] << all k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
S [163] ->
Q [165] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) >>
Why created:    normalization of [serial 2706]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Law of identity. (eqid)

Theorem (784)                               [serial 2706] 
P [160] << all k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
S [163] ->
Q [165] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = ( (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) ) >>
Why created:  applied wp for assignment [serial 2635]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 783:
Theorem (783) [serial 2708] used for:
    normalization of [serial 2706] 


Theorem (785)                               [serial 2635] 
P [160] << all k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
S [163] spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ] := (if SensorConnected?
  and not MotionArtifact? then SpO2? else 0.0 percent)
Q [165] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ] >>
Why created:    normalization of [serial 2609]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 784:
Theorem (784) [serial 2706] used for:
  applied wp for assignment [serial 2635] 


Theorem (786)                               [serial 2609] 
P [160] << all k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  are ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) ) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
S [163] spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ] := (if SensorConnected?
  and not MotionArtifact? then SpO2? else 0.0 percent)
Q [165] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  are ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) ) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( (if SENSOR_CONNECTED^( 0  )
  and not MOTION_ARTIFACT^( 0  ) then SPO2^( 0  ) else 0.0 percent) ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ] >>
Why created:  Substituted assertions' predicates for labels  [serial 2553]
Solved by: [Add unnecessary parentheses] and theorem 785:
Theorem (785) [serial 2635] used for:
    normalization of [serial 2609] 


Theorem (787)                               [serial 2553] 
P [160] << all k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  >>
S [163] spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ] := (if SensorConnected?
  and not MotionArtifact? then SpO2? else 0.0 percent)
Q [165] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and SSQ(x : 0 ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ] >>
Why created:    normalization of [serial 2523]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 786:
Theorem (786) [serial 2609] used for:
  Substituted assertions' predicates for labels  [serial 2553] 


Theorem (788)                               [serial 2523] 
P [160] << all k ~ quantity whole 
  in ( lb + 1  ) .. ( ub - 1  ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub)  >>
S [163] spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ] := (if SensorConnected?
  and not MotionArtifact? then SpO2? else 0.0 percent)
Q [165] << ( all k ~ quantity whole 
  in ( lb + 1  ) .. ( ub - 1  ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub)  )
  and ( spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(x : 0 ) ) >>
Why created:  <<P1>> S1 <<Q1>> in concurrent composition for [serial 2517]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 787:
Theorem (787) [serial 2553] used for:
    normalization of [serial 2523] 


Theorem (789)                               [serial 2723] 
P [169] << (if SENSOR_CONNECTED^( - ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0.0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED^( - ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0.0 percent) + 
( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( -1  + ub ) 
  of (if SENSOR_CONNECTED^( - ub + k )
       and not MOTION_ARTIFACT^( - ub + k ) then SPO2^( - ub + k ) else 0.0 percent)  ) = totalSpO2
  and - lb + ub = window_size >>
S [172] ->
Q [174] << (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( -1  + ub ) 
  of (if SENSOR_CONNECTED^( - ub + k )
       and not MOTION_ARTIFACT^( - ub + k ) then SPO2^( - ub + k ) else 0.0 percent)  ) = 
(if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + - (if SENSOR_CONNECTED^( 
- ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0.0 percent) + 
totalSpO2 >>
Why created:    normalization of [serial 2721]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Cancellation law for addition. (addcan)

Theorem (790)                               [serial 2721] 
P [169] << (if SENSOR_CONNECTED^( lb + - ub )
  and not MOTION_ARTIFACT^( lb + - ub ) then SPO2^( lb + - ub ) else 0.0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED^( lb + - ub )
  and not MOTION_ARTIFACT^( lb + - ub ) then SPO2^( lb + - ub ) else 0.0 percent) + 
( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub + - 1  ) 
  of (if SENSOR_CONNECTED^( k + - ub )
       and not MOTION_ARTIFACT^( k + - ub ) then SPO2^( k + - ub ) else 0.0 percent)  ) = totalSpO2
  and ub + - lb = window_size >>
S [172] ->
Q [174] << (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub + - 1  ) 
  of (if SENSOR_CONNECTED^( k + - ub )
       and not MOTION_ARTIFACT^( k + - ub ) then SPO2^( k + - ub ) else 0.0 percent)  ) = ( 
- (if SENSOR_CONNECTED^( lb + - ub )
  and not MOTION_ARTIFACT^( lb + - ub ) then SPO2^( lb + - ub ) else 0.0 percent) + 
(if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + totalSpO2 ) >>
Why created:   changing adding negation to subtraction  [serial 2720]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 789:
Theorem (789) [serial 2723] used for:
    normalization of [serial 2721] 


Theorem (791)                               [serial 2720] 
P [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0.0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0.0 percent) + 
( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [172] ->
Q [174] << (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = ( 
(if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + totalSpO2 ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0.0 percent) >>
Why created:    normalization of [serial 2718]
Solved by: Relationship between subtraction and negative. (negsub) and theorem 790:
Theorem (790) [serial 2721] used for:
   changing adding negation to subtraction  [serial 2720] 


Theorem (792)                               [serial 2718] 
P [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0.0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0.0 percent) + 
( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [172] ->
Q [174] << (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = ( 
(if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + totalSpO2 ) - ( (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0.0 percent) ) >>
Why created:  Guided Substitution of Equals 
 replacing "spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ]" with its = "( (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0.0 percent) )" in its postcondition [serial 2716]
Solved by: [Add unnecessary parentheses] and theorem 791:
Theorem (791) [serial 2720] used for:
    normalization of [serial 2718] 


Theorem (793)                               [serial 2716] 
P [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0.0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0.0 percent) + 
( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [172] ->
Q [174] << (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = ( 
(if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + totalSpO2 ) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ] >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 2715]
Solved by:  Guided Substitution of Equals
 and theorem 792:
Theorem (792) [serial 2718] used for:
  Guided Substitution of Equals 
 replacing "spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ]" with its = "( (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0.0 percent) )" in its postcondition [serial 2716] 


Theorem (794)                               [serial 2717] 
P [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0.0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0.0 percent) + 
( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [172] ->
Q [174] << ub - lb = window_size >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 2715]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (795)                               [serial 2715] 
P [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0.0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0.0 percent) + 
( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [172] ->
Q [174] << (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = ( 
(if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + totalSpO2 ) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ]
  and ub - lb = window_size >>
Why created:    normalization of [serial 2713]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Join consequents with conjunction. (3jca) and theorems 793 794:
Theorem (793) [serial 2716] used for:
  Join consequents with conjunction. (3jca)
   [serial 2715] 
Theorem (794) [serial 2717] used for:
  Join consequents with conjunction. (3jca)
   [serial 2715] 


Theorem (796)                               [serial 2713] 
P [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0.0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0.0 percent) + 
( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [172] ->
Q [174] << (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = ( ( 
(if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + totalSpO2 ) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ] )
  and ub - lb = window_size >>
Why created:  applied wp for assignment [serial 2637]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 795:
Theorem (795) [serial 2715] used for:
    normalization of [serial 2713] 


Theorem (797)                               [serial 2637] 
P [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0.0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ]
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0.0 percent) + 
( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [172] totalSpO2 := ( (if SensorConnected?
  and not MotionArtifact? then SpO2? else 0.0 percent) + totalSpO2 ) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ]
Q [174] << (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then SPO2^0  else 0.0 percent) + ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0.0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
Why created:    normalization of [serial 2610]
  Using: (bl.addcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 796:
Theorem (796) [serial 2713] used for:
  applied wp for assignment [serial 2637] 


Theorem (798)                               [serial 2610] 
P [169] << ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) )  ) + 
( (if SENSOR_CONNECTED^( ( lb - ub ) )
  and not MOTION_ARTIFACT^( ( lb - ub ) ) then SPO2^( ( lb - ub ) ) else 0.0 percent) ) = totalSpO2
  and ub - lb = window_size
  and ( (if SENSOR_CONNECTED^( ( lb - ub ) )
  and not MOTION_ARTIFACT^( ( lb - ub ) ) then SPO2^( ( lb - ub ) ) else 0.0 percent) ) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ] >>
S [172] totalSpO2 := ( (if SensorConnected?
  and not MotionArtifact? then SpO2? else 0.0 percent) + totalSpO2 ) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ]
Q [174] << ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0.0 percent) )  ) + 
( (if SENSOR_CONNECTED^( 0  )
  and not MOTION_ARTIFACT^( 0  ) then SPO2^( 0  ) else 0.0 percent) ) = totalSpO2
  and ub - lb = window_size >>
Why created:  Substituted assertions' predicates for labels  [serial 2555]
Solved by: Addition Commutes. (bl.addcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 797:
Theorem (797) [serial 2637] used for:
    normalization of [serial 2610] 


Theorem (799)                               [serial 2555] 
P [169] << ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of SSQ(k - ub)  ) + SSQ(lb - ub) = totalSpO2
  and ub - lb = window_size
  and SSQ(lb - ub) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ] >>
S [172] totalSpO2 := ( (if SensorConnected?
  and not MotionArtifact? then SpO2? else 0.0 percent) + totalSpO2 ) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ]
Q [174] << ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  of SSQ(k - ub)  ) + SSQ(x : 0 ) = totalSpO2
  and ub - lb = window_size >>
Why created:    normalization of [serial 2524]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 798:
Theorem (798) [serial 2610] used for:
  Substituted assertions' predicates for labels  [serial 2555] 


Theorem (800)                               [serial 2524] 
P [169] << ( totalSpO2 = ( SSQ(lb - ub) + ( sum k ~ quantity whole 
  in ( lb + 1  ) .. ( ub - 1  ) 
  of SSQ(k - ub)  ) ) )
  and ( spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(lb - ub) )
  and ( ( ub - lb ) = window_size ) >>
S [172] totalSpO2 := ( totalSpO2 + (if SensorConnected?
  and not MotionArtifact? then SpO2? else 0.0 percent) ) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ]
Q [174] << ( totalSpO2 = ( SSQ(x : 0 ) + ( sum k ~ quantity whole 
  in ( lb + 1  ) .. ( ub - 1  ) 
  of SSQ(k - ub)  ) ) )
  and ( ( ub - lb ) = window_size ) >>
Why created:  <<P2>> S2 <<Q2>> in concurrent composition for [serial 2517]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 799:
Theorem (799) [serial 2555] used for:
    normalization of [serial 2524] 


Theorem (801)                               [serial 2684] 
P [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
S [181] ->
Q [183] << ( numberof k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = ( numberof k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) >>
Why created:  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))  [serial 2683]
Solved by: Law of identity. (eqid)

Theorem (802)                               [serial 2683] 
P [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
S [181] ->
Q [183] << ( numberof k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) >>
Why created:  [Add unnecessary parentheses]
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2682]
Solved by:  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))
 and theorem 801:
Theorem (801) [serial 2684] used for:
  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))  [serial 2683] 


Theorem (803)                               [serial 2682] 
P [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
S [181] ->
Q [183] << ( numberof k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = ( (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) >>
Why created:  Addition Commutes. (bl.addcom)
  [Add unnecessary parentheses]
  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>> 
 replacing "goodCount"
 with its ="
 ( ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )" [serial 2681]
Solved by:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))
 [Add unnecessary parentheses] and theorem 802:
Theorem (802) [serial 2683] used for:
  [Add unnecessary parentheses]
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2682] 


Theorem (804)                               [serial 2681] 
P [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
S [181] ->
Q [183] << ( numberof k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = ( (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + goodCount ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) >>
Why created:  Equality Commutes. (eqcom)
  [Add unnecessary parentheses]
  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))  [serial 2680]
Solved by:  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
 Addition Commutes. (bl.addcom) [Add unnecessary parentheses] and theorem 803:
Theorem (803) [serial 2682] used for:
  Addition Commutes. (bl.addcom)
  [Add unnecessary parentheses]
  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>> 
 replacing "goodCount"
 with its ="
 ( ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )" [serial 2681] 


Theorem (805)                               [serial 2680] 
P [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
S [181] ->
Q [183] << ( (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + goodCount ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) = ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) >>
Why created:  [Add unnecessary parentheses]
  Substitution of Equivalents:
  <<...P[a|b] and (a iff b)>> S <<Q>>
  ----------------------
   <<...P and (a iff b)>> S <<Q>> 
 replacing "goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ]"
 with its iff"
 ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) )" [serial 2679]
Solved by:  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))
 Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 804:
Theorem (804) [serial 2681] used for:
  Equality Commutes. (eqcom)
  [Add unnecessary parentheses]
  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))  [serial 2680] 


Theorem (806)                               [serial 2679] 
P [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
S [181] ->
Q [183] << ( (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + goodCount ) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] then 1  else 0 ) = ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) >>
Why created:  Equality Commutes. (eqcom)
  [Add unnecessary parentheses]
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2678]
Solved by:  Substitution of Equivalents:
  <<...P[a|b] and (a iff b)>> S <<Q>>
  ----------------------
   <<...P and (a iff b)>> S <<Q>>
 [Add unnecessary parentheses] and theorem 805:
Theorem (805) [serial 2680] used for:
  [Add unnecessary parentheses]
  Substitution of Equivalents:
  <<...P[a|b] and (a iff b)>> S <<Q>>
  ----------------------
   <<...P and (a iff b)>> S <<Q>> 
 replacing "goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ]"
 with its iff"
 ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) )" [serial 2679] 


Theorem (807)                               [serial 2678] 
P [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) + ( numberof k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
S [181] ->
Q [183] << ( (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) = ( (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + goodCount ) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] then 1  else 0 ) >>
Why created:    normalization of [serial 2676]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))
 Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 806:
Theorem (806) [serial 2679] used for:
  Equality Commutes. (eqcom)
  [Add unnecessary parentheses]
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2678] 


Theorem (808)                               [serial 2676] 
P [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) + ( numberof k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
S [181] ->
Q [183] << ( (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) = ( ( (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + goodCount ) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] then 1  else 0 ) ) >>
Why created:  applied wp for assignment [serial 2557]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 807:
Theorem (807) [serial 2678] used for:
    normalization of [serial 2676] 


Theorem (809)                               [serial 2557] 
P [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] )
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) + ( numberof k ~ quantity whole 
  in ( 1  + lb ) .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
S [181] goodCount := ( (if SensorConnected?
  and not MotionArtifact? then 1  else 0 ) + goodCount ) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] then 1  else 0 )
Q [183] << ( (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) = goodCount >>
Why created:    normalization of [serial 2525]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 808:
Theorem (808) [serial 2676] used for:
  applied wp for assignment [serial 2557] 


Theorem (810)                               [serial 2525] 
P [176] << ( goodCount = ( (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) + ( numberof k ~ quantity whole 
  in ( lb + 1  ) .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) )
  and ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] ) >>
S [181] goodCount := ( goodCount + (if ( SensorConnected?
  and not MotionArtifact? ) then 1  else 0 ) ) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] then 1  else 0 )
Q [183] << goodCount = ( ( (if SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) ) >>
Why created:  <<P3>> S3 <<Q3>> in concurrent composition for [serial 2517]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 809:
Theorem (809) [serial 2557] used for:
    normalization of [serial 2525] 


Theorem (811)                               [serial 2567] 
P [188] << GS() >>
S [189] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] := ( SensorConnected?
  and not MotionArtifact? )
Q [191] << ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and GS()
  and true >>
Why created:    normalization of [serial 2530]
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (812)                               [serial 2530] 
P [188] << GS() >>
S [189] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] := ( SensorConnected?
  and not MotionArtifact? )
Q [191] << ( goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) )
  and GS()
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: Biconditional (iff) Commutes. (bicom) and theorem 811:
Theorem (811) [serial 2567] used for:
    normalization of [serial 2530] 


Theorem (813)                               [serial 2567] 
P [188] << GS() >>
S [189] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] := ( SensorConnected?
  and not MotionArtifact? )
Q [191] << ( ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] )
  and GS()
  and true >>
Why created:    normalization of [serial 2530]
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (814)                               [serial 2530] 
P [188] << GS() >>
S [189] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] := ( SensorConnected?
  and not MotionArtifact? )
Q [191] << ( goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) )
  and GS()
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: Biconditional (iff) Commutes. (bicom) and theorem 813:
Theorem (813) [serial 2567] used for:
    normalization of [serial 2530] 


Theorem (815)                               [serial 2526] 
P [188] << GS() >>
S [189] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] := ( SensorConnected?
  and not MotionArtifact? )
Q [191] << ( goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^0 
  and not MOTION_ARTIFACT^0  ) )
  and GS()
  and AXIOM_LB() >>
Why created:  <<P4>> S4 <<Q4>> in concurrent composition for [serial 2517]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 814 814:
Theorem (814) [serial 2530] used for:
   add user-defined "givens" to postcondition 
Theorem (814) [serial 2530] used for:
   add user-defined "givens" to postcondition 


Theorem (816)                               [serial 2517] 
P [158] << RUN_AV()
  and AXIOM_LB() >>
S [160]   << all k ~ quantity whole 
    in ( lb + 1  ) .. ( ub - 1  ) 
    are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub)  >>
  spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ] := (if SensorConnected?
    and not MotionArtifact? then SpO2? else 0.0 percent)
  << ( all k ~ quantity whole 
    in ( lb + 1  ) .. ( ub - 1  ) 
    are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub)  )
    and ( spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(x : 0 ) ) >>
  &
  << ( totalSpO2 = ( SSQ(lb - ub) + ( sum k ~ quantity whole 
    in ( lb + 1  ) .. ( ub - 1  ) 
    of SSQ(k - ub)  ) ) )
    and ( spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(lb - ub) )
    and ( ( ub - lb ) = window_size ) >>
  totalSpO2 := ( totalSpO2 + (if SensorConnected?
    and not MotionArtifact? then SpO2? else 0.0 percent) ) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ]
  << ( totalSpO2 = ( SSQ(x : 0 ) + ( sum k ~ quantity whole 
    in ( lb + 1  ) .. ( ub - 1  ) 
    of SSQ(k - ub)  ) ) )
    and ( ( ub - lb ) = window_size ) >>
  &
  << ( goodCount = ( (if SENSOR_CONNECTED^( lb - ub )
    and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) + ( numberof k ~ quantity whole 
    in ( lb + 1  ) .. ( ub - 1  ) 
    that ( SENSOR_CONNECTED^( k - ub )
           and not MOTION_ARTIFACT^( k - ub ) )  ) ) )
    and ( ( SENSOR_CONNECTED^( lb - ub )
    and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] ) >>
  goodCount := ( goodCount + (if ( SensorConnected?
    and not MotionArtifact? ) then 1  else 0 ) ) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] then 1  else 0 )
  << goodCount = ( ( (if SENSOR_CONNECTED^0 
    and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
    in lb .. ( ub - 1  ) 
    that ( SENSOR_CONNECTED^( k - ub )
           and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
    and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) ) >>
  &
  << GS() >>
  goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] := ( SensorConnected?
    and not MotionArtifact? )
  << ( goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^0 
    and not MOTION_ARTIFACT^0  ) )
    and GS()
    and AXIOM_LB() >> 
Q [194] << ( all k ~ quantity whole 
  in ( lb + 1  ) .. ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub)  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in ( lb + 1  ) .. ub 
  of SSQ(k - ub)  ) )
  and ( ( ub - lb ) = window_size )
  and ( goodCount = ( numberof k ~ quantity whole 
  in ( lb + 1  ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in ( lb + 1  ) .. ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 2507]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 751 755 759 763 782 788 800 810 815:
Theorem (751) [serial 2518] used for:
  P -> P1 in concurrent composition for [serial 2517] 
Theorem (755) [serial 2519] used for:
  P -> P2 in concurrent composition for [serial 2517] 
Theorem (759) [serial 2520] used for:
  P -> P3 in concurrent composition for [serial 2517] 
Theorem (763) [serial 2521] used for:
  P -> P4 in concurrent composition for [serial 2517] 
Theorem (782) [serial 2522] used for:
  Q1 and Q2 and  . . . and Qn -> Q in concurrent composition for [serial 2517] 
Theorem (788) [serial 2523] used for:
  <<P1>> S1 <<Q1>> in concurrent composition for [serial 2517] 
Theorem (800) [serial 2524] used for:
  <<P2>> S2 <<Q2>> in concurrent composition for [serial 2517] 
Theorem (810) [serial 2525] used for:
  <<P3>> S3 <<Q3>> in concurrent composition for [serial 2517] 
Theorem (815) [serial 2526] used for:
  <<P4>> S4 <<Q4>> in concurrent composition for [serial 2517] 


Theorem (817)                               [serial 2507] 
P [158] << RUN_AV()
  and AXIOM_LB() >>
S [159]   {
    << all k ~ quantity whole 
      in ( lb + 1  ) .. ( ub - 1  ) 
      are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub)  >>
    spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ] := (if SensorConnected?
      and not MotionArtifact? then SpO2? else 0.0 percent)
    << ( all k ~ quantity whole 
      in ( lb + 1  ) .. ( ub - 1  ) 
      are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub)  )
      and ( spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(x : 0 ) ) >>
    &
    << ( totalSpO2 = ( SSQ(lb - ub) + ( sum k ~ quantity whole 
      in ( lb + 1  ) .. ( ub - 1  ) 
      of SSQ(k - ub)  ) ) )
      and ( spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(lb - ub) )
      and ( ( ub - lb ) = window_size ) >>
    totalSpO2 := ( totalSpO2 + (if SensorConnected?
      and not MotionArtifact? then SpO2? else 0.0 percent) ) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ]
    << ( totalSpO2 = ( SSQ(x : 0 ) + ( sum k ~ quantity whole 
      in ( lb + 1  ) .. ( ub - 1  ) 
      of SSQ(k - ub)  ) ) )
      and ( ( ub - lb ) = window_size ) >>
    &
    << ( goodCount = ( (if SENSOR_CONNECTED^( lb - ub )
      and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) + ( numberof k ~ quantity whole 
      in ( lb + 1  ) .. ( ub - 1  ) 
      that ( SENSOR_CONNECTED^( k - ub )
             and not MOTION_ARTIFACT^( k - ub ) )  ) ) )
      and ( ( SENSOR_CONNECTED^( lb - ub )
      and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] ) >>
    goodCount := ( goodCount + (if ( SensorConnected?
      and not MotionArtifact? ) then 1  else 0 ) ) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] then 1  else 0 )
    << goodCount = ( ( (if SENSOR_CONNECTED^0 
      and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
      in lb .. ( ub - 1  ) 
      that ( SENSOR_CONNECTED^( k - ub )
             and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
      and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) ) >>
    &
    << GS() >>
    goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] := ( SensorConnected?
      and not MotionArtifact? )
    << ( goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^0 
      and not MOTION_ARTIFACT^0  ) )
      and GS()
      and AXIOM_LB() >> 
  } 
Q [194] << ( all k ~ quantity whole 
  in ( lb + 1  ) .. ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub)  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in ( lb + 1  ) .. ub 
  of SSQ(k - ub)  ) )
  and ( ( ub - lb ) = window_size )
  and ( goodCount = ( numberof k ~ quantity whole 
  in ( lb + 1  ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in ( lb + 1  ) .. ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1053]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 816:
Theorem (816) [serial 2517] used for:
  <<P>> T <<Q>> in behavior action block for [serial 2507] 


Theorem (818)                               [serial 2559] 
P [194] << ( all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( numberof k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1  + lb ) .. ub 
  of SSQ(k - ub)  ) = totalSpO2
  and ub - lb = window_size >>
S [203] |ub,lb,window_size',totalSpO2',goodCount' := 1  + ub,1  + lb,window_size,totalSpO2,goodCount|  
Q [204] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are SSQ(( 1  + k ) - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(( 1  + k ) - ub)  )
  and window_size' = ( 1  + ub ) - ( 1  + lb ) >>
Why created:    normalization of [serial 2508]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Cancellation law for addition. (addcan)

Theorem (819)                               [serial 2508] 
P [194] << ( all k ~ quantity whole 
  in ( lb + 1  ) .. ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub)  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in ( lb + 1  ) .. ub 
  of SSQ(k - ub)  ) )
  and ( ( ub - lb ) = window_size )
  and ( goodCount = ( numberof k ~ quantity whole 
  in ( lb + 1  ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in ( lb + 1  ) .. ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
S [203] |ub,lb,window_size',totalSpO2',goodCount' := ub + 1 ,lb + 1 ,window_size,totalSpO2,goodCount|  
Q [204] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ( ub - 1  ))  )
  and ( totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ( ub - 1  ))  ) )
  and ( ( ( ub - 1  ) - ( lb - 1  ) ) = window_size' )
  and ( goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1053]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 818:
Theorem (818) [serial 2559] used for:
    normalization of [serial 2508] 


Theorem (820)                               [serial 2561] 
P [204] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are SSQ(( 1  + k ) - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(( 1  + k ) - ub)  )
  and window_size' = ( 1  + ub ) - ( 1  + lb ) >>
S [214] |spo2_hist',goodSamp',ub',lb' := spo2_hist,goodSamp,ub,lb|  
Q [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]' = SSQ(( 
      1  + k ) - ub)  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]' iff ( SENSOR_CONNECTED^( ( 
      1  + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) )  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( ( 1  + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1  + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(( 1  + k ) - ub)  )
  and window_size' = ( 1  + ub' ) - ( 1  + lb' ) >>
Why created:    normalization of [serial 2509]
  Using: (bl.addcom) (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Cancellation law for addition. (addcan)

Theorem (821)                               [serial 2509] 
P [204] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ( ub - 1  ))  )
  and ( totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ( ub - 1  ))  ) )
  and ( ( ( ub - 1  ) - ( lb - 1  ) ) = window_size' )
  and ( goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) >>
S [214] |spo2_hist',goodSamp',ub',lb' := spo2_hist,goodSamp,ub,lb|  
Q [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]' = SSQ(k - ( ub - 1  ))  )
  and ( totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  of SSQ(k - ( ub - 1  ))  ) )
  and ( ( ( ub' - 1  ) - ( lb' - 1  ) ) = window_size' )
  and ( goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1  ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]' iff ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) >>
Why created:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1053]
Solved by: Addition Commutes. (bl.addcom) Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 820:
Theorem (820) [serial 2561] used for:
    normalization of [serial 2509] 


Theorem (822)                               [serial 1053] 
P [88] << INV_AV()
  and ( ( ub - lb ) = window_size ) >>
S [148]   << RUN_AV() >>
    if 
      (goodCount > 0 )~> 
        << RUN_AV()
          and ( goodCount > 0  )
          and AXIOM_K2I() >>
        SpO2Avg!(totalSpO2 / goodCount)
        << RUN_AV() >> 
    []
      (goodCount <= 0 )~> 
        << RUN_AV() >>
        skip
        << RUN_AV() >> 
    fi
  ;
  << RUN_AV()
    and AXIOM_LB() >>
    {
      << all k ~ quantity whole 
        in ( lb + 1  ) .. ( ub - 1  ) 
        are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub)  >>
      spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ] := (if SensorConnected?
        and not MotionArtifact? then SpO2? else 0.0 percent)
      << ( all k ~ quantity whole 
        in ( lb + 1  ) .. ( ub - 1  ) 
        are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub)  )
        and ( spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(x : 0 ) ) >>
      &
      << ( totalSpO2 = ( SSQ(lb - ub) + ( sum k ~ quantity whole 
        in ( lb + 1  ) .. ( ub - 1  ) 
        of SSQ(k - ub)  ) ) )
        and ( spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(lb - ub) )
        and ( ( ub - lb ) = window_size ) >>
      totalSpO2 := ( totalSpO2 + (if SensorConnected?
        and not MotionArtifact? then SpO2? else 0.0 percent) ) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples ]
      << ( totalSpO2 = ( SSQ(x : 0 ) + ( sum k ~ quantity whole 
        in ( lb + 1  ) .. ( ub - 1  ) 
        of SSQ(k - ub)  ) ) )
        and ( ( ub - lb ) = window_size ) >>
      &
      << ( goodCount = ( (if SENSOR_CONNECTED^( lb - ub )
        and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) + ( numberof k ~ quantity whole 
        in ( lb + 1  ) .. ( ub - 1  ) 
        that ( SENSOR_CONNECTED^( k - ub )
               and not MOTION_ARTIFACT^( k - ub ) )  ) ) )
        and ( ( SENSOR_CONNECTED^( lb - ub )
        and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] ) >>
      goodCount := ( goodCount + (if ( SensorConnected?
        and not MotionArtifact? ) then 1  else 0 ) ) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples ] then 1  else 0 )
      << goodCount = ( ( (if SENSOR_CONNECTED^0 
        and not MOTION_ARTIFACT^0  then 1  else 0 ) + ( numberof k ~ quantity whole 
        in lb .. ( ub - 1  ) 
        that ( SENSOR_CONNECTED^( k - ub )
               and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
        and not MOTION_ARTIFACT^( lb - ub ) then 1  else 0 ) ) >>
      &
      << GS() >>
      goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] := ( SensorConnected?
        and not MotionArtifact? )
      << ( goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^0 
        and not MOTION_ARTIFACT^0  ) )
        and GS()
        and AXIOM_LB() >> 
    } 
  << ( all k ~ quantity whole 
    in ( lb + 1  ) .. ub 
    are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ub)  )
    and ( totalSpO2 = ( sum k ~ quantity whole 
    in ( lb + 1  ) .. ub 
    of SSQ(k - ub)  ) )
    and ( ( ub - lb ) = window_size )
    and ( goodCount = ( numberof k ~ quantity whole 
    in ( lb + 1  ) .. ub 
    that ( SENSOR_CONNECTED^( k - ub )
           and not MOTION_ARTIFACT^( k - ub ) )  ) )
    and ( all k ~ quantity whole 
    in ( lb + 1  ) .. ub 
    are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ub )
          and not MOTION_ARTIFACT^( k - ub ) )  ) >>
  ;
  |ub,lb,window_size',totalSpO2',goodCount' := ub + 1 ,lb + 1 ,window_size,totalSpO2,goodCount|  
  << ( all k ~ quantity whole 
    in lb .. ( ub - 1  ) 
    are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ] = SSQ(k - ( ub - 1  ))  )
    and ( totalSpO2' = ( sum k ~ quantity whole 
    in lb .. ( ub - 1  ) 
    of SSQ(k - ( ub - 1  ))  ) )
    and ( ( ( ub - 1  ) - ( lb - 1  ) ) = window_size' )
    and ( goodCount' = ( numberof k ~ quantity whole 
    in lb .. ( ub - 1  ) 
    that ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
           and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) )
    and ( all k ~ quantity whole 
    in lb .. ( ub - 1  ) 
    are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ] iff ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
          and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) >>
  ;
  |spo2_hist',goodSamp',ub',lb' := spo2_hist,goodSamp,ub,lb|  
  << ( all k ~ quantity whole 
    in lb .. ( ub - 1  ) 
    are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples ]' = SSQ(k - ( ub - 1  ))  )
    and ( totalSpO2' = ( sum k ~ quantity whole 
    in lb .. ( ub - 1  ) 
    of SSQ(k - ( ub - 1  ))  ) )
    and ( ( ( ub' - 1  ) - ( lb' - 1  ) ) = window_size' )
    and ( goodCount' = ( numberof k ~ quantity whole 
    in lb .. ( ub - 1  ) 
    that ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
           and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) )
    and ( all k ~ quantity whole 
    in lb .. ( ub - 1  ) 
    are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples ]' iff ( SENSOR_CONNECTED^( k - ( ub - 1  ) )
          and not MOTION_ARTIFACT^( k - ( ub - 1  ) ) )  ) >> 
Q [88] << ( INV_AV()
  and ( ( ub - lb ) = window_size ) )^1  >>
Why created:   <<M(run) and x>> A <<M(run)>> for SpAt4: run-[x]->run{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 717 719 747 817 819 821:
Theorem (717) [serial 2504] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1053] 
Theorem (719) [serial 2505] used for:
  <<Q4>> -> <<Q>> in sequential composition for [serial 1053] 
Theorem (747) [serial 2506] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1053] 
Theorem (817) [serial 2507] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1053] 
Theorem (819) [serial 2508] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1053] 
Theorem (821) [serial 2509] used for:
  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1053] 


Theorem (823)                               [serial 1042] 
P [34] <<   >>
S [51] ->
Q [34] << SpO2AverageThread.imp proof obligations >>
Why created:  Initial proof obligations for SpO2AverageThread.imp
Solved by:  Component verification conditions
 and theorems 607 610 612 615 622 624 697 704 711 713 822:
Theorem (607) [serial 1043] used for:
  <<M(fillingWindow)>> -> <<I>> from invariant I when complete state fillingWindow has Assertion <<M(fillingWindow)>> in its definition. 
Theorem (610) [serial 1044] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (612) [serial 1045] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state chooseToRun, <<M(chooseToRun)>> -> <<e1 or e2 or . . . en>> 
Theorem (615) [serial 1046] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (622) [serial 1047] used for:
   <<M(start) and x>> A <<M(fillingWindow)>> for SpAT0: start-[x]->fillingWindow{A}; 
Theorem (624) [serial 1048] used for:
   <<M(start) and x>> A <<M(fail)>> for SpAT0a: start-[x]->fail{A}; 
Theorem (697) [serial 1049] used for:
   <<M(fillingWindow) and x>> A <<M(chooseToRun)>> for SpAT1: fillingWindow-[x]->chooseToRun{A}; 
Theorem (704) [serial 1050] used for:
   <<M(chooseToRun) and x>> A <<M(fillingWindow)>> for SpAT2: chooseToRun-[x]->fillingWindow{A}; 
Theorem (711) [serial 1051] used for:
   <<M(chooseToRun) and x>> A <<M(run)>> for SpAT3: chooseToRun-[x]->run{A}; 
Theorem (713) [serial 1052] used for:
   <<M(chooseToRun) and x>> A <<M(fail)>> for SpAT3a: chooseToRun-[x]->fail{A}; 
Theorem (822) [serial 1053] used for:
   <<M(run) and x>> A <<M(run)>> for SpAt4: run-[x]->run{A}; 


Theorem (824)                               [serial 1054] 
P [1] << SpO2Avg = SPO2_AVERAGE() >>
S [2] ->
Q [1] << SpO2Avg = SPO2_AVERAGE() >>
Why created:  Composition of Subcomponents via Directional Connection av.SpO2Avg -> so.SpO2Avg:
 SpO2Avg -> SpO2Avg
Solved by: Identity (id):  P->P is tautology

Theorem (825)                               [serial 1055] 
P [1] << SpO2Avg_AverageSpO2 = SPO2_AVERAGE() >>
S [2] ->
Q [1] << SpO2Avg_AverageSpO2 = SPO2_AVERAGE() >>
Why created:  Composition of Subcomponents via Directional Connection av.SpO2Avg -> rd.AverageSpO2:
 SpO2Avg -> AverageSpO2
Solved by: Identity (id):  P->P is tautology

Theorem (826)                               [serial 1056] 
P [1] << HEART_RATE_LOWER_LIMIT_ALARM() >>
S [2] ->
Q [1] << HEART_RATE_LOWER_LIMIT_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection po.HeartRateLowerLimitViolated -> ui.uit.HeartRateLowerLimitViolated:
 HeartRateLowerLimitViolated -> HeartRateLowerLimitViolated
Solved by: Identity (id):  P->P is tautology

Theorem (827)                               [serial 1057] 
P [1] << HEART_RATE_UPPER_LIMIT_ALARM() >>
S [2] ->
Q [1] << HEART_RATE_UPPER_LIMIT_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection po.HeartRateUpperLimitViolated -> ui.uit.HeartRateUpperLimitViolated:
 HeartRateUpperLimitViolated -> HeartRateUpperLimitViolated
Solved by: Identity (id):  P->P is tautology

Theorem (828)                               [serial 1058] 
P [1] << MOTION_ARTIFACT_ALARM() >>
S [2] ->
Q [1] << MOTION_ARTIFACT_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection app.tg.ma.MotionArtifactAlarm -> ui.uit.MotionArtifactAlarm:
 MotionArtifactAlarm -> MotionArtifactAlarm
Solved by: Identity (id):  P->P is tautology

Theorem (829)                               [serial 1059] 
P [1] << SUPPL_O2_ALARM() >>
S [2] ->
Q [1] << SUPPL_O2_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection app.tg.so.SpO2DerivedLowerLimitAlarm -> ui.uit.SpO2DerivedLowerLimitAlarm:
 SpO2DerivedLowerLimitAlarm -> SpO2DerivedLowerLimitAlarm
Solved by: Identity (id):  P->P is tautology

Theorem (830)                               [serial 1060] 
P [1] << RAPID_DECLINE_ALARM() >>
S [2] ->
Q [1] << RAPID_DECLINE_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection app.tg.rd.RapidSpO2DeclineAlarm -> ui.uit.RapidSpO2DeclineAlarm:
 RapidSpO2DeclineAlarm -> RapidSpO2DeclineAlarm
Solved by: Identity (id):  P->P is tautology

Theorem (831)                               [serial 1061] 
P [1] << SPO2_TREND() >>
S [2] ->
Q [1] << SPO2_TREND() >>
Why created:  Composition of Subcomponents via Directional Connection app.tg.tr.SpO2Trend -> ui.uit.SpO2Trend:
 SpO2Trend -> SpO2Trend
Solved by: Identity (id):  P->P is tautology

Theorem (832)                               [serial 1062] 
P [1] << HeartRateTrend = HEART_RATE_HISTORY >>
S [2] ->
Q [1] << HeartRateTrend = HEART_RATE_HISTORY >>
Why created:  Composition of Subcomponents via Directional Connection app.tg.hrt.HeartRateTrend -> ui.uit.HeartRateTrend:
 HeartRateTrend -> HeartRateTrend
Solved by: Identity (id):  P->P is tautology

Theorem (833)                               [serial 1063] 
P [1] << SpO2Avg = SPO2_AVERAGE() >>
S [2] ->
Q [1] << SpO2Avg = SPO2_AVERAGE() >>
Why created:  Composition of Subcomponents via Directional Connection app.tg.av.SpO2Avg -> ui.uit.SpO2Avg:
 SpO2Avg -> SpO2Avg
Solved by: Identity (id):  P->P is tautology

Theorem (834)                               [serial 1064] 
P [235] << HEART_RATE_LOWER_LIMIT_ALARM() >>
S [130] ->
Q [347] << HEART_RATE_LOWER_LIMIT_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.heart_rate_lower_limit_violated:
 HeartRateLowerLimitViolated -> HeartRateLowerLimitViolated
Solved by: Identity (id):  P->P is tautology

Theorem (835)                               [serial 1065] 
P [250] << HEART_RATE_UPPER_LIMIT_ALARM() >>
S [134] ->
Q [354] << HEART_RATE_UPPER_LIMIT_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.heart_rate_upper_limit_violated:
 HeartRateUpperLimitViolated -> HeartRateUpperLimitViolated
Solved by: Identity (id):  P->P is tautology

Theorem (836)                               [serial 1066] 
P [546] << HeartRateTrend = HEART_RATE_HISTORY >>
S [137] ->
Q [357] << HeartRateTrend = HEART_RATE_HISTORY >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.heart_rate_trend:
 HeartRateTrend -> HeartRateTrend
Solved by: Identity (id):  P->P is tautology

Theorem (837)                               [serial 1067] 
P [569] << SUPPL_O2_ALARM() >>
S [143] ->
Q [382] << SUPPL_O2_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.supplemental_oxygen_alarm:
 SpO2DerivedLowerLimitAlarm -> SpO2DerivedLowerLimitAlarm
Solved by: Identity (id):  P->P is tautology

Theorem (838)                               [serial 1068] 
P [577] << RAPID_DECLINE_ALARM() >>
S [149] ->
Q [398] << RAPID_DECLINE_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.rapid_spo2_decline_alarm:
 RapidSpO2DeclineAlarm -> RapidSpO2DeclineAlarm
Solved by: Identity (id):  P->P is tautology

Theorem (839)                               [serial 1069] 
P [554] << MOTION_ARTIFACT_ALARM() >>
S [160] ->
Q [405] << MOTION_ARTIFACT_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.motion_artifact_alarm:
 MotionArtifactAlarm -> MotionArtifactAlarm
Solved by: Identity (id):  P->P is tautology

Theorem (840)                               [serial 1070] 
P [583] << SPO2_TREND() >>
S [166] ->
Q [411] << SPO2_TREND() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.spO2_Trend:
 SpO2Trend -> SpO2Trend
Solved by: Identity (id):  P->P is tautology

Theorem (841)                               [serial 1071] 
P [561] << SpO2Avg = SPO2_AVERAGE() >>
S [167] ->
Q [368] << SpO2Avg = SPO2_AVERAGE() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.spO2_Average:
 SpO2Avg -> SpO2Avg
Solved by: Identity (id):  P->P is tautology

Theorem (842)                               [serial 1072] 
P [326] << SPO2_LOWER_LIMIT_ALARM() >>
S [431] ->
Q [467] << SPO2_LOWER_LIMIT_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_spo2_llv:
 SpO2LowerLimitViolated -> SpO2LowerLimitViolated
Solved by: Identity (id):  P->P is tautology

Theorem (843)                               [serial 1073] 
P [347] << HEART_RATE_LOWER_LIMIT_ALARM() >>
S [434] ->
Q [475] << HEART_RATE_LOWER_LIMIT_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_heartrate_llv:
 HeartRateLowerLimitViolated -> HeartRateLowerLimitViolated
Solved by: Identity (id):  P->P is tautology

Theorem (844)                               [serial 1074] 
P [354] << HEART_RATE_UPPER_LIMIT_ALARM() >>
S [436] ->
Q [479] << HEART_RATE_UPPER_LIMIT_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_heartrate_ulv:
 HeartRateUpperLimitViolated -> HeartRateUpperLimitViolated
Solved by: Identity (id):  P->P is tautology

Theorem (845)                               [serial 1075] 
P [357] << HeartRateTrend = HEART_RATE_HISTORY >>
S [437] ->
Q [482] << HeartRateTrend = HEART_RATE_HISTORY >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_heartrate_trend:
 HeartRateTrend -> HeartRateTrend
Solved by: Identity (id):  P->P is tautology

Theorem (846)                               [serial 1076] 
P [382] << SUPPL_O2_ALARM() >>
S [440] ->
Q [490] << SUPPL_O2_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_spo2derived_lla:
 SpO2DerivedLowerLimitAlarm -> SpO2DerivedLowerLimitAlarm
Solved by: Identity (id):  P->P is tautology

Theorem (847)                               [serial 1077] 
P [368] << SpO2Avg = SPO2_AVERAGE() >>
S [442] ->
Q [497] << SpO2Avg = SPO2_AVERAGE() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_spo2avg:
 SpO2Avg -> SpO2Avg
Solved by: Identity (id):  P->P is tautology

Theorem (848)                               [serial 1078] 
P [398] << RAPID_DECLINE_ALARM() >>
S [445] ->
Q [505] << RAPID_DECLINE_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_rapiddeclinealarm:
 RapidSpO2DeclineAlarm -> RapidSpO2DeclineAlarm
Solved by: Identity (id):  P->P is tautology

Theorem (849)                               [serial 1079] 
P [405] << MOTION_ARTIFACT_ALARM() >>
S [447] ->
Q [512] << MOTION_ARTIFACT_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_motionartifactalarm:
 MotionArtifactAlarm -> MotionArtifactAlarm
Solved by: Identity (id):  P->P is tautology

Theorem (850)                               [serial 1080] 
P [411] << SPO2_TREND() >>
S [448] ->
Q [518] << SPO2_TREND() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_spo2trend:
 SpO2Trend -> SpO2Trend
Solved by: Identity (id):  P->P is tautology

Theorem (851)                               [serial 1081] 
P [634] << HeartRateTrend = HEART_RATE_HISTORY >>
S [595] ->
Q [546] << HeartRateTrend = HEART_RATE_HISTORY >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoAppProcess.imp.ap_heartrate_trend:
 HeartRateTrend -> HeartRateTrend
Solved by: Identity (id):  P->P is tautology

Theorem (852)                               [serial 1082] 
P [642] << MOTION_ARTIFACT_ALARM() >>
S [598] ->
Q [554] << MOTION_ARTIFACT_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoAppProcess.imp.ap_maa:
 MotionArtifactAlarm -> MotionArtifactAlarm
Solved by: Identity (id):  P->P is tautology

Theorem (853)                               [serial 1083] 
P [657] << SUPPL_O2_ALARM() >>
S [601] ->
Q [569] << SUPPL_O2_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoAppProcess.imp.ap_spo2derived_lla:
 SpO2DerivedLowerLimitAlarm -> SpO2DerivedLowerLimitAlarm
Solved by: Identity (id):  P->P is tautology

Theorem (854)                               [serial 1084] 
P [665] << RAPID_DECLINE_ALARM() >>
S [604] ->
Q [577] << RAPID_DECLINE_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoAppProcess.imp.ap_rda:
 RapidSpO2DeclineAlarm -> RapidSpO2DeclineAlarm
Solved by: Identity (id):  P->P is tautology

Theorem (855)                               [serial 1085] 
P [671] << SPO2_TREND() >>
S [605] ->
Q [583] << SPO2_TREND() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoAppProcess.imp.ap_spo2trend:
 SpO2Trend -> SpO2Trend
Solved by: Identity (id):  P->P is tautology

Theorem (856)                               [serial 1086] 
P [649] << SpO2Avg = SPO2_AVERAGE() >>
S [606] ->
Q [561] << SpO2Avg = SPO2_AVERAGE() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoAppProcess.imp.ap_spo2average:
 SpO2Avg -> SpO2Avg
Solved by: Identity (id):  P->P is tautology

Theorem (857)                               [serial 1087] 
P [13] << MOTION_ARTIFACT_ALARM() >>
S [694] ->
Q [642] << MOTION_ARTIFACT_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.maa:
 MotionArtifactAlarm -> MotionArtifactAlarm
Solved by: Identity (id):  P->P is tautology

Theorem (858)                               [serial 1088] 
P [17] << SpO2Avg = SPO2_AVERAGE() >>
S [698] ->
Q [649] << SpO2Avg = SPO2_AVERAGE() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.avout:
 SpO2Avg -> SpO2Avg
Solved by: Identity (id):  P->P is tautology

Theorem (859)                               [serial 1089] 
P [17] << SpO2Avg = SPO2_AVERAGE() >>
S [699] ->
Q [9] << SpO2Avg = SPO2_AVERAGE() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.avso:
 SpO2Avg -> SpO2Avg
Solved by: Identity (id):  P->P is tautology

Theorem (860)                               [serial 1090] 
P [17] << SUPPL_O2_ALARM() >>
S [703] ->
Q [657] << SUPPL_O2_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.soalarm:
 SpO2DerivedLowerLimitAlarm -> SpO2DerivedLowerLimitAlarm
Solved by: Identity (id):  P->P is tautology

Theorem (861)                               [serial 1091] 
P [22] << RAPID_DECLINE_ALARM() >>
S [706] ->
Q [665] << RAPID_DECLINE_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.rdalarm:
 RapidSpO2DeclineAlarm -> RapidSpO2DeclineAlarm
Solved by: Identity (id):  P->P is tautology

Theorem (862)                               [serial 1092] 
P [15] << SPO2_TREND() >>
S [707] ->
Q [671] << SPO2_TREND() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.sptrend:
 SpO2Trend -> SpO2Trend
Solved by: Identity (id):  P->P is tautology

Theorem (863)                               [serial 1093] 
P [15] << HeartRateTrend = HEART_RATE_HISTORY >>
S [709] ->
Q [634] << HeartRateTrend = HEART_RATE_HISTORY >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.hrtr:
 HeartRateTrend -> HeartRateTrend
Solved by: Identity (id):  P->P is tautology

Theorem (864)                               [serial 1094] 
P [17] << SpO2Avg_AverageSpO2 = SPO2_AVERAGE() >>
S [711] ->
Q [20] << SpO2Avg_AverageSpO2 = SPO2_AVERAGE() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.spo2av:
 SpO2Avg -> AverageSpO2
Solved by: Identity (id):  P->P is tautology

Theorem (865)                               [serial 1001] 
Why created:  All verification conditions have been proved correct. 
Solved by:  Component and Connection Proofs
 and theorems 17 249 511 583 604 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864:
Theorem (17) [serial 1002] used for:
  Initial proof obligations for RapidDeclineThread.imp 
Theorem (249) [serial 1007] used for:
  Initial proof obligations for HeartRateTrendThread.imp 
Theorem (511) [serial 1018] used for:
  Initial proof obligations for SpO2TrendThread.imp 
Theorem (583) [serial 1029] used for:
  Initial proof obligations for MotionArtifactThread.imp 
Theorem (604) [serial 1034] used for:
  Initial proof obligations for SupplemetalOxygenThread.imp 
Theorem (823) [serial 1042] used for:
  Initial proof obligations for SpO2AverageThread.imp 
Theorem (824) [serial 1054] used for:
  Composition of Subcomponents via Directional Connection av.SpO2Avg -> so.SpO2Avg:
 SpO2Avg -> SpO2Avg 
Theorem (825) [serial 1055] used for:
  Composition of Subcomponents via Directional Connection av.SpO2Avg -> rd.AverageSpO2:
 SpO2Avg -> AverageSpO2 
Theorem (826) [serial 1056] used for:
  Composition of Subcomponents via Directional Connection po.HeartRateLowerLimitViolated -> ui.uit.HeartRateLowerLimitViolated:
 HeartRateLowerLimitViolated -> HeartRateLowerLimitViolated 
Theorem (827) [serial 1057] used for:
  Composition of Subcomponents via Directional Connection po.HeartRateUpperLimitViolated -> ui.uit.HeartRateUpperLimitViolated:
 HeartRateUpperLimitViolated -> HeartRateUpperLimitViolated 
Theorem (828) [serial 1058] used for:
  Composition of Subcomponents via Directional Connection app.tg.ma.MotionArtifactAlarm -> ui.uit.MotionArtifactAlarm:
 MotionArtifactAlarm -> MotionArtifactAlarm 
Theorem (829) [serial 1059] used for:
  Composition of Subcomponents via Directional Connection app.tg.so.SpO2DerivedLowerLimitAlarm -> ui.uit.SpO2DerivedLowerLimitAlarm:
 SpO2DerivedLowerLimitAlarm -> SpO2DerivedLowerLimitAlarm 
Theorem (830) [serial 1060] used for:
  Composition of Subcomponents via Directional Connection app.tg.rd.RapidSpO2DeclineAlarm -> ui.uit.RapidSpO2DeclineAlarm:
 RapidSpO2DeclineAlarm -> RapidSpO2DeclineAlarm 
Theorem (831) [serial 1061] used for:
  Composition of Subcomponents via Directional Connection app.tg.tr.SpO2Trend -> ui.uit.SpO2Trend:
 SpO2Trend -> SpO2Trend 
Theorem (832) [serial 1062] used for:
  Composition of Subcomponents via Directional Connection app.tg.hrt.HeartRateTrend -> ui.uit.HeartRateTrend:
 HeartRateTrend -> HeartRateTrend 
Theorem (833) [serial 1063] used for:
  Composition of Subcomponents via Directional Connection app.tg.av.SpO2Avg -> ui.uit.SpO2Avg:
 SpO2Avg -> SpO2Avg 
Theorem (834) [serial 1064] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.heart_rate_lower_limit_violated:
 HeartRateLowerLimitViolated -> HeartRateLowerLimitViolated 
Theorem (835) [serial 1065] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.heart_rate_upper_limit_violated:
 HeartRateUpperLimitViolated -> HeartRateUpperLimitViolated 
Theorem (836) [serial 1066] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.heart_rate_trend:
 HeartRateTrend -> HeartRateTrend 
Theorem (837) [serial 1067] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.supplemental_oxygen_alarm:
 SpO2DerivedLowerLimitAlarm -> SpO2DerivedLowerLimitAlarm 
Theorem (838) [serial 1068] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.rapid_spo2_decline_alarm:
 RapidSpO2DeclineAlarm -> RapidSpO2DeclineAlarm 
Theorem (839) [serial 1069] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.motion_artifact_alarm:
 MotionArtifactAlarm -> MotionArtifactAlarm 
Theorem (840) [serial 1070] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.spO2_Trend:
 SpO2Trend -> SpO2Trend 
Theorem (841) [serial 1071] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.spO2_Average:
 SpO2Avg -> SpO2Avg 
Theorem (842) [serial 1072] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_spo2_llv:
 SpO2LowerLimitViolated -> SpO2LowerLimitViolated 
Theorem (843) [serial 1073] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_heartrate_llv:
 HeartRateLowerLimitViolated -> HeartRateLowerLimitViolated 
Theorem (844) [serial 1074] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_heartrate_ulv:
 HeartRateUpperLimitViolated -> HeartRateUpperLimitViolated 
Theorem (845) [serial 1075] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_heartrate_trend:
 HeartRateTrend -> HeartRateTrend 
Theorem (846) [serial 1076] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_spo2derived_lla:
 SpO2DerivedLowerLimitAlarm -> SpO2DerivedLowerLimitAlarm 
Theorem (847) [serial 1077] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_spo2avg:
 SpO2Avg -> SpO2Avg 
Theorem (848) [serial 1078] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_rapiddeclinealarm:
 RapidSpO2DeclineAlarm -> RapidSpO2DeclineAlarm 
Theorem (849) [serial 1079] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_motionartifactalarm:
 MotionArtifactAlarm -> MotionArtifactAlarm 
Theorem (850) [serial 1080] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_spo2trend:
 SpO2Trend -> SpO2Trend 
Theorem (851) [serial 1081] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoAppProcess.imp.ap_heartrate_trend:
 HeartRateTrend -> HeartRateTrend 
Theorem (852) [serial 1082] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoAppProcess.imp.ap_maa:
 MotionArtifactAlarm -> MotionArtifactAlarm 
Theorem (853) [serial 1083] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoAppProcess.imp.ap_spo2derived_lla:
 SpO2DerivedLowerLimitAlarm -> SpO2DerivedLowerLimitAlarm 
Theorem (854) [serial 1084] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoAppProcess.imp.ap_rda:
 RapidSpO2DeclineAlarm -> RapidSpO2DeclineAlarm 
Theorem (855) [serial 1085] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoAppProcess.imp.ap_spo2trend:
 SpO2Trend -> SpO2Trend 
Theorem (856) [serial 1086] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoAppProcess.imp.ap_spo2average:
 SpO2Avg -> SpO2Avg 
Theorem (857) [serial 1087] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.maa:
 MotionArtifactAlarm -> MotionArtifactAlarm 
Theorem (858) [serial 1088] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.avout:
 SpO2Avg -> SpO2Avg 
Theorem (859) [serial 1089] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.avso:
 SpO2Avg -> SpO2Avg 
Theorem (860) [serial 1090] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.soalarm:
 SpO2DerivedLowerLimitAlarm -> SpO2DerivedLowerLimitAlarm 
Theorem (861) [serial 1091] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.rdalarm:
 RapidSpO2DeclineAlarm -> RapidSpO2DeclineAlarm 
Theorem (862) [serial 1092] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.sptrend:
 SpO2Trend -> SpO2Trend 
Theorem (863) [serial 1093] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.hrtr:
 HeartRateTrend -> HeartRateTrend 
Theorem (864) [serial 1094] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.spo2av:
 SpO2Avg -> AverageSpO2 


closing proof file "/Applications/osate2_2023-03-master/Eclipse.app/Contents/MacOS/proof.txt" 