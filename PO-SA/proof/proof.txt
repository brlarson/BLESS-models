This file, proof.txt, was produced the BLESS Proof Assistant v3.2.0
  at Thu Aug 24 14:16:02 CDT 2023 by brianlarson

Theorem (1)                               [serial 1003] 
P [37] << true >>
S [34] ->
Q [34] << true >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by:  True Conclusion Schema (tc): P->true


Theorem (2)                               [serial 1004] 
P [36] << true >>
S [36] ->
Q [36] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by:  True Conclusion Schema (tc): P->true


Theorem (3)                               [serial 1096] 
P [36] << true >>
S [39] ->
Q [37] << true >>
Why created:    normalization of [serial 1005]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (4)                               [serial 1005] 
P [36] << true >>
S [39] ->
Q [37] << ( true )^1 >>
Why created:   <<M(start)>> -> <<M(run)>> for rdt0: start-[ ]->run{};
Solved by:  Constants are always the same
and theorem 3:
Theorem (3) [serial 1096] used for:
    normalization of [serial 1005] 


Theorem (5)                               [serial 1115] 
P [37] << true >>
S [42] ->
Q [42] << true >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1104]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (6)                               [serial 1104] 
P [37] << true >>
S [42] ->
Q [42] << ( MAX_SPO2_DECLINE^0 + SPO2^0 < SPO2_AVERAGE()^0
  and ADULT_RAPID_DECLINE_ALARM_ENABLED^0
  and SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) or not ( MAX_SPO2_DECLINE^0 + SPO2^0 < SPO2_AVERAGE()^0
  and ADULT_RAPID_DECLINE_ALARM_ENABLED^0
  and SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) >>
Why created:    normalization of [serial 1099]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 5:
Theorem (5) [serial 1115] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1104] 


Theorem (7)                               [serial 1099] 
P [37] << true >>
S [42] ->
Q [42] << ( ADULT_RAPID_DECLINE_ALARM_ENABLED^0
  and SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0
  and SPO2^0 + MAX_SPO2_DECLINE^0 < SPO2_AVERAGE()^0 ) or ( not ( ADULT_RAPID_DECLINE_ALARM_ENABLED^0
  and SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0
  and SPO2^0 + MAX_SPO2_DECLINE^0 < SPO2_AVERAGE()^0 ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1098]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 6:
Theorem (6) [serial 1104] used for:
    normalization of [serial 1099] 


Theorem (8)                               [serial 1124] 
P [42] << MAX_SPO2_DECLINE + SPO2 < SPO2_AVERAGE()
  and ADULT_RAPID_DECLINE_ALARM_ENABLED
  and SENSOR_CONNECTED
  and not MOTION_ARTIFACT >>
S [42] ->
Q [45] << MAX_SPO2_DECLINE + SPO2 < SPO2_AVERAGE()
  and ADULT_RAPID_DECLINE_ALARM_ENABLED
  and SENSOR_CONNECTED
  and not MOTION_ARTIFACT >>
Why created:    normalization of [serial 1122]
Solved by:  Identity (id):  P->P is tautology


Theorem (9)                               [serial 1122] 
P [42] << MAX_SPO2_DECLINE + SPO2 < SPO2_AVERAGE()
  and ADULT_RAPID_DECLINE_ALARM_ENABLED
  and SENSOR_CONNECTED
  and not MOTION_ARTIFACT >>
S [42] ->
Q [45] << ( ADULT_RAPID_DECLINE_ALARM_ENABLED
  and SPO2 + MAX_SPO2_DECLINE < SPO2_AVERAGE()
  and SENSOR_CONNECTED
  and not MOTION_ARTIFACT ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1121]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 8:
Theorem (8) [serial 1124] used for:
    normalization of [serial 1122] 


Theorem (10)                               [serial 1121] 
P [42] << MAX_SPO2_DECLINE + SPO2 < SPO2_AVERAGE()
  and ADULT_RAPID_DECLINE_ALARM_ENABLED
  and SENSOR_CONNECTED
  and not MOTION_ARTIFACT >>
S [42] ->
Q [45] << RAPID_DECLINE_ALARM() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1116]
Solved by:  Substitution of Assertion Labels
and theorem 9:
Theorem (9) [serial 1122] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1121] 


Theorem (11)                               [serial 1116] 
P [42] << ( ( MAX_SPO2_DECLINE^0 + SPO2^0 < SPO2_AVERAGE()^0
  and ADULT_RAPID_DECLINE_ALARM_ENABLED^0
  and SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) ) >>
S [42] ->
Q [45] << RAPID_DECLINE_ALARM() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1106]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 10:
Theorem (10) [serial 1121] used for:
  Assume Present:  P = P@now = P^0   [serial 1116] 


Theorem (12)                               [serial 1106] 
P [42] << ( MAX_SPO2_DECLINE^0 + SPO2^0 < SPO2_AVERAGE()^0
  and ADULT_RAPID_DECLINE_ALARM_ENABLED^0
  and SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 )
  and true >>
S [42] ->
Q [45] << RAPID_DECLINE_ALARM() >>
Why created:    normalization of [serial 1100]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 11:
Theorem (11) [serial 1116] used for:
  Law of And-Simplification:  P and true is P [serial 1106] 


Theorem (13)                               [serial 1100] 
P [42] << true
  and ( ADULT_RAPID_DECLINE_ALARM_ENABLED^0
  and SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0
  and SPO2^0 + MAX_SPO2_DECLINE^0 < SPO2_AVERAGE()^0 ) >>
S [42] ->
Q [45] << RAPID_DECLINE_ALARM() >>
Why created:    <<P and B0>> -> <<P0>> in alternative for [serial 1098]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 12:
Theorem (12) [serial 1106] used for:
    normalization of [serial 1100] 


Theorem (14)                               [serial 1118] 
P [45] << RAPID_DECLINE_ALARM() >>
S [46] ->
Q [22] << RAPID_DECLINE_ALARM() >>
Why created:  applied port output <<pre>> -> <<M[RapidSpO2DeclineAlarm]>> [serial 1108]
Solved by:  Identity (id):  P->P is tautology


Theorem (15)                               [serial 1119] 
P [46] << ( RAPID_DECLINE_ALARM() )
  and RapidSpO2DeclineAlarm^0 >>
S [46] ->
Q [37] << true >>
Why created:  applied port output <<pre and M[RapidSpO2DeclineAlarm]^0>> -> <<post>> [serial 1108]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (16)                               [serial 1108] 
P [45] << RAPID_DECLINE_ALARM() >>
S [46] RapidSpO2DeclineAlarm!
Q [37] << true >>
Why created:    normalization of [serial 1101]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
and theorems 14 15:
Theorem (14) [serial 1118] used for:
  applied port output <<pre>> -> <<M[RapidSpO2DeclineAlarm]>> [serial 1108] 
Theorem (15) [serial 1119] used for:
  applied port output <<pre and M[RapidSpO2DeclineAlarm]^0>> -> <<post>> [serial 1108] 


Theorem (17)                               [serial 1101] 
P [45] << RAPID_DECLINE_ALARM() >>
S [46] RapidSpO2DeclineAlarm!
Q [37] << ( true )^1 >>
Why created:    <<P0>> S0 <<Q>> in alternative for [serial 1098]
Solved by:  Constants are always the same
and theorem 16:
Theorem (16) [serial 1108] used for:
    normalization of [serial 1101] 


Theorem (18)                               [serial 1120] 
P [42] << ( not ( MAX_SPO2_DECLINE^0 + SPO2^0 < SPO2_AVERAGE()^0
  and ADULT_RAPID_DECLINE_ALARM_ENABLED^0
  and SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) ) >>
S [50] ->
Q [37] << true >>
Why created:    <<P>> -> <<Q>>
  for [serial 1117]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (19)                               [serial 1117] 
P [42] << ( not ( MAX_SPO2_DECLINE^0 + SPO2^0 < SPO2_AVERAGE()^0
  and ADULT_RAPID_DECLINE_ALARM_ENABLED^0
  and SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) ) >>
S [50] skip
Q [37] << true >>
Why created:  Law of And-Simplification:  P and true is P [serial 1110]
Solved by:  Skip Means Implication:  <<P>> skip <<Q>>  is  <<P>> -> <<Q>>
and theorem 18:
Theorem (18) [serial 1120] used for:
    <<P>> -> <<Q>>
  for [serial 1117] 


Theorem (20)                               [serial 1110] 
P [42] << not ( MAX_SPO2_DECLINE^0 + SPO2^0 < SPO2_AVERAGE()^0
  and ADULT_RAPID_DECLINE_ALARM_ENABLED^0
  and SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 )
  and true >>
S [50] skip
Q [37] << true >>
Why created:    normalization of [serial 1102]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 19:
Theorem (19) [serial 1117] used for:
  Law of And-Simplification:  P and true is P [serial 1110] 


Theorem (21)                               [serial 1102] 
P [42] << true
  and ( not ( ADULT_RAPID_DECLINE_ALARM_ENABLED^0
  and SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0
  and SPO2^0 + MAX_SPO2_DECLINE^0 < SPO2_AVERAGE()^0 ) ) >>
S [50] skip
Q [37] << ( true )^1 >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1098]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Constants are always the same
  Associativity: a.(b.c) = a.b.c
and theorem 20:
Theorem (20) [serial 1110] used for:
    normalization of [serial 1102] 


Theorem (22)                               [serial 1098] 
P [37] << true >>
S [42]   if 
    (AdultRapidDeclineAlarmEnabled?
    and SensorConnected?
    and not MotionArtifact?
    and SpO2? + MaxSpO2Decline? < AverageSpO2?)~> 
      << RAPID_DECLINE_ALARM() >>
      RapidSpO2DeclineAlarm! 
  []
    (not ( AdultRapidDeclineAlarmEnabled?
    and SensorConnected?
    and not MotionArtifact?
    and SpO2? + MaxSpO2Decline? < AverageSpO2? ))~> 
      skip 
  fi
Q [37] << ( true )^1 >>
Why created:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1006]
Solved by:  Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>>
and theorems 7 13 17 21:
Theorem (7) [serial 1099] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1098] 
Theorem (13) [serial 1100] used for:
    <<P and B0>> -> <<P0>> in alternative for [serial 1098] 
Theorem (17) [serial 1101] used for:
    <<P0>> S0 <<Q>> in alternative for [serial 1098] 
Theorem (21) [serial 1102] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1098] 


Theorem (23)                               [serial 1006] 
P [37] << true >>
S [42]   if 
    (AdultRapidDeclineAlarmEnabled?
    and SensorConnected?
    and not MotionArtifact?
    and SpO2? + MaxSpO2Decline? < AverageSpO2?)~> 
      << RAPID_DECLINE_ALARM() >>
      RapidSpO2DeclineAlarm! 
  []
    (not ( AdultRapidDeclineAlarmEnabled?
    and SensorConnected?
    and not MotionArtifact?
    and SpO2? + MaxSpO2Decline? < AverageSpO2? ))~> 
      skip 
  fi
Q [37] << ( true )^1 >>
Why created:   <<M(run) and x>> A <<M(run)>> for rdt1: run-[x]->run{A};
Solved by:  Introduction of Existential Quantification
and theorem 22:
Theorem (22) [serial 1098] used for:
  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1006] 


Theorem (24)                               [serial 1002] 
P [34] <<   >>
S [34] ->
Q [34] << RapidDeclineThread.imp proof obligations >>
Why created:  Initial proof obligations for RapidDeclineThread.imp
Solved by:  Component verification conditions
and theorems 1 2 4 23:
Theorem (1) [serial 1003] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (2) [serial 1004] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (4) [serial 1005] used for:
   <<M(start)>> -> <<M(run)>> for rdt0: start-[ ]->run{}; 
Theorem (23) [serial 1006] used for:
   <<M(run) and x>> A <<M(run)>> for rdt1: run-[x]->run{A}; 


Theorem (25)                               [serial 1128] 
P [53] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [36] ->
Q [36] << all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  >>
Why created:    normalization of [serial 1126]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (26)                               [serial 1126] 
P [53] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
S [36] ->
Q [36] << all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1008]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 25:
Theorem (25) [serial 1128] used for:
    normalization of [serial 1126] 


Theorem (27)                               [serial 1008] 
P [53] << INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
S [36] ->
Q [36] << all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by:  Substitution of Assertion Labels
and theorem 26:
Theorem (26) [serial 1126] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1008] 


Theorem (28)                               [serial 1132] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [36] ->
Q [36] << all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  >>
Why created:    normalization of [serial 1130]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (29)                               [serial 1130] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [36] ->
Q [36] << all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1009]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 28:
Theorem (28) [serial 1132] used for:
    normalization of [serial 1130] 


Theorem (30)                               [serial 1009] 
P [49] << INV_HR()
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [36] ->
Q [36] << all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  >>
Why created:  <<M(fill)>> -> <<I>> from invariant I when complete state fill has Assertion <<M(fill)>> in its definition.
Solved by:  Substitution of Assertion Labels
and theorem 29:
Theorem (29) [serial 1130] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1009] 


Theorem (31)                               [serial 1010] 
P [45] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and num_samples = 0
  and ( all s ~ quantity whole 
  in ( num_samples + 1 ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  ) >>
S [45] ->
Q [45] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by:  True Conclusion Schema (tc): P->true


Theorem (32)                               [serial 1137] 
P [51] << HOLD_HR(num_samples) >>
S [51] ->
Q [51] << true >>
Why created:  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1135]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (33)                               [serial 1135] 
P [51] << HOLD_HR(num_samples) >>
S [51] ->
Q [51] << #PulseOx_Properties::Num_Trending_Samples < num_samples or num_samples < #PulseOx_Properties::Num_Trending_Samples or 
#PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 1011]
Solved by:  Less than, greater than, or equal:  |-a<b or b<a or a=b
and theorem 32:
Theorem (32) [serial 1137] used for:
  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1135] 


Theorem (34)                               [serial 1011] 
P [51] << HOLD_HR(num_samples) >>
S [51] ->
Q [51] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples ) or ( num_samples = #PulseOx_Properties::Num_Trending_Samples ) or 
( num_samples > #PulseOx_Properties::Num_Trending_Samples ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state check, <<M(check)>> -> <<e1 or e2 or . . . en>>
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of Greater Than: (a>b) = (b<a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 33:
Theorem (33) [serial 1135] used for:
    normalization of [serial 1011] 


Theorem (35)                               [serial 1182] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] ->
Q [36] << true >>
Why created:    normalization of [serial 1177]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (36)                               [serial 1177] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] ->
Q [36] << ( true ) >>
Why created:  Empty Range Law All: all a:t which false are V is tautology  [serial 1173]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 35:
Theorem (35) [serial 1182] used for:
    normalization of [serial 1177] 


Theorem (37)                               [serial 1173] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] ->
Q [36] << ( all s ~ quantity whole 
  which false 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1171]
Solved by:  Empty Range Law All: all a:t which false are V is tautology
and theorem 36:
Theorem (36) [serial 1177] used for:
  Empty Range Law All: all a:t which false are V is tautology  [serial 1173] 


Theorem (38)                               [serial 1187] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] ->
Q [49] << num_samples < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Guided Substitution of Equals 
 replacing "0" with its = "num_samples" in its postcondition [serial 1174]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (39)                               [serial 1174] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] ->
Q [49] << 0 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1171]
Solved by:  Guided Substitution of Equals
and theorem 38:
Theorem (38) [serial 1187] used for:
  Guided Substitution of Equals 
 replacing "0" with its = "num_samples" in its postcondition [serial 1174] 


Theorem (40)                               [serial 1171] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] ->
Q [49] << ( all s ~ quantity whole 
  which false 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and 0 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Empty Range [serial 1169]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 37 39:
Theorem (37) [serial 1173] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1171] 
Theorem (39) [serial 1174] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1171] 


Theorem (41)                               [serial 1169] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] ->
Q [49] << ( all s ~ quantity whole 
  in 1 .. 0 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and 0 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Guided Substitution of Equals 
 replacing "num_samples" with its = "0" in its postcondition [serial 1168]
Solved by:  Empty Range
and theorem 40:
Theorem (40) [serial 1171] used for:
  Empty Range [serial 1169] 


Theorem (42)                               [serial 1184] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] ->
Q [36] << true >>
Why created:    normalization of [serial 1178]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (43)                               [serial 1178] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] ->
Q [36] << ( true ) >>
Why created:  Empty Range Law All: all a:t which false are V is tautology  [serial 1175]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 42:
Theorem (42) [serial 1184] used for:
    normalization of [serial 1178] 


Theorem (44)                               [serial 1175] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] ->
Q [36] << ( all s ~ quantity whole 
  which false 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1172]
Solved by:  Empty Range Law All: all a:t which false are V is tautology
and theorem 43:
Theorem (43) [serial 1178] used for:
  Empty Range Law All: all a:t which false are V is tautology  [serial 1175] 


Theorem (45)                               [serial 1188] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] ->
Q [49] << num_samples < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Guided Substitution of Equals 
 replacing "0" with its = "num_samples" in its postcondition [serial 1176]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (46)                               [serial 1176] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] ->
Q [49] << 0 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1172]
Solved by:  Guided Substitution of Equals
and theorem 45:
Theorem (45) [serial 1188] used for:
  Guided Substitution of Equals 
 replacing "0" with its = "num_samples" in its postcondition [serial 1176] 


Theorem (47)                               [serial 1172] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] ->
Q [49] << ( all s ~ quantity whole 
  which false 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and 0 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Empty Range [serial 1170]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 44 46:
Theorem (44) [serial 1175] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1172] 
Theorem (46) [serial 1176] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1172] 


Theorem (48)                               [serial 1170] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] ->
Q [49] << ( all s ~ quantity whole 
  in 1 .. 0 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and 0 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "num_samples" with its = "0" in its postcondition [serial 1168]
Solved by:  Empty Range
and theorem 47:
Theorem (47) [serial 1172] used for:
  Empty Range [serial 1170] 


Theorem (49)                               [serial 1168] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] ->
Q [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  applied wp for simultaneous assignment [serial 1165]
Solved by:  Guided Substitution of Equals
  Guided Substitution of Equals
and theorems 41 48:
Theorem (41) [serial 1169] used for:
  Guided Substitution of Equals 
 replacing "num_samples" with its = "0" in its postcondition [serial 1168] 
Theorem (48) [serial 1170] used for:
  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "num_samples" with its = "0" in its postcondition [serial 1168] 


Theorem (50)                               [serial 1165] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:    normalization of [serial 1163]
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Simultaneous Assignment
and theorem 49:
Theorem (49) [serial 1168] used for:
  applied wp for simultaneous assignment [serial 1165] 


Theorem (51)                               [serial 1163] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if not ( SENSOR_CONNECTED^( - s ) )^1 or MOTION_ARTIFACT^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1161]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Caret Compostition:  (x^a)^b is x^(a+b)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 50:
Theorem (50) [serial 1165] used for:
    normalization of [serial 1163] 


Theorem (52)                               [serial 1161] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( not SENSOR_CONNECTED^( - s ) )^1 or MOTION_ARTIFACT^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:    normalization of [serial 1159]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 51:
Theorem (51) [serial 1163] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1161] 


Theorem (53)                               [serial 1159] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( MOTION_ARTIFACT^( ( - s ) + 1 ) or ( not SENSOR_CONNECTED^( - s ) )^1 ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1157]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 52:
Theorem (52) [serial 1161] used for:
    normalization of [serial 1159] 


Theorem (54)                               [serial 1157] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1 then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:    normalization of [serial 1155]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 53:
Theorem (53) [serial 1159] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1157] 


Theorem (55)                               [serial 1155] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1 then ( 0 Hz )^1 else HEART_RATE^( 
      ( - s ) + 1 )) = heart_rate_store[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1153]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Constants are always the same
  Associativity: a.(b.c) = a.b.c
and theorem 54:
Theorem (54) [serial 1157] used for:
    normalization of [serial 1155] 


Theorem (56)                               [serial 1153] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))^1 = heart_rate_store[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:    normalization of [serial 1151]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 55:
Theorem (55) [serial 1155] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1153] 


Theorem (57)                               [serial 1151] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))^1 = ( heart_rate_store[s] )^1 )  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1149]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 56:
Theorem (56) [serial 1153] used for:
    normalization of [serial 1151] 


Theorem (58)                               [serial 1149] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s )) = heart_rate_store[s] )^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:    normalization of [serial 1147]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 57:
Theorem (57) [serial 1151] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1149] 


Theorem (59)                               [serial 1147] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( ( num_samples )^1 < ( #PulseOx_Properties::Num_Trending_Samples )^1 )
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s )) = heart_rate_store[s] )^1  ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1145]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Constants are always the same
  Associativity: a.(b.c) = a.b.c
and theorem 58:
Theorem (58) [serial 1149] used for:
    normalization of [serial 1147] 


Theorem (60)                               [serial 1145] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples )^1
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  )^1 >>
Why created:    normalization of [serial 1143]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 59:
Theorem (59) [serial 1147] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1145] 


Theorem (61)                               [serial 1143] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  )^1
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1140]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 60:
Theorem (60) [serial 1145] used for:
    normalization of [serial 1143] 


Theorem (62)                               [serial 1140] 
P [45] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples )^1 >>
Why created:    normalization of [serial 1138]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 61:
Theorem (61) [serial 1143] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1140] 


Theorem (63)                               [serial 1138] 
P [45] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and num_samples = 0
  and ( all s ~ quantity whole 
  in ( num_samples + 1 ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  ) >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples )^1 >>
Why created:  Substituted assertions' predicates for labels  [serial 1012]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 62:
Theorem (62) [serial 1140] used for:
    normalization of [serial 1138] 


Theorem (64)                               [serial 1012] 
P [45] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and num_samples = 0
  and ( all s ~ quantity whole 
  in ( num_samples + 1 ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  ) >>
S [58] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( INV_HR()
  and num_samples < #PulseOx_Properties::Num_Trending_Samples )^1 >>
Why created:   <<M(start)>> A <<M(fill)>> for hrtt0: start-[ ]->fill{A};
Solved by:  Substitution of Assertion Labels
and theorem 63:
Theorem (63) [serial 1138] used for:
  Substituted assertions' predicates for labels  [serial 1012] 


Theorem (65)                               [serial 1261] 
P [49] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and INV_HR() >>
S [49] ->
Q [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and INV_HR() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1260]
Solved by:  Identity (id):  P->P is tautology


Theorem (66)                               [serial 1260] 
P [49] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and INV_HR() >>
S [49] ->
Q [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and true
  and INV_HR() >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 65:
Theorem (65) [serial 1261] used for:
  Law of And-Simplification:  P and true is P [serial 1260] 


Theorem (67)                               [serial 1261] 
P [49] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and INV_HR() >>
S [49] ->
Q [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and INV_HR() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1260]
Solved by:  Identity (id):  P->P is tautology


Theorem (68)                               [serial 1260] 
P [49] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and INV_HR() >>
S [49] ->
Q [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and true
  and INV_HR() >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 67:
Theorem (67) [serial 1261] used for:
  Law of And-Simplification:  P and true is P [serial 1260] 


Theorem (69)                               [serial 1192] 
P [49] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and INV_HR() >>
S [49] ->
Q [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_HRT()
  and INV_HR() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1190]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 68 68:
Theorem (68) [serial 1260] used for:
   add user-defined axioms to postcondition 
Theorem (68) [serial 1260] used for:
   add user-defined axioms to postcondition 


Theorem (70)                               [serial 1263] 
P [103] << all #0# ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - #0# ) or not SENSOR_CONNECTED^( 1 - #0# ) then 0 Hz else HEART_RATE^( 1 - #0# )) = heart_rate_store[#0#]  >>
S [51] ->
Q [51] << all #1# ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - #1# ) or not SENSOR_CONNECTED^( 1 - #1# ) then 0 Hz else HEART_RATE^( 1 - #1# )) = heart_rate_store[#1#]  >>
Why created:  Replacement of Quantified Variables with #1, #2, etc.  [serial 1262]
Solved by:  Identity (id):  P->P is tautology


Theorem (71)                               [serial 1262] 
P [103] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]  >>
S [51] ->
Q [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s ))  ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1193]
Solved by:  Replacement of Quantified Variables with #1, #2, etc.
and theorem 70:
Theorem (70) [serial 1263] used for:
  Replacement of Quantified Variables with #1, #2, etc.  [serial 1262] 


Theorem (72)                               [serial 1193] 
P [103] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]  >>
S [51] ->
Q [51] << HOLD_HR(num_samples) >>
Why created:  <<Q6>> -> <<Q>> in sequential composition for [serial 1190]
Solved by:  Substitution of Assertion Labels
and theorem 71:
Theorem (71) [serial 1262] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1193] 


Theorem (73)                               [serial 1328] 
P [62] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and HEART_RATE_HISTORY = HeartRateTrend
  and HEART_RATE_HISTORY = heart_rate_store
  and NUM_SAMPLES = num_samples >>
S [63] ->
Q [63] << HEART_RATE_HISTORY = heart_rate_store >>
Why created:    normalization of [serial 1326]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (74)                               [serial 1326] 
P [62] << num_samples = NUM_SAMPLES
  and heart_rate_store = HEART_RATE_HISTORY
  and HEART_RATE_HISTORY = HeartRateTrend
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  ) >>
S [63] ->
Q [63] << HEART_RATE_HISTORY = heart_rate_store >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1325]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 73:
Theorem (73) [serial 1328] used for:
    normalization of [serial 1326] 


Theorem (75)                               [serial 1325] 
P [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and ( num_samples = NUM_SAMPLES
  and heart_rate_store = HEART_RATE_HISTORY
  and HEART_RATE_HISTORY = HeartRateTrend )
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  ) >>
S [63] ->
Q [63] << HEART_RATE_HISTORY = heart_rate_store >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1225]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 74:
Theorem (74) [serial 1326] used for:
  Associativity: a.(b.c) = a.b.c [serial 1325] 


Theorem (76)                               [serial 1225] 
P [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_HRT()
  and INV_HR() >>
S [63] ->
Q [63] << HEART_RATE_HISTORY = heart_rate_store >>
Why created:    normalization of [serial 1213]
Solved by:  Substitution of Assertion Labels
and theorem 75:
Theorem (75) [serial 1325] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1225] 


Theorem (77)                               [serial 1213] 
P [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_HRT()
  and INV_HR() >>
S [63] ->
Q [63] << heart_rate_store = HEART_RATE_HISTORY >>
Why created:  applied port output of value <<pre>> -> <<M(HeartRateTrend)[HeartRateTrend|heart_rate_store]>> [serial 1194]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 76:
Theorem (76) [serial 1225] used for:
    normalization of [serial 1213] 


Theorem (78)                               [serial 1227] 
P [63] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_HRT()
  and INV_HR() )
  and ( HEART_RATE_HISTORY = heart_rate_store )^0 >>
S [63] ->
Q [65] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_HRT()
  and INV_HR() >>
Why created:    normalization of [serial 1214]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (79)                               [serial 1214] 
P [63] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_HRT()
  and INV_HR() )
  and ( heart_rate_store = HEART_RATE_HISTORY )^0 >>
S [63] ->
Q [65] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_HRT()
  and INV_HR() >>
Why created:  applied port output <<pre and (heart_rate_store = HEART_RATE_HISTORY)^0>> -> <<post>> [serial 1194]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Associativity: a.(b.c) = a.b.c
and theorem 78:
Theorem (78) [serial 1227] used for:
    normalization of [serial 1214] 


Theorem (80)                               [serial 1194] 
P [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_HRT()
  and INV_HR() >>
S [63] HeartRateTrend!(heart_rate_store)
Q [65] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_HRT()
  and INV_HR() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1190]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 77 79:
Theorem (77) [serial 1213] used for:
  applied port output of value <<pre>> -> <<M(HeartRateTrend)[HeartRateTrend|heart_rate_store]>> [serial 1194] 
Theorem (79) [serial 1214] used for:
  applied port output <<pre and (heart_rate_store = HEART_RATE_HISTORY)^0>> -> <<post>> [serial 1194] 


Theorem (81)                               [serial 1333] 
P [65] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and HEART_RATE_HISTORY = HeartRateTrend
  and HEART_RATE_HISTORY = heart_rate_store
  and NUM_SAMPLES = num_samples >>
S [66] ->
Q [66] << NUM_SAMPLES = num_samples >>
Why created:    normalization of [serial 1331]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (82)                               [serial 1331] 
P [65] << num_samples = NUM_SAMPLES
  and heart_rate_store = HEART_RATE_HISTORY
  and HEART_RATE_HISTORY = HeartRateTrend
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  ) >>
S [66] ->
Q [66] << NUM_SAMPLES = num_samples >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1330]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 81:
Theorem (81) [serial 1333] used for:
    normalization of [serial 1331] 


Theorem (83)                               [serial 1330] 
P [65] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and ( num_samples = NUM_SAMPLES
  and heart_rate_store = HEART_RATE_HISTORY
  and HEART_RATE_HISTORY = HeartRateTrend )
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  ) >>
S [66] ->
Q [66] << NUM_SAMPLES = num_samples >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1229]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 82:
Theorem (82) [serial 1331] used for:
  Associativity: a.(b.c) = a.b.c [serial 1330] 


Theorem (84)                               [serial 1229] 
P [65] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_HRT()
  and INV_HR() >>
S [66] ->
Q [66] << NUM_SAMPLES = num_samples >>
Why created:    normalization of [serial 1215]
Solved by:  Substitution of Assertion Labels
and theorem 83:
Theorem (83) [serial 1330] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1229] 


Theorem (85)                               [serial 1215] 
P [65] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_HRT()
  and INV_HR() >>
S [66] ->
Q [66] << num_samples = NUM_SAMPLES >>
Why created:  applied port output of value <<pre>> -> <<M(NumSamples)[NumSamples|num_samples]>> [serial 1195]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 84:
Theorem (84) [serial 1229] used for:
    normalization of [serial 1215] 


Theorem (86)                               [serial 1258] 
P [66] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_HRT()
  and INV_HR()
  and ( NUM_SAMPLES = num_samples )^0 >>
S [66] ->
Q [68] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and INV_HR() >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1231]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (87)                               [serial 1231] 
P [66] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_HRT()
  and INV_HR() )
  and ( NUM_SAMPLES = num_samples )^0 >>
S [66] ->
Q [68] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and INV_HR() >>
Why created:    normalization of [serial 1216]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 86:
Theorem (86) [serial 1258] used for:
  Associativity: a.(b.c) = a.b.c [serial 1231] 


Theorem (88)                               [serial 1216] 
P [66] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_HRT()
  and INV_HR() )
  and ( num_samples = NUM_SAMPLES )^0 >>
S [66] ->
Q [68] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and INV_HR() >>
Why created:  applied port output <<pre and (num_samples = NUM_SAMPLES)^0>> -> <<post>> [serial 1195]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Associativity: a.(b.c) = a.b.c
and theorem 87:
Theorem (87) [serial 1231] used for:
    normalization of [serial 1216] 


Theorem (89)                               [serial 1195] 
P [65] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_HRT()
  and INV_HR() >>
S [66] NumSamples!(num_samples)
Q [68] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and INV_HR() >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1190]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 85 88:
Theorem (85) [serial 1215] used for:
  applied port output of value <<pre>> -> <<M(NumSamples)[NumSamples|num_samples]>> [serial 1195] 
Theorem (88) [serial 1216] used for:
  applied port output <<pre and (num_samples = NUM_SAMPLES)^0>> -> <<post>> [serial 1195] 


Theorem (90)                               [serial 1217] 
P [71] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = heart_rate_store[i] >>
S [72] ->
Q [73] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = heart_rate_store[i] >>
Why created:  applied wp for assignment [serial 1200]
Solved by:  Identity (id):  P->P is tautology


Theorem (91)                               [serial 1200] 
P [71] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = heart_rate_store[i] >>
S [72] hr_nxt[1 + i] := heart_rate_store[i]
Q [73] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
1 + i] >>
Why created:  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1196]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 90:
Theorem (90) [serial 1217] used for:
  applied wp for assignment [serial 1200] 


Theorem (92)                               [serial 1339] 
P [68] << ( all #4# ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - #4# ) or not SENSOR_CONNECTED^( - #4# ) then 0 Hz else HEART_RATE^( - #4# )) = heart_rate_store[#4#]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [69] ->
Q [19] << all #5# ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - #5# ) or not SENSOR_CONNECTED^( - #5# ) then 0 Hz else HEART_RATE^( - #5# )) = heart_rate_store[#5#]  >>
Why created:  Replacement of Quantified Variables with #1, #2, etc.  [serial 1337]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (93)                               [serial 1337] 
P [68] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [69] ->
Q [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = heart_rate_store[i]  >>
Why created:    normalization of [serial 1335]
Solved by:  Replacement of Quantified Variables with #1, #2, etc.
and theorem 92:
Theorem (92) [serial 1339] used for:
  Replacement of Quantified Variables with #1, #2, etc.  [serial 1337] 


Theorem (94)                               [serial 1335] 
P [68] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  ) >>
S [69] ->
Q [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = heart_rate_store[i]  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1233]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 93:
Theorem (93) [serial 1337] used for:
    normalization of [serial 1335] 


Theorem (95)                               [serial 1233] 
P [68] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and INV_HR() >>
S [69] ->
Q [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = heart_rate_store[i]  >>
Why created:    normalization of [serial 1201]
Solved by:  Substitution of Assertion Labels
and theorem 94:
Theorem (94) [serial 1335] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1233] 


Theorem (96)                               [serial 1201] 
P [68] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples
  and INV_HR() ) >>
S [69] ->
Q [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = heart_rate_store[i]  >>
Why created:    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1196]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 95:
Theorem (95) [serial 1233] used for:
    normalization of [serial 1201] 


Theorem (97)                               [serial 1202] 
P [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  >>
S [69] ->
Q [75] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  >>
Why created:    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1196]
Solved by:  Identity (id):  P->P is tautology


Theorem (98)                               [serial 1196] 
P [68] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and INV_HR() >>
S [69] forall i in 1 .. num_samples
    {
    << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = heart_rate_store[i] >>
    hr_nxt[1 + i] := heart_rate_store[i]
    << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
    1 + i] >>
    }  
Q [75] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1190]
Solved by:  Universal Quantification Rule:
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any
and theorems 91 96 97:
Theorem (91) [serial 1200] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1196] 
Theorem (96) [serial 1201] used for:
    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1196] 
Theorem (97) [serial 1202] used for:
    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1196] 


Theorem (99)                               [serial 1259] 
P [75] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  >>
S [78] ->
Q [78] << true >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1237]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (100)                               [serial 1237] 
P [75] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  >>
S [78] ->
Q [78] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) or not ( MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0 ) >>
Why created:    normalization of [serial 1203]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 99:
Theorem (99) [serial 1259] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1237] 


Theorem (101)                               [serial 1203] 
P [75] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  >>
S [78] ->
Q [78] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) or ( not ( MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0 ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1197]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 100:
Theorem (100) [serial 1237] used for:
    normalization of [serial 1203] 


Theorem (102)                               [serial 1265] 
P [78] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [78] ->
Q [80] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1264]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (103)                               [serial 1274] 
P [78] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 Hz else HEART_RATE^( - i - 1 )) = hr_nxt[
      2 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [78] ->
Q [75] << all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 Hz else HEART_RATE^( - i - 1 )) = hr_nxt[
      2 + i]  >>
Why created:    normalization of [serial 1272]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (104)                               [serial 1272] 
P [78] << ( all i ~ quantity whole 
  in 0 .. ( num_samples + - 1 ) 
  are (if MOTION_ARTIFACT^( ( - 1 + - i ) ) or not SENSOR_CONNECTED^( ( 
      - 1 + - i ) ) then 0 Hz else HEART_RATE^( ( - 1 + - i ) )) = hr_nxt[
      2 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [78] ->
Q [75] << all i ~ quantity whole 
  in 0 .. ( num_samples + - 1 ) 
  are (if MOTION_ARTIFACT^( ( - 1 + - i ) ) or not SENSOR_CONNECTED^( ( 
      - 1 + - i ) ) then 0 Hz else HEART_RATE^( ( - 1 + - i ) )) = hr_nxt[
      2 + i]  >>
Why created:   changing adding negation to subtraction  [serial 1270]
Solved by:  Reflexivity of Addition: a+b=b+a
  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 103:
Theorem (103) [serial 1274] used for:
    normalization of [serial 1272] 


Theorem (105)                               [serial 1270] 
P [78] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( -(1 + i) ) or not SENSOR_CONNECTED^( -(1 + i) ) then 0 Hz else HEART_RATE^( -(
      1 + i) )) = hr_nxt[2 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [78] ->
Q [75] << all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( -(1 + i) ) or not SENSOR_CONNECTED^( -(1 + i) ) then 0 Hz else HEART_RATE^( -(
      1 + i) )) = hr_nxt[2 + i]  >>
Why created:    normalization of [serial 1268]
Solved by:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 104:
Theorem (104) [serial 1272] used for:
   changing adding negation to subtraction  [serial 1270] 


Theorem (106)                               [serial 1268] 
P [78] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( -(1 + i) ) or not SENSOR_CONNECTED^( -(1 + i) ) then 0 Hz else HEART_RATE^( -(
      1 + i) )) = hr_nxt[1 + i + 1]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [78] ->
Q [75] << all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( -(1 + i) ) or not SENSOR_CONNECTED^( -(1 + i) ) then 0 Hz else HEART_RATE^( -(
      1 + i) )) = hr_nxt[1 + i + 1]  >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1267]
Solved by:  Literal Arithmetic
  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 105:
Theorem (105) [serial 1270] used for:
    normalization of [serial 1268] 


Theorem (107)                               [serial 1267] 
P [78] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( -(1 + i) ) or not SENSOR_CONNECTED^( -(1 + i) ) then 0 Hz else HEART_RATE^( -(
      1 + i) )) = hr_nxt[( 1 + i ) + 1]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [78] ->
Q [75] << all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( -(1 + i) ) or not SENSOR_CONNECTED^( -(1 + i) ) then 0 Hz else HEART_RATE^( -(
      1 + i) )) = hr_nxt[( 1 + i ) + 1]  >>
Why created:  Shift Quantification Range so Lower Bound is Zero  [serial 1266]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 106:
Theorem (106) [serial 1268] used for:
  Associativity: a.(b.c) = a.b.c [serial 1267] 


Theorem (108)                               [serial 1266] 
P [78] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [78] ->
Q [75] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are hr_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))  ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1264]
Solved by:  Shift Quantification Range so Lower Bound is Zero
and theorem 107:
Theorem (107) [serial 1267] used for:
  Shift Quantification Range so Lower Bound is Zero  [serial 1266] 


Theorem (109)                               [serial 1264] 
P [78] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [78] ->
Q [80] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and ( all i ~ quantity whole 
  in 1 .. num_samples 
  are hr_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))  ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1204]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 102 108:
Theorem (102) [serial 1265] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1264] 
Theorem (108) [serial 1266] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1264] 


Theorem (110)                               [serial 1204] 
P [78] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [78] ->
Q [80] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFT_HR() >>
Why created:    <<P and B0>> -> <<P0>> in alternative for [serial 1197]
Solved by:  Substitution of Assertion Labels
and theorem 109:
Theorem (109) [serial 1264] used for:
  Substituted assertions' predicates for labels  [serial 1204] 


Theorem (111)                               [serial 1280] 
P [80] << ( MOTION_ARTIFACT or not SENSOR_CONNECTED )
  and SHFT_HR() >>
S [81] ->
Q [82] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1279]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (112)                               [serial 1279] 
P [80] << ( MOTION_ARTIFACT or not SENSOR_CONNECTED )
  and SHFT_HR() >>
S [81] ->
Q [82] << 0 Hz = 0 Hz >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1278]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 111:
Theorem (111) [serial 1280] used for:
  Equality Law (idistr):  a=a <-> true [serial 1279] 


Theorem (113)                               [serial 1278] 
P [80] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFT_HR() >>
S [81] ->
Q [82] << 0 Hz = 0 Hz >>
Why created:   Conditional True Expression:  b and x=e  iff  b and x=(b??e:g)   [serial 1276]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 112:
Theorem (112) [serial 1279] used for:
  Assume Present:  P = P@now = P^0   [serial 1278] 


Theorem (114)                               [serial 1276] 
P [80] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFT_HR() >>
S [81] ->
Q [82] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = 0 Hz >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1218]
Solved by:  Conditional True Expression:  b and x=e  iff  b and x=(b??e:g) 
and theorem 113:
Theorem (113) [serial 1278] used for:
   Conditional True Expression:  b and x=e  iff  b and x=(b??e:g)   [serial 1276] 


Theorem (115)                               [serial 1277] 
P [80] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFT_HR() >>
S [81] ->
Q [82] << SHFT_HR() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1218]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (116)                               [serial 1218] 
P [80] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFT_HR() >>
S [81] ->
Q [82] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = 0 Hz
  and SHFT_HR() >>
Why created:  applied wp for assignment [serial 1205]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 114 115:
Theorem (114) [serial 1276] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1218] 
Theorem (115) [serial 1277] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1218] 


Theorem (117)                               [serial 1205] 
P [80] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFT_HR() >>
S [81] hr_nxt[1] := 0 Hz
Q [82] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and SHFT_HR() >>
Why created:    <<P0>> S0 <<Q0>> in alternative for [serial 1197]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 116:
Theorem (116) [serial 1218] used for:
  applied wp for assignment [serial 1205] 


Theorem (118)                               [serial 1297] 
P [82] << ( all #2# ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - #2# - 1 ) or not SENSOR_CONNECTED^( - #2# - 1 ) then 0 Hz else HEART_RATE^( - #2# - 1 )) = hr_nxt[
      2 + #2#]  )
  and (if MOTION_ARTIFACT or not SENSOR_CONNECTED then 0 Hz else HEART_RATE) = hr_nxt[1] >>
S [78] ->
Q [90] << all #3# ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - #3# - 1 ) or not SENSOR_CONNECTED^( - #3# - 1 ) then 0 Hz else HEART_RATE^( - #3# - 1 )) = hr_nxt[
      2 + #3#]  >>
Why created:    normalization of [serial 1295]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (119)                               [serial 1295] 
P [82] << ( all #2# ~ quantity whole 
  in 0 .. ( num_samples + - 1 ) 
  are (if MOTION_ARTIFACT^( - #2# + - 1 ) or not SENSOR_CONNECTED^( - #2# + 
      - 1 ) then 0 Hz else HEART_RATE^( - #2# + - 1 )) = hr_nxt[2 + #2#]  )
  and (if MOTION_ARTIFACT or not SENSOR_CONNECTED then 0 Hz else HEART_RATE) = hr_nxt[1] >>
S [78] ->
Q [90] << all #3# ~ quantity whole 
  in 0 .. ( - 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( - 1 + - #3# ) or not SENSOR_CONNECTED^( - 1 + 
      - #3# ) then 0 Hz else HEART_RATE^( - 1 + - #3# )) = hr_nxt[2 + #3#]  >>
Why created:   changing adding negation to subtraction  [serial 1294]
Solved by:  Reflexivity of Addition: a+b=b+a
  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 118:
Theorem (118) [serial 1297] used for:
    normalization of [serial 1295] 


Theorem (120)                               [serial 1294] 
P [82] << ( all #2# ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - #2# - 1 ) or not SENSOR_CONNECTED^( - #2# - 1 ) then 0 Hz else HEART_RATE^( - #2# - 1 )) = hr_nxt[
      2 + #2#]  )
  and (if MOTION_ARTIFACT or not SENSOR_CONNECTED then 0 Hz else HEART_RATE) = hr_nxt[1] >>
S [78] ->
Q [90] << all #3# ~ quantity whole 
  in 0 .. ( -1 + num_samples ) 
  are (if MOTION_ARTIFACT^( -1 + - #3# ) or not SENSOR_CONNECTED^( -1 + 
      - #3# ) then 0 Hz else HEART_RATE^( -1 + - #3# )) = hr_nxt[2 + #3#]  >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1293]
Solved by:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 119:
Theorem (119) [serial 1295] used for:
   changing adding negation to subtraction  [serial 1294] 


Theorem (121)                               [serial 1293] 
P [82] << ( all #2# ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - #2# - 1 ) or not SENSOR_CONNECTED^( - #2# - 1 ) then 0 Hz else HEART_RATE^( - #2# - 1 )) = hr_nxt[
      2 + #2#]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
S [78] ->
Q [90] << all #3# ~ quantity whole 
  in 0 .. ( -1 + num_samples ) 
  are (if MOTION_ARTIFACT^( -1 + - #3# ) or not SENSOR_CONNECTED^( -1 + 
      - #3# ) then 0 Hz else HEART_RATE^( -1 + - #3# )) = hr_nxt[2 + #3#]  >>
Why created:  Replacement of Quantified Variables with #1, #2, etc.  [serial 1291]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 120:
Theorem (120) [serial 1294] used for:
  Assume Present:  P = P@now = P^0   [serial 1293] 


Theorem (122)                               [serial 1291] 
P [82] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 Hz else HEART_RATE^( - i - 1 )) = hr_nxt[
      2 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
S [78] ->
Q [90] << all i ~ quantity whole 
  in 0 .. ( -1 + num_samples ) 
  are (if MOTION_ARTIFACT^( -1 + - i ) or not SENSOR_CONNECTED^( -1 + - i ) then 0 Hz else HEART_RATE^( 
      -1 + - i )) = hr_nxt[2 + i]  >>
Why created:    normalization of [serial 1289]
Solved by:  Replacement of Quantified Variables with #1, #2, etc.
and theorem 121:
Theorem (121) [serial 1293] used for:
  Replacement of Quantified Variables with #1, #2, etc.  [serial 1291] 


Theorem (123)                               [serial 1289] 
P [82] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 Hz else HEART_RATE^( - i - 1 )) = hr_nxt[
      1 + i + 1]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
S [78] ->
Q [90] << all i ~ quantity whole 
  in 0 .. ( -1 + num_samples ) 
  are (if MOTION_ARTIFACT^( -1 + - i ) or not SENSOR_CONNECTED^( -1 + - i ) then 0 Hz else HEART_RATE^( 
      -1 + - i )) = hr_nxt[2 + i]  >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1287]
Solved by:  Literal Arithmetic
  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 122:
Theorem (122) [serial 1291] used for:
    normalization of [serial 1289] 


Theorem (124)                               [serial 1287] 
P [82] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 Hz else HEART_RATE^( - i - 1 )) = hr_nxt[
      ( 1 + i ) + 1]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
S [78] ->
Q [90] << all i ~ quantity whole 
  in 0 .. ( -1 + num_samples ) 
  are (if MOTION_ARTIFACT^( -1 + - i ) or not SENSOR_CONNECTED^( -1 + - i ) then 0 Hz else HEART_RATE^( 
      -1 + - i )) = hr_nxt[2 + i]  >>
Why created:    normalization of [serial 1285]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 123:
Theorem (123) [serial 1289] used for:
  Associativity: a.(b.c) = a.b.c [serial 1287] 


Theorem (125)                               [serial 1285] 
P [82] << ( all i ~ quantity whole 
  in 0 .. ( num_samples + - 1 ) 
  are (if MOTION_ARTIFACT^( ( - 1 + - i ) ) or not SENSOR_CONNECTED^( ( 
      - 1 + - i ) ) then 0 Hz else HEART_RATE^( ( - 1 + - i ) )) = hr_nxt[
      ( 1 + i ) + 1]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
S [78] ->
Q [90] << all i ~ quantity whole 
  in 0 .. ( 1 + num_samples + - 2 ) 
  are (if MOTION_ARTIFACT^( 1 + - 2 + - i ) or not SENSOR_CONNECTED^( 1 + 
      - 2 + - i ) then 0 Hz else HEART_RATE^( 1 + - 2 + - i )) = hr_nxt[
      2 + i]  >>
Why created:   changing adding negation to subtraction  [serial 1284]
Solved by:  Literal Arithmetic
  Reflexivity of Addition: a+b=b+a
  Unary Minus:  -(x-y) is (y-x)
  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 124:
Theorem (124) [serial 1287] used for:
    normalization of [serial 1285] 


Theorem (126)                               [serial 1284] 
P [82] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( -(1 + i) ) or not SENSOR_CONNECTED^( -(1 + i) ) then 0 Hz else HEART_RATE^( -(
      1 + i) )) = hr_nxt[( 1 + i ) + 1]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
S [78] ->
Q [90] << all i ~ quantity whole 
  in 0 .. ( ( 1 + num_samples ) - 2 ) 
  are (if MOTION_ARTIFACT^( 1 - ( 2 + i ) ) or not SENSOR_CONNECTED^( 1 - ( 
      2 + i ) ) then 0 Hz else HEART_RATE^( 1 - ( 2 + i ) )) = hr_nxt[2 + 
      i]  >>
Why created:  Shift Quantification Range so Lower Bound is Zero  [serial 1283]
Solved by:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 125:
Theorem (125) [serial 1285] used for:
   changing adding negation to subtraction  [serial 1284] 


Theorem (127)                               [serial 1283] 
P [82] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and ( all i ~ quantity whole 
  in 1 .. num_samples 
  are hr_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))  ) >>
S [78] ->
Q [90] << ( all i ~ quantity whole 
  in 2 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1281]
Solved by:  Shift Quantification Range so Lower Bound is Zero
and theorem 126:
Theorem (126) [serial 1284] used for:
  Shift Quantification Range so Lower Bound is Zero  [serial 1283] 


Theorem (128)                               [serial 1281] 
P [82] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and SHFT_HR() >>
S [78] ->
Q [90] << ( all i ~ quantity whole 
  in 2 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1206]
Solved by:  Substitution of Assertion Labels
and theorem 127:
Theorem (127) [serial 1283] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1281] 


Theorem (129)                               [serial 1282] 
P [82] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and SHFT_HR() >>
S [78] ->
Q [89] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1206]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (130)                               [serial 1206] 
P [82] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and SHFT_HR() >>
S [78] ->
Q [89] << ( all i ~ quantity whole 
  in 2 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
Why created:    <<Q0>> -> <<Q>> in alternative  for [serial 1197]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 128 129:
Theorem (128) [serial 1281] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1206] 
Theorem (129) [serial 1282] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1206] 


Theorem (131)                               [serial 1342] 
P [78] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [78] ->
Q [85] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:    normalization of [serial 1340]
Solved by:  Identity (id):  P->P is tautology


Theorem (132)                               [serial 1340] 
P [78] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [78] ->
Q [85] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are hr_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))  )
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1242]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 131:
Theorem (131) [serial 1342] used for:
    normalization of [serial 1340] 


Theorem (133)                               [serial 1242] 
P [78] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [78] ->
Q [85] << SHFT_HR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:    normalization of [serial 1207]
Solved by:  Substitution of Assertion Labels
and theorem 132:
Theorem (132) [serial 1340] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1242] 


Theorem (134)                               [serial 1207] 
P [78] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and ( not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) ) >>
S [78] ->
Q [85] << SHFT_HR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:    <<P and B1>> -> <<P1>> in alternative for [serial 1197]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 133:
Theorem (133) [serial 1242] used for:
    normalization of [serial 1207] 


Theorem (135)                               [serial 1304] 
P [85] << SHFT_HR()
  and not ( MOTION_ARTIFACT or not SENSOR_CONNECTED ) >>
S [86] ->
Q [87] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1303]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (136)                               [serial 1303] 
P [85] << SHFT_HR()
  and not ( MOTION_ARTIFACT or not SENSOR_CONNECTED ) >>
S [86] ->
Q [87] << HEART_RATE = HEART_RATE >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1302]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 135:
Theorem (135) [serial 1304] used for:
  Equality Law (idistr):  a=a <-> true [serial 1303] 


Theorem (137)                               [serial 1302] 
P [85] << SHFT_HR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [86] ->
Q [87] << HEART_RATE = HEART_RATE^0 >>
Why created:  Replacing port names with BLESS::Value properties  [serial 1300]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 136:
Theorem (136) [serial 1303] used for:
  Assume Present:  P = P@now = P^0   [serial 1302] 


Theorem (138)                               [serial 1300] 
P [85] << SHFT_HR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [86] ->
Q [87] << HeartRate = HEART_RATE^0 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1299]
Solved by:  Replacing port names with BLESS::Value properties
and theorem 137:
Theorem (137) [serial 1302] used for:
  Replacing port names with BLESS::Value properties  [serial 1300] 


Theorem (139)                               [serial 1301] 
P [85] << SHFT_HR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [86] ->
Q [87] << SHFT_HR() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1299]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (140)                               [serial 1299] 
P [85] << SHFT_HR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [86] ->
Q [87] << HeartRate = HEART_RATE^0
  and SHFT_HR() >>
Why created:   Conditional False Expression:  not b and x=g  iff  not b and x=(b??e:g)   [serial 1219]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 138 139:
Theorem (138) [serial 1300] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1299] 
Theorem (139) [serial 1301] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1299] 


Theorem (141)                               [serial 1219] 
P [85] << SHFT_HR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [86] ->
Q [87] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = HeartRate
  and SHFT_HR() >>
Why created:  applied wp for assignment [serial 1208]
Solved by:  Conditional False Expression:  not b and x=g  iff  not b and x=(b??e:g) 
and theorem 140:
Theorem (140) [serial 1299] used for:
   Conditional False Expression:  not b and x=g  iff  not b and x=(b??e:g)   [serial 1219] 


Theorem (142)                               [serial 1208] 
P [85] << SHFT_HR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [86] hr_nxt[1] := HeartRate
Q [87] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and SHFT_HR() >>
Why created:    <<P1>> S1 <<Q1>> in alternative for [serial 1197]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 141:
Theorem (141) [serial 1219] used for:
  applied wp for assignment [serial 1208] 


Theorem (143)                               [serial 1322] 
P [87] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 Hz else HEART_RATE^( - i - 1 )) = hr_nxt[
      2 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
S [78] ->
Q [90] << all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 Hz else HEART_RATE^( - i - 1 )) = hr_nxt[
      2 + i]  >>
Why created:    normalization of [serial 1320]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (144)                               [serial 1320] 
P [87] << ( all i ~ quantity whole 
  in 0 .. ( num_samples + - 1 ) 
  are (if MOTION_ARTIFACT^( - i + - 1 ) or not SENSOR_CONNECTED^( - i + 
      - 1 ) then 0 Hz else HEART_RATE^( - i + - 1 )) = hr_nxt[2 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
S [78] ->
Q [90] << all i ~ quantity whole 
  in 0 .. ( - 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( - 1 + - i ) or not SENSOR_CONNECTED^( - 1 + 
      - i ) then 0 Hz else HEART_RATE^( - 1 + - i )) = hr_nxt[2 + i]  >>
Why created:   changing adding negation to subtraction  [serial 1318]
Solved by:  Reflexivity of Addition: a+b=b+a
  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 143:
Theorem (143) [serial 1322] used for:
    normalization of [serial 1320] 


Theorem (145)                               [serial 1318] 
P [87] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 Hz else HEART_RATE^( - i - 1 )) = hr_nxt[
      2 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
S [78] ->
Q [90] << all i ~ quantity whole 
  in 0 .. ( -1 + num_samples ) 
  are (if MOTION_ARTIFACT^( -1 + - i ) or not SENSOR_CONNECTED^( -1 + - i ) then 0 Hz else HEART_RATE^( 
      -1 + - i )) = hr_nxt[2 + i]  >>
Why created:    normalization of [serial 1316]
Solved by:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 144:
Theorem (144) [serial 1320] used for:
   changing adding negation to subtraction  [serial 1318] 


Theorem (146)                               [serial 1316] 
P [87] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 Hz else HEART_RATE^( - i - 1 )) = hr_nxt[
      1 + i + 1]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
S [78] ->
Q [90] << all i ~ quantity whole 
  in 0 .. ( -1 + num_samples ) 
  are (if MOTION_ARTIFACT^( -1 + - i ) or not SENSOR_CONNECTED^( -1 + - i ) then 0 Hz else HEART_RATE^( 
      -1 + - i )) = hr_nxt[2 + i]  >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1314]
Solved by:  Literal Arithmetic
  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 145:
Theorem (145) [serial 1318] used for:
    normalization of [serial 1316] 


Theorem (147)                               [serial 1314] 
P [87] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 Hz else HEART_RATE^( - i - 1 )) = hr_nxt[
      ( 1 + i ) + 1]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
S [78] ->
Q [90] << all i ~ quantity whole 
  in 0 .. ( -1 + num_samples ) 
  are (if MOTION_ARTIFACT^( -1 + - i ) or not SENSOR_CONNECTED^( -1 + - i ) then 0 Hz else HEART_RATE^( 
      -1 + - i )) = hr_nxt[2 + i]  >>
Why created:    normalization of [serial 1312]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 146:
Theorem (146) [serial 1316] used for:
  Associativity: a.(b.c) = a.b.c [serial 1314] 


Theorem (148)                               [serial 1312] 
P [87] << ( all i ~ quantity whole 
  in 0 .. ( num_samples + - 1 ) 
  are (if MOTION_ARTIFACT^( ( - 1 + - i ) ) or not SENSOR_CONNECTED^( ( 
      - 1 + - i ) ) then 0 Hz else HEART_RATE^( ( - 1 + - i ) )) = hr_nxt[
      ( 1 + i ) + 1]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
S [78] ->
Q [90] << all i ~ quantity whole 
  in 0 .. ( 1 + num_samples + - 2 ) 
  are (if MOTION_ARTIFACT^( 1 + - 2 + - i ) or not SENSOR_CONNECTED^( 1 + 
      - 2 + - i ) then 0 Hz else HEART_RATE^( 1 + - 2 + - i )) = hr_nxt[
      2 + i]  >>
Why created:   changing adding negation to subtraction  [serial 1311]
Solved by:  Literal Arithmetic
  Reflexivity of Addition: a+b=b+a
  Unary Minus:  -(x-y) is (y-x)
  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 147:
Theorem (147) [serial 1314] used for:
    normalization of [serial 1312] 


Theorem (149)                               [serial 1311] 
P [87] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( -(1 + i) ) or not SENSOR_CONNECTED^( -(1 + i) ) then 0 Hz else HEART_RATE^( -(
      1 + i) )) = hr_nxt[( 1 + i ) + 1]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
S [78] ->
Q [90] << all i ~ quantity whole 
  in 0 .. ( ( 1 + num_samples ) - 2 ) 
  are (if MOTION_ARTIFACT^( 1 - ( 2 + i ) ) or not SENSOR_CONNECTED^( 1 - ( 
      2 + i ) ) then 0 Hz else HEART_RATE^( 1 - ( 2 + i ) )) = hr_nxt[2 + 
      i]  >>
Why created:  Shift Quantification Range so Lower Bound is Zero  [serial 1309]
Solved by:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 148:
Theorem (148) [serial 1312] used for:
   changing adding negation to subtraction  [serial 1311] 


Theorem (150)                               [serial 1309] 
P [87] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
S [78] ->
Q [90] << ( all i ~ quantity whole 
  in 2 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1307]
Solved by:  Shift Quantification Range so Lower Bound is Zero
and theorem 149:
Theorem (149) [serial 1311] used for:
  Shift Quantification Range so Lower Bound is Zero  [serial 1309] 


Theorem (151)                               [serial 1310] 
P [87] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
S [78] ->
Q [89] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1307]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (152)                               [serial 1307] 
P [87] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
S [78] ->
Q [89] << ( all i ~ quantity whole 
  in 2 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
Why created:    normalization of [serial 1305]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 150 151:
Theorem (150) [serial 1309] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1307] 
Theorem (151) [serial 1310] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1307] 


Theorem (153)                               [serial 1305] 
P [87] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and ( all i ~ quantity whole 
  in 1 .. num_samples 
  are hr_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))  ) >>
S [78] ->
Q [89] << ( all i ~ quantity whole 
  in 2 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1209]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 152:
Theorem (152) [serial 1307] used for:
    normalization of [serial 1305] 


Theorem (154)                               [serial 1209] 
P [87] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and SHFT_HR() >>
S [78] ->
Q [89] << ( all i ~ quantity whole 
  in 2 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
Why created:    <<Q1>> -> <<Q>> in alternative  for [serial 1197]
Solved by:  Substitution of Assertion Labels
and theorem 153:
Theorem (153) [serial 1305] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1209] 


Theorem (155)                               [serial 1197] 
P [75] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  >>
S [78]   if 
    (MotionArtifact? or not SensorConnected?)~> 
      << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
        and SHFT_HR() >>
      hr_nxt[1] := 0 Hz
      << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
        and SHFT_HR() >> 
  []
    (not ( MotionArtifact? or not SensorConnected? ))~> 
      << SHFT_HR()
        and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
      hr_nxt[1] := HeartRate
      << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
        and SHFT_HR() >> 
  fi
Q [89] << ( all i ~ quantity whole 
  in 2 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
Why created:  <<Q3 and P4>> S4 <<Q4 and P5>> in sequential composition for [serial 1190]
Solved by:  Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>>
and theorems 101 110 117 130 134 142 154:
Theorem (101) [serial 1203] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1197] 
Theorem (110) [serial 1204] used for:
    <<P and B0>> -> <<P0>> in alternative for [serial 1197] 
Theorem (117) [serial 1205] used for:
    <<P0>> S0 <<Q0>> in alternative for [serial 1197] 
Theorem (130) [serial 1206] used for:
    <<Q0>> -> <<Q>> in alternative  for [serial 1197] 
Theorem (134) [serial 1207] used for:
    <<P and B1>> -> <<P1>> in alternative for [serial 1197] 
Theorem (142) [serial 1208] used for:
    <<P1>> S1 <<Q1>> in alternative for [serial 1197] 
Theorem (154) [serial 1209] used for:
    <<Q1>> -> <<Q>> in alternative  for [serial 1197] 


Theorem (156)                               [serial 1324] 
P [89] << ( all i ~ quantity whole 
  in 1 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
S [93] ->
Q [94] << all i ~ quantity whole 
  in 1 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  >>
Why created:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1220]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (157)                               [serial 1220] 
P [89] << ( all i ~ quantity whole 
  in 2 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
S [93] ->
Q [94] << all i ~ quantity whole 
  in 1 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  >>
Why created:  applied wp for assignment [serial 1198]
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
and theorem 156:
Theorem (156) [serial 1324] used for:
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1220] 


Theorem (158)                               [serial 1198] 
P [89] << ( all i ~ quantity whole 
  in 2 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
S [93] num_samples := 1 + num_samples
Q [94] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  >>
Why created:  <<Q4 and P5>> S5 <<Q5 and P6>> in sequential composition for [serial 1190]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 157:
Theorem (157) [serial 1220] used for:
  applied wp for assignment [serial 1198] 


Theorem (159)                               [serial 1221] 
P [99] << (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i] >>
S [100] ->
Q [101] << (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i] >>
Why created:  applied wp for assignment [serial 1210]
Solved by:  Identity (id):  P->P is tautology


Theorem (160)                               [serial 1210] 
P [99] << (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i] >>
S [100] heart_rate_store[i] := hr_nxt[i]
Q [101] << (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i] >>
Why created:  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1199]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 159:
Theorem (159) [serial 1221] used for:
  applied wp for assignment [serial 1210] 


Theorem (161)                               [serial 1247] 
P [94] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  >>
S [97] ->
Q [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  >>
Why created:    normalization of [serial 1211]
Solved by:  Identity (id):  P->P is tautology


Theorem (162)                               [serial 1211] 
P [94] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  ) >>
S [97] ->
Q [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  >>
Why created:    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1199]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 161:
Theorem (161) [serial 1247] used for:
    normalization of [serial 1211] 


Theorem (163)                               [serial 1212] 
P [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]  >>
S [97] ->
Q [103] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]  >>
Why created:    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1199]
Solved by:  Identity (id):  P->P is tautology


Theorem (164)                               [serial 1199] 
P [94] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  >>
S [97] forall i in 1 .. num_samples
    {
    << (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i] >>
    heart_rate_store[i] := hr_nxt[i]
    << (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i] >>
    }  
Q [103] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]  >>
Why created:  <<Q5 and P6>> S6 <<Q6>> in sequential composition for [serial 1190]
Solved by:  Universal Quantification Rule:
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any
and theorems 160 162 163:
Theorem (160) [serial 1210] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1199] 
Theorem (162) [serial 1211] used for:
    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1199] 
Theorem (163) [serial 1212] used for:
    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1199] 


Theorem (165)                               [serial 1190] 
P [49] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and INV_HR() >>
S [62]   << num_samples < #PulseOx_Properties::Num_Trending_Samples
    and AXIOM_HRT()
    and INV_HR() >>
  HeartRateTrend!(heart_rate_store)
  ;
  << num_samples < #PulseOx_Properties::Num_Trending_Samples
    and AXIOM_HRT()
    and INV_HR() >>
  NumSamples!(num_samples)
  ;
  << num_samples < #PulseOx_Properties::Num_Trending_Samples
    and INV_HR() >>
  forall i in 1 .. num_samples
      {
      << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = heart_rate_store[i] >>
      hr_nxt[1 + i] := heart_rate_store[i]
      << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i] >>
      }  
  <<SHFT_HR: :all i ~ quantity whole 
    in 1 .. num_samples 
    are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
        1 + i]  >>
  ;
    if 
      (MotionArtifact? or not SensorConnected?)~> 
        << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
          and SHFT_HR() >>
        hr_nxt[1] := 0 Hz
        << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
          and SHFT_HR() >> 
    []
      (not ( MotionArtifact? or not SensorConnected? ))~> 
        << SHFT_HR()
          and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
        hr_nxt[1] := HeartRate
        << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
          and SHFT_HR() >> 
    fi
  << ( all i ~ quantity whole 
    in 2 .. ( 1 + num_samples ) 
    are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
    and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
  ;
  num_samples := 1 + num_samples
  << all i ~ quantity whole 
    in 1 .. num_samples 
    are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  >>
  ;
  forall i in 1 .. num_samples
      {
      << (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i] >>
      heart_rate_store[i] := hr_nxt[i]
      << (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i] >>
      }  
  << all i ~ quantity whole 
    in 1 .. num_samples 
    are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]  >> 
Q [51] << HOLD_HR(num_samples) >>
Why created:    normalization of [serial 1013]
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 69 72 80 89 98 155 158 164:
Theorem (69) [serial 1192] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1190] 
Theorem (72) [serial 1193] used for:
  <<Q6>> -> <<Q>> in sequential composition for [serial 1190] 
Theorem (80) [serial 1194] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1190] 
Theorem (89) [serial 1195] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1190] 
Theorem (98) [serial 1196] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1190] 
Theorem (155) [serial 1197] used for:
  <<Q3 and P4>> S4 <<Q4 and P5>> in sequential composition for [serial 1190] 
Theorem (158) [serial 1198] used for:
  <<Q4 and P5>> S5 <<Q5 and P6>> in sequential composition for [serial 1190] 
Theorem (164) [serial 1199] used for:
  <<Q5 and P6>> S6 <<Q6>> in sequential composition for [serial 1190] 


Theorem (166)                               [serial 1013] 
P [49] << INV_HR()
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [62]   << INV_HR()
    and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
    and AXIOM_HRT() >>
  HeartRateTrend!(heart_rate_store)
  ;
  << INV_HR()
    and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
    and AXIOM_HRT() >>
  NumSamples!(num_samples)
  ;
  << INV_HR()
    and ( num_samples < #PulseOx_Properties::Num_Trending_Samples ) >>
  forall i in 1 .. num_samples
      {
      << heart_rate_store[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) >>
      hr_nxt[i + 1] := heart_rate_store[i]
      << hr_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) >>
      }  
  <<SHFT_HR: :all i ~ quantity whole 
    in 1 .. num_samples 
    are hr_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))  >>
  ;
    if 
      (MotionArtifact? or not SensorConnected?)~> 
        << SHFT_HR()
          and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
        hr_nxt[1] := 0 Hz
        << SHFT_HR()
          and hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) >> 
    []
      (not ( MotionArtifact? or not SensorConnected? ))~> 
        << SHFT_HR()
          and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
        hr_nxt[1] := HeartRate
        << SHFT_HR()
          and hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) >> 
    fi
  << hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0)
    and ( all i ~ quantity whole 
    in 2 .. ( num_samples + 1 ) 
    are hr_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))  ) >>
  ;
  num_samples := num_samples + 1
  << all i ~ quantity whole 
    in 1 .. num_samples 
    are hr_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))  >>
  ;
  forall i in 1 .. num_samples
      {
      << hr_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) >>
      heart_rate_store[i] := hr_nxt[i]
      << heart_rate_store[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) >>
      }  
  << all i ~ quantity whole 
    in 1 .. num_samples 
    are heart_rate_store[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))  >> 
Q [51] << HOLD_HR(num_samples) >>
Why created:   <<M(fill) and x>> A <<M(check)>> for hrtt1: fill-[x]->check{A};
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 165:
Theorem (165) [serial 1190] used for:
    normalization of [serial 1013] 


Theorem (167)                               [serial 1373] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [107] ->
Q [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  applied wp for simultaneous assignment [serial 1370]
Solved by:  Identity (id):  P->P is tautology
  Identity (id):  P->P is tautology


Theorem (168)                               [serial 1370] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:    normalization of [serial 1368]
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Simultaneous Assignment
and theorem 167:
Theorem (167) [serial 1373] used for:
  applied wp for simultaneous assignment [serial 1370] 


Theorem (169)                               [serial 1368] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if not ( SENSOR_CONNECTED^( - s ) )^1 or MOTION_ARTIFACT^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1366]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Caret Compostition:  (x^a)^b is x^(a+b)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 168:
Theorem (168) [serial 1370] used for:
    normalization of [serial 1368] 


Theorem (170)                               [serial 1366] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( not SENSOR_CONNECTED^( - s ) )^1 or MOTION_ARTIFACT^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:    normalization of [serial 1364]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 169:
Theorem (169) [serial 1368] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1366] 


Theorem (171)                               [serial 1364] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( MOTION_ARTIFACT^( ( - s ) + 1 ) or ( not SENSOR_CONNECTED^( - s ) )^1 ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1362]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 170:
Theorem (170) [serial 1366] used for:
    normalization of [serial 1364] 


Theorem (172)                               [serial 1362] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1 then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:    normalization of [serial 1360]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 171:
Theorem (171) [serial 1364] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1362] 


Theorem (173)                               [serial 1360] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1 then ( 0 Hz )^1 else HEART_RATE^( 
      ( - s ) + 1 )) = heart_rate_store[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1358]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Constants are always the same
  Associativity: a.(b.c) = a.b.c
and theorem 172:
Theorem (172) [serial 1362] used for:
    normalization of [serial 1360] 


Theorem (174)                               [serial 1358] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))^1 = heart_rate_store[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:    normalization of [serial 1356]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 173:
Theorem (173) [serial 1360] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1358] 


Theorem (175)                               [serial 1356] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))^1 = ( heart_rate_store[s] )^1 )  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1354]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 174:
Theorem (174) [serial 1358] used for:
    normalization of [serial 1356] 


Theorem (176)                               [serial 1354] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s )) = heart_rate_store[s] )^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:    normalization of [serial 1352]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 175:
Theorem (175) [serial 1356] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1354] 


Theorem (177)                               [serial 1352] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( ( num_samples )^1 < ( #PulseOx_Properties::Num_Trending_Samples )^1 )
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s )) = heart_rate_store[s] )^1  ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1350]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Constants are always the same
  Associativity: a.(b.c) = a.b.c
and theorem 176:
Theorem (176) [serial 1354] used for:
    normalization of [serial 1352] 


Theorem (178)                               [serial 1350] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples )^1
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  )^1 >>
Why created:    normalization of [serial 1348]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 177:
Theorem (177) [serial 1352] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1350] 


Theorem (179)                               [serial 1348] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  )^1
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1346]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 178:
Theorem (178) [serial 1350] used for:
    normalization of [serial 1348] 


Theorem (180)                               [serial 1346] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples )^1 >>
Why created:    normalization of [serial 1344]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 179:
Theorem (179) [serial 1348] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1346] 


Theorem (181)                               [serial 1344] 
P [51] << ( ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s ))  ) )
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples ) >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples )^1 >>
Why created:  Substituted assertions' predicates for labels  [serial 1014]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 180:
Theorem (180) [serial 1346] used for:
    normalization of [serial 1344] 


Theorem (182)                               [serial 1014] 
P [51] << ( HOLD_HR(num_samples) )
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples ) >>
S [107] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [49] << ( INV_HR()
  and num_samples < #PulseOx_Properties::Num_Trending_Samples )^1 >>
Why created:   <<M(check) and x>> A <<M(fill)>> for hrtt2a: check-[x]->fill{A};
Solved by:  Substitution of Assertion Labels
and theorem 181:
Theorem (181) [serial 1344] used for:
  Substituted assertions' predicates for labels  [serial 1014] 


Theorem (183)                               [serial 1400] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [109] ->
Q [53] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  applied wp for simultaneous assignment [serial 1397]
Solved by:  Identity (id):  P->P is tautology
  Identity (id):  P->P is tautology


Theorem (184)                               [serial 1397] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:    normalization of [serial 1395]
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Simultaneous Assignment
and theorem 183:
Theorem (183) [serial 1400] used for:
  applied wp for simultaneous assignment [serial 1397] 


Theorem (185)                               [serial 1395] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if not ( SENSOR_CONNECTED^( - s ) )^1 or MOTION_ARTIFACT^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1393]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Caret Compostition:  (x^a)^b is x^(a+b)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 184:
Theorem (184) [serial 1397] used for:
    normalization of [serial 1395] 


Theorem (186)                               [serial 1393] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( not SENSOR_CONNECTED^( - s ) )^1 or MOTION_ARTIFACT^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:    normalization of [serial 1391]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 185:
Theorem (185) [serial 1395] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1393] 


Theorem (187)                               [serial 1391] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( MOTION_ARTIFACT^( ( - s ) + 1 ) or ( not SENSOR_CONNECTED^( - s ) )^1 ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1389]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 186:
Theorem (186) [serial 1393] used for:
    normalization of [serial 1391] 


Theorem (188)                               [serial 1389] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1 then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:    normalization of [serial 1387]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 187:
Theorem (187) [serial 1391] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1389] 


Theorem (189)                               [serial 1387] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1 then ( 0 Hz )^1 else HEART_RATE^( 
      ( - s ) + 1 )) = heart_rate_store[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1385]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Constants are always the same
  Associativity: a.(b.c) = a.b.c
and theorem 188:
Theorem (188) [serial 1389] used for:
    normalization of [serial 1387] 


Theorem (190)                               [serial 1385] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))^1 = heart_rate_store[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:    normalization of [serial 1383]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 189:
Theorem (189) [serial 1387] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1385] 


Theorem (191)                               [serial 1383] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))^1 = ( heart_rate_store[s] )^1 )  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1381]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 190:
Theorem (190) [serial 1385] used for:
    normalization of [serial 1383] 


Theorem (192)                               [serial 1381] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s )) = heart_rate_store[s] )^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:    normalization of [serial 1379]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 191:
Theorem (191) [serial 1383] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1381] 


Theorem (193)                               [serial 1379] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( ( #PulseOx_Properties::Num_Trending_Samples )^1 = ( num_samples )^1 )
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s )) = heart_rate_store[s] )^1  ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1377]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Constants are always the same
  Associativity: a.(b.c) = a.b.c
and theorem 192:
Theorem (192) [serial 1381] used for:
    normalization of [serial 1379] 


Theorem (194)                               [serial 1377] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( #PulseOx_Properties::Num_Trending_Samples = num_samples )^1
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  )^1 >>
Why created:    normalization of [serial 1375]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 193:
Theorem (193) [serial 1379] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1377] 


Theorem (195)                               [serial 1375] 
P [51] << ( ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s ))  ) )
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples ) >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  )^1
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1374]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 194:
Theorem (194) [serial 1377] used for:
    normalization of [serial 1375] 


Theorem (196)                               [serial 1374] 
P [51] << ( ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s ))  ) )
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples ) >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples )^1 >>
Why created:  Substituted assertions' predicates for labels  [serial 1015]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 195:
Theorem (195) [serial 1375] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1374] 


Theorem (197)                               [serial 1015] 
P [51] << ( HOLD_HR(num_samples) )
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples ) >>
S [109] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [53] << ( INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples )^1 >>
Why created:   <<M(check) and x>> A <<M(run)>> for hrtt2b: check-[x]->run{A};
Solved by:  Substitution of Assertion Labels
and theorem 196:
Theorem (196) [serial 1374] used for:
  Substituted assertions' predicates for labels  [serial 1015] 


Theorem (198)                               [serial 1016] 
P [51] << ( HOLD_HR(num_samples) )
  and ( num_samples > #PulseOx_Properties::Num_Trending_Samples ) >>
S [110] ->
Q [55] << true >>
Why created:   <<M(check) and x>> -> <<M(fail)>> for hrtt2c: check-[x]->fail{};
Solved by:  True Conclusion Schema (tc): P->true


Theorem (199)                               [serial 1502] 
P [53] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and INV_HR() >>
S [53] ->
Q [113] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and INV_HR() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1499]
Solved by:  Identity (id):  P->P is tautology


Theorem (200)                               [serial 1499] 
P [53] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and INV_HR() >>
S [53] ->
Q [113] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and true
  and INV_HR() >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 199:
Theorem (199) [serial 1502] used for:
  Law of And-Simplification:  P and true is P [serial 1499] 


Theorem (201)                               [serial 1502] 
P [53] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and INV_HR() >>
S [53] ->
Q [113] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and INV_HR() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1499]
Solved by:  Identity (id):  P->P is tautology


Theorem (202)                               [serial 1499] 
P [53] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and INV_HR() >>
S [53] ->
Q [113] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and true
  and INV_HR() >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 201:
Theorem (201) [serial 1502] used for:
  Law of And-Simplification:  P and true is P [serial 1499] 


Theorem (203)                               [serial 1423] 
P [53] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and INV_HR() >>
S [53] ->
Q [113] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_HRT()
  and INV_HR() >>
Why created:    normalization of [serial 1401]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 202 202:
Theorem (202) [serial 1499] used for:
   add user-defined axioms to postcondition 
Theorem (202) [serial 1499] used for:
   add user-defined axioms to postcondition 


Theorem (204)                               [serial 1401] 
P [53] << INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
S [53] ->
Q [113] << INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_HRT() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1017]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 203:
Theorem (203) [serial 1423] used for:
    normalization of [serial 1401] 


Theorem (205)                               [serial 1534] 
P [161] << ( all #6# ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 + - #6# ) or not SENSOR_CONNECTED^( 1 + - #6# ) then 0 Hz else HEART_RATE^( 
      1 + - #6# )) = heart_rate_store[#6#]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [53] ->
Q [36] << all #7# ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 + - #7# ) or not SENSOR_CONNECTED^( 1 + - #7# ) then 0 Hz else HEART_RATE^( 
      1 + - #7# )) = heart_rate_store[#7#]^1  >>
Why created:   changing adding negation to subtraction  [serial 1533]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (206)                               [serial 1533] 
P [161] << ( all #6# ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - #6# ) or not SENSOR_CONNECTED^( 1 - #6# ) then 0 Hz else HEART_RATE^( 1 - #6# )) = heart_rate_store[#6#]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [53] ->
Q [36] << all #7# ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - #7# ) or not SENSOR_CONNECTED^( 1 - #7# ) then 0 Hz else HEART_RATE^( 1 - #7# )) = heart_rate_store[#7#]^1  >>
Why created:  Replacement of Quantified Variables with #1, #2, etc.  [serial 1531]
Solved by:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 205:
Theorem (205) [serial 1534] used for:
   changing adding negation to subtraction  [serial 1533] 


Theorem (207)                               [serial 1531] 
P [161] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [53] ->
Q [36] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]^1  ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1528]
Solved by:  Replacement of Quantified Variables with #1, #2, etc.
and theorem 206:
Theorem (206) [serial 1533] used for:
  Replacement of Quantified Variables with #1, #2, etc.  [serial 1531] 


Theorem (208)                               [serial 1532] 
P [161] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [53] ->
Q [53] << #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1528]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (209)                               [serial 1528] 
P [161] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [53] ->
Q [16] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:    normalization of [serial 1526]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 207 208:
Theorem (207) [serial 1531] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1528] 
Theorem (208) [serial 1532] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1528] 


Theorem (210)                               [serial 1526] 
P [161] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [53] ->
Q [16] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if not ( SENSOR_CONNECTED^( - s ) )^1 or MOTION_ARTIFACT^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1524]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Caret Compostition:  (x^a)^b is x^(a+b)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 209:
Theorem (209) [serial 1528] used for:
    normalization of [serial 1526] 


Theorem (211)                               [serial 1524] 
P [161] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [53] ->
Q [16] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( not SENSOR_CONNECTED^( - s ) )^1 or MOTION_ARTIFACT^( 1 - s ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:    normalization of [serial 1522]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 210:
Theorem (210) [serial 1526] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1524] 


Theorem (212)                               [serial 1522] 
P [161] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [53] ->
Q [16] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( MOTION_ARTIFACT^( ( - s ) + 1 ) or ( not SENSOR_CONNECTED^( - s ) )^1 ) then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1520]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 211:
Theorem (211) [serial 1524] used for:
    normalization of [serial 1522] 


Theorem (213)                               [serial 1520] 
P [161] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [53] ->
Q [16] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1 then 0 Hz else HEART_RATE^( 1 - s )) = heart_rate_store[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:    normalization of [serial 1518]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 212:
Theorem (212) [serial 1522] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1520] 


Theorem (214)                               [serial 1518] 
P [161] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [53] ->
Q [16] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1 then ( 0 Hz )^1 else HEART_RATE^( 
      ( - s ) + 1 )) = heart_rate_store[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1516]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Constants are always the same
  Associativity: a.(b.c) = a.b.c
and theorem 213:
Theorem (213) [serial 1520] used for:
    normalization of [serial 1518] 


Theorem (215)                               [serial 1516] 
P [161] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [53] ->
Q [16] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))^1 = heart_rate_store[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:    normalization of [serial 1514]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 214:
Theorem (214) [serial 1518] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1516] 


Theorem (216)                               [serial 1514] 
P [161] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [53] ->
Q [16] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))^1 = ( heart_rate_store[s] )^1 )  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1512]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 215:
Theorem (215) [serial 1516] used for:
    normalization of [serial 1514] 


Theorem (217)                               [serial 1512] 
P [161] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [53] ->
Q [16] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s )) = heart_rate_store[s] )^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:    normalization of [serial 1510]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 216:
Theorem (216) [serial 1514] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1512] 


Theorem (218)                               [serial 1510] 
P [161] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [53] ->
Q [16] << ( ( #PulseOx_Properties::Num_Trending_Samples )^1 = ( num_samples )^1 )
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s )) = heart_rate_store[s] )^1  ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1508]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Constants are always the same
  Associativity: a.(b.c) = a.b.c
and theorem 217:
Theorem (217) [serial 1512] used for:
    normalization of [serial 1510] 


Theorem (219)                               [serial 1508] 
P [161] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [53] ->
Q [16] << ( #PulseOx_Properties::Num_Trending_Samples = num_samples )^1
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s )) = heart_rate_store[s]  )^1 >>
Why created:    normalization of [serial 1506]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 218:
Theorem (218) [serial 1510] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1508] 


Theorem (220)                               [serial 1506] 
P [161] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are ( heart_rate_store[i] )^1 = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))  )
  and ( num_samples )^1 = #PulseOx_Properties::Num_Trending_Samples >>
S [53] ->
Q [16] << ( ( #PulseOx_Properties::Num_Trending_Samples = num_samples )^1
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1505]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 219:
Theorem (219) [serial 1508] used for:
    normalization of [serial 1506] 


Theorem (221)                               [serial 1505] 
P [161] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))  )
  and num_samples' = #PulseOx_Properties::Num_Trending_Samples >>
S [53] ->
Q [16] << ( #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  ) )^1 >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1425]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 220:
Theorem (220) [serial 1506] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1505] 


Theorem (222)                               [serial 1425] 
P [161] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))  )
  and num_samples' = #PulseOx_Properties::Num_Trending_Samples >>
S [53] ->
Q [16] << ( #PulseOx_Properties::Num_Trending_Samples = num_samples
  and INV_HR() )^1 >>
Why created:    normalization of [serial 1402]
Solved by:  Substitution of Assertion Labels
and theorem 221:
Theorem (221) [serial 1505] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1425] 


Theorem (223)                               [serial 1402] 
P [161] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))  )
  and num_samples' = #PulseOx_Properties::Num_Trending_Samples >>
S [53] ->
Q [16] << ( INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples )^1 >>
Why created:  <<Q6>> -> <<Q>> in sequential composition for [serial 1017]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 222:
Theorem (222) [serial 1425] used for:
    normalization of [serial 1402] 


Theorem (224)                               [serial 1626] 
P [113] << num_samples = NUM_SAMPLES
  and heart_rate_store = HEART_RATE_HISTORY
  and HEART_RATE_HISTORY = HeartRateTrend
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  ) >>
S [114] ->
Q [114] << heart_rate_store = HEART_RATE_HISTORY >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1625]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (225)                               [serial 1625] 
P [113] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( num_samples = NUM_SAMPLES
  and heart_rate_store = HEART_RATE_HISTORY
  and HEART_RATE_HISTORY = HeartRateTrend )
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  ) >>
S [114] ->
Q [114] << heart_rate_store = HEART_RATE_HISTORY >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1622]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 224:
Theorem (224) [serial 1626] used for:
  Associativity: a.(b.c) = a.b.c [serial 1625] 


Theorem (226)                               [serial 1622] 
P [113] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_HRT()
  and INV_HR() >>
S [114] ->
Q [114] << heart_rate_store = HEART_RATE_HISTORY >>
Why created:  applied port output of value <<pre>> -> <<M(HeartRateTrend)[HeartRateTrend|heart_rate_store]>> [serial 1503]
Solved by:  Substitution of Assertion Labels
and theorem 225:
Theorem (225) [serial 1625] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1622] 


Theorem (227)                               [serial 1624] 
P [114] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_HRT()
  and INV_HR()
  and ( heart_rate_store = HEART_RATE_HISTORY )^0 >>
S [114] ->
Q [116] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and INV_HR() >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1623]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (228)                               [serial 1623] 
P [114] << ( #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_HRT()
  and INV_HR() )
  and ( heart_rate_store = HEART_RATE_HISTORY )^0 >>
S [114] ->
Q [116] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and INV_HR() >>
Why created:  applied port output <<pre and (heart_rate_store = HEART_RATE_HISTORY)^0>> -> <<post>> [serial 1503]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 227:
Theorem (227) [serial 1624] used for:
  Associativity: a.(b.c) = a.b.c [serial 1623] 


Theorem (229)                               [serial 1503] 
P [113] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_HRT()
  and INV_HR() >>
S [114] HeartRateTrend!(heart_rate_store)
Q [116] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and INV_HR() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1500]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 226 228:
Theorem (226) [serial 1622] used for:
  applied port output of value <<pre>> -> <<M(HeartRateTrend)[HeartRateTrend|heart_rate_store]>> [serial 1503] 
Theorem (228) [serial 1623] used for:
  applied port output <<pre and (heart_rate_store = HEART_RATE_HISTORY)^0>> -> <<post>> [serial 1503] 


Theorem (230)                               [serial 1500] 
P [113] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_HRT()
  and INV_HR() >>
S [114] HeartRateTrend!(heart_rate_store)
Q [116] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and true
  and INV_HR() >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 229:
Theorem (229) [serial 1503] used for:
  Law of And-Simplification:  P and true is P [serial 1500] 


Theorem (231)                               [serial 1626] 
P [113] << num_samples = NUM_SAMPLES
  and heart_rate_store = HEART_RATE_HISTORY
  and HEART_RATE_HISTORY = HeartRateTrend
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  ) >>
S [114] ->
Q [114] << heart_rate_store = HEART_RATE_HISTORY >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1625]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (232)                               [serial 1625] 
P [113] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( num_samples = NUM_SAMPLES
  and heart_rate_store = HEART_RATE_HISTORY
  and HEART_RATE_HISTORY = HeartRateTrend )
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  ) >>
S [114] ->
Q [114] << heart_rate_store = HEART_RATE_HISTORY >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1622]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 231:
Theorem (231) [serial 1626] used for:
  Associativity: a.(b.c) = a.b.c [serial 1625] 


Theorem (233)                               [serial 1622] 
P [113] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_HRT()
  and INV_HR() >>
S [114] ->
Q [114] << heart_rate_store = HEART_RATE_HISTORY >>
Why created:  applied port output of value <<pre>> -> <<M(HeartRateTrend)[HeartRateTrend|heart_rate_store]>> [serial 1503]
Solved by:  Substitution of Assertion Labels
and theorem 232:
Theorem (232) [serial 1625] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1622] 


Theorem (234)                               [serial 1624] 
P [114] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_HRT()
  and INV_HR()
  and ( heart_rate_store = HEART_RATE_HISTORY )^0 >>
S [114] ->
Q [116] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and INV_HR() >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1623]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (235)                               [serial 1623] 
P [114] << ( #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_HRT()
  and INV_HR() )
  and ( heart_rate_store = HEART_RATE_HISTORY )^0 >>
S [114] ->
Q [116] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and INV_HR() >>
Why created:  applied port output <<pre and (heart_rate_store = HEART_RATE_HISTORY)^0>> -> <<post>> [serial 1503]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 234:
Theorem (234) [serial 1624] used for:
  Associativity: a.(b.c) = a.b.c [serial 1623] 


Theorem (236)                               [serial 1503] 
P [113] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_HRT()
  and INV_HR() >>
S [114] HeartRateTrend!(heart_rate_store)
Q [116] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and INV_HR() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1500]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 233 235:
Theorem (233) [serial 1622] used for:
  applied port output of value <<pre>> -> <<M(HeartRateTrend)[HeartRateTrend|heart_rate_store]>> [serial 1503] 
Theorem (235) [serial 1623] used for:
  applied port output <<pre and (heart_rate_store = HEART_RATE_HISTORY)^0>> -> <<post>> [serial 1503] 


Theorem (237)                               [serial 1500] 
P [113] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_HRT()
  and INV_HR() >>
S [114] HeartRateTrend!(heart_rate_store)
Q [116] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and true
  and INV_HR() >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 236:
Theorem (236) [serial 1503] used for:
  Law of And-Simplification:  P and true is P [serial 1500] 


Theorem (238)                               [serial 1427] 
P [113] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_HRT()
  and INV_HR() >>
S [114] HeartRateTrend!(heart_rate_store)
Q [116] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_HRT()
  and INV_HR() >>
Why created:    normalization of [serial 1403]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 237 237:
Theorem (237) [serial 1500] used for:
   add user-defined axioms to postcondition 
Theorem (237) [serial 1500] used for:
   add user-defined axioms to postcondition 


Theorem (239)                               [serial 1403] 
P [113] << INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_HRT() >>
S [114] HeartRateTrend!(heart_rate_store)
Q [116] << INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_HRT() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1017]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 238:
Theorem (238) [serial 1427] used for:
    normalization of [serial 1403] 


Theorem (240)                               [serial 1631] 
P [116] << num_samples = NUM_SAMPLES
  and heart_rate_store = HEART_RATE_HISTORY
  and HEART_RATE_HISTORY = HeartRateTrend
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  ) >>
S [117] ->
Q [117] << num_samples = NUM_SAMPLES >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1630]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (241)                               [serial 1630] 
P [116] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( num_samples = NUM_SAMPLES
  and heart_rate_store = HEART_RATE_HISTORY
  and HEART_RATE_HISTORY = HeartRateTrend )
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  ) >>
S [117] ->
Q [117] << num_samples = NUM_SAMPLES >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1627]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 240:
Theorem (240) [serial 1631] used for:
  Associativity: a.(b.c) = a.b.c [serial 1630] 


Theorem (242)                               [serial 1627] 
P [116] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_HRT()
  and INV_HR() >>
S [117] ->
Q [117] << num_samples = NUM_SAMPLES >>
Why created:  applied port output of value <<pre>> -> <<M(NumSamples)[NumSamples|num_samples]>> [serial 1504]
Solved by:  Substitution of Assertion Labels
and theorem 241:
Theorem (241) [serial 1630] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1627] 


Theorem (243)                               [serial 1629] 
P [117] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_HRT()
  and INV_HR()
  and ( num_samples = NUM_SAMPLES )^0 >>
S [117] ->
Q [119] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and INV_HR() >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1628]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (244)                               [serial 1628] 
P [117] << ( #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_HRT()
  and INV_HR() )
  and ( num_samples = NUM_SAMPLES )^0 >>
S [117] ->
Q [119] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and INV_HR() >>
Why created:  applied port output <<pre and (num_samples = NUM_SAMPLES)^0>> -> <<post>> [serial 1504]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 243:
Theorem (243) [serial 1629] used for:
  Associativity: a.(b.c) = a.b.c [serial 1628] 


Theorem (245)                               [serial 1504] 
P [116] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_HRT()
  and INV_HR() >>
S [117] NumSamples!(num_samples)
Q [119] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and INV_HR() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1501]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 242 244:
Theorem (242) [serial 1627] used for:
  applied port output of value <<pre>> -> <<M(NumSamples)[NumSamples|num_samples]>> [serial 1504] 
Theorem (244) [serial 1628] used for:
  applied port output <<pre and (num_samples = NUM_SAMPLES)^0>> -> <<post>> [serial 1504] 


Theorem (246)                               [serial 1501] 
P [116] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_HRT()
  and INV_HR() >>
S [117] NumSamples!(num_samples)
Q [119] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and true
  and INV_HR() >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 245:
Theorem (245) [serial 1504] used for:
  Law of And-Simplification:  P and true is P [serial 1501] 


Theorem (247)                               [serial 1631] 
P [116] << num_samples = NUM_SAMPLES
  and heart_rate_store = HEART_RATE_HISTORY
  and HEART_RATE_HISTORY = HeartRateTrend
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  ) >>
S [117] ->
Q [117] << num_samples = NUM_SAMPLES >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1630]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (248)                               [serial 1630] 
P [116] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( num_samples = NUM_SAMPLES
  and heart_rate_store = HEART_RATE_HISTORY
  and HEART_RATE_HISTORY = HeartRateTrend )
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  ) >>
S [117] ->
Q [117] << num_samples = NUM_SAMPLES >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1627]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 247:
Theorem (247) [serial 1631] used for:
  Associativity: a.(b.c) = a.b.c [serial 1630] 


Theorem (249)                               [serial 1627] 
P [116] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_HRT()
  and INV_HR() >>
S [117] ->
Q [117] << num_samples = NUM_SAMPLES >>
Why created:  applied port output of value <<pre>> -> <<M(NumSamples)[NumSamples|num_samples]>> [serial 1504]
Solved by:  Substitution of Assertion Labels
and theorem 248:
Theorem (248) [serial 1630] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1627] 


Theorem (250)                               [serial 1629] 
P [117] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_HRT()
  and INV_HR()
  and ( num_samples = NUM_SAMPLES )^0 >>
S [117] ->
Q [119] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and INV_HR() >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1628]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (251)                               [serial 1628] 
P [117] << ( #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_HRT()
  and INV_HR() )
  and ( num_samples = NUM_SAMPLES )^0 >>
S [117] ->
Q [119] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and INV_HR() >>
Why created:  applied port output <<pre and (num_samples = NUM_SAMPLES)^0>> -> <<post>> [serial 1504]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 250:
Theorem (250) [serial 1629] used for:
  Associativity: a.(b.c) = a.b.c [serial 1628] 


Theorem (252)                               [serial 1504] 
P [116] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_HRT()
  and INV_HR() >>
S [117] NumSamples!(num_samples)
Q [119] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and INV_HR() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1501]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 249 251:
Theorem (249) [serial 1627] used for:
  applied port output of value <<pre>> -> <<M(NumSamples)[NumSamples|num_samples]>> [serial 1504] 
Theorem (251) [serial 1628] used for:
  applied port output <<pre and (num_samples = NUM_SAMPLES)^0>> -> <<post>> [serial 1504] 


Theorem (253)                               [serial 1501] 
P [116] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_HRT()
  and INV_HR() >>
S [117] NumSamples!(num_samples)
Q [119] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and true
  and INV_HR() >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 252:
Theorem (252) [serial 1504] used for:
  Law of And-Simplification:  P and true is P [serial 1501] 


Theorem (254)                               [serial 1429] 
P [116] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_HRT()
  and INV_HR() >>
S [117] NumSamples!(num_samples)
Q [119] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_CR()
  and INV_HR() >>
Why created:    normalization of [serial 1404]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 253 253:
Theorem (253) [serial 1501] used for:
   add user-defined axioms to postcondition 
Theorem (253) [serial 1501] used for:
   add user-defined axioms to postcondition 


Theorem (255)                               [serial 1404] 
P [116] << INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_HRT() >>
S [117] NumSamples!(num_samples)
Q [119] << INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_CR() >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1017]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 254:
Theorem (254) [serial 1429] used for:
    normalization of [serial 1404] 


Theorem (256)                               [serial 1549] 
P [122] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = heart_rate_store[i]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [124] ->
Q [125] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = heart_rate_store[i]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  applied wp for assignment [serial 1435]
Solved by:  Identity (id):  P->P is tautology


Theorem (257)                               [serial 1435] 
P [122] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = heart_rate_store[i]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [124] hr_nxt[1 + i] := heart_rate_store[i]
Q [125] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
1 + i]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 1409]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 256:
Theorem (256) [serial 1549] used for:
  applied wp for assignment [serial 1435] 


Theorem (258)                               [serial 1409] 
P [122] << heart_rate_store[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
S [124] hr_nxt[i + 1] := heart_rate_store[i]
Q [125] << hr_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
Why created:  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1405]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 257:
Theorem (257) [serial 1435] used for:
    normalization of [serial 1409] 


Theorem (259)                               [serial 1542] 
P [119] << ( all #8# ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( -(1 + #8#) ) or not SENSOR_CONNECTED^( -(1 + 
      #8#) ) then 0 Hz else HEART_RATE^( -(1 + #8#) )) = heart_rate_store[
      1 + #8#]  )
  and num_samples - 2 < num_samples - 1
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [120] ->
Q [19] << ( all #9# ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( -(1 + #9#) ) or not SENSOR_CONNECTED^( -(1 + 
      #9#) ) then 0 Hz else HEART_RATE^( -(1 + #9#) )) = heart_rate_store[
      1 + #9#]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 1540]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (260)                               [serial 1540] 
P [119] << ( all #8# ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( -(1 + #8#) ) or not SENSOR_CONNECTED^( -(1 + 
      #8#) ) then 0 Hz else HEART_RATE^( -(1 + #8#) )) = heart_rate_store[
      1 + #8#]  )
  and num_samples - 2 < num_samples - 1
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [120] ->
Q [19] << ( all #9# ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( -(1 + #9#) ) or not SENSOR_CONNECTED^( -(1 + 
      #9#) ) then 0 Hz else HEART_RATE^( -(1 + #9#) )) = heart_rate_store[
      1 + #9#]  )
  and ( #PulseOx_Properties::Num_Trending_Samples = num_samples ) >>
Why created:  Introduction of (unused) Universal Quantification [serial 1539]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 259:
Theorem (259) [serial 1542] used for:
    normalization of [serial 1540] 


Theorem (261)                               [serial 1539] 
P [119] << ( all #8# ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( -(1 + #8#) ) or not SENSOR_CONNECTED^( -(1 + 
      #8#) ) then 0 Hz else HEART_RATE^( -(1 + #8#) )) = heart_rate_store[
      1 + #8#]  )
  and num_samples - 2 < num_samples - 1
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [120] ->
Q [19] << ( all #9# ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( -(1 + #9#) ) or not SENSOR_CONNECTED^( -(1 + 
      #9#) ) then 0 Hz else HEART_RATE^( -(1 + #9#) )) = heart_rate_store[
      1 + #9#]  )
  and ( all #9# ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are #PulseOx_Properties::Num_Trending_Samples = num_samples  ) >>
Why created:  Combine Universal Quantifications: all x:t in R are (A and B) = (all x:t in R are A) and (all x:t in R are B)  [serial 1538]
Solved by:  Introduction of (unused) Universal Quantification
and theorem 260:
Theorem (260) [serial 1540] used for:
  Introduction of (unused) Universal Quantification [serial 1539] 


Theorem (262)                               [serial 1538] 
P [119] << ( all #8# ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( -(1 + #8#) ) or not SENSOR_CONNECTED^( -(1 + 
      #8#) ) then 0 Hz else HEART_RATE^( -(1 + #8#) )) = heart_rate_store[
      1 + #8#]  )
  and num_samples - 2 < num_samples - 1
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [120] ->
Q [19] << all #9# ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( -(1 + #9#) ) or not SENSOR_CONNECTED^( -(1 + 
      #9#) ) then 0 Hz else HEART_RATE^( -(1 + #9#) )) = heart_rate_store[
      1 + #9#]
        and #PulseOx_Properties::Num_Trending_Samples = num_samples  >>
Why created:  Replacement of Quantified Variables with #1, #2, etc.  [serial 1537]
Solved by:  Combine Universal Quantifications: all x:t in R are (A and B) = (all x:t in R are A) and (all x:t in R are B)
and theorem 261:
Theorem (261) [serial 1539] used for:
  Combine Universal Quantifications: all x:t in R are (A and B) = (all x:t in R are A) and (all x:t in R are B)  [serial 1538] 


Theorem (263)                               [serial 1537] 
P [119] << ( all s ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( -(1 + s) ) or not SENSOR_CONNECTED^( -(1 + s) ) then 0 Hz else HEART_RATE^( -(
      1 + s) )) = heart_rate_store[1 + s]  )
  and num_samples - 2 < num_samples - 1
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [120] ->
Q [19] << all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( -(1 + i) ) or not SENSOR_CONNECTED^( -(1 + i) ) then 0 Hz else HEART_RATE^( -(
      1 + i) )) = heart_rate_store[1 + i]
        and #PulseOx_Properties::Num_Trending_Samples = num_samples  >>
Why created:  Contract Universal Quantification Range  [serial 1536]
Solved by:  Replacement of Quantified Variables with #1, #2, etc.
and theorem 262:
Theorem (262) [serial 1538] used for:
  Replacement of Quantified Variables with #1, #2, etc.  [serial 1537] 


Theorem (264)                               [serial 1536] 
P [119] << ( all s ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( -(1 + s) ) or not SENSOR_CONNECTED^( -(1 + s) ) then 0 Hz else HEART_RATE^( -(
      1 + s) )) = heart_rate_store[1 + s]  )
  and num_samples - 2 < num_samples - 1
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [120] ->
Q [19] << all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( -(1 + i) ) or not SENSOR_CONNECTED^( -(1 + i) ) then 0 Hz else HEART_RATE^( -(
      1 + i) )) = heart_rate_store[1 + i]
        and #PulseOx_Properties::Num_Trending_Samples = num_samples  >>
Why created:  Shift Quantification Range so Lower Bound is Zero  [serial 1535]
Solved by:  Contract Universal Quantification Range
and theorem 263:
Theorem (263) [serial 1537] used for:
  Contract Universal Quantification Range  [serial 1536] 


Theorem (265)                               [serial 1535] 
P [119] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( num_samples - 2 < num_samples - 1 )
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 Hz else HEART_RATE^( - s ))  ) >>
S [120] ->
Q [19] << all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = heart_rate_store[i]
        and #PulseOx_Properties::Num_Trending_Samples = num_samples  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1431]
Solved by:  Shift Quantification Range so Lower Bound is Zero
and theorem 264:
Theorem (264) [serial 1536] used for:
  Shift Quantification Range so Lower Bound is Zero  [serial 1535] 


Theorem (266)                               [serial 1431] 
P [119] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_CR()
  and INV_HR() >>
S [120] ->
Q [19] << all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = heart_rate_store[i]
        and #PulseOx_Properties::Num_Trending_Samples = num_samples  >>
Why created:    normalization of [serial 1410]
Solved by:  Substitution of Assertion Labels
and theorem 265:
Theorem (265) [serial 1535] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1431] 


Theorem (267)                               [serial 1410] 
P [119] << ( INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_CR() ) >>
S [120] ->
Q [19] << all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are heart_rate_store[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1405]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 266:
Theorem (266) [serial 1431] used for:
    normalization of [serial 1410] 


Theorem (268)                               [serial 1547] 
P [19] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [120] ->
Q [128] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 1545]
Solved by:  Identity (id):  P->P is tautology


Theorem (269)                               [serial 1545] 
P [19] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and ( #PulseOx_Properties::Num_Trending_Samples = num_samples ) >>
S [120] ->
Q [128] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  Introduction of (unused) Universal Quantification [serial 1544]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 268:
Theorem (268) [serial 1547] used for:
    normalization of [serial 1545] 


Theorem (270)                               [serial 1544] 
P [19] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are #PulseOx_Properties::Num_Trending_Samples = num_samples  ) >>
S [120] ->
Q [128] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  Combine Universal Quantifications: all x:t in R are (A and B) = (all x:t in R are A) and (all x:t in R are B)  [serial 1433]
Solved by:  Introduction of (unused) Universal Quantification
and theorem 269:
Theorem (269) [serial 1545] used for:
  Introduction of (unused) Universal Quantification [serial 1544] 


Theorem (271)                               [serial 1433] 
P [19] << all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]
        and #PulseOx_Properties::Num_Trending_Samples = num_samples  >>
S [120] ->
Q [128] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 1411]
Solved by:  Combine Universal Quantifications: all x:t in R are (A and B) = (all x:t in R are A) and (all x:t in R are B)
and theorem 270:
Theorem (270) [serial 1544] used for:
  Combine Universal Quantifications: all x:t in R are (A and B) = (all x:t in R are A) and (all x:t in R are B)  [serial 1433] 


Theorem (272)                               [serial 1411] 
P [19] << all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are hr_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
S [120] ->
Q [128] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are hr_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
Why created:    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1405]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 271:
Theorem (271) [serial 1433] used for:
    normalization of [serial 1411] 


Theorem (273)                               [serial 1405] 
P [119] << INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_CR() >>
S [120] forall i in 1 .. ( num_samples - 1 )
    {
    << heart_rate_store[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))
      and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
    hr_nxt[i + 1] := heart_rate_store[i]
    << hr_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))
      and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
    }  
Q [128] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are hr_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1017]
Solved by:  Universal Quantification Rule:
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any
and theorems 258 267 272:
Theorem (258) [serial 1409] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1405] 
Theorem (267) [serial 1410] used for:
    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1405] 
Theorem (272) [serial 1411] used for:
    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1405] 


Theorem (274)                               [serial 1476] 
P [128] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [132] ->
Q [132] << true >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1437]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (275)                               [serial 1437] 
P [128] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [132] ->
Q [132] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) or not ( MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0 ) >>
Why created:    normalization of [serial 1412]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 274:
Theorem (274) [serial 1476] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1437] 


Theorem (276)                               [serial 1412] 
P [128] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are hr_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
S [132] ->
Q [132] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) or ( not ( MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0 ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1406]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 275:
Theorem (275) [serial 1437] used for:
    normalization of [serial 1412] 


Theorem (277)                               [serial 1621] 
P [132] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [132] ->
Q [134] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1619]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (278)                               [serial 1619] 
P [132] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [132] ->
Q [134] << ( ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:    normalization of [serial 1617]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 277:
Theorem (277) [serial 1621] used for:
  Associativity: a.(b.c) = a.b.c [serial 1619] 


Theorem (279)                               [serial 1617] 
P [132] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [132] ->
Q [134] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and ( ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are hr_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1496]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 278:
Theorem (278) [serial 1619] used for:
    normalization of [serial 1617] 


Theorem (280)                               [serial 1496] 
P [132] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [132] ->
Q [134] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFTR_HR() >>
Why created:    normalization of [serial 1477]
Solved by:  Substitution of Assertion Labels
and theorem 279:
Theorem (279) [serial 1617] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1496] 


Theorem (281)                               [serial 1477] 
P [132] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [132] ->
Q [134] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFTR_HR() >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1439]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 280:
Theorem (280) [serial 1496] used for:
    normalization of [serial 1477] 


Theorem (282)                               [serial 1439] 
P [132] << ( ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [132] ->
Q [134] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFTR_HR() >>
Why created:    normalization of [serial 1413]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 281:
Theorem (281) [serial 1477] used for:
  Associativity: a.(b.c) = a.b.c [serial 1439] 


Theorem (283)                               [serial 1413] 
P [132] << ( ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are hr_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [132] ->
Q [134] << SHFTR_HR()
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:    <<P and B0>> -> <<P0>> in alternative for [serial 1406]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 282:
Theorem (282) [serial 1439] used for:
    normalization of [serial 1413] 


Theorem (284)                               [serial 1554] 
P [134] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFTR_HR() >>
S [135] ->
Q [136] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1553]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (285)                               [serial 1553] 
P [134] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFTR_HR() >>
S [135] ->
Q [136] << 0 Hz = 0 Hz >>
Why created:   Conditional True Expression:  b and x=e  iff  b and x=(b??e:g)   [serial 1551]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 284:
Theorem (284) [serial 1554] used for:
  Equality Law (idistr):  a=a <-> true [serial 1553] 


Theorem (286)                               [serial 1551] 
P [134] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFTR_HR() >>
S [135] ->
Q [136] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = 0 Hz >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1550]
Solved by:  Conditional True Expression:  b and x=e  iff  b and x=(b??e:g) 
and theorem 285:
Theorem (285) [serial 1553] used for:
   Conditional True Expression:  b and x=e  iff  b and x=(b??e:g)   [serial 1551] 


Theorem (287)                               [serial 1552] 
P [134] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFTR_HR() >>
S [135] ->
Q [136] << SHFTR_HR() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1550]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (288)                               [serial 1550] 
P [134] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFTR_HR() >>
S [135] ->
Q [136] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = 0 Hz
  and SHFTR_HR() >>
Why created:  applied wp for assignment [serial 1441]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 286 287:
Theorem (286) [serial 1551] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1550] 
Theorem (287) [serial 1552] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1550] 


Theorem (289)                               [serial 1441] 
P [134] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFTR_HR() >>
S [135] hr_nxt[1] := 0 Hz
Q [136] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and SHFTR_HR() >>
Why created:    normalization of [serial 1414]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 288:
Theorem (288) [serial 1550] used for:
  applied wp for assignment [serial 1441] 


Theorem (290)                               [serial 1414] 
P [134] << SHFTR_HR()
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [135] hr_nxt[1] := 0 Hz
Q [136] << SHFTR_HR()
  and ( hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) ) >>
Why created:    <<P0>> S0 <<Q0>> in alternative for [serial 1406]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 289:
Theorem (289) [serial 1441] used for:
    normalization of [serial 1414] 


Theorem (291)                               [serial 1577] 
P [136] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 Hz else HEART_RATE^( - i - 1 )) = hr_nxt[
      2 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [132] ->
Q [145] << all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 Hz else HEART_RATE^( - i - 1 )) = hr_nxt[
      2 + i]  >>
Why created:    normalization of [serial 1575]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (292)                               [serial 1575] 
P [136] << ( all i ~ quantity whole 
  in 0 .. ( num_samples + - 2 ) 
  are (if MOTION_ARTIFACT^( - i + - 1 ) or not SENSOR_CONNECTED^( - i + 
      - 1 ) then 0 Hz else HEART_RATE^( - i + - 1 )) = hr_nxt[2 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [132] ->
Q [145] << all i ~ quantity whole 
  in 0 .. ( num_samples + - 2 ) 
  are (if MOTION_ARTIFACT^( - 1 + - i ) or not SENSOR_CONNECTED^( - 1 + 
      - i ) then 0 Hz else HEART_RATE^( - 1 + - i )) = hr_nxt[2 + i]  >>
Why created:   changing adding negation to subtraction  [serial 1573]
Solved by:  Reflexivity of Addition: a+b=b+a
  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 291:
Theorem (291) [serial 1577] used for:
    normalization of [serial 1575] 


Theorem (293)                               [serial 1573] 
P [136] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 Hz else HEART_RATE^( - i - 1 )) = hr_nxt[
      2 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [132] ->
Q [145] << all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( -1 + - i ) or not SENSOR_CONNECTED^( -1 + - i ) then 0 Hz else HEART_RATE^( 
      -1 + - i )) = hr_nxt[2 + i]  >>
Why created:    normalization of [serial 1571]
Solved by:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 292:
Theorem (292) [serial 1575] used for:
   changing adding negation to subtraction  [serial 1573] 


Theorem (294)                               [serial 1571] 
P [136] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 Hz else HEART_RATE^( - i - 1 )) = hr_nxt[
      1 + i + 1]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [132] ->
Q [145] << all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( -1 + - i ) or not SENSOR_CONNECTED^( -1 + - i ) then 0 Hz else HEART_RATE^( 
      -1 + - i )) = hr_nxt[2 + i]  >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1569]
Solved by:  Literal Arithmetic
  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 293:
Theorem (293) [serial 1573] used for:
    normalization of [serial 1571] 


Theorem (295)                               [serial 1569] 
P [136] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 Hz else HEART_RATE^( - i - 1 )) = hr_nxt[
      ( 1 + i ) + 1]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [132] ->
Q [145] << all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( -1 + - i ) or not SENSOR_CONNECTED^( -1 + - i ) then 0 Hz else HEART_RATE^( 
      -1 + - i )) = hr_nxt[2 + i]  >>
Why created:    normalization of [serial 1567]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 294:
Theorem (294) [serial 1571] used for:
  Associativity: a.(b.c) = a.b.c [serial 1569] 


Theorem (296)                               [serial 1567] 
P [136] << ( all i ~ quantity whole 
  in 0 .. ( num_samples + - 2 ) 
  are (if MOTION_ARTIFACT^( ( - 1 + - i ) ) or not SENSOR_CONNECTED^( ( 
      - 1 + - i ) ) then 0 Hz else HEART_RATE^( ( - 1 + - i ) )) = hr_nxt[
      ( 1 + i ) + 1]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [132] ->
Q [145] << all i ~ quantity whole 
  in 0 .. ( num_samples + - 2 ) 
  are (if MOTION_ARTIFACT^( 1 + - 2 + - i ) or not SENSOR_CONNECTED^( 1 + 
      - 2 + - i ) then 0 Hz else HEART_RATE^( 1 + - 2 + - i )) = hr_nxt[
      2 + i]  >>
Why created:   changing adding negation to subtraction  [serial 1566]
Solved by:  Literal Arithmetic
  Reflexivity of Addition: a+b=b+a
  Unary Minus:  -(x-y) is (y-x)
  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 295:
Theorem (295) [serial 1569] used for:
    normalization of [serial 1567] 


Theorem (297)                               [serial 1566] 
P [136] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( -(1 + i) ) or not SENSOR_CONNECTED^( -(1 + i) ) then 0 Hz else HEART_RATE^( -(
      1 + i) )) = hr_nxt[( 1 + i ) + 1]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [132] ->
Q [145] << all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( 1 - ( 2 + i ) ) or not SENSOR_CONNECTED^( 1 - ( 
      2 + i ) ) then 0 Hz else HEART_RATE^( 1 - ( 2 + i ) )) = hr_nxt[2 + 
      i]  >>
Why created:  Shift Quantification Range so Lower Bound is Zero  [serial 1563]
Solved by:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 296:
Theorem (296) [serial 1567] used for:
   changing adding negation to subtraction  [serial 1566] 


Theorem (298)                               [serial 1563] 
P [136] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [132] ->
Q [145] << ( all i ~ quantity whole 
  in 2 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1561]
Solved by:  Shift Quantification Range so Lower Bound is Zero
and theorem 297:
Theorem (297) [serial 1566] used for:
  Shift Quantification Range so Lower Bound is Zero  [serial 1563] 


Theorem (299)                               [serial 1564] 
P [136] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [132] ->
Q [143] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1561]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (300)                               [serial 1565] 
P [136] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [132] ->
Q [144] << #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1561]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (301)                               [serial 1561] 
P [136] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [132] ->
Q [143] << ( all i ~ quantity whole 
  in 2 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 1559]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 298 299 300:
Theorem (298) [serial 1563] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1561] 
Theorem (299) [serial 1564] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1561] 
Theorem (300) [serial 1565] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1561] 


Theorem (302)                               [serial 1559] 
P [136] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
S [132] ->
Q [143] << ( all i ~ quantity whole 
  in 2 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1557]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 301:
Theorem (301) [serial 1561] used for:
    normalization of [serial 1559] 


Theorem (303)                               [serial 1557] 
P [136] << ( ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
S [132] ->
Q [143] << ( all i ~ quantity whole 
  in 2 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 1555]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 302:
Theorem (302) [serial 1559] used for:
  Associativity: a.(b.c) = a.b.c [serial 1557] 


Theorem (304)                               [serial 1555] 
P [136] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and ( ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are hr_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples ) >>
S [132] ->
Q [143] << ( all i ~ quantity whole 
  in 2 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1443]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 303:
Theorem (303) [serial 1557] used for:
    normalization of [serial 1555] 


Theorem (305)                               [serial 1443] 
P [136] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and SHFTR_HR() >>
S [132] ->
Q [143] << ( all i ~ quantity whole 
  in 2 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 1415]
Solved by:  Substitution of Assertion Labels
and theorem 304:
Theorem (304) [serial 1555] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1443] 


Theorem (306)                               [serial 1415] 
P [136] << SHFTR_HR()
  and ( hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) ) >>
S [132] ->
Q [143] << hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0)
  and num_samples = #PulseOx_Properties::Num_Trending_Samples
  and ( all i ~ quantity whole 
  in 2 .. num_samples 
  are hr_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))  ) >>
Why created:    <<Q0>> -> <<Q>> in alternative  for [serial 1406]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 305:
Theorem (305) [serial 1443] used for:
    normalization of [serial 1415] 


Theorem (307)                               [serial 1615] 
P [132] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [132] ->
Q [139] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:    normalization of [serial 1613]
Solved by:  Identity (id):  P->P is tautology


Theorem (308)                               [serial 1613] 
P [132] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [132] ->
Q [139] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are hr_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1612]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 307:
Theorem (307) [serial 1615] used for:
    normalization of [serial 1613] 


Theorem (309)                               [serial 1612] 
P [132] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [132] ->
Q [139] << ( ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are hr_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples )
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1478]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 308:
Theorem (308) [serial 1613] used for:
  Associativity: a.(b.c) = a.b.c [serial 1612] 


Theorem (310)                               [serial 1478] 
P [132] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [132] ->
Q [139] << SHFTR_HR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1445]
Solved by:  Substitution of Assertion Labels
and theorem 309:
Theorem (309) [serial 1612] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1478] 


Theorem (311)                               [serial 1445] 
P [132] << ( ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples )
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [132] ->
Q [139] << SHFTR_HR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:    normalization of [serial 1416]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 310:
Theorem (310) [serial 1478] used for:
  Associativity: a.(b.c) = a.b.c [serial 1445] 


Theorem (312)                               [serial 1416] 
P [132] << ( ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are hr_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples )
  and ( not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) ) >>
S [132] ->
Q [139] << SHFTR_HR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:    <<P and B1>> -> <<P1>> in alternative for [serial 1406]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 311:
Theorem (311) [serial 1445] used for:
    normalization of [serial 1416] 


Theorem (313)                               [serial 1586] 
P [139] << SHFTR_HR()
  and not ( MOTION_ARTIFACT or not SENSOR_CONNECTED ) >>
S [140] ->
Q [141] << SHFTR_HR() >>
Why created:    normalization of [serial 1584]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (314)                               [serial 1584] 
P [139] << SHFTR_HR()
  and not ( MOTION_ARTIFACT or not SENSOR_CONNECTED ) >>
S [140] ->
Q [141] << ( SHFTR_HR() ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1583]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 313:
Theorem (313) [serial 1586] used for:
    normalization of [serial 1584] 


Theorem (315)                               [serial 1583] 
P [139] << SHFTR_HR()
  and not ( MOTION_ARTIFACT or not SENSOR_CONNECTED ) >>
S [140] ->
Q [141] << true
  and SHFTR_HR() >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1582]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 314:
Theorem (314) [serial 1584] used for:
  Law of And-Simplification:  P and true is P [serial 1583] 


Theorem (316)                               [serial 1582] 
P [139] << SHFTR_HR()
  and not ( MOTION_ARTIFACT or not SENSOR_CONNECTED ) >>
S [140] ->
Q [141] << HEART_RATE = HEART_RATE
  and SHFTR_HR() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1581]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 315:
Theorem (315) [serial 1583] used for:
  Equality Law (idistr):  a=a <-> true [serial 1582] 


Theorem (317)                               [serial 1581] 
P [139] << SHFTR_HR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [140] ->
Q [141] << HEART_RATE = HEART_RATE^0
  and SHFTR_HR() >>
Why created:  Replacing port names with BLESS::Value properties  [serial 1580]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 316:
Theorem (316) [serial 1582] used for:
  Assume Present:  P = P@now = P^0   [serial 1581] 


Theorem (318)                               [serial 1580] 
P [139] << SHFTR_HR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [140] ->
Q [141] << HeartRate = HEART_RATE^0
  and SHFTR_HR() >>
Why created:   Conditional False Expression:  not b and x=g  iff  not b and x=(b??e:g)   [serial 1579]
Solved by:  Replacing port names with BLESS::Value properties
and theorem 317:
Theorem (317) [serial 1581] used for:
  Replacing port names with BLESS::Value properties  [serial 1580] 


Theorem (319)                               [serial 1579] 
P [139] << SHFTR_HR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [140] ->
Q [141] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = HeartRate
  and SHFTR_HR() >>
Why created:  applied wp for assignment [serial 1447]
Solved by:  Conditional False Expression:  not b and x=g  iff  not b and x=(b??e:g) 
and theorem 318:
Theorem (318) [serial 1580] used for:
   Conditional False Expression:  not b and x=g  iff  not b and x=(b??e:g)   [serial 1579] 


Theorem (320)                               [serial 1447] 
P [139] << SHFTR_HR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [140] hr_nxt[1] := HeartRate
Q [141] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and SHFTR_HR() >>
Why created:    normalization of [serial 1417]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 319:
Theorem (319) [serial 1579] used for:
  applied wp for assignment [serial 1447] 


Theorem (321)                               [serial 1417] 
P [139] << SHFTR_HR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [140] hr_nxt[1] := HeartRate
Q [141] << SHFTR_HR()
  and ( hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) ) >>
Why created:    <<P1>> S1 <<Q1>> in alternative for [serial 1406]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 320:
Theorem (320) [serial 1447] used for:
    normalization of [serial 1417] 


Theorem (322)                               [serial 1598] 
P [141] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [132] ->
Q [145] << all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  >>
Why created:  Shift Quantification Range so Lower Bound is Zero  [serial 1597]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (323)                               [serial 1597] 
P [141] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [132] ->
Q [145] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  >>
Why created:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1594]
Solved by:  Shift Quantification Range so Lower Bound is Zero
and theorem 322:
Theorem (322) [serial 1598] used for:
  Shift Quantification Range so Lower Bound is Zero  [serial 1597] 


Theorem (324)                               [serial 1594] 
P [141] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [132] ->
Q [145] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1592]
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
and theorem 323:
Theorem (323) [serial 1597] used for:
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1594] 


Theorem (325)                               [serial 1595] 
P [141] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [132] ->
Q [143] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1592]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (326)                               [serial 1596] 
P [141] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [132] ->
Q [144] << #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1592]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (327)                               [serial 1592] 
P [141] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i )) = hr_nxt[
      1 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [132] ->
Q [143] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 1590]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 324 325 326:
Theorem (324) [serial 1594] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1592] 
Theorem (325) [serial 1595] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1592] 
Theorem (326) [serial 1596] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1592] 


Theorem (328)                               [serial 1590] 
P [141] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are hr_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1] >>
S [132] ->
Q [143] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1589]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 327:
Theorem (327) [serial 1592] used for:
    normalization of [serial 1590] 


Theorem (329)                               [serial 1589] 
P [141] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and ( ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are hr_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples ) >>
S [132] ->
Q [143] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1588]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 328:
Theorem (328) [serial 1590] used for:
  Associativity: a.(b.c) = a.b.c [serial 1589] 


Theorem (330)                               [serial 1588] 
P [141] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and SHFTR_HR() >>
S [132] ->
Q [143] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1449]
Solved by:  Substitution of Assertion Labels
and theorem 329:
Theorem (329) [serial 1589] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1588] 


Theorem (331)                               [serial 1449] 
P [141] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and SHFTR_HR() >>
S [132] ->
Q [143] << ( all i ~ quantity whole 
  in 2 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 1418]
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
and theorem 330:
Theorem (330) [serial 1588] used for:
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1449] 


Theorem (332)                               [serial 1418] 
P [141] << SHFTR_HR()
  and ( hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) ) >>
S [132] ->
Q [143] << hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0)
  and num_samples = #PulseOx_Properties::Num_Trending_Samples
  and ( all i ~ quantity whole 
  in 2 .. num_samples 
  are hr_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))  ) >>
Why created:    <<Q1>> -> <<Q>> in alternative  for [serial 1406]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 331:
Theorem (331) [serial 1449] used for:
    normalization of [serial 1418] 


Theorem (333)                               [serial 1406] 
P [128] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are hr_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
S [132]   if 
    (MotionArtifact? or not SensorConnected?)~> 
      << SHFTR_HR()
        and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
      hr_nxt[1] := 0 Hz
      << SHFTR_HR()
        and ( hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) ) >> 
  []
    (not ( MotionArtifact? or not SensorConnected? ))~> 
      << SHFTR_HR()
        and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
      hr_nxt[1] := HeartRate
      << SHFTR_HR()
        and ( hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) ) >> 
  fi
Q [143] << hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0)
  and num_samples = #PulseOx_Properties::Num_Trending_Samples
  and ( all i ~ quantity whole 
  in 2 .. num_samples 
  are hr_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))  ) >>
Why created:  <<Q3 and P4>> S4 <<Q4 and P5>> in sequential composition for [serial 1017]
Solved by:  Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>>
and theorems 276 283 290 306 312 321 332:
Theorem (276) [serial 1412] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1406] 
Theorem (283) [serial 1413] used for:
    <<P and B0>> -> <<P0>> in alternative for [serial 1406] 
Theorem (290) [serial 1414] used for:
    <<P0>> S0 <<Q0>> in alternative for [serial 1406] 
Theorem (306) [serial 1415] used for:
    <<Q0>> -> <<Q>> in alternative  for [serial 1406] 
Theorem (312) [serial 1416] used for:
    <<P and B1>> -> <<P1>> in alternative for [serial 1406] 
Theorem (321) [serial 1417] used for:
    <<P1>> S1 <<Q1>> in alternative for [serial 1406] 
Theorem (332) [serial 1418] used for:
    <<Q1>> -> <<Q>> in alternative  for [serial 1406] 


Theorem (334)                               [serial 1604] 
P [150] << (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [152] ->
Q [153] << (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  applied wp for assignment [serial 1455]
Solved by:  Identity (id):  P->P is tautology


Theorem (335)                               [serial 1455] 
P [150] << (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [152] heart_rate_store[i] := hr_nxt[i]
Q [153] << (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 1419]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 334:
Theorem (334) [serial 1604] used for:
  applied wp for assignment [serial 1455] 


Theorem (336)                               [serial 1419] 
P [150] << hr_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
S [152] heart_rate_store[i] := hr_nxt[i]
Q [153] << heart_rate_store[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
Why created:  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1407]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 335:
Theorem (335) [serial 1455] used for:
    normalization of [serial 1419] 


Theorem (337)                               [serial 1601] 
P [143] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [148] ->
Q [19] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
  and ( #PulseOx_Properties::Num_Trending_Samples = num_samples ) >>
Why created:  Introduction of (unused) Universal Quantification [serial 1600]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (338)                               [serial 1600] 
P [143] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [148] ->
Q [19] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
  and ( all i ~ quantity whole 
  in 1 .. num_samples 
  are #PulseOx_Properties::Num_Trending_Samples = num_samples  ) >>
Why created:  Combine Universal Quantifications: all x:t in R are (A and B) = (all x:t in R are A) and (all x:t in R are B)  [serial 1599]
Solved by:  Introduction of (unused) Universal Quantification
and theorem 337:
Theorem (337) [serial 1601] used for:
  Introduction of (unused) Universal Quantification [serial 1600] 


Theorem (339)                               [serial 1599] 
P [143] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [148] ->
Q [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]
        and #PulseOx_Properties::Num_Trending_Samples = num_samples  >>
Why created:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1451]
Solved by:  Combine Universal Quantifications: all x:t in R are (A and B) = (all x:t in R are A) and (all x:t in R are B)
and theorem 338:
Theorem (338) [serial 1600] used for:
  Combine Universal Quantifications: all x:t in R are (A and B) = (all x:t in R are A) and (all x:t in R are B)  [serial 1599] 


Theorem (340)                               [serial 1451] 
P [143] << ( all i ~ quantity whole 
  in 2 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) = hr_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [148] ->
Q [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = hr_nxt[i]
        and #PulseOx_Properties::Num_Trending_Samples = num_samples  >>
Why created:    normalization of [serial 1420]
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
and theorem 339:
Theorem (339) [serial 1599] used for:
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1451] 


Theorem (341)                               [serial 1420] 
P [143] << ( hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0)
  and num_samples = #PulseOx_Properties::Num_Trending_Samples
  and ( all i ~ quantity whole 
  in 2 .. num_samples 
  are hr_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))  ) ) >>
S [148] ->
Q [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are hr_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1407]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 340:
Theorem (340) [serial 1451] used for:
    normalization of [serial 1420] 


Theorem (342)                               [serial 1603] 
P [19] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]  )
  and ( #PulseOx_Properties::Num_Trending_Samples = num_samples ) >>
S [148] ->
Q [156] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  Introduction of (unused) Universal Quantification [serial 1602]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (343)                               [serial 1602] 
P [19] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]  )
  and ( all i ~ quantity whole 
  in 1 .. num_samples 
  are #PulseOx_Properties::Num_Trending_Samples = num_samples  ) >>
S [148] ->
Q [156] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  Combine Universal Quantifications: all x:t in R are (A and B) = (all x:t in R are A) and (all x:t in R are B)  [serial 1453]
Solved by:  Introduction of (unused) Universal Quantification
and theorem 342:
Theorem (342) [serial 1603] used for:
  Introduction of (unused) Universal Quantification [serial 1602] 


Theorem (344)                               [serial 1453] 
P [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]
        and #PulseOx_Properties::Num_Trending_Samples = num_samples  >>
S [148] ->
Q [156] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 1421]
Solved by:  Combine Universal Quantifications: all x:t in R are (A and B) = (all x:t in R are A) and (all x:t in R are B)
and theorem 343:
Theorem (343) [serial 1602] used for:
  Combine Universal Quantifications: all x:t in R are (A and B) = (all x:t in R are A) and (all x:t in R are B)  [serial 1453] 


Theorem (345)                               [serial 1421] 
P [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
S [148] ->
Q [156] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
Why created:    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1407]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 344:
Theorem (344) [serial 1453] used for:
    normalization of [serial 1421] 


Theorem (346)                               [serial 1407] 
P [143] << hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0)
  and num_samples = #PulseOx_Properties::Num_Trending_Samples
  and ( all i ~ quantity whole 
  in 2 .. num_samples 
  are hr_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))  ) >>
S [148] forall i in 1 .. num_samples
    {
    << hr_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))
      and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
    heart_rate_store[i] := hr_nxt[i]
    << heart_rate_store[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))
      and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
    }  
Q [156] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
Why created:  <<Q4 and P5>> S5 <<Q5 and P6>> in sequential composition for [serial 1017]
Solved by:  Universal Quantification Rule:
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any
and theorems 336 341 345:
Theorem (336) [serial 1419] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1407] 
Theorem (341) [serial 1420] used for:
    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1407] 
Theorem (345) [serial 1421] used for:
    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1407] 


Theorem (347)                               [serial 1607] 
P [156] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [160] ->
Q [161] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 1605]
Solved by:  Identity (id):  P->P is tautology


Theorem (348)                               [serial 1609] 
P [156] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [160] ->
Q [161] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 1605]
Solved by:  Identity (id):  P->P is tautology


Theorem (349)                               [serial 1605] 
P [156] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [160] ->
Q [161] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
Why created:  applied wp for simultaneous assignment [serial 1457]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorems 347 348:
Theorem (347) [serial 1607] used for:
    normalization of [serial 1605] 
Theorem (348) [serial 1609] used for:
    normalization of [serial 1605] 


Theorem (350)                               [serial 1457] 
P [156] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i )) = heart_rate_store[i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [160] |heart_rate_store',num_samples' := heart_rate_store,num_samples|  
Q [161] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))  )
  and num_samples' = #PulseOx_Properties::Num_Trending_Samples >>
Why created:    normalization of [serial 1408]
Solved by:  Simultaneous Assignment
and theorem 349:
Theorem (349) [serial 1605] used for:
  applied wp for simultaneous assignment [serial 1457] 


Theorem (351)                               [serial 1408] 
P [156] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
S [160] |heart_rate_store',num_samples' := heart_rate_store,num_samples|  
Q [161] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are heart_rate_store[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))  )
  and num_samples' = #PulseOx_Properties::Num_Trending_Samples >>
Why created:  <<Q5 and P6>> S6 <<Q6>> in sequential composition for [serial 1017]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 350:
Theorem (350) [serial 1457] used for:
    normalization of [serial 1408] 


Theorem (352)                               [serial 1017] 
P [53] << INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
S [113]   << INV_HR()
    and num_samples = #PulseOx_Properties::Num_Trending_Samples
    and AXIOM_HRT() >>
  HeartRateTrend!(heart_rate_store)
  ;
  << INV_HR()
    and num_samples = #PulseOx_Properties::Num_Trending_Samples
    and AXIOM_HRT() >>
  NumSamples!(num_samples)
  ;
  << INV_HR()
    and num_samples = #PulseOx_Properties::Num_Trending_Samples
    and AXIOM_CR() >>
  forall i in 1 .. ( num_samples - 1 )
      {
      << heart_rate_store[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
      hr_nxt[i + 1] := heart_rate_store[i]
      << hr_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
      }  
  <<SHFTR_HR: :( all i ~ quantity whole 
    in 1 .. ( num_samples - 1 ) 
    are hr_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 Hz else HEART_RATE^( - i ))  )
    and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
  ;
    if 
      (MotionArtifact? or not SensorConnected?)~> 
        << SHFTR_HR()
          and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
        hr_nxt[1] := 0 Hz
        << SHFTR_HR()
          and ( hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) ) >> 
    []
      (not ( MotionArtifact? or not SensorConnected? ))~> 
        << SHFTR_HR()
          and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
        hr_nxt[1] := HeartRate
        << SHFTR_HR()
          and ( hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0) ) >> 
    fi
  << hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 Hz else HEART_RATE^0)
    and num_samples = #PulseOx_Properties::Num_Trending_Samples
    and ( all i ~ quantity whole 
    in 2 .. num_samples 
    are hr_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))  ) >>
  ;
  forall i in 1 .. num_samples
      {
      << hr_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
      heart_rate_store[i] := hr_nxt[i]
      << heart_rate_store[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
      }  
  << ( all i ~ quantity whole 
    in 1 .. num_samples 
    are heart_rate_store[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))  )
    and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
  ;
  |heart_rate_store',num_samples' := heart_rate_store,num_samples|  
  << ( all i ~ quantity whole 
    in 1 .. num_samples 
    are heart_rate_store[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 Hz else HEART_RATE^( 1 - i ))  )
    and num_samples' = #PulseOx_Properties::Num_Trending_Samples >> 
Q [53] << ( INV_HR()
  and num_samples = #PulseOx_Properties::Num_Trending_Samples )^1 >>
Why created:   <<M(run) and x>> A <<M(run)>> for hrtt3: run-[x]->run{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 204 223 239 255 273 333 346 351:
Theorem (204) [serial 1401] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1017] 
Theorem (223) [serial 1402] used for:
  <<Q6>> -> <<Q>> in sequential composition for [serial 1017] 
Theorem (239) [serial 1403] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1017] 
Theorem (255) [serial 1404] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1017] 
Theorem (273) [serial 1405] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1017] 
Theorem (333) [serial 1406] used for:
  <<Q3 and P4>> S4 <<Q4 and P5>> in sequential composition for [serial 1017] 
Theorem (346) [serial 1407] used for:
  <<Q4 and P5>> S5 <<Q5 and P6>> in sequential composition for [serial 1017] 
Theorem (351) [serial 1408] used for:
  <<Q5 and P6>> S6 <<Q6>> in sequential composition for [serial 1017] 


Theorem (353)                               [serial 1007] 
P [28] <<   >>
S [36] ->
Q [28] << HeartRateTrendThread.imp proof obligations >>
Why created:  Initial proof obligations for HeartRateTrendThread.imp
Solved by:  Component verification conditions
and theorems 27 30 31 34 64 166 182 197 198 352:
Theorem (27) [serial 1008] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (30) [serial 1009] used for:
  <<M(fill)>> -> <<I>> from invariant I when complete state fill has Assertion <<M(fill)>> in its definition. 
Theorem (31) [serial 1010] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (34) [serial 1011] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state check, <<M(check)>> -> <<e1 or e2 or . . . en>> 
Theorem (64) [serial 1012] used for:
   <<M(start)>> A <<M(fill)>> for hrtt0: start-[ ]->fill{A}; 
Theorem (166) [serial 1013] used for:
   <<M(fill) and x>> A <<M(check)>> for hrtt1: fill-[x]->check{A}; 
Theorem (182) [serial 1014] used for:
   <<M(check) and x>> A <<M(fill)>> for hrtt2a: check-[x]->fill{A}; 
Theorem (197) [serial 1015] used for:
   <<M(check) and x>> A <<M(run)>> for hrtt2b: check-[x]->run{A}; 
Theorem (198) [serial 1016] used for:
   <<M(check) and x>> -> <<M(fail)>> for hrtt2c: check-[x]->fail{}; 
Theorem (352) [serial 1017] used for:
   <<M(run) and x>> A <<M(run)>> for hrtt3: run-[x]->run{A}; 


Theorem (354)                               [serial 1634] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [33] ->
Q [33] << all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s]  >>
Why created:    normalization of [serial 1632]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (355)                               [serial 1632] 
P [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  )
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples ) >>
S [33] ->
Q [33] << all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1019]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 354:
Theorem (354) [serial 1634] used for:
    normalization of [serial 1632] 


Theorem (356)                               [serial 1019] 
P [51] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples ) >>
S [33] ->
Q [33] << all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by:  Substitution of Assertion Labels
and theorem 355:
Theorem (355) [serial 1632] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1019] 


Theorem (357)                               [serial 1638] 
P [47] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [33] ->
Q [33] << all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s]  >>
Why created:    normalization of [serial 1636]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (358)                               [serial 1636] 
P [47] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  )
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples ) >>
S [33] ->
Q [33] << all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1020]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 357:
Theorem (357) [serial 1638] used for:
    normalization of [serial 1636] 


Theorem (359)                               [serial 1020] 
P [47] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples ) >>
S [33] ->
Q [33] << all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  >>
Why created:  <<M(loading)>> -> <<I>> from invariant I when complete state loading has Assertion <<M(loading)>> in its definition.
Solved by:  Substitution of Assertion Labels
and theorem 358:
Theorem (358) [serial 1636] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1020] 


Theorem (360)                               [serial 1021] 
P [43] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
  and ( num_samples = 0 )
  and ( all s ~ quantity whole 
  in ( num_samples + 1 ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  ) >>
S [43] ->
Q [43] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by:  True Conclusion Schema (tc): P->true


Theorem (361)                               [serial 1643] 
P [49] << HOLD(num_samples) >>
S [49] ->
Q [49] << true >>
Why created:  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1641]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (362)                               [serial 1641] 
P [49] << HOLD(num_samples) >>
S [49] ->
Q [49] << #PulseOx_Properties::Num_Trending_Samples < num_samples or num_samples < #PulseOx_Properties::Num_Trending_Samples or 
#PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 1022]
Solved by:  Less than, greater than, or equal:  |-a<b or b<a or a=b
and theorem 361:
Theorem (361) [serial 1643] used for:
  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1641] 


Theorem (363)                               [serial 1022] 
P [49] << HOLD(num_samples) >>
S [49] ->
Q [49] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples ) or ( num_samples = #PulseOx_Properties::Num_Trending_Samples ) or 
( num_samples > #PulseOx_Properties::Num_Trending_Samples ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state check, <<M(check)>> -> <<e1 or e2 or . . . en>>
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of Greater Than: (a>b) = (b<a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 362:
Theorem (362) [serial 1641] used for:
    normalization of [serial 1022] 


Theorem (364)                               [serial 1681] 
P [43] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [55] ->
Q [33] << true >>
Why created:  Empty Range Law All: all a:t which false are V is tautology  [serial 1680]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (365)                               [serial 1680] 
P [43] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [55] ->
Q [33] << all s ~ quantity whole 
  which false 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  >>
Why created:  Empty Range [serial 1679]
Solved by:  Empty Range Law All: all a:t which false are V is tautology
and theorem 364:
Theorem (364) [serial 1681] used for:
  Empty Range Law All: all a:t which false are V is tautology  [serial 1680] 


Theorem (366)                               [serial 1679] 
P [43] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [55] ->
Q [33] << all s ~ quantity whole 
  in 1 .. 0 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  >>
Why created:  Guided Substitution of Equals 
 replacing "num_samples" with its = "0" in its postcondition [serial 1677]
Solved by:  Empty Range
and theorem 365:
Theorem (365) [serial 1680] used for:
  Empty Range [serial 1679] 


Theorem (367)                               [serial 1677] 
P [43] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [55] ->
Q [33] << all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  >>
Why created:    normalization of [serial 1674]
Solved by:  Guided Substitution of Equals
and theorem 366:
Theorem (366) [serial 1679] used for:
  Guided Substitution of Equals 
 replacing "num_samples" with its = "0" in its postcondition [serial 1677] 


Theorem (368)                               [serial 1674] 
P [43] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [55] ->
Q [33] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1673]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 367:
Theorem (367) [serial 1677] used for:
    normalization of [serial 1674] 


Theorem (369)                               [serial 1675] 
P [43] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [55] ->
Q [47] << num_samples < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1673]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (370)                               [serial 1673] 
P [43] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [55] ->
Q [47] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  applied wp for assignment [serial 1670]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 368 369:
Theorem (368) [serial 1674] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1673] 
Theorem (369) [serial 1675] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1673] 


Theorem (371)                               [serial 1670] 
P [43] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:    normalization of [serial 1668]
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 370:
Theorem (370) [serial 1673] used for:
  applied wp for assignment [serial 1670] 


Theorem (372)                               [serial 1668] 
P [43] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if not ( SENSOR_CONNECTED^( - s ) )^1 or MOTION_ARTIFACT^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1666]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Caret Compostition:  (x^a)^b is x^(a+b)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 371:
Theorem (371) [serial 1670] used for:
    normalization of [serial 1668] 


Theorem (373)                               [serial 1666] 
P [43] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( not SENSOR_CONNECTED^( - s ) )^1 or MOTION_ARTIFACT^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:    normalization of [serial 1664]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 372:
Theorem (372) [serial 1668] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1666] 


Theorem (374)                               [serial 1664] 
P [43] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( MOTION_ARTIFACT^( ( - s ) + 1 ) or ( not SENSOR_CONNECTED^( - s ) )^1 ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1662]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 373:
Theorem (373) [serial 1666] used for:
    normalization of [serial 1664] 


Theorem (375)                               [serial 1662] 
P [43] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1 then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:    normalization of [serial 1660]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 374:
Theorem (374) [serial 1664] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1662] 


Theorem (376)                               [serial 1660] 
P [43] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1 then ( 0 percent )^1 else SPO2^( 
      ( - s ) + 1 )) = spo2_a[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1658]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Constants are always the same
  Associativity: a.(b.c) = a.b.c
and theorem 375:
Theorem (375) [serial 1662] used for:
    normalization of [serial 1660] 


Theorem (377)                               [serial 1658] 
P [43] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))^1 = spo2_a[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:    normalization of [serial 1656]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 376:
Theorem (376) [serial 1660] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1658] 


Theorem (378)                               [serial 1656] 
P [43] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))^1 = ( spo2_a[s] )^1 )  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1654]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 377:
Theorem (377) [serial 1658] used for:
    normalization of [serial 1656] 


Theorem (379)                               [serial 1654] 
P [43] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s] )^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:    normalization of [serial 1652]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 378:
Theorem (378) [serial 1656] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1654] 


Theorem (380)                               [serial 1652] 
P [43] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( ( num_samples )^1 < ( #PulseOx_Properties::Num_Trending_Samples )^1 )
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s] )^1  ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1650]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Constants are always the same
  Associativity: a.(b.c) = a.b.c
and theorem 379:
Theorem (379) [serial 1654] used for:
    normalization of [serial 1652] 


Theorem (381)                               [serial 1650] 
P [43] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples )^1
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s]  )^1 >>
Why created:    normalization of [serial 1648]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 380:
Theorem (380) [serial 1652] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1650] 


Theorem (382)                               [serial 1648] 
P [43] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s]  )^1
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1646]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 381:
Theorem (381) [serial 1650] used for:
    normalization of [serial 1648] 


Theorem (383)                               [serial 1646] 
P [43] << ( all s ~ quantity whole 
  in ( 1 + num_samples ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and 0 = num_samples >>
S [55] num_samples' := num_samples
Q [47] << ( ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples )^1 >>
Why created:    normalization of [serial 1644]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 382:
Theorem (382) [serial 1648] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1646] 


Theorem (384)                               [serial 1644] 
P [43] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
  and ( num_samples = 0 )
  and ( all s ~ quantity whole 
  in ( num_samples + 1 ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  ) >>
S [55] num_samples' := num_samples
Q [47] << ( ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  )
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples ) )^1 >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1023]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 383:
Theorem (383) [serial 1646] used for:
    normalization of [serial 1644] 


Theorem (385)                               [serial 1023] 
P [43] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
  and ( num_samples = 0 )
  and ( all s ~ quantity whole 
  in ( num_samples + 1 ) .. #PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^( - s )  ) >>
S [55] num_samples' := num_samples
Q [47] << ( SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples ) )^1 >>
Why created:   <<M(start)>> A <<M(loading)>> for sptt0: start-[ ]->loading{A};
Solved by:  Substitution of Assertion Labels
and theorem 384:
Theorem (384) [serial 1644] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1023] 


Theorem (386)                               [serial 1776] 
P [47] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and SpO2_INV() >>
S [47] ->
Q [58] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and SpO2_INV() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1749]
Solved by:  Identity (id):  P->P is tautology


Theorem (387)                               [serial 1749] 
P [47] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and SpO2_INV() >>
S [47] ->
Q [58] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and SpO2_INV()
  and true >>
Why created:    normalization of [serial 1703]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 386:
Theorem (386) [serial 1776] used for:
  Law of And-Simplification:  P and true is P [serial 1749] 


Theorem (388)                               [serial 1703] 
P [47] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples ) >>
S [47] ->
Q [58] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 387:
Theorem (387) [serial 1749] used for:
    normalization of [serial 1703] 


Theorem (389)                               [serial 1776] 
P [47] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and SpO2_INV() >>
S [47] ->
Q [58] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and SpO2_INV() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1749]
Solved by:  Identity (id):  P->P is tautology


Theorem (390)                               [serial 1749] 
P [47] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and SpO2_INV() >>
S [47] ->
Q [58] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and SpO2_INV()
  and true >>
Why created:    normalization of [serial 1703]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 389:
Theorem (389) [serial 1776] used for:
  Law of And-Simplification:  P and true is P [serial 1749] 


Theorem (391)                               [serial 1703] 
P [47] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples ) >>
S [47] ->
Q [58] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 390:
Theorem (390) [serial 1749] used for:
    normalization of [serial 1703] 


Theorem (392)                               [serial 1682] 
P [47] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples ) >>
S [47] ->
Q [58] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
  and AXIOM_NS() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1024]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 391 391:
Theorem (391) [serial 1703] used for:
   add user-defined axioms to postcondition 
Theorem (391) [serial 1703] used for:
   add user-defined axioms to postcondition 


Theorem (393)                               [serial 1783] 
P [102] << all #10# ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - #10# ) or not SENSOR_CONNECTED^( 1 - #10# ) then 0 percent else SPO2^( 1 - #10# )) = spo2_a[#10#]  >>
S [49] ->
Q [49] << all #11# ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - #11# ) or not SENSOR_CONNECTED^( 1 - #11# ) then 0 percent else SPO2^( 1 - #11# )) = spo2_a[#11#]  >>
Why created:  Replacement of Quantified Variables with #1, #2, etc.  [serial 1781]
Solved by:  Identity (id):  P->P is tautology


Theorem (394)                               [serial 1781] 
P [102] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_a[i]  >>
S [49] ->
Q [49] << all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  >>
Why created:    normalization of [serial 1779]
Solved by:  Replacement of Quantified Variables with #1, #2, etc.
and theorem 393:
Theorem (393) [serial 1783] used for:
  Replacement of Quantified Variables with #1, #2, etc.  [serial 1781] 


Theorem (395)                               [serial 1779] 
P [102] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_a[i]  >>
S [49] ->
Q [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s ))  ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1715]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 394:
Theorem (394) [serial 1781] used for:
    normalization of [serial 1779] 


Theorem (396)                               [serial 1715] 
P [102] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_a[i]  >>
S [49] ->
Q [49] << HOLD(num_samples) >>
Why created:    normalization of [serial 1683]
Solved by:  Substitution of Assertion Labels
and theorem 395:
Theorem (395) [serial 1779] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1715] 


Theorem (397)                               [serial 1683] 
P [102] << all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  >>
S [49] ->
Q [49] << HOLD(num_samples) >>
Why created:  <<Q6>> -> <<Q>> in sequential composition for [serial 1024]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 396:
Theorem (396) [serial 1715] used for:
    normalization of [serial 1683] 


Theorem (398)                               [serial 1843] 
P [58] << num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
S [60] ->
Q [15] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
Why created:  Guided Substitution of Equals 
 replacing "SPO2_HISTORY" with its = "spo2_a" in its postcondition [serial 1842]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (399)                               [serial 1842] 
P [58] << num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
S [60] ->
Q [15] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are SPO2_HISTORY[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
Why created:  Guided Substitution of Equals 
 replacing "NUM_SAMPLES" with its = "num_samples" in its postcondition [serial 1841]
Solved by:  Guided Substitution of Equals
and theorem 398:
Theorem (398) [serial 1843] used for:
  Guided Substitution of Equals 
 replacing "SPO2_HISTORY" with its = "spo2_a" in its postcondition [serial 1842] 


Theorem (400)                               [serial 1841] 
P [58] << num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
S [60] ->
Q [15] << ( all s ~ quantity whole 
  in 1 .. NUM_SAMPLES 
  are SPO2_HISTORY[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1840]
Solved by:  Guided Substitution of Equals
and theorem 399:
Theorem (399) [serial 1842] used for:
  Guided Substitution of Equals 
 replacing "NUM_SAMPLES" with its = "num_samples" in its postcondition [serial 1841] 


Theorem (401)                               [serial 1840] 
P [58] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and ( num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY )
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
S [60] ->
Q [15] << ( all s ~ quantity whole 
  in 1 .. NUM_SAMPLES 
  are SPO2_HISTORY[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1751]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 400:
Theorem (400) [serial 1841] used for:
  Associativity: a.(b.c) = a.b.c [serial 1840] 


Theorem (402)                               [serial 1751] 
P [58] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_NS()
  and SpO2_INV() >>
S [60] ->
Q [15] << SPO2_TREND() >>
Why created:    normalization of [serial 1712]
Solved by:  Substitution of Assertion Labels
and theorem 401:
Theorem (401) [serial 1840] used for:
  Substituted assertions' predicates for labels  [serial 1751] 


Theorem (403)                               [serial 1712] 
P [58] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
  and AXIOM_NS() >>
S [60] ->
Q [15] << SPO2_TREND() >>
Why created:  applied port output of value <<pre>> -> <<M(SpO2Trend)[SpO2Trend|spo2_a]>> [serial 1704]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 402:
Theorem (402) [serial 1751] used for:
    normalization of [serial 1712] 


Theorem (404)                               [serial 1778] 
P [60] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_NS()
  and SpO2_INV()
  and SPO2_TREND()^0 >>
S [60] ->
Q [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and SpO2_INV() >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1777]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (405)                               [serial 1777] 
P [60] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_NS()
  and SpO2_INV() )
  and SPO2_TREND()^0 >>
S [60] ->
Q [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and SpO2_INV() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1753]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 404:
Theorem (404) [serial 1778] used for:
  Associativity: a.(b.c) = a.b.c [serial 1777] 


Theorem (406)                               [serial 1753] 
P [60] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_NS()
  and SpO2_INV() )
  and SPO2_TREND()^0 >>
S [60] ->
Q [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and SpO2_INV()
  and true >>
Why created:    normalization of [serial 1713]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 405:
Theorem (405) [serial 1777] used for:
  Law of And-Simplification:  P and true is P [serial 1753] 


Theorem (407)                               [serial 1713] 
P [60] << ( SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
  and AXIOM_NS() )
  and ( SPO2_TREND() )^0 >>
S [60] ->
Q [62] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
  and true >>
Why created:  applied port output <<pre and (SPO2_TREND())^0>> -> <<post>> [serial 1704]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 406:
Theorem (406) [serial 1753] used for:
    normalization of [serial 1713] 


Theorem (408)                               [serial 1704] 
P [58] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
  and AXIOM_NS() >>
S [60] SpO2Trend!(spo2_a)
Q [62] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 403 407:
Theorem (403) [serial 1712] used for:
  applied port output of value <<pre>> -> <<M(SpO2Trend)[SpO2Trend|spo2_a]>> [serial 1704] 
Theorem (407) [serial 1713] used for:
  applied port output <<pre and (SPO2_TREND())^0>> -> <<post>> [serial 1704] 


Theorem (409)                               [serial 1843] 
P [58] << num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
S [60] ->
Q [15] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
Why created:  Guided Substitution of Equals 
 replacing "SPO2_HISTORY" with its = "spo2_a" in its postcondition [serial 1842]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (410)                               [serial 1842] 
P [58] << num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
S [60] ->
Q [15] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are SPO2_HISTORY[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
Why created:  Guided Substitution of Equals 
 replacing "NUM_SAMPLES" with its = "num_samples" in its postcondition [serial 1841]
Solved by:  Guided Substitution of Equals
and theorem 409:
Theorem (409) [serial 1843] used for:
  Guided Substitution of Equals 
 replacing "SPO2_HISTORY" with its = "spo2_a" in its postcondition [serial 1842] 


Theorem (411)                               [serial 1841] 
P [58] << num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
S [60] ->
Q [15] << ( all s ~ quantity whole 
  in 1 .. NUM_SAMPLES 
  are SPO2_HISTORY[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1840]
Solved by:  Guided Substitution of Equals
and theorem 410:
Theorem (410) [serial 1842] used for:
  Guided Substitution of Equals 
 replacing "NUM_SAMPLES" with its = "num_samples" in its postcondition [serial 1841] 


Theorem (412)                               [serial 1840] 
P [58] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and ( num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY )
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
S [60] ->
Q [15] << ( all s ~ quantity whole 
  in 1 .. NUM_SAMPLES 
  are SPO2_HISTORY[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1751]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 411:
Theorem (411) [serial 1841] used for:
  Associativity: a.(b.c) = a.b.c [serial 1840] 


Theorem (413)                               [serial 1751] 
P [58] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_NS()
  and SpO2_INV() >>
S [60] ->
Q [15] << SPO2_TREND() >>
Why created:    normalization of [serial 1712]
Solved by:  Substitution of Assertion Labels
and theorem 412:
Theorem (412) [serial 1840] used for:
  Substituted assertions' predicates for labels  [serial 1751] 


Theorem (414)                               [serial 1712] 
P [58] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
  and AXIOM_NS() >>
S [60] ->
Q [15] << SPO2_TREND() >>
Why created:  applied port output of value <<pre>> -> <<M(SpO2Trend)[SpO2Trend|spo2_a]>> [serial 1704]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 413:
Theorem (413) [serial 1751] used for:
    normalization of [serial 1712] 


Theorem (415)                               [serial 1778] 
P [60] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_NS()
  and SpO2_INV()
  and SPO2_TREND()^0 >>
S [60] ->
Q [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and SpO2_INV() >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1777]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (416)                               [serial 1777] 
P [60] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_NS()
  and SpO2_INV() )
  and SPO2_TREND()^0 >>
S [60] ->
Q [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and SpO2_INV() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1753]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 415:
Theorem (415) [serial 1778] used for:
  Associativity: a.(b.c) = a.b.c [serial 1777] 


Theorem (417)                               [serial 1753] 
P [60] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_NS()
  and SpO2_INV() )
  and SPO2_TREND()^0 >>
S [60] ->
Q [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and SpO2_INV()
  and true >>
Why created:    normalization of [serial 1713]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 416:
Theorem (416) [serial 1777] used for:
  Law of And-Simplification:  P and true is P [serial 1753] 


Theorem (418)                               [serial 1713] 
P [60] << ( SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
  and AXIOM_NS() )
  and ( SPO2_TREND() )^0 >>
S [60] ->
Q [62] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
  and true >>
Why created:  applied port output <<pre and (SPO2_TREND())^0>> -> <<post>> [serial 1704]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 417:
Theorem (417) [serial 1753] used for:
    normalization of [serial 1713] 


Theorem (419)                               [serial 1704] 
P [58] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
  and AXIOM_NS() >>
S [60] SpO2Trend!(spo2_a)
Q [62] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 414 418:
Theorem (414) [serial 1712] used for:
  applied port output of value <<pre>> -> <<M(SpO2Trend)[SpO2Trend|spo2_a]>> [serial 1704] 
Theorem (418) [serial 1713] used for:
  applied port output <<pre and (SPO2_TREND())^0>> -> <<post>> [serial 1704] 


Theorem (420)                               [serial 1684] 
P [58] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
  and AXIOM_NS() >>
S [60] SpO2Trend!(spo2_a)
Q [62] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
  and AXIOM_NS() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1024]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 419 419:
Theorem (419) [serial 1704] used for:
   add user-defined axioms to postcondition 
Theorem (419) [serial 1704] used for:
   add user-defined axioms to postcondition 


Theorem (421)                               [serial 1787] 
P [62] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and NUM_SAMPLES = num_samples
  and SPO2_HISTORY = spo2_a >>
S [64] ->
Q [64] << NUM_SAMPLES = num_samples >>
Why created:    normalization of [serial 1785]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (422)                               [serial 1785] 
P [62] << num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY
  and num_samples < #PulseOx_Properties::Num_Trending_Samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
S [64] ->
Q [64] << NUM_SAMPLES = num_samples >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1784]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 421:
Theorem (421) [serial 1787] used for:
    normalization of [serial 1785] 


Theorem (423)                               [serial 1784] 
P [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and ( num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY )
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
S [64] ->
Q [64] << NUM_SAMPLES = num_samples >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1717]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 422:
Theorem (422) [serial 1785] used for:
  Associativity: a.(b.c) = a.b.c [serial 1784] 


Theorem (424)                               [serial 1717] 
P [62] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_NS()
  and SpO2_INV() >>
S [64] ->
Q [64] << NUM_SAMPLES = num_samples >>
Why created:    normalization of [serial 1705]
Solved by:  Substitution of Assertion Labels
and theorem 423:
Theorem (423) [serial 1784] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1717] 


Theorem (425)                               [serial 1705] 
P [62] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
  and AXIOM_NS() >>
S [64] ->
Q [64] << num_samples = NUM_SAMPLES >>
Why created:  applied port output of value <<pre>> -> <<M(NumSamples)[NumSamples|num_samples]>> [serial 1685]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 424:
Theorem (424) [serial 1717] used for:
    normalization of [serial 1705] 


Theorem (426)                               [serial 1774] 
P [64] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_NS()
  and SpO2_INV()
  and ( NUM_SAMPLES = num_samples )^0 >>
S [64] ->
Q [66] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and SpO2_INV() >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1719]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (427)                               [serial 1719] 
P [64] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples
  and AXIOM_NS()
  and SpO2_INV() )
  and ( NUM_SAMPLES = num_samples )^0 >>
S [64] ->
Q [66] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and SpO2_INV() >>
Why created:    normalization of [serial 1706]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 426:
Theorem (426) [serial 1774] used for:
  Associativity: a.(b.c) = a.b.c [serial 1719] 


Theorem (428)                               [serial 1706] 
P [64] << ( SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
  and AXIOM_NS() )
  and ( num_samples = NUM_SAMPLES )^0 >>
S [64] ->
Q [66] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples ) >>
Why created:  applied port output <<pre and (num_samples = NUM_SAMPLES)^0>> -> <<post>> [serial 1685]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 427:
Theorem (427) [serial 1719] used for:
    normalization of [serial 1706] 


Theorem (429)                               [serial 1685] 
P [62] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
  and AXIOM_NS() >>
S [64] NumSamples!(num_samples)
Q [66] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples ) >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1024]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 425 428:
Theorem (425) [serial 1705] used for:
  applied port output of value <<pre>> -> <<M(NumSamples)[NumSamples|num_samples]>> [serial 1685] 
Theorem (428) [serial 1706] used for:
  applied port output <<pre and (num_samples = NUM_SAMPLES)^0>> -> <<post>> [serial 1685] 


Theorem (430)                               [serial 1725] 
P [69] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_a[i] >>
S [70] ->
Q [71] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_a[i] >>
Why created:    normalization of [serial 1707]
Solved by:  Identity (id):  P->P is tautology


Theorem (431)                               [serial 1707] 
P [69] << spo2_a[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) >>
S [70] ->
Q [71] << spo2_a[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) >>
Why created:  applied wp for assignment [serial 1690]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 430:
Theorem (430) [serial 1725] used for:
    normalization of [serial 1707] 


Theorem (432)                               [serial 1690] 
P [69] << spo2_a[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) >>
S [70] spo2_nxt[i + 1] := spo2_a[i]
Q [71] << spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) >>
Why created:  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1686]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 431:
Theorem (431) [serial 1707] used for:
  applied wp for assignment [serial 1690] 


Theorem (433)                               [serial 1798] 
P [66] << ( all #12# ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - #12# ) or not SENSOR_CONNECTED^( - #12# ) then 0 percent else SPO2^( - #12# )) = spo2_a[#12#]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [67] ->
Q [19] << all #13# ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - #13# ) or not SENSOR_CONNECTED^( - #13# ) then 0 percent else SPO2^( - #13# )) = spo2_a[#13#]  >>
Why created:  Replacement of Quantified Variables with #1, #2, etc.  [serial 1796]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (434)                               [serial 1796] 
P [66] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [67] ->
Q [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_a[i]  >>
Why created:    normalization of [serial 1794]
Solved by:  Replacement of Quantified Variables with #1, #2, etc.
and theorem 433:
Theorem (433) [serial 1798] used for:
  Replacement of Quantified Variables with #1, #2, etc.  [serial 1796] 


Theorem (435)                               [serial 1794] 
P [66] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
S [67] ->
Q [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_a[i]  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1721]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 434:
Theorem (434) [serial 1796] used for:
    normalization of [serial 1794] 


Theorem (436)                               [serial 1721] 
P [66] << num_samples < #PulseOx_Properties::Num_Trending_Samples
  and SpO2_INV() >>
S [67] ->
Q [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_a[i]  >>
Why created:    normalization of [serial 1691]
Solved by:  Substitution of Assertion Labels
and theorem 435:
Theorem (435) [serial 1794] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1721] 


Theorem (437)                               [serial 1691] 
P [66] << ( SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples ) ) >>
S [67] ->
Q [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  >>
Why created:    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1686]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 436:
Theorem (436) [serial 1721] used for:
    normalization of [serial 1691] 


Theorem (438)                               [serial 1723] 
P [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  >>
S [67] ->
Q [73] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  >>
Why created:    normalization of [serial 1692]
Solved by:  Identity (id):  P->P is tautology


Theorem (439)                               [serial 1692] 
P [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  >>
S [67] ->
Q [73] << all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  >>
Why created:    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1686]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 438:
Theorem (438) [serial 1723] used for:
    normalization of [serial 1692] 


Theorem (440)                               [serial 1686] 
P [66] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples ) >>
S [67] forall i in 1 .. num_samples
    {
    << spo2_a[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) >>
    spo2_nxt[i + 1] := spo2_a[i]
    << spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) >>
    }  
Q [73] << all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1024]
Solved by:  Universal Quantification Rule:
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any
and theorems 432 437 439:
Theorem (432) [serial 1690] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1686] 
Theorem (437) [serial 1691] used for:
    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1686] 
Theorem (439) [serial 1692] used for:
    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1686] 


Theorem (441)                               [serial 1775] 
P [73] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  >>
S [76] ->
Q [76] << true >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1727]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (442)                               [serial 1727] 
P [73] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  >>
S [76] ->
Q [76] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) or not ( MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0 ) >>
Why created:    normalization of [serial 1693]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 441:
Theorem (441) [serial 1775] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1727] 


Theorem (443)                               [serial 1693] 
P [73] << all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  >>
S [76] ->
Q [76] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) or ( not ( MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0 ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1687]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 442:
Theorem (442) [serial 1727] used for:
    normalization of [serial 1693] 


Theorem (444)                               [serial 1792] 
P [76] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [76] ->
Q [78] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:    normalization of [serial 1789]
Solved by:  Identity (id):  P->P is tautology


Theorem (445)                               [serial 1789] 
P [76] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [76] ->
Q [78] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1729]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 444:
Theorem (444) [serial 1792] used for:
    normalization of [serial 1789] 


Theorem (446)                               [serial 1729] 
P [76] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [76] ->
Q [78] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFT() >>
Why created:    normalization of [serial 1694]
Solved by:  Substitution of Assertion Labels
and theorem 445:
Theorem (445) [serial 1789] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1729] 


Theorem (447)                               [serial 1694] 
P [76] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [76] ->
Q [78] << SHFT()
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:    <<P and B0>> -> <<P0>> in alternative for [serial 1687]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 446:
Theorem (446) [serial 1729] used for:
    normalization of [serial 1694] 


Theorem (448)                               [serial 1799] 
P [78] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFT() >>
S [79] ->
Q [80] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1731]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (449)                               [serial 1805] 
P [78] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [79] ->
Q [81] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1804]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (450)                               [serial 1804] 
P [78] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [79] ->
Q [81] << 0 = 0 >>
Why created:  Remove units from quantities  [serial 1803]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 449:
Theorem (449) [serial 1805] used for:
  Equality Law (idistr):  a=a <-> true [serial 1804] 


Theorem (451)                               [serial 1803] 
P [78] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [79] ->
Q [81] << 0 percent = 0 percent >>
Why created:   Conditional True Expression:  b and x=e  iff  b and x=(b??e:g)   [serial 1802]
Solved by:  Remove units from quantities
and theorem 450:
Theorem (450) [serial 1804] used for:
  Remove units from quantities  [serial 1803] 


Theorem (452)                               [serial 1802] 
P [78] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  ) >>
S [79] ->
Q [81] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = 0 percent >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1800]
Solved by:  Conditional True Expression:  b and x=e  iff  b and x=(b??e:g) 
and theorem 451:
Theorem (451) [serial 1803] used for:
   Conditional True Expression:  b and x=e  iff  b and x=(b??e:g)   [serial 1802] 


Theorem (453)                               [serial 1800] 
P [78] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFT() >>
S [79] ->
Q [81] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = 0 percent >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1731]
Solved by:  Substitution of Assertion Labels
and theorem 452:
Theorem (452) [serial 1802] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1800] 


Theorem (454)                               [serial 1801] 
P [78] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFT() >>
S [79] ->
Q [80] << SHFT() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1731]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (455)                               [serial 1731] 
P [78] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFT() >>
S [79] ->
Q [80] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = 0 percent
  and SHFT() >>
Why created:    normalization of [serial 1708]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 448 453 454:
Theorem (448) [serial 1799] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1731] 
Theorem (453) [serial 1800] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1731] 
Theorem (454) [serial 1801] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1731] 


Theorem (456)                               [serial 1708] 
P [78] << SHFT()
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [79] ->
Q [80] << SHFT()
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and ( 0 percent = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) ) >>
Why created:  applied wp for assignment [serial 1695]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 455:
Theorem (455) [serial 1731] used for:
    normalization of [serial 1708] 


Theorem (457)                               [serial 1695] 
P [78] << SHFT()
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [79] spo2_nxt[1] := 0 percent
Q [80] << SHFT()
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and ( spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) ) >>
Why created:    <<P0>> S0 <<Q0>> in alternative for [serial 1687]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 456:
Theorem (456) [serial 1708] used for:
  applied wp for assignment [serial 1695] 


Theorem (458)                               [serial 1820] 
P [80] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 percent else SPO2^( - i - 1 )) = spo2_nxt[
      2 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
S [76] ->
Q [90] << all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 percent else SPO2^( - i - 1 )) = spo2_nxt[
      2 + i]  >>
Why created:    normalization of [serial 1818]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (459)                               [serial 1818] 
P [80] << ( all i ~ quantity whole 
  in 0 .. ( num_samples + - 1 ) 
  are (if MOTION_ARTIFACT^( - i + - 1 ) or not SENSOR_CONNECTED^( - i + 
      - 1 ) then 0 percent else SPO2^( - i + - 1 )) = spo2_nxt[2 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
S [76] ->
Q [90] << all i ~ quantity whole 
  in 0 .. ( - 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( - 1 + - i ) or not SENSOR_CONNECTED^( - 1 + 
      - i ) then 0 percent else SPO2^( - 1 + - i )) = spo2_nxt[2 + i]  >>
Why created:   changing adding negation to subtraction  [serial 1816]
Solved by:  Reflexivity of Addition: a+b=b+a
  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 458:
Theorem (458) [serial 1820] used for:
    normalization of [serial 1818] 


Theorem (460)                               [serial 1816] 
P [80] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 percent else SPO2^( - i - 1 )) = spo2_nxt[
      2 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
S [76] ->
Q [90] << all i ~ quantity whole 
  in 0 .. ( -1 + num_samples ) 
  are (if MOTION_ARTIFACT^( -1 + - i ) or not SENSOR_CONNECTED^( -1 + - i ) then 0 percent else SPO2^( 
      -1 + - i )) = spo2_nxt[2 + i]  >>
Why created:    normalization of [serial 1814]
Solved by:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 459:
Theorem (459) [serial 1818] used for:
   changing adding negation to subtraction  [serial 1816] 


Theorem (461)                               [serial 1814] 
P [80] << ( all i ~ quantity whole 
  in 0 .. ( num_samples + - 1 ) 
  are (if MOTION_ARTIFACT^( ( - 1 + - i ) ) or not SENSOR_CONNECTED^( ( 
      - 1 + - i ) ) then 0 percent else SPO2^( ( - 1 + - i ) )) = spo2_nxt[
      1 + i + 1]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
S [76] ->
Q [90] << all i ~ quantity whole 
  in 0 .. ( 1 + num_samples + - 2 ) 
  are (if MOTION_ARTIFACT^( 1 + - 2 + - i ) or not SENSOR_CONNECTED^( 1 + 
      - 2 + - i ) then 0 percent else SPO2^( 1 + - 2 + - i )) = spo2_nxt[
      2 + i]  >>
Why created:   changing adding negation to subtraction  [serial 1813]
Solved by:  Literal Arithmetic
  Reflexivity of Addition: a+b=b+a
  Unary Minus:  -(x-y) is (y-x)
  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 460:
Theorem (460) [serial 1816] used for:
    normalization of [serial 1814] 


Theorem (462)                               [serial 1813] 
P [80] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( -(1 + i) ) or not SENSOR_CONNECTED^( -(1 + i) ) then 0 percent else SPO2^( -(
      1 + i) )) = spo2_nxt[1 + i + 1]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
S [76] ->
Q [90] << all i ~ quantity whole 
  in 0 .. ( ( 1 + num_samples ) - 2 ) 
  are (if MOTION_ARTIFACT^( 1 - ( 2 + i ) ) or not SENSOR_CONNECTED^( 1 - ( 
      2 + i ) ) then 0 percent else SPO2^( 1 - ( 2 + i ) )) = spo2_nxt[2 + 
      i]  >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1812]
Solved by:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 461:
Theorem (461) [serial 1814] used for:
   changing adding negation to subtraction  [serial 1813] 


Theorem (463)                               [serial 1812] 
P [80] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( -(1 + i) ) or not SENSOR_CONNECTED^( -(1 + i) ) then 0 percent else SPO2^( -(
      1 + i) )) = spo2_nxt[( 1 + i ) + 1]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
S [76] ->
Q [90] << all i ~ quantity whole 
  in 0 .. ( ( 1 + num_samples ) - 2 ) 
  are (if MOTION_ARTIFACT^( 1 - ( 2 + i ) ) or not SENSOR_CONNECTED^( 1 - ( 
      2 + i ) ) then 0 percent else SPO2^( 1 - ( 2 + i ) )) = spo2_nxt[2 + 
      i]  >>
Why created:  Shift Quantification Range so Lower Bound is Zero  [serial 1810]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 462:
Theorem (462) [serial 1813] used for:
  Associativity: a.(b.c) = a.b.c [serial 1812] 


Theorem (464)                               [serial 1810] 
P [80] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
S [76] ->
Q [90] << ( all i ~ quantity whole 
  in 2 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1808]
Solved by:  Shift Quantification Range so Lower Bound is Zero
and theorem 463:
Theorem (463) [serial 1812] used for:
  Shift Quantification Range so Lower Bound is Zero  [serial 1810] 


Theorem (465)                               [serial 1811] 
P [80] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
S [76] ->
Q [89] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1808]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (466)                               [serial 1808] 
P [80] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
S [76] ->
Q [89] << ( all i ~ quantity whole 
  in 2 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
Why created:    normalization of [serial 1806]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 464 465:
Theorem (464) [serial 1810] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1808] 
Theorem (465) [serial 1811] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1808] 


Theorem (467)                               [serial 1806] 
P [80] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  ) >>
S [76] ->
Q [89] << ( all i ~ quantity whole 
  in 2 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1733]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 466:
Theorem (466) [serial 1808] used for:
    normalization of [serial 1806] 


Theorem (468)                               [serial 1733] 
P [80] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and SHFT() >>
S [76] ->
Q [89] << ( all i ~ quantity whole 
  in 2 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
Why created:    normalization of [serial 1696]
Solved by:  Substitution of Assertion Labels
and theorem 467:
Theorem (467) [serial 1806] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1733] 


Theorem (469)                               [serial 1696] 
P [80] << SHFT()
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and ( spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) ) >>
S [76] ->
Q [89] << ( spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) )
  and ( all i ~ quantity whole 
  in 2 .. ( num_samples + 1 ) 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  ) >>
Why created:    <<Q0>> -> <<Q>> in alternative  for [serial 1687]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 468:
Theorem (468) [serial 1733] used for:
    normalization of [serial 1696] 


Theorem (470)                               [serial 1826] 
P [76] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [76] ->
Q [84] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  >>
Why created:    normalization of [serial 1824]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (471)                               [serial 1824] 
P [76] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [76] ->
Q [84] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1822]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 470:
Theorem (470) [serial 1826] used for:
    normalization of [serial 1824] 


Theorem (472)                               [serial 1822] 
P [76] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [76] ->
Q [84] << SHFT() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735]
Solved by:  Substitution of Assertion Labels
and theorem 471:
Theorem (471) [serial 1824] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1822] 


Theorem (473)                               [serial 1823] 
P [76] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [76] ->
Q [84] << not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (474)                               [serial 1735] 
P [76] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [76] ->
Q [84] << SHFT()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:    normalization of [serial 1697]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 472 473:
Theorem (472) [serial 1822] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735] 
Theorem (473) [serial 1823] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735] 


Theorem (475)                               [serial 1697] 
P [76] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  )
  and ( not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) ) >>
S [76] ->
Q [84] << SHFT()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:    <<P and B1>> -> <<P1>> in alternative for [serial 1687]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 474:
Theorem (474) [serial 1735] used for:
    normalization of [serial 1697] 


Theorem (476)                               [serial 1834] 
P [84] << SHFT()
  and not ( MOTION_ARTIFACT or not SENSOR_CONNECTED ) >>
S [85] ->
Q [87] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1833]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (477)                               [serial 1833] 
P [84] << SHFT()
  and not ( MOTION_ARTIFACT or not SENSOR_CONNECTED ) >>
S [85] ->
Q [87] << SPO2 = SPO2 >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1832]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 476:
Theorem (476) [serial 1834] used for:
  Equality Law (idistr):  a=a <-> true [serial 1833] 


Theorem (478)                               [serial 1832] 
P [84] << SHFT()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [85] ->
Q [87] << SPO2 = SPO2^0 >>
Why created:  Replacing port names with BLESS::Value properties  [serial 1831]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 477:
Theorem (477) [serial 1833] used for:
  Assume Present:  P = P@now = P^0   [serial 1832] 


Theorem (479)                               [serial 1831] 
P [84] << SHFT()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [85] ->
Q [87] << SpO2 = SPO2^0 >>
Why created:   Conditional False Expression:  not b and x=g  iff  not b and x=(b??e:g)   [serial 1828]
Solved by:  Replacing port names with BLESS::Value properties
and theorem 478:
Theorem (478) [serial 1832] used for:
  Replacing port names with BLESS::Value properties  [serial 1831] 


Theorem (480)                               [serial 1828] 
P [84] << SHFT()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [85] ->
Q [87] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = SpO2 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737]
Solved by:  Conditional False Expression:  not b and x=g  iff  not b and x=(b??e:g) 
and theorem 479:
Theorem (479) [serial 1831] used for:
   Conditional False Expression:  not b and x=g  iff  not b and x=(b??e:g)   [serial 1828] 


Theorem (481)                               [serial 1829] 
P [84] << SHFT()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [85] ->
Q [86] << SHFT() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (482)                               [serial 1830] 
P [84] << SHFT()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [85] ->
Q [86] << not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (483)                               [serial 1737] 
P [84] << SHFT()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [85] ->
Q [86] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = SpO2
  and SHFT()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:    normalization of [serial 1709]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 480 481 482:
Theorem (480) [serial 1828] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737] 
Theorem (481) [serial 1829] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737] 
Theorem (482) [serial 1830] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737] 


Theorem (484)                               [serial 1709] 
P [84] << SHFT()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [85] ->
Q [86] << SHFT()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and ( SpO2 = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) ) >>
Why created:  applied wp for assignment [serial 1698]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 483:
Theorem (483) [serial 1737] used for:
    normalization of [serial 1709] 


Theorem (485)                               [serial 1698] 
P [84] << SHFT()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [85] spo2_nxt[1] := SpO2
Q [86] << SHFT()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and ( spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) ) >>
Why created:    <<P1>> S1 <<Q1>> in alternative for [serial 1687]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 484:
Theorem (484) [serial 1709] used for:
  applied wp for assignment [serial 1698] 


Theorem (486)                               [serial 1838] 
P [86] << ( all i ~ quantity whole 
  in 0 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [76] ->
Q [89] << ( all i ~ quantity whole 
  in 0 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
Why created:  Shift Quantification Range so Lower Bound is Zero  [serial 1837]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (487)                               [serial 1837] 
P [86] << ( all i ~ quantity whole 
  in 0 .. num_samples 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [76] ->
Q [89] << ( all i ~ quantity whole 
  in 1 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
Why created:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1836]
Solved by:  Shift Quantification Range so Lower Bound is Zero
and theorem 486:
Theorem (486) [serial 1838] used for:
  Shift Quantification Range so Lower Bound is Zero  [serial 1837] 


Theorem (488)                               [serial 1836] 
P [86] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  )
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [76] ->
Q [89] << ( all i ~ quantity whole 
  in 1 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1835]
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
and theorem 487:
Theorem (487) [serial 1837] used for:
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1836] 


Theorem (489)                               [serial 1835] 
P [86] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and SHFT()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [76] ->
Q [89] << ( all i ~ quantity whole 
  in 1 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
Why created:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1739]
Solved by:  Substitution of Assertion Labels
and theorem 488:
Theorem (488) [serial 1836] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1835] 


Theorem (490)                               [serial 1739] 
P [86] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and SHFT()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [76] ->
Q [89] << ( all i ~ quantity whole 
  in 2 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
Why created:    normalization of [serial 1699]
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
and theorem 489:
Theorem (489) [serial 1835] used for:
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1739] 


Theorem (491)                               [serial 1699] 
P [86] << SHFT()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and ( spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) ) >>
S [76] ->
Q [89] << ( spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) )
  and ( all i ~ quantity whole 
  in 2 .. ( num_samples + 1 ) 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  ) >>
Why created:    <<Q1>> -> <<Q>> in alternative  for [serial 1687]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 490:
Theorem (490) [serial 1739] used for:
    normalization of [serial 1699] 


Theorem (492)                               [serial 1687] 
P [73] << all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  >>
S [76]   if 
    (MotionArtifact? or not SensorConnected?)~> 
      << SHFT()
        and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
      spo2_nxt[1] := 0 percent
      << SHFT()
        and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
        and ( spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) ) >> 
  []
    (not ( MotionArtifact? or not SensorConnected? ))~> 
      << SHFT()
        and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
      spo2_nxt[1] := SpO2
      << SHFT()
        and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
        and ( spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) ) >> 
  fi
Q [89] << ( spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) )
  and ( all i ~ quantity whole 
  in 2 .. ( num_samples + 1 ) 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  ) >>
Why created:  <<Q3 and P4>> S4 <<Q4 and P5>> in sequential composition for [serial 1024]
Solved by:  Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>>
and theorems 443 447 457 469 475 485 491:
Theorem (443) [serial 1693] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1687] 
Theorem (447) [serial 1694] used for:
    <<P and B0>> -> <<P0>> in alternative for [serial 1687] 
Theorem (457) [serial 1695] used for:
    <<P0>> S0 <<Q0>> in alternative for [serial 1687] 
Theorem (469) [serial 1696] used for:
    <<Q0>> -> <<Q>> in alternative  for [serial 1687] 
Theorem (475) [serial 1697] used for:
    <<P and B1>> -> <<P1>> in alternative for [serial 1687] 
Theorem (485) [serial 1698] used for:
    <<P1>> S1 <<Q1>> in alternative for [serial 1687] 
Theorem (491) [serial 1699] used for:
    <<Q1>> -> <<Q>> in alternative  for [serial 1687] 


Theorem (493)                               [serial 1839] 
P [89] << ( all i ~ quantity whole 
  in 1 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
S [93] ->
Q [94] << all i ~ quantity whole 
  in 1 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  >>
Why created:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1741]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (494)                               [serial 1741] 
P [89] << ( all i ~ quantity whole 
  in 2 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
S [93] ->
Q [94] << all i ~ quantity whole 
  in 1 .. ( 1 + num_samples ) 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  >>
Why created:    normalization of [serial 1710]
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
and theorem 493:
Theorem (493) [serial 1839] used for:
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1741] 


Theorem (495)                               [serial 1710] 
P [89] << ( spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) )
  and ( all i ~ quantity whole 
  in 2 .. ( num_samples + 1 ) 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  ) >>
S [93] ->
Q [94] << all i ~ quantity whole 
  in 1 .. ( num_samples + 1 ) 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  >>
Why created:  applied wp for assignment [serial 1688]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 494:
Theorem (494) [serial 1741] used for:
    normalization of [serial 1710] 


Theorem (496)                               [serial 1688] 
P [89] << ( spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) )
  and ( all i ~ quantity whole 
  in 2 .. ( num_samples + 1 ) 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  ) >>
S [93] num_samples := num_samples + 1
Q [94] << all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  >>
Why created:  <<Q4 and P5>> S5 <<Q5 and P6>> in sequential composition for [serial 1024]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 495:
Theorem (495) [serial 1710] used for:
  applied wp for assignment [serial 1688] 


Theorem (497)                               [serial 1747] 
P [98] << (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i] >>
S [99] ->
Q [100] << (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i] >>
Why created:    normalization of [serial 1711]
Solved by:  Identity (id):  P->P is tautology


Theorem (498)                               [serial 1711] 
P [98] << spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) >>
S [99] ->
Q [100] << spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) >>
Why created:  applied wp for assignment [serial 1700]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 497:
Theorem (497) [serial 1747] used for:
    normalization of [serial 1711] 


Theorem (499)                               [serial 1700] 
P [98] << spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) >>
S [99] spo2_a[i] := spo2_nxt[i]
Q [100] << spo2_a[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) >>
Why created:  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1689]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 498:
Theorem (498) [serial 1711] used for:
  applied wp for assignment [serial 1700] 


Theorem (500)                               [serial 1743] 
P [94] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  >>
S [96] ->
Q [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  >>
Why created:    normalization of [serial 1701]
Solved by:  Identity (id):  P->P is tautology


Theorem (501)                               [serial 1701] 
P [94] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  ) >>
S [96] ->
Q [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  >>
Why created:    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1689]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 500:
Theorem (500) [serial 1743] used for:
    normalization of [serial 1701] 


Theorem (502)                               [serial 1745] 
P [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_a[i]  >>
S [96] ->
Q [102] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_a[i]  >>
Why created:    normalization of [serial 1702]
Solved by:  Identity (id):  P->P is tautology


Theorem (503)                               [serial 1702] 
P [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  >>
S [96] ->
Q [102] << all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  >>
Why created:    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1689]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 502:
Theorem (502) [serial 1745] used for:
    normalization of [serial 1702] 


Theorem (504)                               [serial 1689] 
P [94] << all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  >>
S [96] forall i in 1 .. num_samples
    {
    << spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) >>
    spo2_a[i] := spo2_nxt[i]
    << spo2_a[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) >>
    }  
Q [102] << all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  >>
Why created:  <<Q5 and P6>> S6 <<Q6>> in sequential composition for [serial 1024]
Solved by:  Universal Quantification Rule:
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any
and theorems 499 501 503:
Theorem (499) [serial 1700] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1689] 
Theorem (501) [serial 1701] used for:
    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1689] 
Theorem (503) [serial 1702] used for:
    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1689] 


Theorem (505)                               [serial 1024] 
P [47] << SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples ) >>
S [58]   << SpO2_INV()
    and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
    and AXIOM_NS() >>
  SpO2Trend!(spo2_a)
  ;
  << SpO2_INV()
    and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )
    and AXIOM_NS() >>
  NumSamples!(num_samples)
  ;
  << SpO2_INV()
    and ( num_samples < #PulseOx_Properties::Num_Trending_Samples ) >>
  forall i in 1 .. num_samples
      {
      << spo2_a[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) >>
      spo2_nxt[i + 1] := spo2_a[i]
      << spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) >>
      }  
  <<SHFT: :all i ~ quantity whole 
    in 1 .. num_samples 
    are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  >>
  ;
    if 
      (MotionArtifact? or not SensorConnected?)~> 
        << SHFT()
          and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
        spo2_nxt[1] := 0 percent
        << SHFT()
          and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
          and ( spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) ) >> 
    []
      (not ( MotionArtifact? or not SensorConnected? ))~> 
        << SHFT()
          and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
        spo2_nxt[1] := SpO2
        << SHFT()
          and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
          and ( spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) ) >> 
    fi
  << ( spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) )
    and ( all i ~ quantity whole 
    in 2 .. ( num_samples + 1 ) 
    are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  ) >>
  ;
  num_samples := num_samples + 1
  << all i ~ quantity whole 
    in 1 .. num_samples 
    are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  >>
  ;
  forall i in 1 .. num_samples
      {
      << spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) >>
      spo2_a[i] := spo2_nxt[i]
      << spo2_a[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) >>
      }  
  << all i ~ quantity whole 
    in 1 .. num_samples 
    are spo2_a[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  >> 
Q [49] << HOLD(num_samples) >>
Why created:   <<M(loading) and x>> A <<M(check)>> for sptt1: loading-[x]->check{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 392 397 420 429 440 492 496 504:
Theorem (392) [serial 1682] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1024] 
Theorem (397) [serial 1683] used for:
  <<Q6>> -> <<Q>> in sequential composition for [serial 1024] 
Theorem (420) [serial 1684] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1024] 
Theorem (429) [serial 1685] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1024] 
Theorem (440) [serial 1686] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1024] 
Theorem (492) [serial 1687] used for:
  <<Q3 and P4>> S4 <<Q4 and P5>> in sequential composition for [serial 1024] 
Theorem (496) [serial 1688] used for:
  <<Q4 and P5>> S5 <<Q5 and P6>> in sequential composition for [serial 1024] 
Theorem (504) [serial 1689] used for:
  <<Q5 and P6>> S6 <<Q6>> in sequential composition for [serial 1024] 


Theorem (506)                               [serial 1874] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] ->
Q [47] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  applied wp for simultaneous assignment [serial 1871]
Solved by:  Identity (id):  P->P is tautology
  Identity (id):  P->P is tautology


Theorem (507)                               [serial 1871] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:    normalization of [serial 1869]
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Simultaneous Assignment
and theorem 506:
Theorem (506) [serial 1874] used for:
  applied wp for simultaneous assignment [serial 1871] 


Theorem (508)                               [serial 1869] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if not ( SENSOR_CONNECTED^( - s ) )^1 or MOTION_ARTIFACT^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1867]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Caret Compostition:  (x^a)^b is x^(a+b)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 507:
Theorem (507) [serial 1871] used for:
    normalization of [serial 1869] 


Theorem (509)                               [serial 1867] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( not SENSOR_CONNECTED^( - s ) )^1 or MOTION_ARTIFACT^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:    normalization of [serial 1865]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 508:
Theorem (508) [serial 1869] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1867] 


Theorem (510)                               [serial 1865] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( MOTION_ARTIFACT^( ( - s ) + 1 ) or ( not SENSOR_CONNECTED^( - s ) )^1 ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1863]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 509:
Theorem (509) [serial 1867] used for:
    normalization of [serial 1865] 


Theorem (511)                               [serial 1863] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1 then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:    normalization of [serial 1861]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 510:
Theorem (510) [serial 1865] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1863] 


Theorem (512)                               [serial 1861] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1 then ( 0 percent )^1 else SPO2^( 
      ( - s ) + 1 )) = spo2_a[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1859]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Constants are always the same
  Associativity: a.(b.c) = a.b.c
and theorem 511:
Theorem (511) [serial 1863] used for:
    normalization of [serial 1861] 


Theorem (513)                               [serial 1859] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))^1 = spo2_a[s]^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:    normalization of [serial 1857]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 512:
Theorem (512) [serial 1861] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1859] 


Theorem (514)                               [serial 1857] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))^1 = ( spo2_a[s] )^1 )  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1855]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 513:
Theorem (513) [serial 1859] used for:
    normalization of [serial 1857] 


Theorem (515)                               [serial 1855] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s] )^1  )
  and num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
Why created:    normalization of [serial 1853]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 514:
Theorem (514) [serial 1857] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1855] 


Theorem (516)                               [serial 1853] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( ( num_samples )^1 < ( #PulseOx_Properties::Num_Trending_Samples )^1 )
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s] )^1  ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1851]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Constants are always the same
  Associativity: a.(b.c) = a.b.c
and theorem 515:
Theorem (515) [serial 1855] used for:
    normalization of [serial 1853] 


Theorem (517)                               [serial 1851] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( num_samples < #PulseOx_Properties::Num_Trending_Samples )^1
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s]  )^1 >>
Why created:    normalization of [serial 1849]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 516:
Theorem (516) [serial 1853] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1851] 


Theorem (518)                               [serial 1849] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s]  )^1
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1846]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 517:
Theorem (517) [serial 1851] used for:
    normalization of [serial 1849] 


Theorem (519)                               [serial 1846] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s]  )
  and num_samples < #PulseOx_Properties::Num_Trending_Samples )^1 >>
Why created:    normalization of [serial 1844]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 518:
Theorem (518) [serial 1849] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1846] 


Theorem (520)                               [serial 1844] 
P [49] << ( ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s ))  ) )
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples ) >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  )
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples ) )^1 >>
Why created:  Substituted assertions' predicates for labels  [serial 1025]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 519:
Theorem (519) [serial 1846] used for:
    normalization of [serial 1844] 


Theorem (521)                               [serial 1025] 
P [49] << ( HOLD(num_samples) )
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples ) >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ( SpO2_INV()
  and ( num_samples < #PulseOx_Properties::Num_Trending_Samples ) )^1 >>
Why created:   <<M(check) and x>> A <<M(loading)>> for sptt2a: check-[x]->loading{A};
Solved by:  Substitution of Assertion Labels
and theorem 520:
Theorem (520) [serial 1844] used for:
  Substituted assertions' predicates for labels  [serial 1025] 


Theorem (522)                               [serial 1905] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [107] ->
Q [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  applied wp for simultaneous assignment [serial 1902]
Solved by:  Identity (id):  P->P is tautology
  Identity (id):  P->P is tautology


Theorem (523)                               [serial 1902] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:    normalization of [serial 1900]
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Simultaneous Assignment
and theorem 522:
Theorem (522) [serial 1905] used for:
  applied wp for simultaneous assignment [serial 1902] 


Theorem (524)                               [serial 1900] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if not ( SENSOR_CONNECTED^( - s ) )^1 or MOTION_ARTIFACT^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1898]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Caret Compostition:  (x^a)^b is x^(a+b)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 523:
Theorem (523) [serial 1902] used for:
    normalization of [serial 1900] 


Theorem (525)                               [serial 1898] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( not SENSOR_CONNECTED^( - s ) )^1 or MOTION_ARTIFACT^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:    normalization of [serial 1896]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 524:
Theorem (524) [serial 1900] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1898] 


Theorem (526)                               [serial 1896] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( MOTION_ARTIFACT^( ( - s ) + 1 ) or ( not SENSOR_CONNECTED^( - s ) )^1 ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1894]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 525:
Theorem (525) [serial 1898] used for:
    normalization of [serial 1896] 


Theorem (527)                               [serial 1894] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1 then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:    normalization of [serial 1892]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 526:
Theorem (526) [serial 1896] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1894] 


Theorem (528)                               [serial 1892] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1 then ( 0 percent )^1 else SPO2^( 
      ( - s ) + 1 )) = spo2_a[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1890]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Constants are always the same
  Associativity: a.(b.c) = a.b.c
and theorem 527:
Theorem (527) [serial 1894] used for:
    normalization of [serial 1892] 


Theorem (529)                               [serial 1890] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))^1 = spo2_a[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:    normalization of [serial 1888]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 528:
Theorem (528) [serial 1892] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1890] 


Theorem (530)                               [serial 1888] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))^1 = ( spo2_a[s] )^1 )  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1886]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 529:
Theorem (529) [serial 1890] used for:
    normalization of [serial 1888] 


Theorem (531)                               [serial 1886] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s] )^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:    normalization of [serial 1884]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 530:
Theorem (530) [serial 1888] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1886] 


Theorem (532)                               [serial 1884] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( ( #PulseOx_Properties::Num_Trending_Samples )^1 = ( num_samples )^1 )
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s] )^1  ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1882]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Constants are always the same
  Associativity: a.(b.c) = a.b.c
and theorem 531:
Theorem (531) [serial 1886] used for:
    normalization of [serial 1884] 


Theorem (533)                               [serial 1882] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( #PulseOx_Properties::Num_Trending_Samples = num_samples )^1
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s]  )^1 >>
Why created:    normalization of [serial 1880]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 532:
Theorem (532) [serial 1884] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1882] 


Theorem (534)                               [serial 1880] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s]  )^1
  and ( #PulseOx_Properties::Num_Trending_Samples = num_samples )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1877]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 533:
Theorem (533) [serial 1882] used for:
    normalization of [serial 1880] 


Theorem (535)                               [serial 1877] 
P [49] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples )^1 >>
Why created:    normalization of [serial 1875]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 534:
Theorem (534) [serial 1880] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 1877] 


Theorem (536)                               [serial 1875] 
P [49] << ( ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s ))  ) )
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples ) >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  )
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples ) )^1 >>
Why created:  Substituted assertions' predicates for labels  [serial 1026]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 535:
Theorem (535) [serial 1877] used for:
    normalization of [serial 1875] 


Theorem (537)                               [serial 1026] 
P [49] << ( HOLD(num_samples) )
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples ) >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ( SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples ) )^1 >>
Why created:   <<M(check) and x>> A <<M(run)>> for sptt2b: check-[x]->run{A};
Solved by:  Substitution of Assertion Labels
and theorem 536:
Theorem (536) [serial 1875] used for:
  Substituted assertions' predicates for labels  [serial 1026] 


Theorem (538)                               [serial 1027] 
P [49] << ( HOLD(num_samples) )
  and ( num_samples > #PulseOx_Properties::Num_Trending_Samples ) >>
S [108] ->
Q [53] << true >>
Why created:   <<M(check) and x>> -> <<M(fail)>> for sptt2c: check-[x]->fail{};
Solved by:  True Conclusion Schema (tc): P->true


Theorem (539)                               [serial 1987] 
P [51] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV() >>
S [51] ->
Q [111] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1961]
Solved by:  Identity (id):  P->P is tautology


Theorem (540)                               [serial 1961] 
P [51] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV() >>
S [51] ->
Q [111] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV()
  and true >>
Why created:    normalization of [serial 1927]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 539:
Theorem (539) [serial 1987] used for:
  Law of And-Simplification:  P and true is P [serial 1961] 


Theorem (541)                               [serial 1927] 
P [51] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples ) >>
S [51] ->
Q [111] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples )
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 540:
Theorem (540) [serial 1961] used for:
    normalization of [serial 1927] 


Theorem (542)                               [serial 1987] 
P [51] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV() >>
S [51] ->
Q [111] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1961]
Solved by:  Identity (id):  P->P is tautology


Theorem (543)                               [serial 1961] 
P [51] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV() >>
S [51] ->
Q [111] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV()
  and true >>
Why created:    normalization of [serial 1927]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 542:
Theorem (542) [serial 1987] used for:
  Law of And-Simplification:  P and true is P [serial 1961] 


Theorem (544)                               [serial 1927] 
P [51] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples ) >>
S [51] ->
Q [111] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples )
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 543:
Theorem (543) [serial 1961] used for:
    normalization of [serial 1927] 


Theorem (545)                               [serial 1906] 
P [51] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples ) >>
S [51] ->
Q [111] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples )
  and AXIOM_NS() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1028]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 544 544:
Theorem (544) [serial 1927] used for:
   add user-defined axioms to postcondition 
Theorem (544) [serial 1927] used for:
   add user-defined axioms to postcondition 


Theorem (546)                               [serial 2036] 
P [164] << ( all #14# ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - #14# ) or not SENSOR_CONNECTED^( 1 - #14# ) then 0 percent else SPO2^( 1 - #14# )) = spo2_a[#14#]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [51] ->
Q [16] << ( all #15# ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - #15# ) or not SENSOR_CONNECTED^( 1 - #15# ) then 0 percent else SPO2^( 1 - #15# )) = spo2_a[#15#]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:  Replacement of Quantified Variables with #1, #2, etc.  [serial 2033]
Solved by:  Identity (id):  P->P is tautology


Theorem (547)                               [serial 2033] 
P [164] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_a[i]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [51] ->
Q [16] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - s ) or not SENSOR_CONNECTED^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:    normalization of [serial 2031]
Solved by:  Replacement of Quantified Variables with #1, #2, etc.
and theorem 546:
Theorem (546) [serial 2036] used for:
  Replacement of Quantified Variables with #1, #2, etc.  [serial 2033] 


Theorem (548)                               [serial 2031] 
P [164] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_a[i]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [51] ->
Q [16] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if not ( SENSOR_CONNECTED^( - s ) )^1 or MOTION_ARTIFACT^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2029]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Caret Compostition:  (x^a)^b is x^(a+b)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 547:
Theorem (547) [serial 2033] used for:
    normalization of [serial 2031] 


Theorem (549)                               [serial 2029] 
P [164] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_a[i]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [51] ->
Q [16] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( not SENSOR_CONNECTED^( - s ) )^1 or MOTION_ARTIFACT^( 1 - s ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:    normalization of [serial 2027]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 548:
Theorem (548) [serial 2031] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2029] 


Theorem (550)                               [serial 2027] 
P [164] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_a[i]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [51] ->
Q [16] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( MOTION_ARTIFACT^( ( - s ) + 1 ) or ( not SENSOR_CONNECTED^( - s ) )^1 ) then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2025]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 549:
Theorem (549) [serial 2029] used for:
    normalization of [serial 2027] 


Theorem (551)                               [serial 2025] 
P [164] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_a[i]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [51] ->
Q [16] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1 then 0 percent else SPO2^( 1 - s )) = spo2_a[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:    normalization of [serial 2023]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 550:
Theorem (550) [serial 2027] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2025] 


Theorem (552)                               [serial 2023] 
P [164] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_a[i]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [51] ->
Q [16] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if ( MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) )^1 then ( 0 percent )^1 else SPO2^( 
      ( - s ) + 1 )) = spo2_a[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2021]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Constants are always the same
  Associativity: a.(b.c) = a.b.c
and theorem 551:
Theorem (551) [serial 2025] used for:
    normalization of [serial 2023] 


Theorem (553)                               [serial 2021] 
P [164] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_a[i]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [51] ->
Q [16] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))^1 = spo2_a[s]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:    normalization of [serial 2019]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 552:
Theorem (552) [serial 2023] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2021] 


Theorem (554)                               [serial 2019] 
P [164] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_a[i]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [51] ->
Q [16] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))^1 = ( spo2_a[s] )^1 )  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2017]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 553:
Theorem (553) [serial 2021] used for:
    normalization of [serial 2019] 


Theorem (555)                               [serial 2017] 
P [164] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_a[i]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [51] ->
Q [16] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s] )^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
Why created:    normalization of [serial 2015]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 554:
Theorem (554) [serial 2019] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2017] 


Theorem (556)                               [serial 2015] 
P [164] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_a[i]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [51] ->
Q [16] << ( ( #PulseOx_Properties::Num_Trending_Samples )^1 = ( num_samples )^1 )
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are ( (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s] )^1  ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2013]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Constants are always the same
  Associativity: a.(b.c) = a.b.c
and theorem 555:
Theorem (555) [serial 2017] used for:
    normalization of [serial 2015] 


Theorem (557)                               [serial 2013] 
P [164] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_a[i]^1  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples^1 >>
S [51] ->
Q [16] << ( #PulseOx_Properties::Num_Trending_Samples = num_samples )^1
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s]  )^1 >>
Why created:    normalization of [serial 2011]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 556:
Theorem (556) [serial 2015] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2013] 


Theorem (558)                               [serial 2011] 
P [164] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are ( spo2_a[i] )^1 = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  )
  and ( num_samples )^1 = #PulseOx_Properties::Num_Trending_Samples >>
S [51] ->
Q [16] << ( ( #PulseOx_Properties::Num_Trending_Samples = num_samples )^1
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2010]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 557:
Theorem (557) [serial 2013] used for:
    normalization of [serial 2011] 


Theorem (559)                               [serial 2010] 
P [164] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  )
  and num_samples' = #PulseOx_Properties::Num_Trending_Samples >>
S [51] ->
Q [16] << ( #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) )^1 >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1931]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 558:
Theorem (558) [serial 2011] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2010] 


Theorem (560)                               [serial 1931] 
P [164] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  )
  and num_samples' = #PulseOx_Properties::Num_Trending_Samples >>
S [51] ->
Q [16] << ( #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV() )^1 >>
Why created:    normalization of [serial 1907]
Solved by:  Substitution of Assertion Labels
and theorem 559:
Theorem (559) [serial 2010] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1931] 


Theorem (561)                               [serial 1907] 
P [164] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  )
  and num_samples' = #PulseOx_Properties::Num_Trending_Samples >>
S [51] ->
Q [16] << ( SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples ) )^1 >>
Why created:  <<Q6>> -> <<Q>> in sequential composition for [serial 1028]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 560:
Theorem (560) [serial 1931] used for:
    normalization of [serial 1907] 


Theorem (562)                               [serial 2141] 
P [111] << num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
S [113] ->
Q [15] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
Why created:  Guided Substitution of Equals 
 replacing "SPO2_HISTORY" with its = "spo2_a" in its postcondition [serial 2140]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (563)                               [serial 2140] 
P [111] << num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
S [113] ->
Q [15] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are SPO2_HISTORY[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
Why created:  Guided Substitution of Equals 
 replacing "NUM_SAMPLES" with its = "num_samples" in its postcondition [serial 2139]
Solved by:  Guided Substitution of Equals
and theorem 562:
Theorem (562) [serial 2141] used for:
  Guided Substitution of Equals 
 replacing "SPO2_HISTORY" with its = "spo2_a" in its postcondition [serial 2140] 


Theorem (564)                               [serial 2139] 
P [111] << num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
S [113] ->
Q [15] << ( all s ~ quantity whole 
  in 1 .. NUM_SAMPLES 
  are SPO2_HISTORY[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2138]
Solved by:  Guided Substitution of Equals
and theorem 563:
Theorem (563) [serial 2140] used for:
  Guided Substitution of Equals 
 replacing "NUM_SAMPLES" with its = "num_samples" in its postcondition [serial 2139] 


Theorem (565)                               [serial 2138] 
P [111] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY )
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
S [113] ->
Q [15] << ( all s ~ quantity whole 
  in 1 .. NUM_SAMPLES 
  are SPO2_HISTORY[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2131]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 564:
Theorem (564) [serial 2139] used for:
  Associativity: a.(b.c) = a.b.c [serial 2138] 


Theorem (566)                               [serial 2131] 
P [111] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_NS()
  and SpO2_INV() >>
S [113] ->
Q [15] << SPO2_TREND() >>
Why created:  applied port output of value <<pre>> -> <<M(SpO2Trend)[SpO2Trend|spo2_a]>> [serial 1988]
Solved by:  Substitution of Assertion Labels
and theorem 565:
Theorem (565) [serial 2138] used for:
  Substituted assertions' predicates for labels  [serial 2131] 


Theorem (567)                               [serial 2136] 
P [113] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_NS()
  and SpO2_INV()
  and SPO2_TREND()^0 >>
S [113] ->
Q [115] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV() >>
Why created:    normalization of [serial 2133]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (568)                               [serial 2133] 
P [113] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_NS()
  and SpO2_INV()
  and ( SPO2_TREND() )^0 >>
S [113] ->
Q [115] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV() >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2132]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 567:
Theorem (567) [serial 2136] used for:
    normalization of [serial 2133] 


Theorem (569)                               [serial 2132] 
P [113] << ( #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_NS()
  and SpO2_INV() )
  and ( SPO2_TREND() )^0 >>
S [113] ->
Q [115] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV() >>
Why created:  applied port output <<pre and (SPO2_TREND())^0>> -> <<post>> [serial 1988]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 568:
Theorem (568) [serial 2133] used for:
  Associativity: a.(b.c) = a.b.c [serial 2132] 


Theorem (570)                               [serial 1988] 
P [111] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_NS()
  and SpO2_INV() >>
S [113] SpO2Trend!(spo2_a)
Q [115] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1963]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 566 569:
Theorem (566) [serial 2131] used for:
  applied port output of value <<pre>> -> <<M(SpO2Trend)[SpO2Trend|spo2_a]>> [serial 1988] 
Theorem (569) [serial 2132] used for:
  applied port output <<pre and (SPO2_TREND())^0>> -> <<post>> [serial 1988] 


Theorem (571)                               [serial 1963] 
P [111] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_NS()
  and SpO2_INV() >>
S [113] SpO2Trend!(spo2_a)
Q [115] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV()
  and true >>
Why created:    normalization of [serial 1928]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 570:
Theorem (570) [serial 1988] used for:
  Law of And-Simplification:  P and true is P [serial 1963] 


Theorem (572)                               [serial 1928] 
P [111] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples )
  and AXIOM_NS() >>
S [113] SpO2Trend!(spo2_a)
Q [115] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples )
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 571:
Theorem (571) [serial 1963] used for:
    normalization of [serial 1928] 


Theorem (573)                               [serial 2141] 
P [111] << num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
S [113] ->
Q [15] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
Why created:  Guided Substitution of Equals 
 replacing "SPO2_HISTORY" with its = "spo2_a" in its postcondition [serial 2140]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (574)                               [serial 2140] 
P [111] << num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
S [113] ->
Q [15] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are SPO2_HISTORY[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
Why created:  Guided Substitution of Equals 
 replacing "NUM_SAMPLES" with its = "num_samples" in its postcondition [serial 2139]
Solved by:  Guided Substitution of Equals
and theorem 573:
Theorem (573) [serial 2141] used for:
  Guided Substitution of Equals 
 replacing "SPO2_HISTORY" with its = "spo2_a" in its postcondition [serial 2140] 


Theorem (575)                               [serial 2139] 
P [111] << num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
S [113] ->
Q [15] << ( all s ~ quantity whole 
  in 1 .. NUM_SAMPLES 
  are SPO2_HISTORY[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2138]
Solved by:  Guided Substitution of Equals
and theorem 574:
Theorem (574) [serial 2140] used for:
  Guided Substitution of Equals 
 replacing "NUM_SAMPLES" with its = "num_samples" in its postcondition [serial 2139] 


Theorem (576)                               [serial 2138] 
P [111] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY )
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
S [113] ->
Q [15] << ( all s ~ quantity whole 
  in 1 .. NUM_SAMPLES 
  are SPO2_HISTORY[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2131]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 575:
Theorem (575) [serial 2139] used for:
  Associativity: a.(b.c) = a.b.c [serial 2138] 


Theorem (577)                               [serial 2131] 
P [111] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_NS()
  and SpO2_INV() >>
S [113] ->
Q [15] << SPO2_TREND() >>
Why created:  applied port output of value <<pre>> -> <<M(SpO2Trend)[SpO2Trend|spo2_a]>> [serial 1988]
Solved by:  Substitution of Assertion Labels
and theorem 576:
Theorem (576) [serial 2138] used for:
  Substituted assertions' predicates for labels  [serial 2131] 


Theorem (578)                               [serial 2136] 
P [113] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_NS()
  and SpO2_INV()
  and SPO2_TREND()^0 >>
S [113] ->
Q [115] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV() >>
Why created:    normalization of [serial 2133]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (579)                               [serial 2133] 
P [113] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_NS()
  and SpO2_INV()
  and ( SPO2_TREND() )^0 >>
S [113] ->
Q [115] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV() >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2132]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 578:
Theorem (578) [serial 2136] used for:
    normalization of [serial 2133] 


Theorem (580)                               [serial 2132] 
P [113] << ( #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_NS()
  and SpO2_INV() )
  and ( SPO2_TREND() )^0 >>
S [113] ->
Q [115] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV() >>
Why created:  applied port output <<pre and (SPO2_TREND())^0>> -> <<post>> [serial 1988]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 579:
Theorem (579) [serial 2133] used for:
  Associativity: a.(b.c) = a.b.c [serial 2132] 


Theorem (581)                               [serial 1988] 
P [111] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_NS()
  and SpO2_INV() >>
S [113] SpO2Trend!(spo2_a)
Q [115] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1963]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 577 580:
Theorem (577) [serial 2131] used for:
  applied port output of value <<pre>> -> <<M(SpO2Trend)[SpO2Trend|spo2_a]>> [serial 1988] 
Theorem (580) [serial 2132] used for:
  applied port output <<pre and (SPO2_TREND())^0>> -> <<post>> [serial 1988] 


Theorem (582)                               [serial 1963] 
P [111] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_NS()
  and SpO2_INV() >>
S [113] SpO2Trend!(spo2_a)
Q [115] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV()
  and true >>
Why created:    normalization of [serial 1928]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 581:
Theorem (581) [serial 1988] used for:
  Law of And-Simplification:  P and true is P [serial 1963] 


Theorem (583)                               [serial 1928] 
P [111] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples )
  and AXIOM_NS() >>
S [113] SpO2Trend!(spo2_a)
Q [115] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples )
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 582:
Theorem (582) [serial 1963] used for:
    normalization of [serial 1928] 


Theorem (584)                               [serial 1908] 
P [111] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples )
  and AXIOM_NS() >>
S [113] SpO2Trend!(spo2_a)
Q [115] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples )
  and AXIOM_NS() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 583 583:
Theorem (583) [serial 1928] used for:
   add user-defined axioms to postcondition 
Theorem (583) [serial 1928] used for:
   add user-defined axioms to postcondition 


Theorem (585)                               [serial 2146] 
P [115] << num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
S [117] ->
Q [117] << num_samples = NUM_SAMPLES >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2145]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (586)                               [serial 2145] 
P [115] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY )
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
S [117] ->
Q [117] << num_samples = NUM_SAMPLES >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2142]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 585:
Theorem (585) [serial 2146] used for:
  Associativity: a.(b.c) = a.b.c [serial 2145] 


Theorem (587)                               [serial 2142] 
P [115] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_NS()
  and SpO2_INV() >>
S [117] ->
Q [117] << num_samples = NUM_SAMPLES >>
Why created:  applied port output of value <<pre>> -> <<M(NumSamples)[NumSamples|num_samples]>> [serial 1989]
Solved by:  Substitution of Assertion Labels
and theorem 586:
Theorem (586) [serial 2145] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2142] 


Theorem (588)                               [serial 2144] 
P [117] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_NS()
  and SpO2_INV()
  and ( num_samples = NUM_SAMPLES )^0 >>
S [117] ->
Q [119] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV() >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2143]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (589)                               [serial 2143] 
P [117] << ( #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_NS()
  and SpO2_INV() )
  and ( num_samples = NUM_SAMPLES )^0 >>
S [117] ->
Q [119] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV() >>
Why created:  applied port output <<pre and (num_samples = NUM_SAMPLES)^0>> -> <<post>> [serial 1989]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 588:
Theorem (588) [serial 2144] used for:
  Associativity: a.(b.c) = a.b.c [serial 2143] 


Theorem (590)                               [serial 1989] 
P [115] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_NS()
  and SpO2_INV() >>
S [117] NumSamples!(num_samples)
Q [119] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1965]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 587 589:
Theorem (587) [serial 2142] used for:
  applied port output of value <<pre>> -> <<M(NumSamples)[NumSamples|num_samples]>> [serial 1989] 
Theorem (589) [serial 2143] used for:
  applied port output <<pre and (num_samples = NUM_SAMPLES)^0>> -> <<post>> [serial 1989] 


Theorem (591)                               [serial 1965] 
P [115] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_NS()
  and SpO2_INV() >>
S [117] NumSamples!(num_samples)
Q [119] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV()
  and true >>
Why created:    normalization of [serial 1929]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 590:
Theorem (590) [serial 1989] used for:
  Law of And-Simplification:  P and true is P [serial 1965] 


Theorem (592)                               [serial 1929] 
P [115] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples )
  and AXIOM_NS() >>
S [117] NumSamples!(num_samples)
Q [119] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples )
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 591:
Theorem (591) [serial 1965] used for:
    normalization of [serial 1929] 


Theorem (593)                               [serial 2146] 
P [115] << num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
S [117] ->
Q [117] << num_samples = NUM_SAMPLES >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2145]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (594)                               [serial 2145] 
P [115] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( num_samples = NUM_SAMPLES
  and spo2_a = SPO2_HISTORY )
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
S [117] ->
Q [117] << num_samples = NUM_SAMPLES >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2142]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 593:
Theorem (593) [serial 2146] used for:
  Associativity: a.(b.c) = a.b.c [serial 2145] 


Theorem (595)                               [serial 2142] 
P [115] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_NS()
  and SpO2_INV() >>
S [117] ->
Q [117] << num_samples = NUM_SAMPLES >>
Why created:  applied port output of value <<pre>> -> <<M(NumSamples)[NumSamples|num_samples]>> [serial 1989]
Solved by:  Substitution of Assertion Labels
and theorem 594:
Theorem (594) [serial 2145] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2142] 


Theorem (596)                               [serial 2144] 
P [117] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_NS()
  and SpO2_INV()
  and ( num_samples = NUM_SAMPLES )^0 >>
S [117] ->
Q [119] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV() >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2143]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (597)                               [serial 2143] 
P [117] << ( #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_NS()
  and SpO2_INV() )
  and ( num_samples = NUM_SAMPLES )^0 >>
S [117] ->
Q [119] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV() >>
Why created:  applied port output <<pre and (num_samples = NUM_SAMPLES)^0>> -> <<post>> [serial 1989]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 596:
Theorem (596) [serial 2144] used for:
  Associativity: a.(b.c) = a.b.c [serial 2143] 


Theorem (598)                               [serial 1989] 
P [115] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_NS()
  and SpO2_INV() >>
S [117] NumSamples!(num_samples)
Q [119] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1965]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 595 597:
Theorem (595) [serial 2142] used for:
  applied port output of value <<pre>> -> <<M(NumSamples)[NumSamples|num_samples]>> [serial 1989] 
Theorem (597) [serial 2143] used for:
  applied port output <<pre and (num_samples = NUM_SAMPLES)^0>> -> <<post>> [serial 1989] 


Theorem (599)                               [serial 1965] 
P [115] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_NS()
  and SpO2_INV() >>
S [117] NumSamples!(num_samples)
Q [119] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and SpO2_INV()
  and true >>
Why created:    normalization of [serial 1929]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 598:
Theorem (598) [serial 1989] used for:
  Law of And-Simplification:  P and true is P [serial 1965] 


Theorem (600)                               [serial 1929] 
P [115] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples )
  and AXIOM_NS() >>
S [117] NumSamples!(num_samples)
Q [119] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples )
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 599:
Theorem (599) [serial 1965] used for:
    normalization of [serial 1929] 


Theorem (601)                               [serial 1909] 
P [115] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples )
  and AXIOM_NS() >>
S [117] NumSamples!(num_samples)
Q [119] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples )
  and AXIOM_CR2() >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 600 600:
Theorem (600) [serial 1929] used for:
   add user-defined axioms to postcondition 
Theorem (600) [serial 1929] used for:
   add user-defined axioms to postcondition 


Theorem (602)                               [serial 2054] 
P [123] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_a[i]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [125] ->
Q [126] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_a[i]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  applied wp for assignment [serial 1937]
Solved by:  Identity (id):  P->P is tautology


Theorem (603)                               [serial 1937] 
P [123] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_a[i]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [125] spo2_nxt[1 + i] := spo2_a[i]
Q [126] << (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
1 + i]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 1914]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 602:
Theorem (602) [serial 2054] used for:
  applied wp for assignment [serial 1937] 


Theorem (604)                               [serial 1914] 
P [123] << spo2_a[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples ) >>
S [125] spo2_nxt[i + 1] := spo2_a[i]
Q [126] << spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
Why created:  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1910]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 603:
Theorem (603) [serial 1937] used for:
    normalization of [serial 1914] 


Theorem (605)                               [serial 2049] 
P [119] << ( all #16# ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - #16# - 1 ) or not SENSOR_CONNECTED^( - #16# - 1 ) then 0 percent else SPO2^( - #16# - 1 )) = spo2_a[
      1 + #16#]  )
  and num_samples - 2 < num_samples - 1
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [121] ->
Q [19] << ( all #17# ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - #17# - 1 ) or not SENSOR_CONNECTED^( - #17# - 1 ) then 0 percent else SPO2^( - #17# - 1 )) = spo2_a[
      1 + #17#]  ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2048]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (606)                               [serial 2051] 
P [119] << ( all #16# ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - #16# - 1 ) or not SENSOR_CONNECTED^( - #16# - 1 ) then 0 percent else SPO2^( - #16# - 1 )) = spo2_a[
      1 + #16#]  )
  and num_samples - 2 < num_samples - 1
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [121] ->
Q [19] << ( #PulseOx_Properties::Num_Trending_Samples = num_samples ) >>
Why created:  Introduction of (unused) Universal Quantification [serial 2050]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (607)                               [serial 2050] 
P [119] << ( all #16# ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - #16# - 1 ) or not SENSOR_CONNECTED^( - #16# - 1 ) then 0 percent else SPO2^( - #16# - 1 )) = spo2_a[
      1 + #16#]  )
  and num_samples - 2 < num_samples - 1
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [121] ->
Q [19] << ( all #17# ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are #PulseOx_Properties::Num_Trending_Samples = num_samples  ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2048]
Solved by:  Introduction of (unused) Universal Quantification
and theorem 606:
Theorem (606) [serial 2051] used for:
  Introduction of (unused) Universal Quantification [serial 2050] 


Theorem (608)                               [serial 2048] 
P [119] << ( all #16# ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - #16# - 1 ) or not SENSOR_CONNECTED^( - #16# - 1 ) then 0 percent else SPO2^( - #16# - 1 )) = spo2_a[
      1 + #16#]  )
  and num_samples - 2 < num_samples - 1
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [121] ->
Q [19] << ( all #17# ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - #17# - 1 ) or not SENSOR_CONNECTED^( - #17# - 1 ) then 0 percent else SPO2^( - #17# - 1 )) = spo2_a[
      1 + #17#]  )
  and ( all #17# ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are #PulseOx_Properties::Num_Trending_Samples = num_samples  ) >>
Why created:  Combine Universal Quantifications: all x:t in R are (A and B) = (all x:t in R are A) and (all x:t in R are B)  [serial 2047]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 605 607:
Theorem (605) [serial 2049] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2048] 
Theorem (607) [serial 2050] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2048] 


Theorem (609)                               [serial 2047] 
P [119] << ( all #16# ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - #16# - 1 ) or not SENSOR_CONNECTED^( - #16# - 1 ) then 0 percent else SPO2^( - #16# - 1 )) = spo2_a[
      1 + #16#]  )
  and num_samples - 2 < num_samples - 1
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [121] ->
Q [19] << all #17# ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - #17# - 1 ) or not SENSOR_CONNECTED^( - #17# - 1 ) then 0 percent else SPO2^( - #17# - 1 )) = spo2_a[
      1 + #17#]
        and #PulseOx_Properties::Num_Trending_Samples = num_samples  >>
Why created:  Replacement of Quantified Variables with #1, #2, etc.  [serial 2046]
Solved by:  Combine Universal Quantifications: all x:t in R are (A and B) = (all x:t in R are A) and (all x:t in R are B)
and theorem 608:
Theorem (608) [serial 2048] used for:
  Combine Universal Quantifications: all x:t in R are (A and B) = (all x:t in R are A) and (all x:t in R are B)  [serial 2047] 


Theorem (610)                               [serial 2046] 
P [119] << ( all s ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - s - 1 ) or not SENSOR_CONNECTED^( - s - 1 ) then 0 percent else SPO2^( - s - 1 )) = spo2_a[
      1 + s]  )
  and num_samples - 2 < num_samples - 1
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [121] ->
Q [19] << all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 percent else SPO2^( - i - 1 )) = spo2_a[
      1 + i]
        and #PulseOx_Properties::Num_Trending_Samples = num_samples  >>
Why created:  Contract Universal Quantification Range  [serial 2044]
Solved by:  Replacement of Quantified Variables with #1, #2, etc.
and theorem 609:
Theorem (609) [serial 2047] used for:
  Replacement of Quantified Variables with #1, #2, etc.  [serial 2046] 


Theorem (611)                               [serial 2044] 
P [119] << ( all s ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - s - 1 ) or not SENSOR_CONNECTED^( - s - 1 ) then 0 percent else SPO2^( - s - 1 )) = spo2_a[
      1 + s]  )
  and num_samples - 2 < num_samples - 1
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [121] ->
Q [19] << all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 percent else SPO2^( - i - 1 )) = spo2_a[
      1 + i]
        and #PulseOx_Properties::Num_Trending_Samples = num_samples  >>
Why created:    normalization of [serial 2042]
Solved by:  Contract Universal Quantification Range
and theorem 610:
Theorem (610) [serial 2046] used for:
  Contract Universal Quantification Range  [serial 2044] 


Theorem (612)                               [serial 2042] 
P [119] << ( all s ~ quantity whole 
  in 0 .. ( num_samples + - 1 ) 
  are (if MOTION_ARTIFACT^( ( - 1 + - s ) ) or not SENSOR_CONNECTED^( ( 
      - 1 + - s ) ) then 0 percent else SPO2^( ( - 1 + - s ) )) = spo2_a[
      1 + s]  )
  and num_samples + - 2 < num_samples + - 1
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [121] ->
Q [19] << all i ~ quantity whole 
  in 0 .. ( num_samples + - 2 ) 
  are (if MOTION_ARTIFACT^( ( - 1 + - i ) ) or not SENSOR_CONNECTED^( ( 
      - 1 + - i ) ) then 0 percent else SPO2^( ( - 1 + - i ) )) = spo2_a[
      1 + i]
        and #PulseOx_Properties::Num_Trending_Samples = num_samples  >>
Why created:   changing adding negation to subtraction  [serial 2041]
Solved by:  Reflexivity of Addition: a+b=b+a
  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 611:
Theorem (611) [serial 2044] used for:
    normalization of [serial 2042] 


Theorem (613)                               [serial 2041] 
P [119] << ( all s ~ quantity whole 
  in 0 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( -(1 + s) ) or not SENSOR_CONNECTED^( -(1 + s) ) then 0 percent else SPO2^( -(
      1 + s) )) = spo2_a[1 + s]  )
  and num_samples - 2 < num_samples - 1
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [121] ->
Q [19] << all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( -(1 + i) ) or not SENSOR_CONNECTED^( -(1 + i) ) then 0 percent else SPO2^( -(
      1 + i) )) = spo2_a[1 + i]
        and #PulseOx_Properties::Num_Trending_Samples = num_samples  >>
Why created:  Shift Quantification Range so Lower Bound is Zero  [serial 2039]
Solved by:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 612:
Theorem (612) [serial 2042] used for:
   changing adding negation to subtraction  [serial 2041] 


Theorem (614)                               [serial 2039] 
P [119] << ( all s ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s )) = spo2_a[s]  )
  and num_samples - 2 < num_samples - 1
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [121] ->
Q [19] << all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_a[i]
        and #PulseOx_Properties::Num_Trending_Samples = num_samples  >>
Why created:    normalization of [serial 2037]
Solved by:  Shift Quantification Range so Lower Bound is Zero
and theorem 613:
Theorem (613) [serial 2041] used for:
  Shift Quantification Range so Lower Bound is Zero  [serial 2039] 


Theorem (615)                               [serial 2037] 
P [119] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( ( num_samples - 2 ) < ( num_samples - 1 ) )
  and ( all s ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^( - s ) or not SENSOR_CONNECTED^( - s ) then 0 percent else SPO2^( - s ))  ) >>
S [121] ->
Q [19] << all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_a[i]
        and #PulseOx_Properties::Num_Trending_Samples = num_samples  >>
Why created:  Substituted assertions' predicates for labels  [serial 1933]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 614:
Theorem (614) [serial 2039] used for:
    normalization of [serial 2037] 


Theorem (616)                               [serial 1933] 
P [119] << #PulseOx_Properties::Num_Trending_Samples = num_samples
  and AXIOM_CR2()
  and SpO2_INV() >>
S [121] ->
Q [19] << all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_a[i]
        and #PulseOx_Properties::Num_Trending_Samples = num_samples  >>
Why created:    normalization of [serial 1915]
Solved by:  Substitution of Assertion Labels
and theorem 615:
Theorem (615) [serial 2037] used for:
  Substituted assertions' predicates for labels  [serial 1933] 


Theorem (617)                               [serial 1915] 
P [119] << ( SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples )
  and AXIOM_CR2() ) >>
S [121] ->
Q [19] << all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are spo2_a[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))
        and ( num_samples = #PulseOx_Properties::Num_Trending_Samples )  >>
Why created:    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1910]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 616:
Theorem (616) [serial 1933] used for:
    normalization of [serial 1915] 


Theorem (618)                               [serial 2053] 
P [19] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and ( #PulseOx_Properties::Num_Trending_Samples = num_samples ) >>
S [121] ->
Q [129] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  Introduction of (unused) Universal Quantification [serial 2052]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (619)                               [serial 2052] 
P [19] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are #PulseOx_Properties::Num_Trending_Samples = num_samples  ) >>
S [121] ->
Q [129] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  Combine Universal Quantifications: all x:t in R are (A and B) = (all x:t in R are A) and (all x:t in R are B)  [serial 1935]
Solved by:  Introduction of (unused) Universal Quantification
and theorem 618:
Theorem (618) [serial 2053] used for:
  Introduction of (unused) Universal Quantification [serial 2052] 


Theorem (620)                               [serial 1935] 
P [19] << all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]
        and #PulseOx_Properties::Num_Trending_Samples = num_samples  >>
S [121] ->
Q [129] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 1916]
Solved by:  Combine Universal Quantifications: all x:t in R are (A and B) = (all x:t in R are A) and (all x:t in R are B)
and theorem 619:
Theorem (619) [serial 2052] used for:
  Combine Universal Quantifications: all x:t in R are (A and B) = (all x:t in R are A) and (all x:t in R are B)  [serial 1935] 


Theorem (621)                               [serial 1916] 
P [19] << all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
S [121] ->
Q [129] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
Why created:    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1910]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 620:
Theorem (620) [serial 1935] used for:
    normalization of [serial 1916] 


Theorem (622)                               [serial 1910] 
P [119] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples )
  and AXIOM_CR2() >>
S [121] forall i in 1 .. ( num_samples - 1 )
    {
    << spo2_a[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))
      and ( num_samples = #PulseOx_Properties::Num_Trending_Samples ) >>
    spo2_nxt[i + 1] := spo2_a[i]
    << spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))
      and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
    }  
Q [129] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1028]
Solved by:  Universal Quantification Rule:
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any
and theorems 604 617 621:
Theorem (604) [serial 1914] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1910] 
Theorem (617) [serial 1915] used for:
    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1910] 
Theorem (621) [serial 1916] used for:
    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1910] 


Theorem (623)                               [serial 1984] 
P [129] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [133] ->
Q [133] << true >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1939]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (624)                               [serial 1939] 
P [129] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [133] ->
Q [133] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) or not ( MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0 ) >>
Why created:    normalization of [serial 1917]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 623:
Theorem (623) [serial 1984] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1939] 


Theorem (625)                               [serial 1917] 
P [129] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
S [133] ->
Q [133] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) or ( not ( MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0 ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1911]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 624:
Theorem (624) [serial 1939] used for:
    normalization of [serial 1917] 


Theorem (626)                               [serial 2151] 
P [133] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [133] ->
Q [135] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2149]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (627)                               [serial 2149] 
P [133] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [133] ->
Q [135] << ( ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:    normalization of [serial 2147]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 626:
Theorem (626) [serial 2151] used for:
  Associativity: a.(b.c) = a.b.c [serial 2149] 


Theorem (628)                               [serial 2147] 
P [133] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [133] ->
Q [135] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and ( ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2004]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 627:
Theorem (627) [serial 2149] used for:
    normalization of [serial 2147] 


Theorem (629)                               [serial 2004] 
P [133] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [133] ->
Q [135] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFTR() >>
Why created:    normalization of [serial 1985]
Solved by:  Substitution of Assertion Labels
and theorem 628:
Theorem (628) [serial 2147] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2004] 


Theorem (630)                               [serial 1985] 
P [133] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [133] ->
Q [135] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFTR() >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1941]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 629:
Theorem (629) [serial 2004] used for:
    normalization of [serial 1985] 


Theorem (631)                               [serial 1941] 
P [133] << ( ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [133] ->
Q [135] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFTR() >>
Why created:    normalization of [serial 1918]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 630:
Theorem (630) [serial 1985] used for:
  Associativity: a.(b.c) = a.b.c [serial 1941] 


Theorem (632)                               [serial 1918] 
P [133] << ( ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [133] ->
Q [135] << SHFTR()
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:    <<P and B0>> -> <<P0>> in alternative for [serial 1911]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 631:
Theorem (631) [serial 1941] used for:
    normalization of [serial 1918] 


Theorem (633)                               [serial 2057] 
P [135] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFTR() >>
S [136] ->
Q [137] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2056]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (634)                               [serial 2061] 
P [135] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFTR() >>
S [136] ->
Q [138] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 2060]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (635)                               [serial 2060] 
P [135] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFTR() >>
S [136] ->
Q [138] << 0 = 0 >>
Why created:  Remove units from quantities  [serial 2058]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 634:
Theorem (634) [serial 2061] used for:
  Equality Law (idistr):  a=a <-> true [serial 2060] 


Theorem (636)                               [serial 2058] 
P [135] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFTR() >>
S [136] ->
Q [138] << 0 percent = 0 percent >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2056]
Solved by:  Remove units from quantities
and theorem 635:
Theorem (635) [serial 2060] used for:
  Remove units from quantities  [serial 2058] 


Theorem (637)                               [serial 2059] 
P [135] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFTR() >>
S [136] ->
Q [137] << SHFTR() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2056]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (638)                               [serial 2056] 
P [135] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFTR() >>
S [136] ->
Q [137] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and 0 percent = 0 percent
  and SHFTR() >>
Why created:   Conditional True Expression:  b and x=e  iff  b and x=(b??e:g)   [serial 2055]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 633 636 637:
Theorem (633) [serial 2057] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2056] 
Theorem (636) [serial 2058] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2056] 
Theorem (637) [serial 2059] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2056] 


Theorem (639)                               [serial 2055] 
P [135] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFTR() >>
S [136] ->
Q [137] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = 0 percent
  and SHFTR() >>
Why created:  applied wp for assignment [serial 1943]
Solved by:  Conditional True Expression:  b and x=e  iff  b and x=(b??e:g) 
and theorem 638:
Theorem (638) [serial 2056] used for:
   Conditional True Expression:  b and x=e  iff  b and x=(b??e:g)   [serial 2055] 


Theorem (640)                               [serial 1943] 
P [135] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and SHFTR() >>
S [136] spo2_nxt[1] := 0 percent
Q [137] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and SHFTR() >>
Why created:    normalization of [serial 1919]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 639:
Theorem (639) [serial 2055] used for:
  applied wp for assignment [serial 1943] 


Theorem (641)                               [serial 1919] 
P [135] << SHFTR()
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [136] spo2_nxt[1] := 0 percent
Q [137] << SHFTR()
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and ( spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) ) >>
Why created:    <<P0>> S0 <<Q0>> in alternative for [serial 1911]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 640:
Theorem (640) [serial 1943] used for:
    normalization of [serial 1919] 


Theorem (642)                               [serial 2082] 
P [137] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 percent else SPO2^( - i - 1 )) = spo2_nxt[
      2 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [133] ->
Q [148] << all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 percent else SPO2^( - i - 1 )) = spo2_nxt[
      2 + i]  >>
Why created:    normalization of [serial 2080]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (643)                               [serial 2080] 
P [137] << ( all i ~ quantity whole 
  in 0 .. ( num_samples + - 2 ) 
  are (if MOTION_ARTIFACT^( - i + - 1 ) or not SENSOR_CONNECTED^( - i + 
      - 1 ) then 0 percent else SPO2^( - i + - 1 )) = spo2_nxt[2 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [133] ->
Q [148] << all i ~ quantity whole 
  in 0 .. ( num_samples + - 2 ) 
  are (if MOTION_ARTIFACT^( - 1 + - i ) or not SENSOR_CONNECTED^( - 1 + 
      - i ) then 0 percent else SPO2^( - 1 + - i )) = spo2_nxt[2 + i]  >>
Why created:   changing adding negation to subtraction  [serial 2078]
Solved by:  Reflexivity of Addition: a+b=b+a
  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 642:
Theorem (642) [serial 2082] used for:
    normalization of [serial 2080] 


Theorem (644)                               [serial 2078] 
P [137] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 percent else SPO2^( - i - 1 )) = spo2_nxt[
      2 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [133] ->
Q [148] << all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( -1 + - i ) or not SENSOR_CONNECTED^( -1 + - i ) then 0 percent else SPO2^( 
      -1 + - i )) = spo2_nxt[2 + i]  >>
Why created:    normalization of [serial 2076]
Solved by:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 643:
Theorem (643) [serial 2080] used for:
   changing adding negation to subtraction  [serial 2078] 


Theorem (645)                               [serial 2076] 
P [137] << ( all i ~ quantity whole 
  in 0 .. ( num_samples + - 2 ) 
  are (if MOTION_ARTIFACT^( ( - 1 + - i ) ) or not SENSOR_CONNECTED^( ( 
      - 1 + - i ) ) then 0 percent else SPO2^( ( - 1 + - i ) )) = spo2_nxt[
      2 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [133] ->
Q [148] << all i ~ quantity whole 
  in 0 .. ( num_samples + - 2 ) 
  are (if MOTION_ARTIFACT^( 1 + - 2 + - i ) or not SENSOR_CONNECTED^( 1 + 
      - 2 + - i ) then 0 percent else SPO2^( 1 + - 2 + - i )) = spo2_nxt[
      2 + i]  >>
Why created:   changing adding negation to subtraction  [serial 2074]
Solved by:  Literal Arithmetic
  Reflexivity of Addition: a+b=b+a
  Unary Minus:  -(x-y) is (y-x)
  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 644:
Theorem (644) [serial 2078] used for:
    normalization of [serial 2076] 


Theorem (646)                               [serial 2074] 
P [137] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( -(1 + i) ) or not SENSOR_CONNECTED^( -(1 + i) ) then 0 percent else SPO2^( -(
      1 + i) )) = spo2_nxt[2 + i]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [133] ->
Q [148] << all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( 1 - ( 2 + i ) ) or not SENSOR_CONNECTED^( 1 - ( 
      2 + i ) ) then 0 percent else SPO2^( 1 - ( 2 + i ) )) = spo2_nxt[2 + 
      i]  >>
Why created:    normalization of [serial 2072]
Solved by:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 645:
Theorem (645) [serial 2076] used for:
   changing adding negation to subtraction  [serial 2074] 


Theorem (647)                               [serial 2072] 
P [137] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( -(1 + i) ) or not SENSOR_CONNECTED^( -(1 + i) ) then 0 percent else SPO2^( -(
      1 + i) )) = spo2_nxt[1 + i + 1]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [133] ->
Q [148] << all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( 1 - ( 2 + i ) ) or not SENSOR_CONNECTED^( 1 - ( 
      2 + i ) ) then 0 percent else SPO2^( 1 - ( 2 + i ) )) = spo2_nxt[2 + 
      i]  >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2071]
Solved by:  Literal Arithmetic
  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 646:
Theorem (646) [serial 2074] used for:
    normalization of [serial 2072] 


Theorem (648)                               [serial 2071] 
P [137] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( -(1 + i) ) or not SENSOR_CONNECTED^( -(1 + i) ) then 0 percent else SPO2^( -(
      1 + i) )) = spo2_nxt[( 1 + i ) + 1]  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [133] ->
Q [148] << all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( 1 - ( 2 + i ) ) or not SENSOR_CONNECTED^( 1 - ( 
      2 + i ) ) then 0 percent else SPO2^( 1 - ( 2 + i ) )) = spo2_nxt[2 + 
      i]  >>
Why created:  Shift Quantification Range so Lower Bound is Zero  [serial 2069]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 647:
Theorem (647) [serial 2072] used for:
  Associativity: a.(b.c) = a.b.c [serial 2071] 


Theorem (649)                               [serial 2069] 
P [137] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
S [133] ->
Q [148] << ( all i ~ quantity whole 
  in 2 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  ) >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2066]
Solved by:  Shift Quantification Range so Lower Bound is Zero
and theorem 648:
Theorem (648) [serial 2071] used for:
  Shift Quantification Range so Lower Bound is Zero  [serial 2069] 


Theorem (650)                               [serial 2066] 
P [137] << ( ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
S [133] ->
Q [148] << ( all i ~ quantity whole 
  in 2 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2064]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 649:
Theorem (649) [serial 2069] used for:
  Associativity: a.(b.c) = a.b.c [serial 2066] 


Theorem (651)                               [serial 2067] 
P [137] << ( ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
S [133] ->
Q [146] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2064]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (652)                               [serial 2070] 
P [137] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
S [133] ->
Q [147] << #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2068]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (653)                               [serial 2068] 
P [137] << ( ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
S [133] ->
Q [147] << #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2064]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 652:
Theorem (652) [serial 2070] used for:
  Associativity: a.(b.c) = a.b.c [serial 2068] 


Theorem (654)                               [serial 2064] 
P [137] << ( ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
S [133] ->
Q [146] << ( all i ~ quantity whole 
  in 2 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 2062]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 650 651 653:
Theorem (650) [serial 2066] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2064] 
Theorem (651) [serial 2067] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2064] 
Theorem (653) [serial 2068] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2064] 


Theorem (655)                               [serial 2062] 
P [137] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and ( ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples ) >>
S [133] ->
Q [146] << ( all i ~ quantity whole 
  in 2 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1945]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 654:
Theorem (654) [serial 2064] used for:
    normalization of [serial 2062] 


Theorem (656)                               [serial 1945] 
P [137] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and SHFTR() >>
S [133] ->
Q [146] << ( all i ~ quantity whole 
  in 2 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 1920]
Solved by:  Substitution of Assertion Labels
and theorem 655:
Theorem (655) [serial 2062] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1945] 


Theorem (657)                               [serial 1920] 
P [137] << SHFTR()
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and ( spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) ) >>
S [133] ->
Q [146] << spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0)
  and num_samples = #PulseOx_Properties::Num_Trending_Samples
  and ( all i ~ quantity whole 
  in 2 .. num_samples 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  ) >>
Why created:    <<Q0>> -> <<Q>> in alternative  for [serial 1911]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 656:
Theorem (656) [serial 1945] used for:
    normalization of [serial 1920] 


Theorem (658)                               [serial 2130] 
P [133] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [133] ->
Q [141] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2128]
Solved by:  Identity (id):  P->P is tautology


Theorem (659)                               [serial 2128] 
P [133] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [133] ->
Q [141] << ( ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples )
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:    normalization of [serial 2126]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 658:
Theorem (658) [serial 2130] used for:
  Associativity: a.(b.c) = a.b.c [serial 2128] 


Theorem (660)                               [serial 2126] 
P [133] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [133] ->
Q [141] << ( ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples )
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1986]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 659:
Theorem (659) [serial 2128] used for:
    normalization of [serial 2126] 


Theorem (661)                               [serial 1986] 
P [133] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [133] ->
Q [141] << SHFTR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 1947]
Solved by:  Substitution of Assertion Labels
and theorem 660:
Theorem (660) [serial 2126] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1986] 


Theorem (662)                               [serial 1947] 
P [133] << ( ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples )
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [133] ->
Q [141] << SHFTR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:    normalization of [serial 1921]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 661:
Theorem (661) [serial 1986] used for:
  Associativity: a.(b.c) = a.b.c [serial 1947] 


Theorem (663)                               [serial 1921] 
P [133] << ( ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples )
  and ( not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) ) >>
S [133] ->
Q [141] << SHFTR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:    <<P and B1>> -> <<P1>> in alternative for [serial 1911]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 662:
Theorem (662) [serial 1947] used for:
    normalization of [serial 1921] 


Theorem (664)                               [serial 2091] 
P [141] << SHFTR()
  and not ( MOTION_ARTIFACT or not SENSOR_CONNECTED ) >>
S [142] ->
Q [144] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 2090]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (665)                               [serial 2090] 
P [141] << SHFTR()
  and not ( MOTION_ARTIFACT or not SENSOR_CONNECTED ) >>
S [142] ->
Q [144] << SPO2 = SPO2 >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2089]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 664:
Theorem (664) [serial 2091] used for:
  Equality Law (idistr):  a=a <-> true [serial 2090] 


Theorem (666)                               [serial 2089] 
P [141] << SHFTR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [142] ->
Q [144] << SPO2 = SPO2^0 >>
Why created:  Replacing port names with BLESS::Value properties  [serial 2086]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 665:
Theorem (665) [serial 2090] used for:
  Assume Present:  P = P@now = P^0   [serial 2089] 


Theorem (667)                               [serial 2086] 
P [141] << SHFTR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [142] ->
Q [144] << SpO2 = SPO2^0 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2085]
Solved by:  Replacing port names with BLESS::Value properties
and theorem 666:
Theorem (666) [serial 2089] used for:
  Replacing port names with BLESS::Value properties  [serial 2086] 


Theorem (668)                               [serial 2087] 
P [141] << SHFTR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [142] ->
Q [143] << SHFTR() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2085]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (669)                               [serial 2088] 
P [141] << SHFTR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [142] ->
Q [143] << not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2085]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (670)                               [serial 2085] 
P [141] << SHFTR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [142] ->
Q [143] << SpO2 = SPO2^0
  and SHFTR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:   Conditional False Expression:  not b and x=g  iff  not b and x=(b??e:g)   [serial 2084]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 667 668 669:
Theorem (667) [serial 2086] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2085] 
Theorem (668) [serial 2087] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2085] 
Theorem (669) [serial 2088] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2085] 


Theorem (671)                               [serial 2084] 
P [141] << SHFTR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [142] ->
Q [143] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = SpO2
  and SHFTR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:  applied wp for assignment [serial 1949]
Solved by:  Conditional False Expression:  not b and x=g  iff  not b and x=(b??e:g) 
and theorem 670:
Theorem (670) [serial 2085] used for:
   Conditional False Expression:  not b and x=g  iff  not b and x=(b??e:g)   [serial 2084] 


Theorem (672)                               [serial 1949] 
P [141] << SHFTR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [142] spo2_nxt[1] := SpO2
Q [143] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and SHFTR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:    normalization of [serial 1922]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 671:
Theorem (671) [serial 2084] used for:
  applied wp for assignment [serial 1949] 


Theorem (673)                               [serial 1922] 
P [141] << SHFTR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [142] spo2_nxt[1] := SpO2
Q [143] << SHFTR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and ( spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) ) >>
Why created:    <<P1>> S1 <<Q1>> in alternative for [serial 1911]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 672:
Theorem (672) [serial 1949] used for:
    normalization of [serial 1922] 


Theorem (674)                               [serial 2111] 
P [143] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 percent else SPO2^( - i - 1 )) = spo2_nxt[
      2 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [133] ->
Q [148] << all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 percent else SPO2^( - i - 1 )) = spo2_nxt[
      2 + i]  >>
Why created:    normalization of [serial 2109]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (675)                               [serial 2109] 
P [143] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 percent else SPO2^( - i - 1 )) = spo2_nxt[
      1 + i + 1]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [133] ->
Q [148] << all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 percent else SPO2^( - i - 1 )) = spo2_nxt[
      2 + i]  >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2107]
Solved by:  Literal Arithmetic
  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 674:
Theorem (674) [serial 2111] used for:
    normalization of [serial 2109] 


Theorem (676)                               [serial 2107] 
P [143] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 percent else SPO2^( - i - 1 )) = spo2_nxt[
      ( 1 + i ) + 1]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [133] ->
Q [148] << all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 percent else SPO2^( - i - 1 )) = spo2_nxt[
      2 + i]  >>
Why created:    normalization of [serial 2105]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 675:
Theorem (675) [serial 2109] used for:
  Associativity: a.(b.c) = a.b.c [serial 2107] 


Theorem (677)                               [serial 2105] 
P [143] << ( all i ~ quantity whole 
  in 0 .. ( num_samples + - 2 ) 
  are (if MOTION_ARTIFACT^( - i + - 1 ) or not SENSOR_CONNECTED^( - i + 
      - 1 ) then 0 percent else SPO2^( - i + - 1 )) = spo2_nxt[( 1 + i ) + 
      1]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [133] ->
Q [148] << all i ~ quantity whole 
  in 0 .. ( num_samples + - 2 ) 
  are (if MOTION_ARTIFACT^( - 1 + - i ) or not SENSOR_CONNECTED^( - 1 + 
      - i ) then 0 percent else SPO2^( - 1 + - i )) = spo2_nxt[2 + i]  >>
Why created:   changing adding negation to subtraction  [serial 2103]
Solved by:  Reflexivity of Addition: a+b=b+a
  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 676:
Theorem (676) [serial 2107] used for:
    normalization of [serial 2105] 


Theorem (678)                               [serial 2103] 
P [143] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( - i - 1 ) or not SENSOR_CONNECTED^( - i - 1 ) then 0 percent else SPO2^( - i - 1 )) = spo2_nxt[
      ( 1 + i ) + 1]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [133] ->
Q [148] << all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( -1 + - i ) or not SENSOR_CONNECTED^( -1 + - i ) then 0 percent else SPO2^( 
      -1 + - i )) = spo2_nxt[2 + i]  >>
Why created:    normalization of [serial 2101]
Solved by:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 677:
Theorem (677) [serial 2105] used for:
   changing adding negation to subtraction  [serial 2103] 


Theorem (679)                               [serial 2101] 
P [143] << ( all i ~ quantity whole 
  in 0 .. ( num_samples + - 2 ) 
  are (if MOTION_ARTIFACT^( ( - 1 + - i ) ) or not SENSOR_CONNECTED^( ( 
      - 1 + - i ) ) then 0 percent else SPO2^( ( - 1 + - i ) )) = spo2_nxt[
      ( 1 + i ) + 1]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [133] ->
Q [148] << all i ~ quantity whole 
  in 0 .. ( num_samples + - 2 ) 
  are (if MOTION_ARTIFACT^( 1 + - 2 + - i ) or not SENSOR_CONNECTED^( 1 + 
      - 2 + - i ) then 0 percent else SPO2^( 1 + - 2 + - i )) = spo2_nxt[
      2 + i]  >>
Why created:   changing adding negation to subtraction  [serial 2100]
Solved by:  Literal Arithmetic
  Reflexivity of Addition: a+b=b+a
  Unary Minus:  -(x-y) is (y-x)
  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 678:
Theorem (678) [serial 2103] used for:
    normalization of [serial 2101] 


Theorem (680)                               [serial 2100] 
P [143] << ( all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( -(1 + i) ) or not SENSOR_CONNECTED^( -(1 + i) ) then 0 percent else SPO2^( -(
      1 + i) )) = spo2_nxt[( 1 + i ) + 1]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [133] ->
Q [148] << all i ~ quantity whole 
  in 0 .. ( num_samples - 2 ) 
  are (if MOTION_ARTIFACT^( 1 - ( 2 + i ) ) or not SENSOR_CONNECTED^( 1 - ( 
      2 + i ) ) then 0 percent else SPO2^( 1 - ( 2 + i ) )) = spo2_nxt[2 + 
      i]  >>
Why created:  Shift Quantification Range so Lower Bound is Zero  [serial 2097]
Solved by:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 679:
Theorem (679) [serial 2101] used for:
   changing adding negation to subtraction  [serial 2100] 


Theorem (681)                               [serial 2097] 
P [143] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [133] ->
Q [148] << ( all i ~ quantity whole 
  in 2 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2095]
Solved by:  Shift Quantification Range so Lower Bound is Zero
and theorem 680:
Theorem (680) [serial 2100] used for:
  Shift Quantification Range so Lower Bound is Zero  [serial 2097] 


Theorem (682)                               [serial 2098] 
P [143] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [133] ->
Q [146] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2095]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (683)                               [serial 2099] 
P [143] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [133] ->
Q [147] << #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2095]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (684)                               [serial 2095] 
P [143] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i )) = spo2_nxt[
      1 + i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [133] ->
Q [146] << ( all i ~ quantity whole 
  in 2 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 2093]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 681 682 683:
Theorem (681) [serial 2097] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2095] 
Theorem (682) [serial 2098] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2095] 
Theorem (683) [serial 2099] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2095] 


Theorem (685)                               [serial 2093] 
P [143] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [133] ->
Q [146] << ( all i ~ quantity whole 
  in 2 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2092]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 684:
Theorem (684) [serial 2095] used for:
    normalization of [serial 2093] 


Theorem (686)                               [serial 2092] 
P [143] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and ( ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples )
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [133] ->
Q [146] << ( all i ~ quantity whole 
  in 2 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1951]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 685:
Theorem (685) [serial 2093] used for:
  Associativity: a.(b.c) = a.b.c [serial 2092] 


Theorem (687)                               [serial 1951] 
P [143] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and SHFTR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [133] ->
Q [146] << ( all i ~ quantity whole 
  in 2 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 1923]
Solved by:  Substitution of Assertion Labels
and theorem 686:
Theorem (686) [serial 2092] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1951] 


Theorem (688)                               [serial 1923] 
P [143] << SHFTR()
  and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and ( spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) ) >>
S [133] ->
Q [146] << spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0)
  and num_samples = #PulseOx_Properties::Num_Trending_Samples
  and ( all i ~ quantity whole 
  in 2 .. num_samples 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  ) >>
Why created:    <<Q1>> -> <<Q>> in alternative  for [serial 1911]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 687:
Theorem (687) [serial 1951] used for:
    normalization of [serial 1923] 


Theorem (689)                               [serial 1911] 
P [129] << ( all i ~ quantity whole 
  in 1 .. ( num_samples - 1 ) 
  are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
S [133]   if 
    (MotionArtifact? or not SensorConnected?)~> 
      << SHFTR()
        and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
      spo2_nxt[1] := 0 percent
      << SHFTR()
        and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
        and ( spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) ) >> 
  []
    (not ( MotionArtifact? or not SensorConnected? ))~> 
      << SHFTR()
        and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
      spo2_nxt[1] := SpO2
      << SHFTR()
        and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
        and ( spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) ) >> 
  fi
Q [146] << spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0)
  and num_samples = #PulseOx_Properties::Num_Trending_Samples
  and ( all i ~ quantity whole 
  in 2 .. num_samples 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  ) >>
Why created:  <<Q3 and P4>> S4 <<Q4 and P5>> in sequential composition for [serial 1028]
Solved by:  Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>>
and theorems 625 632 641 657 663 673 688:
Theorem (625) [serial 1917] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1911] 
Theorem (632) [serial 1918] used for:
    <<P and B0>> -> <<P0>> in alternative for [serial 1911] 
Theorem (641) [serial 1919] used for:
    <<P0>> S0 <<Q0>> in alternative for [serial 1911] 
Theorem (657) [serial 1920] used for:
    <<Q0>> -> <<Q>> in alternative  for [serial 1911] 
Theorem (663) [serial 1921] used for:
    <<P and B1>> -> <<P1>> in alternative for [serial 1911] 
Theorem (673) [serial 1922] used for:
    <<P1>> S1 <<Q1>> in alternative for [serial 1911] 
Theorem (688) [serial 1923] used for:
    <<Q1>> -> <<Q>> in alternative  for [serial 1911] 


Theorem (690)                               [serial 2120] 
P [153] << (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [155] ->
Q [156] << (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 2118]
Solved by:  Identity (id):  P->P is tautology


Theorem (691)                               [serial 2118] 
P [153] << (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [155] ->
Q [156] << spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  applied wp for assignment [serial 1957]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 690:
Theorem (690) [serial 2120] used for:
    normalization of [serial 2118] 


Theorem (692)                               [serial 1957] 
P [153] << (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [155] spo2_a[i]' := spo2_nxt[i]
Q [156] << spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 1924]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 691:
Theorem (691) [serial 2118] used for:
  applied wp for assignment [serial 1957] 


Theorem (693)                               [serial 1924] 
P [153] << spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
S [155] spo2_a[i]' := spo2_nxt[i]
Q [156] << spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
Why created:  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1912]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 692:
Theorem (692) [serial 1957] used for:
    normalization of [serial 1924] 


Theorem (694)                               [serial 2115] 
P [146] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [151] ->
Q [19] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  )
  and ( #PulseOx_Properties::Num_Trending_Samples = num_samples ) >>
Why created:  Introduction of (unused) Universal Quantification [serial 2114]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (695)                               [serial 2114] 
P [146] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [151] ->
Q [19] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  )
  and ( all i ~ quantity whole 
  in 1 .. num_samples 
  are #PulseOx_Properties::Num_Trending_Samples = num_samples  ) >>
Why created:  Combine Universal Quantifications: all x:t in R are (A and B) = (all x:t in R are A) and (all x:t in R are B)  [serial 2113]
Solved by:  Introduction of (unused) Universal Quantification
and theorem 694:
Theorem (694) [serial 2115] used for:
  Introduction of (unused) Universal Quantification [serial 2114] 


Theorem (696)                               [serial 2113] 
P [146] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [151] ->
Q [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]
        and #PulseOx_Properties::Num_Trending_Samples = num_samples  >>
Why created:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1953]
Solved by:  Combine Universal Quantifications: all x:t in R are (A and B) = (all x:t in R are A) and (all x:t in R are B)
and theorem 695:
Theorem (695) [serial 2114] used for:
  Combine Universal Quantifications: all x:t in R are (A and B) = (all x:t in R are A) and (all x:t in R are B)  [serial 2113] 


Theorem (697)                               [serial 1953] 
P [146] << ( all i ~ quantity whole 
  in 2 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]  )
  and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) = spo2_nxt[1]
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [151] ->
Q [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i )) = spo2_nxt[i]
        and #PulseOx_Properties::Num_Trending_Samples = num_samples  >>
Why created:    normalization of [serial 1925]
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
and theorem 696:
Theorem (696) [serial 2113] used for:
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 1953] 


Theorem (698)                               [serial 1925] 
P [146] << ( spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0)
  and num_samples = #PulseOx_Properties::Num_Trending_Samples
  and ( all i ~ quantity whole 
  in 2 .. num_samples 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  ) ) >>
S [151] ->
Q [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
Why created:    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1912]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 697:
Theorem (697) [serial 1953] used for:
    normalization of [serial 1925] 


Theorem (699)                               [serial 2117] 
P [19] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  )
  and ( #PulseOx_Properties::Num_Trending_Samples = num_samples ) >>
S [151] ->
Q [159] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  Introduction of (unused) Universal Quantification [serial 2116]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (700)                               [serial 2116] 
P [19] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  )
  and ( all i ~ quantity whole 
  in 1 .. num_samples 
  are #PulseOx_Properties::Num_Trending_Samples = num_samples  ) >>
S [151] ->
Q [159] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:  Combine Universal Quantifications: all x:t in R are (A and B) = (all x:t in R are A) and (all x:t in R are B)  [serial 1955]
Solved by:  Introduction of (unused) Universal Quantification
and theorem 699:
Theorem (699) [serial 2117] used for:
  Introduction of (unused) Universal Quantification [serial 2116] 


Theorem (701)                               [serial 1955] 
P [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))
        and #PulseOx_Properties::Num_Trending_Samples = num_samples  >>
S [151] ->
Q [159] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 1926]
Solved by:  Combine Universal Quantifications: all x:t in R are (A and B) = (all x:t in R are A) and (all x:t in R are B)
and theorem 700:
Theorem (700) [serial 2116] used for:
  Combine Universal Quantifications: all x:t in R are (A and B) = (all x:t in R are A) and (all x:t in R are B)  [serial 1955] 


Theorem (702)                               [serial 1926] 
P [19] << all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples  >>
S [151] ->
Q [159] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
Why created:    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1912]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 701:
Theorem (701) [serial 1955] used for:
    normalization of [serial 1926] 


Theorem (703)                               [serial 1912] 
P [146] << spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0)
  and num_samples = #PulseOx_Properties::Num_Trending_Samples
  and ( all i ~ quantity whole 
  in 2 .. num_samples 
  are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  ) >>
S [151] forall i in 1 .. num_samples
    {
    << spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))
      and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
    spo2_a[i]' := spo2_nxt[i]
    << spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))
      and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
    }  
Q [159] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
Why created:  <<Q4 and P5>> S5 <<Q5 and P6>> in sequential composition for [serial 1028]
Solved by:  Universal Quantification Rule:
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any
and theorems 693 698 702:
Theorem (693) [serial 1924] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1912] 
Theorem (698) [serial 1925] used for:
    <<P and z in r and x=e>> -> <<all z:i in r are A>>
  for [serial 1912] 
Theorem (702) [serial 1926] used for:
    <<all z:i in r are B>> -> <<Q>> 
  for [serial 1912] 


Theorem (704)                               [serial 2124] 
P [159] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [163] ->
Q [164] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
Why created:    normalization of [serial 2122]
Solved by:  Identity (id):  P->P is tautology


Theorem (705)                               [serial 2122] 
P [159] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [163] ->
Q [164] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
Why created:  applied wp for assignment [serial 1959]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 704:
Theorem (704) [serial 2124] used for:
    normalization of [serial 2122] 


Theorem (706)                               [serial 1959] 
P [159] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  )
  and #PulseOx_Properties::Num_Trending_Samples = num_samples >>
S [163] num_samples' := num_samples
Q [164] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  )
  and num_samples' = #PulseOx_Properties::Num_Trending_Samples >>
Why created:    normalization of [serial 1913]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 705:
Theorem (705) [serial 2122] used for:
  applied wp for assignment [serial 1959] 


Theorem (707)                               [serial 1913] 
P [159] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  )
  and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
S [163] num_samples' := num_samples
Q [164] << ( all i ~ quantity whole 
  in 1 .. num_samples 
  are spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  )
  and num_samples' = #PulseOx_Properties::Num_Trending_Samples >>
Why created:  <<Q5 and P6>> S6 <<Q6>> in sequential composition for [serial 1028]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 706:
Theorem (706) [serial 1959] used for:
    normalization of [serial 1913] 


Theorem (708)                               [serial 1028] 
P [51] << SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples ) >>
S [111]   << SpO2_INV()
    and ( num_samples = #PulseOx_Properties::Num_Trending_Samples )
    and AXIOM_NS() >>
  SpO2Trend!(spo2_a)
  ;
  << SpO2_INV()
    and ( num_samples = #PulseOx_Properties::Num_Trending_Samples )
    and AXIOM_NS() >>
  NumSamples!(num_samples)
  ;
  << SpO2_INV()
    and ( num_samples = #PulseOx_Properties::Num_Trending_Samples )
    and AXIOM_CR2() >>
  forall i in 1 .. ( num_samples - 1 )
      {
      << spo2_a[i] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))
        and ( num_samples = #PulseOx_Properties::Num_Trending_Samples ) >>
      spo2_nxt[i + 1] := spo2_a[i]
      << spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
      }  
  <<SHFTR: :( all i ~ quantity whole 
    in 1 .. ( num_samples - 1 ) 
    are spo2_nxt[i + 1] = (if MOTION_ARTIFACT^( - i ) or not SENSOR_CONNECTED^( - i ) then 0 percent else SPO2^( - i ))  )
    and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
  ;
    if 
      (MotionArtifact? or not SensorConnected?)~> 
        << SHFTR()
          and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
        spo2_nxt[1] := 0 percent
        << SHFTR()
          and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
          and ( spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) ) >> 
    []
      (not ( MotionArtifact? or not SensorConnected? ))~> 
        << SHFTR()
          and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
        spo2_nxt[1] := SpO2
        << SHFTR()
          and not ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
          and ( spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0) ) >> 
    fi
  << spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 percent else SPO2^0)
    and num_samples = #PulseOx_Properties::Num_Trending_Samples
    and ( all i ~ quantity whole 
    in 2 .. num_samples 
    are spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  ) >>
  ;
  forall i in 1 .. num_samples
      {
      << spo2_nxt[i] = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
      spo2_a[i]' := spo2_nxt[i]
      << spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))
        and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
      }  
  << ( all i ~ quantity whole 
    in 1 .. num_samples 
    are spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  )
    and num_samples = #PulseOx_Properties::Num_Trending_Samples >>
  ;
  num_samples' := num_samples
  << ( all i ~ quantity whole 
    in 1 .. num_samples 
    are spo2_a[i]' = (if MOTION_ARTIFACT^( 1 - i ) or not SENSOR_CONNECTED^( 1 - i ) then 0 percent else SPO2^( 1 - i ))  )
    and num_samples' = #PulseOx_Properties::Num_Trending_Samples >> 
Q [51] << ( SpO2_INV()
  and ( num_samples = #PulseOx_Properties::Num_Trending_Samples ) )^1 >>
Why created:   <<M(run) and x>> A <<M(run)>> for sptt3: run-[x]->run{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 545 561 584 601 622 689 703 707:
Theorem (545) [serial 1906] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1028] 
Theorem (561) [serial 1907] used for:
  <<Q6>> -> <<Q>> in sequential composition for [serial 1028] 
Theorem (584) [serial 1908] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028] 
Theorem (601) [serial 1909] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028] 
Theorem (622) [serial 1910] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1028] 
Theorem (689) [serial 1911] used for:
  <<Q3 and P4>> S4 <<Q4 and P5>> in sequential composition for [serial 1028] 
Theorem (703) [serial 1912] used for:
  <<Q4 and P5>> S5 <<Q5 and P6>> in sequential composition for [serial 1028] 
Theorem (707) [serial 1913] used for:
  <<Q5 and P6>> S6 <<Q6>> in sequential composition for [serial 1028] 


Theorem (709)                               [serial 1018] 
P [28] <<   >>
S [33] ->
Q [28] << SpO2TrendThread.imp proof obligations >>
Why created:  Initial proof obligations for SpO2TrendThread.imp
Solved by:  Component verification conditions
and theorems 356 359 360 363 385 505 521 537 538 708:
Theorem (356) [serial 1019] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (359) [serial 1020] used for:
  <<M(loading)>> -> <<I>> from invariant I when complete state loading has Assertion <<M(loading)>> in its definition. 
Theorem (360) [serial 1021] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (363) [serial 1022] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state check, <<M(check)>> -> <<e1 or e2 or . . . en>> 
Theorem (385) [serial 1023] used for:
   <<M(start)>> A <<M(loading)>> for sptt0: start-[ ]->loading{A}; 
Theorem (505) [serial 1024] used for:
   <<M(loading) and x>> A <<M(check)>> for sptt1: loading-[x]->check{A}; 
Theorem (521) [serial 1025] used for:
   <<M(check) and x>> A <<M(loading)>> for sptt2a: check-[x]->loading{A}; 
Theorem (537) [serial 1026] used for:
   <<M(check) and x>> A <<M(run)>> for sptt2b: check-[x]->run{A}; 
Theorem (538) [serial 1027] used for:
   <<M(check) and x>> -> <<M(fail)>> for sptt2c: check-[x]->fail{}; 
Theorem (708) [serial 1028] used for:
   <<M(run) and x>> A <<M(run)>> for sptt3: run-[x]->run{A}; 


Theorem (710)                               [serial 2154] 
P [39] << all j ~ quantity whole 
  in 1 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [34] ->
Q [34] << all j ~ quantity whole 
  in 1 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:    normalization of [serial 2152]
Solved by:  Identity (id):  P->P is tautology


Theorem (711)                               [serial 2152] 
P [39] << ( all j ~ quantity whole 
  in 1 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
S [34] ->
Q [34] << all j ~ quantity whole 
  in 1 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1030]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 710:
Theorem (710) [serial 2154] used for:
    normalization of [serial 2152] 


Theorem (712)                               [serial 1030] 
P [39] << MOINV() >>
S [34] ->
Q [34] << all j ~ quantity whole 
  in 1 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by:  Substitution of Assertion Labels
and theorem 711:
Theorem (711) [serial 2152] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1030] 


Theorem (713)                               [serial 1031] 
P [38] << numBadReadings = 0 >>
S [38] ->
Q [38] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by:  True Conclusion Schema (tc): P->true


Theorem (714)                               [serial 2175] 
P [38] << 0 = numBadReadings >>
S [42] ->
Q [39] << true >>
Why created:  Empty Range Law All: all a:t which false are V is tautology  [serial 2172]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (715)                               [serial 2172] 
P [38] << 0 = numBadReadings >>
S [42] ->
Q [39] << all j ~ quantity whole 
  which false 
  are MOTION_ARTIFACT^( 1 - j ) or not SENSOR_CONNECTED^( 1 - j )  >>
Why created:    normalization of [serial 2170]
Solved by:  Empty Range Law All: all a:t which false are V is tautology
and theorem 714:
Theorem (714) [serial 2175] used for:
  Empty Range Law All: all a:t which false are V is tautology  [serial 2172] 


Theorem (716)                               [serial 2170] 
P [38] << 0 = numBadReadings >>
S [42] ->
Q [39] << all j ~ quantity whole 
  which false 
  are not ( SENSOR_CONNECTED^( - j ) )^1 or MOTION_ARTIFACT^( 1 - j )  >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2168]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Caret Compostition:  (x^a)^b is x^(a+b)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 715:
Theorem (715) [serial 2172] used for:
    normalization of [serial 2170] 


Theorem (717)                               [serial 2168] 
P [38] << 0 = numBadReadings >>
S [42] ->
Q [39] << all j ~ quantity whole 
  which false 
  are ( not SENSOR_CONNECTED^( - j ) )^1 or MOTION_ARTIFACT^( 1 - j )  >>
Why created:    normalization of [serial 2166]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 716:
Theorem (716) [serial 2170] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2168] 


Theorem (718)                               [serial 2166] 
P [38] << 0 = numBadReadings >>
S [42] ->
Q [39] << all j ~ quantity whole 
  which false 
  are ( MOTION_ARTIFACT^( ( - j ) + 1 ) or ( not SENSOR_CONNECTED^( - j ) )^1 )  >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2164]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 717:
Theorem (717) [serial 2168] used for:
    normalization of [serial 2166] 


Theorem (719)                               [serial 2164] 
P [38] << 0 = numBadReadings >>
S [42] ->
Q [39] << all j ~ quantity whole 
  which false 
  are ( MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j ) )^1  >>
Why created:    normalization of [serial 2162]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 718:
Theorem (718) [serial 2166] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2164] 


Theorem (720)                               [serial 2162] 
P [38] << 0 = numBadReadings >>
S [42] ->
Q [39] << ( all j ~ quantity whole 
  which false 
  are ( MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j ) )^1  ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2161]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 719:
Theorem (719) [serial 2164] used for:
    normalization of [serial 2162] 


Theorem (721)                               [serial 2161] 
P [38] << 0 = numBadReadings >>
S [42] ->
Q [39] << ( all j ~ quantity whole 
  which false 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  )^1 >>
Why created:  Empty Range [serial 2160]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 720:
Theorem (720) [serial 2162] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2161] 


Theorem (722)                               [serial 2160] 
P [38] << 0 = numBadReadings >>
S [42] ->
Q [39] << ( all j ~ quantity whole 
  in 1 .. 0 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  )^1 >>
Why created:  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>> 
 replacing "numBadReadings"
 with its ="
 ( 0 )" [serial 2158]
Solved by:  Empty Range
and theorem 721:
Theorem (721) [serial 2161] used for:
  Empty Range [serial 2160] 


Theorem (723)                               [serial 2158] 
P [38] << 0 = numBadReadings >>
S [42] ->
Q [39] << ( all j ~ quantity whole 
  in 1 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  )^1 >>
Why created:    normalization of [serial 2156]
Solved by:  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
and theorem 722:
Theorem (722) [serial 2160] used for:
  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>> 
 replacing "numBadReadings"
 with its ="
 ( 0 )" [serial 2158] 


Theorem (724)                               [serial 2156] 
P [38] << numBadReadings = 0 >>
S [42] ->
Q [39] << ( ( all j ~ quantity whole 
  in 1 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) )^1 >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1032]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 723:
Theorem (723) [serial 2158] used for:
    normalization of [serial 2156] 


Theorem (725)                               [serial 1032] 
P [38] << numBadReadings = 0 >>
S [42] ->
Q [39] << ( MOINV() )^1 >>
Why created:   <<M(start)>> -> <<M(run)>> for mat0: start-[ ]->run{};
Solved by:  Substitution of Assertion Labels
and theorem 724:
Theorem (724) [serial 2156] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1032] 


Theorem (726)                               [serial 2176] 
P [39] << MOINV() >>
S [39] ->
Q [44] << MOINV() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1033]
Solved by:  Identity (id):  P->P is tautology


Theorem (727)                               [serial 2328] 
P [68] << all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [39] ->
Q [16] << all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:  Shift Quantification Range so Lower Bound is Zero  [serial 2325]
Solved by:  Identity (id):  P->P is tautology


Theorem (728)                               [serial 2325] 
P [68] << all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [39] ->
Q [16] << all j ~ quantity whole 
  in 1 .. numBadReadings 
  are MOTION_ARTIFACT^( 1 - j ) or not SENSOR_CONNECTED^( 1 - j )  >>
Why created:    normalization of [serial 2323]
Solved by:  Shift Quantification Range so Lower Bound is Zero
and theorem 727:
Theorem (727) [serial 2328] used for:
  Shift Quantification Range so Lower Bound is Zero  [serial 2325] 


Theorem (729)                               [serial 2323] 
P [68] << all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [39] ->
Q [16] << all j ~ quantity whole 
  in 1 .. numBadReadings 
  are not ( SENSOR_CONNECTED^( - j ) )^1 or MOTION_ARTIFACT^( 1 - j )  >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2321]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Caret Compostition:  (x^a)^b is x^(a+b)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 728:
Theorem (728) [serial 2325] used for:
    normalization of [serial 2323] 


Theorem (730)                               [serial 2321] 
P [68] << all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [39] ->
Q [16] << all j ~ quantity whole 
  in 1 .. numBadReadings 
  are ( not SENSOR_CONNECTED^( - j ) )^1 or MOTION_ARTIFACT^( 1 - j )  >>
Why created:    normalization of [serial 2319]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 729:
Theorem (729) [serial 2323] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2321] 


Theorem (731)                               [serial 2319] 
P [68] << all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [39] ->
Q [16] << all j ~ quantity whole 
  in 1 .. numBadReadings 
  are ( MOTION_ARTIFACT^( ( - j ) + 1 ) or ( not SENSOR_CONNECTED^( - j ) )^1 )  >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2317]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 730:
Theorem (730) [serial 2321] used for:
    normalization of [serial 2319] 


Theorem (732)                               [serial 2317] 
P [68] << all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [39] ->
Q [16] << all j ~ quantity whole 
  in 1 .. numBadReadings 
  are ( MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j ) )^1  >>
Why created:    normalization of [serial 2315]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 731:
Theorem (731) [serial 2319] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2317] 


Theorem (733)                               [serial 2315] 
P [68] << all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [39] ->
Q [16] << ( all j ~ quantity whole 
  in 1 .. numBadReadings 
  are ( MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j ) )^1  ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2292]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 732:
Theorem (732) [serial 2317] used for:
    normalization of [serial 2315] 


Theorem (734)                               [serial 2292] 
P [68] << all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [39] ->
Q [16] << ( all j ~ quantity whole 
  in 1 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  )^1 >>
Why created:    normalization of [serial 2281]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 733:
Theorem (733) [serial 2315] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2292] 


Theorem (735)                               [serial 2281] 
P [68] << ( all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
S [39] ->
Q [16] << ( all j ~ quantity whole 
  in 1 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  )^1 >>
Why created:  Substituted assertions' predicates for labels  [serial 2250]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 734:
Theorem (734) [serial 2292] used for:
    normalization of [serial 2281] 


Theorem (736)                               [serial 2250] 
P [68] << NUMBAD() >>
S [39] ->
Q [16] << ( all j ~ quantity whole 
  in 1 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  )^1 >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2196]
Solved by:  Substitution of Assertion Labels
and theorem 735:
Theorem (735) [serial 2281] used for:
  Substituted assertions' predicates for labels  [serial 2250] 


Theorem (737)                               [serial 2196] 
P [68] << NUMBAD() >>
S [39] ->
Q [16] << MOINV()^1 >>
Why created:    normalization of [serial 2177]
Solved by:  Substitution of Assertion Labels
and theorem 736:
Theorem (736) [serial 2250] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2196] 


Theorem (738)                               [serial 2177] 
P [68] << NUMBAD() >>
S [39] ->
Q [16] << ( MOINV() )^1 >>
Why created:  <<Q2>> -> <<Q>> in sequential composition for [serial 1033]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 737:
Theorem (737) [serial 2196] used for:
    normalization of [serial 2177] 


Theorem (739)                               [serial 2313] 
P [44] << all j ~ quantity whole 
  in 1 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [45] ->
Q [45] << true >>
Why created:    normalization of [serial 2311]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (740)                               [serial 2311] 
P [44] << all j ~ quantity whole 
  in 1 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [45] ->
Q [45] << ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 2310]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 739:
Theorem (739) [serial 2313] used for:
    normalization of [serial 2311] 


Theorem (741)                               [serial 2310] 
P [44] << all j ~ quantity whole 
  in 1 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [45] ->
Q [45] << ( true )
  and ( true ) >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 2309]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 740:
Theorem (740) [serial 2311] used for:
  Law of And-Simplification:  P and P is P [serial 2310] 


Theorem (742)                               [serial 2309] 
P [44] << all j ~ quantity whole 
  in 1 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [45] ->
Q [45] << ( SENSOR_CONNECTED^0 or MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and ( not MOTION_ARTIFACT^0 or MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:  Distributing Postcondition Or-Over-And [serial 2290]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 741:
Theorem (741) [serial 2310] used for:
  Law of Excluded Middle: P or not P is tautology [serial 2309] 


Theorem (743)                               [serial 2290] 
P [44] << all j ~ quantity whole 
  in 1 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [45] ->
Q [45] << ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) or MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 >>
Why created:    normalization of [serial 2280]
Solved by:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 742:
Theorem (742) [serial 2309] used for:
  Distributing Postcondition Or-Over-And [serial 2290] 


Theorem (744)                               [serial 2280] 
P [44] << ( all j ~ quantity whole 
  in 1 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
S [45] ->
Q [45] << ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) or MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 >>
Why created:  Substituted assertions' predicates for labels  [serial 2243]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 743:
Theorem (743) [serial 2290] used for:
    normalization of [serial 2280] 


Theorem (745)                               [serial 2243] 
P [44] << MOINV() >>
S [45] ->
Q [45] << ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) or MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 >>
Why created:    normalization of [serial 2226]
Solved by:  Substitution of Assertion Labels
and theorem 744:
Theorem (744) [serial 2280] used for:
  Substituted assertions' predicates for labels  [serial 2243] 


Theorem (746)                               [serial 2226] 
P [44] << MOINV() >>
S [45] ->
Q [45] << MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 or ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2180]
Solved by:  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 745:
Theorem (745) [serial 2243] used for:
    normalization of [serial 2226] 


Theorem (747)                               [serial 2180] 
P [44] << MOINV() >>
S [45] ->
Q [45] << ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) or ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 2178]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 746:
Theorem (746) [serial 2226] used for:
  Associativity: a.(b.c) = a.b.c [serial 2180] 


Theorem (748)                               [serial 2245] 
P [45] << MOINV()
  and SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 >>
S [45] ->
Q [48] << SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 >>
Why created:    normalization of [serial 2227]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (749)                               [serial 2227] 
P [45] << SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0
  and MOINV() >>
S [45] ->
Q [48] << SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2199]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 748:
Theorem (748) [serial 2245] used for:
    normalization of [serial 2227] 


Theorem (750)                               [serial 2199] 
P [45] << ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 )
  and MOINV() >>
S [45] ->
Q [48] << SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 >>
Why created:    normalization of [serial 2181]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 749:
Theorem (749) [serial 2227] used for:
  Associativity: a.(b.c) = a.b.c [serial 2199] 


Theorem (751)                               [serial 2181] 
P [45] << MOINV()
  and ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) >>
S [45] ->
Q [48] << SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 >>
Why created:    <<P and B0>> -> <<P0>> in alternative for [serial 2178]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 750:
Theorem (750) [serial 2199] used for:
    normalization of [serial 2181] 


Theorem (752)                               [serial 2277] 
P [48] << SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 >>
S [49] ->
Q [50] << true >>
Why created:  Empty Range Law All: all a:t which false are V is tautology  [serial 2275]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (753)                               [serial 2275] 
P [48] << SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 >>
S [49] ->
Q [50] << all j ~ quantity whole 
  which false 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:  Empty Range [serial 2262]
Solved by:  Empty Range Law All: all a:t which false are V is tautology
and theorem 752:
Theorem (752) [serial 2277] used for:
  Empty Range Law All: all a:t which false are V is tautology  [serial 2275] 


Theorem (754)                               [serial 2262] 
P [48] << SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 >>
S [49] ->
Q [50] << all j ~ quantity whole 
  in 0 .. -1 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:    normalization of [serial 2253]
Solved by:  Empty Range
and theorem 753:
Theorem (753) [serial 2275] used for:
  Empty Range [serial 2262] 


Theorem (755)                               [serial 2253] 
P [48] << SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 >>
S [49] ->
Q [50] << ( all j ~ quantity whole 
  in 0 .. ( 0 - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
Why created:  applied wp for assignment [serial 2248]
Solved by:  Literal Arithmetic
  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Unary Minus:  -(x-y) is (y-x)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 754:
Theorem (754) [serial 2262] used for:
    normalization of [serial 2253] 


Theorem (756)                               [serial 2248] 
P [48] << SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 >>
S [49] numBadReadings := 0
Q [50] << ( all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2182]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 755:
Theorem (755) [serial 2253] used for:
  applied wp for assignment [serial 2248] 


Theorem (757)                               [serial 2182] 
P [48] << SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 >>
S [49] numBadReadings := 0
Q [50] << NUMBAD() >>
Why created:    <<P0>> S0 <<Q0>> in alternative for [serial 2178]
Solved by:  Substitution of Assertion Labels
and theorem 756:
Theorem (756) [serial 2248] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2182] 


Theorem (758)                               [serial 2183] 
P [50] << NUMBAD() >>
S [45] ->
Q [57] << NUMBAD() >>
Why created:    <<Q0>> -> <<Q>> in alternative  for [serial 2178]
Solved by:  Identity (id):  P->P is tautology


Theorem (759)                               [serial 2306] 
P [45] << ( all j ~ quantity whole 
  in 0 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [45] ->
Q [53] << all j ~ quantity whole 
  in 0 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 2286]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (760)                               [serial 2286] 
P [45] << ( all j ~ quantity whole 
  in 1 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  )
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [45] ->
Q [53] << all j ~ quantity whole 
  in 0 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:    normalization of [serial 2278]
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
and theorem 759:
Theorem (759) [serial 2306] used for:
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 2286] 


Theorem (761)                               [serial 2278] 
P [45] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and ( all j ~ quantity whole 
  in 1 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
S [45] ->
Q [53] << all j ~ quantity whole 
  in 0 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:  Substituted assertions' predicates for labels  [serial 2203]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 760:
Theorem (760) [serial 2286] used for:
    normalization of [serial 2278] 


Theorem (762)                               [serial 2203] 
P [45] << ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 )
  and MOINV() >>
S [45] ->
Q [53] << all j ~ quantity whole 
  in 0 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:    normalization of [serial 2184]
Solved by:  Substitution of Assertion Labels
and theorem 761:
Theorem (761) [serial 2278] used for:
  Substituted assertions' predicates for labels  [serial 2203] 


Theorem (763)                               [serial 2184] 
P [45] << MOINV()
  and ( MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 ) >>
S [45] ->
Q [53] << all j ~ quantity whole 
  in 0 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:    <<P and B1>> -> <<P1>> in alternative for [serial 2178]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 762:
Theorem (762) [serial 2203] used for:
    normalization of [serial 2184] 


Theorem (764)                               [serial 2267] 
P [53] << all j ~ quantity whole 
  in 0 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [54] ->
Q [55] << all j ~ quantity whole 
  in 0 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:    normalization of [serial 2255]
Solved by:  Identity (id):  P->P is tautology


Theorem (765)                               [serial 2255] 
P [53] << all j ~ quantity whole 
  in 0 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [54] ->
Q [55] << ( all j ~ quantity whole 
  in 0 .. ( ( 1 + numBadReadings ) - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
Why created:  applied wp for assignment [serial 2251]
Solved by:  Subtaction of Added Value:  (a+b)-a is b
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 764:
Theorem (764) [serial 2267] used for:
    normalization of [serial 2255] 


Theorem (766)                               [serial 2251] 
P [53] << all j ~ quantity whole 
  in 0 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [54] numBadReadings := 1 + numBadReadings
Q [55] << ( all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2205]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 765:
Theorem (765) [serial 2255] used for:
  applied wp for assignment [serial 2251] 


Theorem (767)                               [serial 2205] 
P [53] << all j ~ quantity whole 
  in 0 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [54] numBadReadings := 1 + numBadReadings
Q [55] << NUMBAD() >>
Why created:    normalization of [serial 2185]
Solved by:  Substitution of Assertion Labels
and theorem 766:
Theorem (766) [serial 2251] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2205] 


Theorem (768)                               [serial 2185] 
P [53] << all j ~ quantity whole 
  in 0 .. numBadReadings 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [54] numBadReadings := numBadReadings + 1
Q [55] << NUMBAD() >>
Why created:    <<P1>> S1 <<Q1>> in alternative for [serial 2178]
Solved by:  Reflexivity of Addition: a+b=b+a
  Associativity: a.(b.c) = a.b.c
and theorem 767:
Theorem (767) [serial 2205] used for:
    normalization of [serial 2185] 


Theorem (769)                               [serial 2186] 
P [55] << NUMBAD() >>
S [45] ->
Q [57] << NUMBAD() >>
Why created:    <<Q1>> -> <<Q>> in alternative  for [serial 2178]
Solved by:  Identity (id):  P->P is tautology


Theorem (770)                               [serial 2178] 
P [44] << MOINV() >>
S [45]   if 
    (SensorConnected?
    and not MotionArtifact?)~> 
      << SENSOR_CONNECTED^0
        and not MOTION_ARTIFACT^0 >>
      numBadReadings := 0
      << NUMBAD() >> 
  []
    (MotionArtifact? or not SensorConnected?)~> 
      << all j ~ quantity whole 
        in 0 .. numBadReadings 
        are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
      numBadReadings := numBadReadings + 1
      << NUMBAD() >> 
  fi
Q [57] << NUMBAD() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1033]
Solved by:  Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>>
and theorems 747 751 757 758 763 768 769:
Theorem (747) [serial 2180] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 2178] 
Theorem (751) [serial 2181] used for:
    <<P and B0>> -> <<P0>> in alternative for [serial 2178] 
Theorem (757) [serial 2182] used for:
    <<P0>> S0 <<Q0>> in alternative for [serial 2178] 
Theorem (758) [serial 2183] used for:
    <<Q0>> -> <<Q>> in alternative  for [serial 2178] 
Theorem (763) [serial 2184] used for:
    <<P and B1>> -> <<P1>> in alternative for [serial 2178] 
Theorem (768) [serial 2185] used for:
    <<P1>> S1 <<Q1>> in alternative for [serial 2178] 
Theorem (769) [serial 2186] used for:
    <<Q1>> -> <<Q>> in alternative  for [serial 2178] 


Theorem (771)                               [serial 2308] 
P [57] << all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [59] ->
Q [59] << true >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 2307]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (772)                               [serial 2307] 
P [57] << all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [59] ->
Q [59] << numBadReadings - 1 < #PulseOx_Properties::Motion_Artifact_Sample_Limit or 
( not ( numBadReadings - 1 < #PulseOx_Properties::Motion_Artifact_Sample_Limit ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2288]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 771:
Theorem (771) [serial 2308] used for:
  Law of Excluded Middle: P or not P is tautology [serial 2307] 


Theorem (773)                               [serial 2288] 
P [57] << all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [59] ->
Q [59] << numBadReadings - 1 < #PulseOx_Properties::Motion_Artifact_Sample_Limit or 
#PulseOx_Properties::Motion_Artifact_Sample_Limit <= numBadReadings - 1 >>
Why created:    normalization of [serial 2279]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 772:
Theorem (772) [serial 2307] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2288] 


Theorem (774)                               [serial 2279] 
P [57] << ( all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
S [59] ->
Q [59] << numBadReadings - 1 < #PulseOx_Properties::Motion_Artifact_Sample_Limit or 
#PulseOx_Properties::Motion_Artifact_Sample_Limit <= numBadReadings - 1 >>
Why created:  Substituted assertions' predicates for labels  [serial 2208]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 773:
Theorem (773) [serial 2288] used for:
    normalization of [serial 2279] 


Theorem (775)                               [serial 2208] 
P [57] << NUMBAD() >>
S [59] ->
Q [59] << numBadReadings - 1 < #PulseOx_Properties::Motion_Artifact_Sample_Limit or 
#PulseOx_Properties::Motion_Artifact_Sample_Limit <= numBadReadings - 1 >>
Why created:    normalization of [serial 2187]
Solved by:  Substitution of Assertion Labels
and theorem 774:
Theorem (774) [serial 2279] used for:
  Substituted assertions' predicates for labels  [serial 2208] 


Theorem (776)                               [serial 2187] 
P [57] << NUMBAD() >>
S [59] ->
Q [59] << ( ( numBadReadings - 1 ) < #PulseOx_Properties::Motion_Artifact_Sample_Limit ) or 
( ( numBadReadings - 1 ) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 2179]
Solved by:  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 775:
Theorem (775) [serial 2208] used for:
    normalization of [serial 2187] 


Theorem (777)                               [serial 2210] 
P [59] << numBadReadings - 1 < #PulseOx_Properties::Motion_Artifact_Sample_Limit
  and NUMBAD() >>
S [59] ->
Q [61] << NUMBAD() >>
Why created:    normalization of [serial 2188]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (778)                               [serial 2188] 
P [59] << NUMBAD()
  and ( ( numBadReadings - 1 ) < #PulseOx_Properties::Motion_Artifact_Sample_Limit ) >>
S [59] ->
Q [61] << NUMBAD() >>
Why created:    <<P and B0>> -> <<P0>> in alternative for [serial 2179]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 777:
Theorem (777) [serial 2210] used for:
    normalization of [serial 2188] 


Theorem (779)                               [serial 2296] 
P [61] << all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
S [61] ->
Q [61] << all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:    normalization of [serial 2283]
Solved by:  Identity (id):  P->P is tautology


Theorem (780)                               [serial 2283] 
P [61] << ( all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
S [61] ->
Q [61] << all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:  Substituted assertions' predicates for labels  [serial 2264]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 779:
Theorem (779) [serial 2296] used for:
    normalization of [serial 2283] 


Theorem (781)                               [serial 2264] 
P [61] << NUMBAD() >>
S [61] ->
Q [61] << all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:    normalization of [serial 2254]
Solved by:  Substitution of Assertion Labels
and theorem 780:
Theorem (780) [serial 2283] used for:
  Substituted assertions' predicates for labels  [serial 2264] 


Theorem (782)                               [serial 2254] 
P [61] << NUMBAD() >>
S [61] ->
Q [61] << ( all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
Why created:    <<P>> -> <<Q>>
  for [serial 2249]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 781:
Theorem (781) [serial 2264] used for:
    normalization of [serial 2254] 


Theorem (783)                               [serial 2249] 
P [61] << NUMBAD() >>
S [61] skip
Q [61] << ( all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2189]
Solved by:  Skip Means Implication:  <<P>> skip <<Q>>  is  <<P>> -> <<Q>>
and theorem 782:
Theorem (782) [serial 2254] used for:
    <<P>> -> <<Q>>
  for [serial 2249] 


Theorem (784)                               [serial 2189] 
P [61] << NUMBAD() >>
S [61] skip
Q [61] << NUMBAD() >>
Why created:    <<P0>> S0 <<Q0>> in alternative for [serial 2179]
Solved by:  Substitution of Assertion Labels
and theorem 783:
Theorem (783) [serial 2249] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2189] 


Theorem (785)                               [serial 2190] 
P [61] << NUMBAD() >>
S [59] ->
Q [68] << NUMBAD() >>
Why created:    <<Q0>> -> <<Q>> in alternative  for [serial 2179]
Solved by:  Identity (id):  P->P is tautology


Theorem (786)                               [serial 2214] 
P [59] << #PulseOx_Properties::Motion_Artifact_Sample_Limit <= numBadReadings - 1
  and NUMBAD() >>
S [59] ->
Q [64] << #PulseOx_Properties::Motion_Artifact_Sample_Limit <= numBadReadings - 1
  and NUMBAD() >>
Why created:    normalization of [serial 2191]
Solved by:  Identity (id):  P->P is tautology


Theorem (787)                               [serial 2191] 
P [59] << NUMBAD()
  and ( ( numBadReadings - 1 ) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit ) >>
S [59] ->
Q [64] << NUMBAD()
  and ( ( numBadReadings - 1 ) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit ) >>
Why created:    <<P and B1>> -> <<P1>> in alternative for [serial 2179]
Solved by:  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 786:
Theorem (786) [serial 2214] used for:
    normalization of [serial 2191] 


Theorem (788)                               [serial 2329] 
P [64] << ( all j ~ quantity whole 
  in 0 .. #PulseOx_Properties::Motion_Artifact_Sample_Limit 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  )
  and #PulseOx_Properties::Motion_Artifact_Sample_Limit <= numBadReadings - 1 >>
S [65] ->
Q [13] << all j ~ quantity whole 
  in 0 .. #PulseOx_Properties::Motion_Artifact_Sample_Limit 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:  Contract Universal Quantification Range  [serial 2294]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (789)                               [serial 2294] 
P [64] << ( all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  )
  and #PulseOx_Properties::Motion_Artifact_Sample_Limit <= numBadReadings - 1 >>
S [65] ->
Q [13] << all j ~ quantity whole 
  in 0 .. #PulseOx_Properties::Motion_Artifact_Sample_Limit 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:    normalization of [serial 2282]
Solved by:  Contract Universal Quantification Range
and theorem 788:
Theorem (788) [serial 2329] used for:
  Contract Universal Quantification Range  [serial 2294] 


Theorem (790)                               [serial 2282] 
P [64] << #PulseOx_Properties::Motion_Artifact_Sample_Limit <= numBadReadings - 1
  and ( all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
S [65] ->
Q [13] << ( all j ~ quantity whole 
  in 0 .. #PulseOx_Properties::Motion_Artifact_Sample_Limit 
  are ( MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j ) )  ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2256]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 789:
Theorem (789) [serial 2294] used for:
    normalization of [serial 2282] 


Theorem (791)                               [serial 2256] 
P [64] << #PulseOx_Properties::Motion_Artifact_Sample_Limit <= numBadReadings - 1
  and NUMBAD() >>
S [65] ->
Q [13] << MOTION_ARTIFACT_ALARM() >>
Why created:  applied port output <<pre>> -> <<M[MotionArtifactAlarm]>> [serial 2252]
Solved by:  Substitution of Assertion Labels
and theorem 790:
Theorem (790) [serial 2282] used for:
  Substituted assertions' predicates for labels  [serial 2256] 


Theorem (792)                               [serial 2298] 
P [65] << ( all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  )
  and #PulseOx_Properties::Motion_Artifact_Sample_Limit <= numBadReadings - 1
  and MotionArtifactAlarm^0 >>
S [65] ->
Q [66] << all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:    normalization of [serial 2284]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (793)                               [serial 2284] 
P [65] << #PulseOx_Properties::Motion_Artifact_Sample_Limit <= numBadReadings - 1
  and ( all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  )
  and MotionArtifactAlarm^0 >>
S [65] ->
Q [66] << all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:  Substituted assertions' predicates for labels  [serial 2276]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 792:
Theorem (792) [serial 2298] used for:
    normalization of [serial 2284] 


Theorem (794)                               [serial 2276] 
P [65] << #PulseOx_Properties::Motion_Artifact_Sample_Limit <= numBadReadings - 1
  and NUMBAD()
  and MotionArtifactAlarm^0 >>
S [65] ->
Q [66] << all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2270]
Solved by:  Substitution of Assertion Labels
and theorem 793:
Theorem (793) [serial 2284] used for:
  Substituted assertions' predicates for labels  [serial 2276] 


Theorem (795)                               [serial 2270] 
P [65] << ( #PulseOx_Properties::Motion_Artifact_Sample_Limit <= numBadReadings - 1
  and NUMBAD() )
  and MotionArtifactAlarm^0 >>
S [65] ->
Q [66] << all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
Why created:    normalization of [serial 2257]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 794:
Theorem (794) [serial 2276] used for:
  Associativity: a.(b.c) = a.b.c [serial 2270] 


Theorem (796)                               [serial 2257] 
P [65] << ( #PulseOx_Properties::Motion_Artifact_Sample_Limit <= numBadReadings - 1
  and NUMBAD() )
  and MotionArtifactAlarm^0 >>
S [65] ->
Q [66] << ( all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
Why created:  applied port output <<pre and M[MotionArtifactAlarm]^0>> -> <<post>> [serial 2252]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 795:
Theorem (795) [serial 2270] used for:
    normalization of [serial 2257] 


Theorem (797)                               [serial 2252] 
P [64] << #PulseOx_Properties::Motion_Artifact_Sample_Limit <= numBadReadings - 1
  and NUMBAD() >>
S [65] MotionArtifactAlarm!
Q [66] << ( all j ~ quantity whole 
  in 0 .. ( numBadReadings - 1 ) 
  are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2216]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
and theorems 791 796:
Theorem (791) [serial 2256] used for:
  applied port output <<pre>> -> <<M[MotionArtifactAlarm]>> [serial 2252] 
Theorem (796) [serial 2257] used for:
  applied port output <<pre and M[MotionArtifactAlarm]^0>> -> <<post>> [serial 2252] 


Theorem (798)                               [serial 2216] 
P [64] << #PulseOx_Properties::Motion_Artifact_Sample_Limit <= numBadReadings - 1
  and NUMBAD() >>
S [65] MotionArtifactAlarm!
Q [66] << NUMBAD() >>
Why created:    normalization of [serial 2192]
Solved by:  Substitution of Assertion Labels
and theorem 797:
Theorem (797) [serial 2252] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2216] 


Theorem (799)                               [serial 2192] 
P [64] << NUMBAD()
  and ( ( numBadReadings - 1 ) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit ) >>
S [65] MotionArtifactAlarm!
Q [66] << NUMBAD() >>
Why created:    <<P1>> S1 <<Q1>> in alternative for [serial 2179]
Solved by:  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 798:
Theorem (798) [serial 2216] used for:
    normalization of [serial 2192] 


Theorem (800)                               [serial 2193] 
P [66] << NUMBAD() >>
S [59] ->
Q [68] << NUMBAD() >>
Why created:    <<Q1>> -> <<Q>> in alternative  for [serial 2179]
Solved by:  Identity (id):  P->P is tautology


Theorem (801)                               [serial 2179] 
P [57] << NUMBAD() >>
S [59]   if 
    (( numBadReadings - 1 ) < #PulseOx_Properties::Motion_Artifact_Sample_Limit)~> 
      << NUMBAD() >>
      skip
      << NUMBAD() >> 
  []
    (( numBadReadings - 1 ) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit)~> 
      << NUMBAD()
        and ( ( numBadReadings - 1 ) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit ) >>
      MotionArtifactAlarm!
      << NUMBAD() >> 
  fi
Q [68] << NUMBAD() >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1033]
Solved by:  Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>>
and theorems 776 778 784 785 787 799 800:
Theorem (776) [serial 2187] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 2179] 
Theorem (778) [serial 2188] used for:
    <<P and B0>> -> <<P0>> in alternative for [serial 2179] 
Theorem (784) [serial 2189] used for:
    <<P0>> S0 <<Q0>> in alternative for [serial 2179] 
Theorem (785) [serial 2190] used for:
    <<Q0>> -> <<Q>> in alternative  for [serial 2179] 
Theorem (787) [serial 2191] used for:
    <<P and B1>> -> <<P1>> in alternative for [serial 2179] 
Theorem (799) [serial 2192] used for:
    <<P1>> S1 <<Q1>> in alternative for [serial 2179] 
Theorem (800) [serial 2193] used for:
    <<Q1>> -> <<Q>> in alternative  for [serial 2179] 


Theorem (802)                               [serial 1033] 
P [39] << MOINV() >>
S [44]   << MOINV() >>
    if 
      (SensorConnected?
      and not MotionArtifact?)~> 
        << SENSOR_CONNECTED^0
          and not MOTION_ARTIFACT^0 >>
        numBadReadings := 0
        << NUMBAD() >> 
    []
      (MotionArtifact? or not SensorConnected?)~> 
        << all j ~ quantity whole 
          in 0 .. numBadReadings 
          are MOTION_ARTIFACT^( - j ) or not SENSOR_CONNECTED^( - j )  >>
        numBadReadings := numBadReadings + 1
        << NUMBAD() >> 
    fi
  << NUMBAD() >>
  ;
    if 
      (( numBadReadings - 1 ) < #PulseOx_Properties::Motion_Artifact_Sample_Limit)~> 
        << NUMBAD() >>
        skip
        << NUMBAD() >> 
    []
      (( numBadReadings - 1 ) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit)~> 
        << NUMBAD()
          and ( ( numBadReadings - 1 ) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit ) >>
        MotionArtifactAlarm!
        << NUMBAD() >> 
    fi
  << NUMBAD() >> 
Q [39] << ( MOINV() )^1 >>
Why created:   <<M(run) and x>> A <<M(run)>> for mat1: run-[x]->run{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 726 738 770 801:
Theorem (726) [serial 2176] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1033] 
Theorem (738) [serial 2177] used for:
  <<Q2>> -> <<Q>> in sequential composition for [serial 1033] 
Theorem (770) [serial 2178] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1033] 
Theorem (801) [serial 2179] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1033] 


Theorem (803)                               [serial 1029] 
P [31] <<   >>
S [34] ->
Q [31] << MotionArtifactThread.imp proof obligations >>
Why created:  Initial proof obligations for MotionArtifactThread.imp
Solved by:  Component verification conditions
and theorems 712 713 725 802:
Theorem (712) [serial 1030] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (713) [serial 1031] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (725) [serial 1032] used for:
   <<M(start)>> -> <<M(run)>> for mat0: start-[ ]->run{}; 
Theorem (802) [serial 1033] used for:
   <<M(run) and x>> A <<M(run)>> for mat1: run-[x]->run{A}; 


Theorem (804)                               [serial 1035] 
P [31] << true >>
S [28] ->
Q [28] << true >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by:  True Conclusion Schema (tc): P->true


Theorem (805)                               [serial 1036] 
P [30] << true >>
S [30] ->
Q [30] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by:  True Conclusion Schema (tc): P->true


Theorem (806)                               [serial 2342] 
P [32] << true >>
S [32] ->
Q [32] << true >>
Why created:    normalization of [serial 2340]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (807)                               [serial 2340] 
P [32] << true >>
S [32] ->
Q [32] << ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 2339]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 806:
Theorem (806) [serial 2342] used for:
    normalization of [serial 2340] 


Theorem (808)                               [serial 2339] 
P [32] << true >>
S [32] ->
Q [32] << ( true )
  and ( true ) >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 2338]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 807:
Theorem (807) [serial 2340] used for:
  Law of And-Simplification:  P and P is P [serial 2339] 


Theorem (809)                               [serial 2338] 
P [32] << true >>
S [32] ->
Q [32] << ( SPO2_AVERAGE()^0 < SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0 or not ( SPO2_AVERAGE()^0 < 
SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0 ) or not SUPPL_OXY_ALARM_ENABLED^0 or 
( not ( SPO2_AVERAGE()^0 < SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0 ) or 
not SUPPL_OXY_ALARM_ENABLED^0 ) )
  and ( SUPPL_OXY_ALARM_ENABLED^0 or not ( SPO2_AVERAGE()^0 < SPO2_LOWER_LIMIT^0 + 
SPO2_LOWER_LIMIT_ADJ^0 ) or not SUPPL_OXY_ALARM_ENABLED^0 or ( not ( SPO2_AVERAGE()^0 < 
SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0 ) or not SUPPL_OXY_ALARM_ENABLED^0 ) ) >>
Why created:  Distributing Postcondition Or-Over-And [serial 2336]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 808:
Theorem (808) [serial 2339] used for:
  Law of Excluded Middle: P or not P is tautology [serial 2338] 


Theorem (810)                               [serial 2336] 
P [32] << true >>
S [32] ->
Q [32] << ( SPO2_AVERAGE()^0 < SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0
  and SUPPL_OXY_ALARM_ENABLED^0 ) or ( not ( SPO2_AVERAGE()^0 < SPO2_LOWER_LIMIT^0 + 
SPO2_LOWER_LIMIT_ADJ^0 ) or not SUPPL_OXY_ALARM_ENABLED^0 ) >>
Why created:    normalization of [serial 2334]
Solved by:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 809:
Theorem (809) [serial 2338] used for:
  Distributing Postcondition Or-Over-And [serial 2336] 


Theorem (811)                               [serial 2334] 
P [32] << true >>
S [32] ->
Q [32] << ( SPO2_AVERAGE()^0 < SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0
  and SUPPL_OXY_ALARM_ENABLED^0 ) or ( ( not ( SPO2_AVERAGE()^0 < SPO2_LOWER_LIMIT^0 + 
SPO2_LOWER_LIMIT_ADJ^0 ) ) or not SUPPL_OXY_ALARM_ENABLED^0 ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2332]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 810:
Theorem (810) [serial 2336] used for:
    normalization of [serial 2334] 


Theorem (812)                               [serial 2332] 
P [32] << true >>
S [32] ->
Q [32] << ( SPO2_AVERAGE()^0 < SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0
  and SUPPL_OXY_ALARM_ENABLED^0 ) or ( SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0 <= SPO2_AVERAGE()^0 or 
not SUPPL_OXY_ALARM_ENABLED^0 ) >>
Why created:    normalization of [serial 1037]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 811:
Theorem (811) [serial 2334] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2332] 


Theorem (813)                               [serial 1037] 
P [32] << true >>
S [32] ->
Q [32] << ( SUPPL_OXY_ALARM_ENABLED^0
  and SPO2_AVERAGE()^0 < SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0 ) or 
( not SUPPL_OXY_ALARM_ENABLED^0 or SPO2_AVERAGE()^0 >= SPO2_LOWER_LIMIT^0 + 
SPO2_LOWER_LIMIT_ADJ^0 ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state check, <<M(check)>> -> <<e1 or e2 or . . . en>>
Solved by:  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 812:
Theorem (812) [serial 2332] used for:
    normalization of [serial 1037] 


Theorem (814)                               [serial 2345] 
P [30] << true >>
S [35] ->
Q [31] << true >>
Why created:    normalization of [serial 1038]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (815)                               [serial 1038] 
P [30] << true >>
S [35] ->
Q [31] << ( true )^1 >>
Why created:   <<M(start)>> -> <<M(run)>> for so0: start-[ ]->run{};
Solved by:  Constants are always the same
and theorem 814:
Theorem (814) [serial 2345] used for:
    normalization of [serial 1038] 


Theorem (816)                               [serial 1039] 
P [31] << true >>
S [36] ->
Q [32] << true >>
Why created:   <<M(run) and x>> -> <<M(check)>> for so1: run-[x]->check{};
Solved by:  True Conclusion Schema (tc): P->true


Theorem (817)                               [serial 2356] 
P [37] << SPO2_AVERAGE()^0 < SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0
  and SUPPL_OXY_ALARM_ENABLED^0 >>
S [37] ->
Q [38] << SPO2_AVERAGE()^0 < SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0
  and SUPPL_OXY_ALARM_ENABLED^0 >>
Why created:    normalization of [serial 2354]
Solved by:  Identity (id):  P->P is tautology


Theorem (818)                               [serial 2354] 
P [37] << SPO2_AVERAGE()^0 < SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0
  and SUPPL_OXY_ALARM_ENABLED^0 >>
S [37] ->
Q [38] << ( SUPPL_OXY_ALARM_ENABLED^0
  and ( SPO2_AVERAGE() )^0 < ( SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0 ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2350]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 817:
Theorem (817) [serial 2356] used for:
    normalization of [serial 2354] 


Theorem (819)                               [serial 2350] 
P [37] << SPO2_AVERAGE()^0 < SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0
  and SUPPL_OXY_ALARM_ENABLED^0 >>
S [37] ->
Q [38] << SUPPL_O2_ALARM() >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 2348]
Solved by:  Substitution of Assertion Labels
and theorem 818:
Theorem (818) [serial 2354] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2350] 


Theorem (820)                               [serial 2352] 
P [38] << SUPPL_O2_ALARM() >>
S [38] ->
Q [17] << SUPPL_O2_ALARM() >>
Why created:  applied port output <<pre>> -> <<M[SpO2DerivedLowerLimitAlarm]>> [serial 2351]
Solved by:  Identity (id):  P->P is tautology


Theorem (821)                               [serial 2353] 
P [38] << ( SUPPL_O2_ALARM() )
  and SpO2DerivedLowerLimitAlarm^0 >>
S [38] ->
Q [31] << true >>
Why created:  applied port output <<pre and M[SpO2DerivedLowerLimitAlarm]^0>> -> <<post>> [serial 2351]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (822)                               [serial 2351] 
P [38] << SUPPL_O2_ALARM() >>
S [38] SpO2DerivedLowerLimitAlarm!
Q [31] << true >>
Why created:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 2348]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
and theorems 820 821:
Theorem (820) [serial 2352] used for:
  applied port output <<pre>> -> <<M[SpO2DerivedLowerLimitAlarm]>> [serial 2351] 
Theorem (821) [serial 2353] used for:
  applied port output <<pre and M[SpO2DerivedLowerLimitAlarm]^0>> -> <<post>> [serial 2351] 


Theorem (823)                               [serial 2348] 
P [37] << SPO2_AVERAGE()^0 < SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0
  and SUPPL_OXY_ALARM_ENABLED^0 >>
S [38] << SUPPL_O2_ALARM() >>
SpO2DerivedLowerLimitAlarm!
Q [31] << true >>
Why created:    normalization of [serial 1040]
Solved by:  Introduction of Existential Quantification
and theorems 819 822:
Theorem (819) [serial 2350] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 2348] 
Theorem (822) [serial 2351] used for:
  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 2348] 


Theorem (824)                               [serial 1040] 
P [37] << SUPPL_OXY_ALARM_ENABLED^0
  and SPO2_AVERAGE()^0 < SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0 >>
S [38] << SUPPL_O2_ALARM() >>
SpO2DerivedLowerLimitAlarm!
Q [31] << ( true )^1 >>
Why created:   <<M(check) and x>> A <<M(run)>> for so2: check-[x]->run{A};
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
  Constants are always the same
and theorem 823:
Theorem (823) [serial 2348] used for:
    normalization of [serial 1040] 


Theorem (825)                               [serial 2359] 
P [39] << SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0 <= SPO2_AVERAGE()^0 or not SUPPL_OXY_ALARM_ENABLED^0 >>
S [39] ->
Q [31] << true >>
Why created:    normalization of [serial 1041]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (826)                               [serial 1041] 
P [39] << not SUPPL_OXY_ALARM_ENABLED^0 or SPO2_AVERAGE()^0 >= SPO2_LOWER_LIMIT^0 + 
SPO2_LOWER_LIMIT_ADJ^0 >>
S [39] ->
Q [31] << ( true )^1 >>
Why created:   <<M(check) and x>> -> <<M(run)>> for so3: check-[x]->run{};
Solved by:  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Constants are always the same
and theorem 825:
Theorem (825) [serial 2359] used for:
    normalization of [serial 1041] 


Theorem (827)                               [serial 1034] 
P [28] <<   >>
S [28] ->
Q [28] << SupplemetalOxygenThread.imp proof obligations >>
Why created:  Initial proof obligations for SupplemetalOxygenThread.imp
Solved by:  Component verification conditions
and theorems 804 805 813 815 816 824 826:
Theorem (804) [serial 1035] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (805) [serial 1036] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (813) [serial 1037] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state check, <<M(check)>> -> <<e1 or e2 or . . . en>> 
Theorem (815) [serial 1038] used for:
   <<M(start)>> -> <<M(run)>> for so0: start-[ ]->run{}; 
Theorem (816) [serial 1039] used for:
   <<M(run) and x>> -> <<M(check)>> for so1: run-[x]->check{}; 
Theorem (824) [serial 1040] used for:
   <<M(check) and x>> A <<M(run)>> for so2: check-[x]->run{A}; 
Theorem (826) [serial 1041] used for:
   <<M(check) and x>> -> <<M(run)>> for so3: check-[x]->run{}; 


Theorem (828)                               [serial 2363] 
P [77] << ( GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() )
  and ub - lb < window_size >>
S [51] ->
Q [51] << GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() >>
Why created:    normalization of [serial 2361]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (829)                               [serial 2361] 
P [77] << ( ( ub - lb ) < window_size )
  and ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() ) >>
S [51] ->
Q [51] << WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1043]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 828:
Theorem (828) [serial 2363] used for:
    normalization of [serial 2361] 


Theorem (830)                               [serial 1043] 
P [77] << ( ( ub - lb ) < window_size )
  and INV_AV() >>
S [51] ->
Q [51] << WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() >>
Why created:  <<M(fillingWindow)>> -> <<I>> from invariant I when complete state fillingWindow has Assertion <<M(fillingWindow)>> in its definition.
Solved by:  Substitution of Assertion Labels
and theorem 829:
Theorem (829) [serial 2361] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1043] 


Theorem (831)                               [serial 2367] 
P [88] << ( GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() )
  and ub - lb = window_size >>
S [51] ->
Q [51] << GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() >>
Why created:    normalization of [serial 2365]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (832)                               [serial 2365] 
P [88] << ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() )
  and ( ( ub - lb ) = window_size ) >>
S [51] ->
Q [51] << WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1044]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 831:
Theorem (831) [serial 2367] used for:
    normalization of [serial 2365] 


Theorem (833)                               [serial 1044] 
P [88] << INV_AV()
  and ( ( ub - lb ) = window_size ) >>
S [51] ->
Q [51] << WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by:  Substitution of Assertion Labels
and theorem 832:
Theorem (832) [serial 2365] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1044] 


Theorem (834)                               [serial 2372] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(( 1 + k ) - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(( 1 + k ) - ub)  ) = totalSpO2 >>
S [79] ->
Q [79] << true >>
Why created:  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 2370]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (835)                               [serial 2370] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(( 1 + k ) - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(( 1 + k ) - ub)  ) = totalSpO2 >>
S [79] ->
Q [79] << ub - lb < window_size or window_size < ub - lb or ub - lb = window_size >>
Why created:    normalization of [serial 1045]
Solved by:  Less than, greater than, or equal:  |-a<b or b<a or a=b
and theorem 834:
Theorem (834) [serial 2372] used for:
  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 2370] 


Theorem (836)                               [serial 1045] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ( ub - 1 ))  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ( ub - 1 ))  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) >>
S [79] ->
Q [79] << ( ( ub - lb ) < window_size ) or ( ( ub - lb ) = window_size ) or ( ( ub - lb ) > window_size ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state chooseToRun, <<M(chooseToRun)>> -> <<e1 or e2 or . . . en>>
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of Greater Than: (a>b) = (b<a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 835:
Theorem (835) [serial 2370] used for:
    normalization of [serial 1045] 


Theorem (837)                               [serial 2377] 
P [74] << 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [74] ->
Q [74] << true >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 2376]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (838)                               [serial 2376] 
P [74] << 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [74] ->
Q [74] << ub - lb < window_size or ( not ( ub - lb < window_size ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2374]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 837:
Theorem (837) [serial 2377] used for:
  Law of Excluded Middle: P or not P is tautology [serial 2376] 


Theorem (839)                               [serial 2374] 
P [74] << 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [74] ->
Q [74] << ub - lb < window_size or window_size <= ub - lb >>
Why created:    normalization of [serial 1046]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 838:
Theorem (838) [serial 2376] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2374] 


Theorem (840)                               [serial 1046] 
P [74] << ( numSamplesInWindow = 0 )
  and ( ub = 0 )
  and ( oldestSample = 0 )
  and ( totalSpO2 = 0 percent )
  and ( lb = 0 )
  and ( goodCount = 0 ) >>
S [74] ->
Q [74] << ( ( ub - lb ) < window_size ) or ( ( ub - lb ) >= window_size ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 839:
Theorem (839) [serial 2374] used for:
    normalization of [serial 1046] 


Theorem (841)                               [serial 2496] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [57] << true >>
Why created:  Empty Range Law All: all a:t which false are V is tautology  [serial 2488]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (842)                               [serial 2488] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [57] << all k ~ quantity whole 
  which false 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - 0 )
        and not MOTION_ARTIFACT^( ( 1 + k ) - 0 ) then SPO2^( ( 1 + k ) - 0 ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  >>
Why created:  Empty Range [serial 2469]
Solved by:  Empty Range Law All: all a:t which false are V is tautology
and theorem 841:
Theorem (841) [serial 2496] used for:
  Empty Range Law All: all a:t which false are V is tautology  [serial 2488] 


Theorem (843)                               [serial 2469] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [57] << all k ~ quantity whole 
  in 0 .. -1 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - 0 )
        and not MOTION_ARTIFACT^( ( 1 + k ) - 0 ) then SPO2^( ( 1 + k ) - 0 ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  >>
Why created:    normalization of [serial 2456]
Solved by:  Empty Range
and theorem 842:
Theorem (842) [serial 2488] used for:
  Empty Range [serial 2469] 


Theorem (844)                               [serial 2456] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [57] << all k ~ quantity whole 
  in 0 .. ( 0 - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - 0 )
        and not MOTION_ARTIFACT^( ( 1 + k ) - 0 ) then SPO2^( ( 1 + k ) - 0 ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  >>
Why created:  Guided Substitution of Equals 
 replacing "ub" with its = "0" in its postcondition [serial 2448]
Solved by:  Literal Arithmetic
  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Unary Minus:  -(x-y) is (y-x)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 843:
Theorem (843) [serial 2469] used for:
    normalization of [serial 2456] 


Theorem (845)                               [serial 2448] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [57] << all k ~ quantity whole 
  in 0 .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  >>
Why created:  Guided Substitution of Equals 
 replacing "lb" with its = "0" in its postcondition [serial 2429]
Solved by:  Guided Substitution of Equals
and theorem 844:
Theorem (844) [serial 2456] used for:
  Guided Substitution of Equals 
 replacing "ub" with its = "0" in its postcondition [serial 2448] 


Theorem (846)                               [serial 2429] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [57] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  >>
Why created:    normalization of [serial 2418]
Solved by:  Guided Substitution of Equals
and theorem 845:
Theorem (845) [serial 2448] used for:
  Guided Substitution of Equals 
 replacing "lb" with its = "0" in its postcondition [serial 2429] 


Theorem (847)                               [serial 2418] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [57] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2417]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 846:
Theorem (846) [serial 2429] used for:
    normalization of [serial 2418] 


Theorem (848)                               [serial 2497] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [60] << true >>
Why created:  Empty Range Law All: all a:t which false are V is tautology  [serial 2489]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (849)                               [serial 2489] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [60] << all k ~ quantity whole 
  which false 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - 0 )
        and not MOTION_ARTIFACT^( ( 1 + k ) - 0 ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  >>
Why created:  Empty Range [serial 2471]
Solved by:  Empty Range Law All: all a:t which false are V is tautology
and theorem 848:
Theorem (848) [serial 2497] used for:
  Empty Range Law All: all a:t which false are V is tautology  [serial 2489] 


Theorem (850)                               [serial 2471] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [60] << all k ~ quantity whole 
  in 0 .. -1 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - 0 )
        and not MOTION_ARTIFACT^( ( 1 + k ) - 0 ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  >>
Why created:    normalization of [serial 2457]
Solved by:  Empty Range
and theorem 849:
Theorem (849) [serial 2489] used for:
  Empty Range [serial 2471] 


Theorem (851)                               [serial 2457] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [60] << all k ~ quantity whole 
  in 0 .. ( 0 - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - 0 )
        and not MOTION_ARTIFACT^( ( 1 + k ) - 0 ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  >>
Why created:  Guided Substitution of Equals 
 replacing "ub" with its = "0" in its postcondition [serial 2449]
Solved by:  Literal Arithmetic
  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Unary Minus:  -(x-y) is (y-x)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 850:
Theorem (850) [serial 2471] used for:
    normalization of [serial 2457] 


Theorem (852)                               [serial 2449] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [60] << all k ~ quantity whole 
  in 0 .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  >>
Why created:  Guided Substitution of Equals 
 replacing "lb" with its = "0" in its postcondition [serial 2431]
Solved by:  Guided Substitution of Equals
and theorem 851:
Theorem (851) [serial 2457] used for:
  Guided Substitution of Equals 
 replacing "ub" with its = "0" in its postcondition [serial 2449] 


Theorem (853)                               [serial 2431] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [60] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  >>
Why created:    normalization of [serial 2419]
Solved by:  Guided Substitution of Equals
and theorem 852:
Theorem (852) [serial 2449] used for:
  Guided Substitution of Equals 
 replacing "lb" with its = "0" in its postcondition [serial 2431] 


Theorem (854)                               [serial 2419] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [60] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2417]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 853:
Theorem (853) [serial 2431] used for:
    normalization of [serial 2419] 


Theorem (855)                               [serial 2420] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [77] << ub - lb < window_size >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2417]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (856)                               [serial 2512] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 = totalSpO2 >>
S [93] ->
Q [68] << 0 = goodCount >>
Why created:  Remove units from quantities  [serial 2501]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (857)                               [serial 2501] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [68] << 0 = goodCount >>
Why created:    normalization of [serial 2492]
Solved by:  Remove units from quantities
and theorem 856:
Theorem (856) [serial 2512] used for:
  Remove units from quantities  [serial 2501] 


Theorem (858)                               [serial 2492] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [68] << ( 0 ) = goodCount >>
Why created:  Empty Range Law, numberof: numberof a:t in false that V is 0  [serial 2484]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 857:
Theorem (857) [serial 2501] used for:
    normalization of [serial 2492] 


Theorem (859)                               [serial 2484] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [68] << ( numberof k ~ quantity whole 
  which false 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - 0 )
         and not MOTION_ARTIFACT^( ( 1 + k ) - 0 ) )  ) = goodCount >>
Why created:  Empty Range [serial 2461]
Solved by:  Empty Range Law, numberof: numberof a:t in false that V is 0
and theorem 858:
Theorem (858) [serial 2492] used for:
  Empty Range Law, numberof: numberof a:t in false that V is 0  [serial 2484] 


Theorem (860)                               [serial 2461] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [68] << ( numberof k ~ quantity whole 
  in 0 .. -1 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - 0 )
         and not MOTION_ARTIFACT^( ( 1 + k ) - 0 ) )  ) = goodCount >>
Why created:    normalization of [serial 2452]
Solved by:  Empty Range
and theorem 859:
Theorem (859) [serial 2484] used for:
  Empty Range [serial 2461] 


Theorem (861)                               [serial 2452] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [68] << ( numberof k ~ quantity whole 
  in 0 .. ( 0 - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - 0 )
         and not MOTION_ARTIFACT^( ( 1 + k ) - 0 ) )  ) = goodCount >>
Why created:  Guided Substitution of Equals 
 replacing "ub" with its = "0" in its postcondition [serial 2444]
Solved by:  Literal Arithmetic
  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Unary Minus:  -(x-y) is (y-x)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 860:
Theorem (860) [serial 2461] used for:
    normalization of [serial 2452] 


Theorem (862)                               [serial 2444] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [68] << ( numberof k ~ quantity whole 
  in 0 .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount >>
Why created:  Guided Substitution of Equals 
 replacing "lb" with its = "0" in its postcondition [serial 2421]
Solved by:  Guided Substitution of Equals
and theorem 861:
Theorem (861) [serial 2452] used for:
  Guided Substitution of Equals 
 replacing "ub" with its = "0" in its postcondition [serial 2444] 


Theorem (863)                               [serial 2421] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [68] << ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2417]
Solved by:  Guided Substitution of Equals
and theorem 862:
Theorem (862) [serial 2444] used for:
  Guided Substitution of Equals 
 replacing "lb" with its = "0" in its postcondition [serial 2421] 


Theorem (864)                               [serial 2513] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 = totalSpO2 >>
S [93] ->
Q [66] << 0 = totalSpO2 >>
Why created:  Remove units from quantities  [serial 2503]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (865)                               [serial 2503] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [66] << 0 = totalSpO2 >>
Why created:    normalization of [serial 2493]
Solved by:  Remove units from quantities
and theorem 864:
Theorem (864) [serial 2513] used for:
  Remove units from quantities  [serial 2503] 


Theorem (866)                               [serial 2493] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [66] << ( 0 ) = totalSpO2 >>
Why created:  Empty Range Law Sum: (sum a:t in false of V) = 0  [serial 2485]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 865:
Theorem (865) [serial 2503] used for:
    normalization of [serial 2493] 


Theorem (867)                               [serial 2485] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [66] << ( sum k ~ quantity whole 
  which false 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - 0 )
       and not MOTION_ARTIFACT^( ( 1 + k ) - 0 ) then SPO2^( ( 1 + k ) - 0 ) else 0 percent)  ) = totalSpO2 >>
Why created:  Empty Range [serial 2463]
Solved by:  Empty Range Law Sum: (sum a:t in false of V) = 0
and theorem 866:
Theorem (866) [serial 2493] used for:
  Empty Range Law Sum: (sum a:t in false of V) = 0  [serial 2485] 


Theorem (868)                               [serial 2463] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [66] << ( sum k ~ quantity whole 
  in 0 .. -1 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - 0 )
       and not MOTION_ARTIFACT^( ( 1 + k ) - 0 ) then SPO2^( ( 1 + k ) - 0 ) else 0 percent)  ) = totalSpO2 >>
Why created:    normalization of [serial 2453]
Solved by:  Empty Range
and theorem 867:
Theorem (867) [serial 2485] used for:
  Empty Range [serial 2463] 


Theorem (869)                               [serial 2453] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [66] << ( sum k ~ quantity whole 
  in 0 .. ( 0 - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - 0 )
       and not MOTION_ARTIFACT^( ( 1 + k ) - 0 ) then SPO2^( ( 1 + k ) - 0 ) else 0 percent)  ) = totalSpO2 >>
Why created:  Guided Substitution of Equals 
 replacing "ub" with its = "0" in its postcondition [serial 2445]
Solved by:  Literal Arithmetic
  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Unary Minus:  -(x-y) is (y-x)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 868:
Theorem (868) [serial 2463] used for:
    normalization of [serial 2453] 


Theorem (870)                               [serial 2445] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [66] << ( sum k ~ quantity whole 
  in 0 .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
Why created:  Guided Substitution of Equals 
 replacing "lb" with its = "0" in its postcondition [serial 2422]
Solved by:  Guided Substitution of Equals
and theorem 869:
Theorem (869) [serial 2453] used for:
  Guided Substitution of Equals 
 replacing "ub" with its = "0" in its postcondition [serial 2445] 


Theorem (871)                               [serial 2422] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [66] << ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2417]
Solved by:  Guided Substitution of Equals
and theorem 870:
Theorem (870) [serial 2445] used for:
  Guided Substitution of Equals 
 replacing "lb" with its = "0" in its postcondition [serial 2422] 


Theorem (872)                               [serial 2498] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [57] << true >>
Why created:  Empty Range Law All: all a:t which false are V is tautology  [serial 2490]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (873)                               [serial 2490] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [57] << all k ~ quantity whole 
  which false 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - 0 )
        and not MOTION_ARTIFACT^( ( 1 + k ) - 0 ) then SPO2^( ( 1 + k ) - 0 ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  >>
Why created:  Empty Range [serial 2473]
Solved by:  Empty Range Law All: all a:t which false are V is tautology
and theorem 872:
Theorem (872) [serial 2498] used for:
  Empty Range Law All: all a:t which false are V is tautology  [serial 2490] 


Theorem (874)                               [serial 2473] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [57] << all k ~ quantity whole 
  in 0 .. -1 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - 0 )
        and not MOTION_ARTIFACT^( ( 1 + k ) - 0 ) then SPO2^( ( 1 + k ) - 0 ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  >>
Why created:    normalization of [serial 2458]
Solved by:  Empty Range
and theorem 873:
Theorem (873) [serial 2490] used for:
  Empty Range [serial 2473] 


Theorem (875)                               [serial 2458] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [57] << all k ~ quantity whole 
  in 0 .. ( 0 - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - 0 )
        and not MOTION_ARTIFACT^( ( 1 + k ) - 0 ) then SPO2^( ( 1 + k ) - 0 ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  >>
Why created:  Guided Substitution of Equals 
 replacing "ub" with its = "0" in its postcondition [serial 2450]
Solved by:  Literal Arithmetic
  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Unary Minus:  -(x-y) is (y-x)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 874:
Theorem (874) [serial 2473] used for:
    normalization of [serial 2458] 


Theorem (876)                               [serial 2450] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [57] << all k ~ quantity whole 
  in 0 .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  >>
Why created:  Guided Substitution of Equals 
 replacing "lb" with its = "0" in its postcondition [serial 2435]
Solved by:  Guided Substitution of Equals
and theorem 875:
Theorem (875) [serial 2458] used for:
  Guided Substitution of Equals 
 replacing "ub" with its = "0" in its postcondition [serial 2450] 


Theorem (877)                               [serial 2435] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [57] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  >>
Why created:    normalization of [serial 2423]
Solved by:  Guided Substitution of Equals
and theorem 876:
Theorem (876) [serial 2450] used for:
  Guided Substitution of Equals 
 replacing "lb" with its = "0" in its postcondition [serial 2435] 


Theorem (878)                               [serial 2423] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [57] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2417]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 877:
Theorem (877) [serial 2435] used for:
    normalization of [serial 2423] 


Theorem (879)                               [serial 2499] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [60] << true >>
Why created:  Empty Range Law All: all a:t which false are V is tautology  [serial 2491]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (880)                               [serial 2491] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [60] << all k ~ quantity whole 
  which false 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - 0 )
        and not MOTION_ARTIFACT^( ( 1 + k ) - 0 ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  >>
Why created:  Empty Range [serial 2475]
Solved by:  Empty Range Law All: all a:t which false are V is tautology
and theorem 879:
Theorem (879) [serial 2499] used for:
  Empty Range Law All: all a:t which false are V is tautology  [serial 2491] 


Theorem (881)                               [serial 2475] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [60] << all k ~ quantity whole 
  in 0 .. -1 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - 0 )
        and not MOTION_ARTIFACT^( ( 1 + k ) - 0 ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  >>
Why created:    normalization of [serial 2459]
Solved by:  Empty Range
and theorem 880:
Theorem (880) [serial 2491] used for:
  Empty Range [serial 2475] 


Theorem (882)                               [serial 2459] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [60] << all k ~ quantity whole 
  in 0 .. ( 0 - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - 0 )
        and not MOTION_ARTIFACT^( ( 1 + k ) - 0 ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  >>
Why created:  Guided Substitution of Equals 
 replacing "ub" with its = "0" in its postcondition [serial 2451]
Solved by:  Literal Arithmetic
  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Unary Minus:  -(x-y) is (y-x)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 881:
Theorem (881) [serial 2475] used for:
    normalization of [serial 2459] 


Theorem (883)                               [serial 2451] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [60] << all k ~ quantity whole 
  in 0 .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  >>
Why created:  Guided Substitution of Equals 
 replacing "lb" with its = "0" in its postcondition [serial 2437]
Solved by:  Guided Substitution of Equals
and theorem 882:
Theorem (882) [serial 2459] used for:
  Guided Substitution of Equals 
 replacing "ub" with its = "0" in its postcondition [serial 2451] 


Theorem (884)                               [serial 2437] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [60] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  >>
Why created:    normalization of [serial 2424]
Solved by:  Guided Substitution of Equals
and theorem 883:
Theorem (883) [serial 2451] used for:
  Guided Substitution of Equals 
 replacing "lb" with its = "0" in its postcondition [serial 2437] 


Theorem (885)                               [serial 2424] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [60] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2417]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 884:
Theorem (884) [serial 2437] used for:
    normalization of [serial 2424] 


Theorem (886)                               [serial 2425] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [77] << ub - lb < window_size >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2417]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (887)                               [serial 2514] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 = totalSpO2 >>
S [93] ->
Q [68] << 0 = goodCount >>
Why created:  Remove units from quantities  [serial 2505]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (888)                               [serial 2505] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [68] << 0 = goodCount >>
Why created:    normalization of [serial 2494]
Solved by:  Remove units from quantities
and theorem 887:
Theorem (887) [serial 2514] used for:
  Remove units from quantities  [serial 2505] 


Theorem (889)                               [serial 2494] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [68] << ( 0 ) = goodCount >>
Why created:  Empty Range Law, numberof: numberof a:t in false that V is 0  [serial 2486]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 888:
Theorem (888) [serial 2505] used for:
    normalization of [serial 2494] 


Theorem (890)                               [serial 2486] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [68] << ( numberof k ~ quantity whole 
  which false 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - 0 )
         and not MOTION_ARTIFACT^( ( 1 + k ) - 0 ) )  ) = goodCount >>
Why created:  Empty Range [serial 2465]
Solved by:  Empty Range Law, numberof: numberof a:t in false that V is 0
and theorem 889:
Theorem (889) [serial 2494] used for:
  Empty Range Law, numberof: numberof a:t in false that V is 0  [serial 2486] 


Theorem (891)                               [serial 2465] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [68] << ( numberof k ~ quantity whole 
  in 0 .. -1 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - 0 )
         and not MOTION_ARTIFACT^( ( 1 + k ) - 0 ) )  ) = goodCount >>
Why created:    normalization of [serial 2454]
Solved by:  Empty Range
and theorem 890:
Theorem (890) [serial 2486] used for:
  Empty Range [serial 2465] 


Theorem (892)                               [serial 2454] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [68] << ( numberof k ~ quantity whole 
  in 0 .. ( 0 - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - 0 )
         and not MOTION_ARTIFACT^( ( 1 + k ) - 0 ) )  ) = goodCount >>
Why created:  Guided Substitution of Equals 
 replacing "ub" with its = "0" in its postcondition [serial 2446]
Solved by:  Literal Arithmetic
  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Unary Minus:  -(x-y) is (y-x)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 891:
Theorem (891) [serial 2465] used for:
    normalization of [serial 2454] 


Theorem (893)                               [serial 2446] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [68] << ( numberof k ~ quantity whole 
  in 0 .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount >>
Why created:  Guided Substitution of Equals 
 replacing "lb" with its = "0" in its postcondition [serial 2426]
Solved by:  Guided Substitution of Equals
and theorem 892:
Theorem (892) [serial 2454] used for:
  Guided Substitution of Equals 
 replacing "ub" with its = "0" in its postcondition [serial 2446] 


Theorem (894)                               [serial 2426] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [68] << ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2417]
Solved by:  Guided Substitution of Equals
and theorem 893:
Theorem (893) [serial 2446] used for:
  Guided Substitution of Equals 
 replacing "lb" with its = "0" in its postcondition [serial 2426] 


Theorem (895)                               [serial 2515] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 = totalSpO2 >>
S [93] ->
Q [66] << 0 = totalSpO2 >>
Why created:  Remove units from quantities  [serial 2507]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (896)                               [serial 2507] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [66] << 0 = totalSpO2 >>
Why created:    normalization of [serial 2495]
Solved by:  Remove units from quantities
and theorem 895:
Theorem (895) [serial 2515] used for:
  Remove units from quantities  [serial 2507] 


Theorem (897)                               [serial 2495] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [66] << ( 0 ) = totalSpO2 >>
Why created:  Empty Range Law Sum: (sum a:t in false of V) = 0  [serial 2487]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 896:
Theorem (896) [serial 2507] used for:
    normalization of [serial 2495] 


Theorem (898)                               [serial 2487] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [66] << ( sum k ~ quantity whole 
  which false 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - 0 )
       and not MOTION_ARTIFACT^( ( 1 + k ) - 0 ) then SPO2^( ( 1 + k ) - 0 ) else 0 percent)  ) = totalSpO2 >>
Why created:  Empty Range [serial 2467]
Solved by:  Empty Range Law Sum: (sum a:t in false of V) = 0
and theorem 897:
Theorem (897) [serial 2495] used for:
  Empty Range Law Sum: (sum a:t in false of V) = 0  [serial 2487] 


Theorem (899)                               [serial 2467] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [66] << ( sum k ~ quantity whole 
  in 0 .. -1 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - 0 )
       and not MOTION_ARTIFACT^( ( 1 + k ) - 0 ) then SPO2^( ( 1 + k ) - 0 ) else 0 percent)  ) = totalSpO2 >>
Why created:    normalization of [serial 2455]
Solved by:  Empty Range
and theorem 898:
Theorem (898) [serial 2487] used for:
  Empty Range [serial 2467] 


Theorem (900)                               [serial 2455] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [66] << ( sum k ~ quantity whole 
  in 0 .. ( 0 - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - 0 )
       and not MOTION_ARTIFACT^( ( 1 + k ) - 0 ) then SPO2^( ( 1 + k ) - 0 ) else 0 percent)  ) = totalSpO2 >>
Why created:  Guided Substitution of Equals 
 replacing "ub" with its = "0" in its postcondition [serial 2447]
Solved by:  Literal Arithmetic
  By Zero: (0*x)=0 or (0/x)=0 or (0+x)=x or (x-0)=x or (0-x)=-x
  Unary Minus:  -(x-y) is (y-x)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 899:
Theorem (899) [serial 2467] used for:
    normalization of [serial 2455] 


Theorem (901)                               [serial 2447] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [66] << ( sum k ~ quantity whole 
  in 0 .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
Why created:  Guided Substitution of Equals 
 replacing "lb" with its = "0" in its postcondition [serial 2427]
Solved by:  Guided Substitution of Equals
and theorem 900:
Theorem (900) [serial 2455] used for:
  Guided Substitution of Equals 
 replacing "ub" with its = "0" in its postcondition [serial 2447] 


Theorem (902)                               [serial 2427] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [66] << ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2417]
Solved by:  Guided Substitution of Equals
and theorem 901:
Theorem (901) [serial 2447] used for:
  Guided Substitution of Equals 
 replacing "lb" with its = "0" in its postcondition [serial 2427] 


Theorem (903)                               [serial 2417] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] ->
Q [77] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
Why created:  applied wp for simultaneous assignment [serial 2414]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 847 854 855 863 871 878 885 886 894 902:
Theorem (847) [serial 2418] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2417] 
Theorem (854) [serial 2419] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2417] 
Theorem (855) [serial 2420] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2417] 
Theorem (863) [serial 2421] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2417] 
Theorem (871) [serial 2422] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2417] 
Theorem (878) [serial 2423] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2417] 
Theorem (885) [serial 2424] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2417] 
Theorem (886) [serial 2425] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2417] 
Theorem (894) [serial 2426] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2417] 
Theorem (902) [serial 2427] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2417] 


Theorem (904)                               [serial 2414] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ub^1 - lb^1 < window_size^1
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1 >>
Why created:    normalization of [serial 2412]
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Simultaneous Assignment
and theorem 903:
Theorem (903) [serial 2417] used for:
  applied wp for simultaneous assignment [serial 2414] 


Theorem (905)                               [serial 2412] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if not ( MOTION_ARTIFACT^( k - ub ) )^1
        and SENSOR_CONNECTED^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ub^1 - lb^1 < window_size^1
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if not ( MOTION_ARTIFACT^( k - ub ) )^1
       and SENSOR_CONNECTED^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2410]
Solved by:  Caret Compostition:  (x^a)^b is x^(a+b)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 904:
Theorem (904) [serial 2414] used for:
    normalization of [serial 2412] 


Theorem (906)                               [serial 2410] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if ( not MOTION_ARTIFACT^( k - ub ) )^1
        and SENSOR_CONNECTED^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ub^1 - lb^1 < window_size^1
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if ( not MOTION_ARTIFACT^( k - ub ) )^1
       and SENSOR_CONNECTED^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1 >>
Why created:    normalization of [serial 2408]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 905:
Theorem (905) [serial 2412] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2410] 


Theorem (907)                               [serial 2408] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if ( SENSOR_CONNECTED^( ( k - ub ) + 1 )
        and ( not MOTION_ARTIFACT^( k - ub ) )^1 ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( not ( MOTION_ARTIFACT^( k - ub ) )^1
        and SENSOR_CONNECTED^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ub^1 - lb^1 < window_size^1
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( not ( MOTION_ARTIFACT^( k - ub ) )^1
         and SENSOR_CONNECTED^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if ( SENSOR_CONNECTED^( ( k - ub ) + 1 )
       and ( not MOTION_ARTIFACT^( k - ub ) )^1 ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2406]
Solved by:  Caret Compostition:  (x^a)^b is x^(a+b)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 906:
Theorem (906) [serial 2410] used for:
    normalization of [serial 2408] 


Theorem (908)                               [serial 2406] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )^1 then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( ( not MOTION_ARTIFACT^( k - ub ) )^1
        and SENSOR_CONNECTED^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ub^1 - lb^1 < window_size^1
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( ( not MOTION_ARTIFACT^( k - ub ) )^1
         and SENSOR_CONNECTED^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if ( SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) )^1 then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1 >>
Why created:    normalization of [serial 2404]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 907:
Theorem (907) [serial 2408] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2406] 


Theorem (909)                               [serial 2404] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )^1 then SPO2^( ( k - ub ) + 
      1 ) else ( 0 percent )^1) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( k - ub ) + 1 )
        and ( not MOTION_ARTIFACT^( k - ub ) )^1 ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ub^1 - lb^1 < window_size^1
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( k - ub ) + 1 )
         and ( not MOTION_ARTIFACT^( k - ub ) )^1 )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if ( SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) )^1 then SPO2^( ( k - ub ) + 1 ) else ( 0 percent )^1)  ) = totalSpO2^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2402]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Constants are always the same
  Associativity: a.(b.c) = a.b.c
and theorem 908:
Theorem (908) [serial 2406] used for:
    normalization of [serial 2404] 


Theorem (910)                               [serial 2402] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)^1 = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )^1 iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ub^1 - lb^1 < window_size^1
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )^1  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)^1  ) = totalSpO2^1 >>
Why created:    normalization of [serial 2400]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 909:
Theorem (909) [serial 2404] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2402] 


Theorem (911)                               [serial 2400] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)^1 = ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] )^1 )  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )^1 iff ( goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] )^1 )  )
  and ( ( ub )^1 - ( lb )^1 ) < window_size^1
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) ) )^1  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) )^1  ) = totalSpO2^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2398]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 910:
Theorem (910) [serial 2402] used for:
    normalization of [serial 2400] 


Theorem (912)                               [serial 2398] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] )^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] )^1  )
  and ( ub - lb )^1 < window_size^1
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )^1 = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  )^1 = totalSpO2^1 >>
Why created:    normalization of [serial 2396]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 911:
Theorem (911) [serial 2400] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2398] 


Theorem (913)                               [serial 2396] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( ( ub - lb )^1 < ( window_size )^1 )
  and ( ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )^1 = ( goodCount )^1 )
  and ( ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  )^1 = ( totalSpO2 )^1 )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] )^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] )^1  ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2394]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 912:
Theorem (912) [serial 2398] used for:
    normalization of [serial 2396] 


Theorem (914)                               [serial 2394] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( ub - lb < window_size )^1
  and ( ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount )^1
  and ( ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 )^1
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )^1
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )^1 >>
Why created:    normalization of [serial 2392]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 913:
Theorem (913) [serial 2396] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2394] 


Theorem (915)                               [serial 2392] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )^1
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )^1
  and ( ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount )^1
  and ( ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 )^1
  and ( ub - lb < window_size )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2391]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 914:
Theorem (914) [serial 2394] used for:
    normalization of [serial 2392] 


Theorem (916)                               [serial 2391] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb < window_size )^1 >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2388]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 915:
Theorem (915) [serial 2392] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2391] 


Theorem (917)                               [serial 2388] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 )
  and ub - lb < window_size )^1 >>
Why created:    normalization of [serial 2386]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 916:
Theorem (916) [serial 2391] used for:
  Associativity: a.(b.c) = a.b.c [serial 2388] 


Theorem (918)                               [serial 2386] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) ) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) = totalSpO2 )
  and ub - lb < window_size )^1 >>
Why created:  Substituted assertions' predicates for labels  [serial 2384]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 917:
Theorem (917) [serial 2388] used for:
    normalization of [serial 2386] 


Theorem (919)                               [serial 2384] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) = totalSpO2 )
  and ub - lb < window_size )^1 >>
Why created:    normalization of [serial 2382]
Solved by:  Substitution of Assertion Labels
and theorem 918:
Theorem (918) [serial 2386] used for:
  Substituted assertions' predicates for labels  [serial 2384] 


Theorem (920)                               [serial 2382] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( ( ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) )  ) )
  and ub - lb < window_size )^1 >>
Why created:  Substituted assertions' predicates for labels  [serial 2380]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 919:
Theorem (919) [serial 2384] used for:
    normalization of [serial 2382] 


Theorem (921)                               [serial 2380] 
P [74] << ub - lb < window_size
  and 0 = goodCount
  and 0 = lb
  and 0 = numSamplesInWindow
  and 0 = oldestSample
  and 0 = ub
  and 0 percent = totalSpO2 >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( ( GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() )
  and ub - lb < window_size )^1 >>
Why created:    normalization of [serial 2378]
Solved by:  Substitution of Assertion Labels
and theorem 920:
Theorem (920) [serial 2382] used for:
  Substituted assertions' predicates for labels  [serial 2380] 


Theorem (922)                               [serial 2378] 
P [74] << ( numSamplesInWindow = 0 )
  and ( ub = 0 )
  and ( oldestSample = 0 )
  and ( totalSpO2 = 0 percent )
  and ( lb = 0 )
  and ( goodCount = 0 )
  and ( ( ub - lb ) < window_size ) >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( ( ( ub - lb ) < window_size )
  and ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() ) )^1 >>
Why created:  Substituted assertions' predicates for labels  [serial 1047]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 921:
Theorem (921) [serial 2380] used for:
    normalization of [serial 2378] 


Theorem (923)                               [serial 1047] 
P [74] << ( numSamplesInWindow = 0 )
  and ( ub = 0 )
  and ( oldestSample = 0 )
  and ( totalSpO2 = 0 percent )
  and ( lb = 0 )
  and ( goodCount = 0 )
  and ( ( ub - lb ) < window_size ) >>
S [93] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [77] << ( ( ( ub - lb ) < window_size )
  and INV_AV() )^1 >>
Why created:   <<M(start) and x>> A <<M(fillingWindow)>> for SpAT0: start-[x]->fillingWindow{A};
Solved by:  Substitution of Assertion Labels
and theorem 922:
Theorem (922) [serial 2378] used for:
  Substituted assertions' predicates for labels  [serial 1047] 


Theorem (924)                               [serial 2516] 
P [74] << ( numSamplesInWindow = 0 )
  and ( ub = 0 )
  and ( oldestSample = 0 )
  and ( totalSpO2 = 0 percent )
  and ( lb = 0 )
  and ( goodCount = 0 )
  and ( ( ub - lb ) >= window_size ) >>
S [95] ->
Q [90] << true >>
Why created:  applied wp for simultaneous assignment [serial 1048]
Solved by:  True Conclusion Schema (tc): P->true
  True Conclusion Schema (tc): P->true


Theorem (925)                               [serial 1048] 
P [74] << ( numSamplesInWindow = 0 )
  and ( ub = 0 )
  and ( oldestSample = 0 )
  and ( totalSpO2 = 0 percent )
  and ( lb = 0 )
  and ( goodCount = 0 )
  and ( ( ub - lb ) >= window_size ) >>
S [95] |ub',lb',window_size',totalSpO2',goodCount' := ub,lb,window_size,totalSpO2,goodCount|  
Q [90] << true >>
Why created:   <<M(start) and x>> A <<M(fail)>> for SpAT0a: start-[x]->fail{A};
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Simultaneous Assignment
and theorem 924:
Theorem (924) [serial 2516] used for:
  applied wp for simultaneous assignment [serial 1048] 


Theorem (926)                               [serial 2574] 
P [77] << ( GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() )
  and ub - lb < window_size >>
S [77] ->
Q [77] << ub - lb < window_size >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2572]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (927)                               [serial 2580] 
P [77] << GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW()
  and ub - lb < window_size >>
S [77] ->
Q [77] << GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2578]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (928)                               [serial 2578] 
P [77] << ( GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() )
  and ub - lb < window_size >>
S [77] ->
Q [77] << GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() >>
Why created:    normalization of [serial 2576]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 927:
Theorem (927) [serial 2580] used for:
  Associativity: a.(b.c) = a.b.c [serial 2578] 


Theorem (929)                               [serial 2576] 
P [77] << ( GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() )
  and ub - lb < window_size >>
S [77] ->
Q [77] << ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2575]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 928:
Theorem (928) [serial 2578] used for:
    normalization of [serial 2576] 


Theorem (930)                               [serial 2575] 
P [77] << ( GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() )
  and ub - lb < window_size >>
S [77] ->
Q [77] << INV_AV() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2572]
Solved by:  Substitution of Assertion Labels
and theorem 929:
Theorem (929) [serial 2576] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2575] 


Theorem (931)                               [serial 2572] 
P [77] << ( GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() )
  and ub - lb < window_size >>
S [77] ->
Q [97] << ub - lb < window_size
  and INV_AV() >>
Why created:    normalization of [serial 2570]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 926 930:
Theorem (926) [serial 2574] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2572] 
Theorem (930) [serial 2575] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2572] 


Theorem (932)                               [serial 2570] 
P [77] << ub - lb < window_size
  and ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() ) >>
S [77] ->
Q [97] << ( ( ( ub - lb ) < window_size )
  and INV_AV() ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2534]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 931:
Theorem (931) [serial 2572] used for:
    normalization of [serial 2570] 


Theorem (933)                               [serial 2534] 
P [77] << ub - lb < window_size
  and INV_AV() >>
S [77] ->
Q [97] << FW() >>
Why created:    normalization of [serial 2517]
Solved by:  Substitution of Assertion Labels
and theorem 932:
Theorem (932) [serial 2570] used for:
  Substituted assertions' predicates for labels  [serial 2534] 


Theorem (934)                               [serial 2517] 
P [77] << ( ( ub - lb ) < window_size )
  and INV_AV() >>
S [77] ->
Q [97] << FW() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1049]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 933:
Theorem (933) [serial 2534] used for:
    normalization of [serial 2517] 


Theorem (935)                               [serial 2536] 
P [129] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(( 1 + k ) - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(( 1 + k ) - ub)  ) = totalSpO2 >>
S [79] ->
Q [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(( 1 + k ) - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(( 1 + k ) - ub)  ) = totalSpO2 >>
Why created:    normalization of [serial 2518]
Solved by:  Identity (id):  P->P is tautology


Theorem (936)                               [serial 2518] 
P [129] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ( ub - 1 ))  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ( ub - 1 ))  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) >>
S [79] ->
Q [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ( ub - 1 ))  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ( ub - 1 ))  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) >>
Why created:  <<Q2>> -> <<Q>> in sequential composition for [serial 1049]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 935:
Theorem (935) [serial 2536] used for:
    normalization of [serial 2518] 


Theorem (937)                               [serial 2522] 
P [97] << FW() >>
S [99] ->
Q [99] << FW() >>
Why created:  P -> P1 in concurrent composition for [serial 2521]
Solved by:  Identity (id):  P->P is tautology


Theorem (938)                               [serial 2595] 
P [99] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED
  and not MOTION_ARTIFACT ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 >>
S [103] ->
Q [118] << all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2593]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (939)                               [serial 2593] 
P [99] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED
  and not MOTION_ARTIFACT ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 >>
S [103] ->
Q [118] << all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:    normalization of [serial 2591]
Solved by:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))
and theorem 938:
Theorem (938) [serial 2595] used for:
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2593] 


Theorem (940)                               [serial 2591] 
P [99] << ( ( SENSOR_CONNECTED
  and not MOTION_ARTIFACT ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) + 
( (if SENSOR_CONNECTED^( 0 )
  and not MOTION_ARTIFACT^( 0 ) then SPO2^( 0 ) else 0 percent) ) = totalSpO2
  and ( (if SENSOR_CONNECTED^( 0 )
  and not MOTION_ARTIFACT^( 0 ) then SPO2^( 0 ) else 0 percent) ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) ) )  ) >>
S [103] ->
Q [118] << all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2590]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 939:
Theorem (939) [serial 2593] used for:
    normalization of [serial 2591] 


Theorem (941)                               [serial 2590] 
P [99] << ( ( SENSOR_CONNECTED
  and not MOTION_ARTIFACT ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) + 
( (if SENSOR_CONNECTED^( 0 )
  and not MOTION_ARTIFACT^( 0 ) then SPO2^( 0 ) else 0 percent) ) = totalSpO2
  and ( (if SENSOR_CONNECTED^( 0 )
  and not MOTION_ARTIFACT^( 0 ) then SPO2^( 0 ) else 0 percent) ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) )  ) >>
S [103] ->
Q [118] << all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2589]
Solved by:  Substitution of Assertion Labels
and theorem 940:
Theorem (940) [serial 2591] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2590] 


Theorem (942)                               [serial 2589] 
P [99] << ( ( SENSOR_CONNECTED
  and not MOTION_ARTIFACT ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) + SSQ(x : 0) = totalSpO2
  and SSQ(x : 0) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and GS()
  and WINDOW() >>
S [103] ->
Q [118] << all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2587]
Solved by:  Substitution of Assertion Labels
and theorem 941:
Theorem (941) [serial 2590] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2589] 


Theorem (943)                               [serial 2587] 
P [99] << ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) + SSQ(x : 0) = totalSpO2
  and SSQ(x : 0) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and GS()
  and WINDOW() >>
S [103] ->
Q [118] << all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:    normalization of [serial 2585]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 942:
Theorem (942) [serial 2589] used for:
  Assume Present:  P = P@now = P^0   [serial 2587] 


Theorem (944)                               [serial 2585] 
P [99] << ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) + SSQ(x : 0) = totalSpO2
  and SSQ(x : 0) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and GS()
  and WINDOW() >>
S [103] ->
Q [118] << ( all k ~ quantity whole 
  in lb .. ub 
  are ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) ) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2581]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 943:
Theorem (943) [serial 2587] used for:
    normalization of [serial 2585] 


Theorem (945)                               [serial 2581] 
P [99] << ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) + SSQ(x : 0) = totalSpO2
  and SSQ(x : 0) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and GS()
  and WINDOW() >>
S [103] ->
Q [118] << ( all k ~ quantity whole 
  in lb .. ub 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2539]
Solved by:  Substitution of Assertion Labels
and theorem 944:
Theorem (944) [serial 2585] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2581] 


Theorem (946)                               [serial 2604] 
P [99] << ( all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 >>
S [103] ->
Q [123] << all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2602]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (947)                               [serial 2602] 
P [99] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 >>
S [103] ->
Q [123] << all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:    normalization of [serial 2600]
Solved by:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))
and theorem 946:
Theorem (946) [serial 2604] used for:
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2602] 


Theorem (948)                               [serial 2600] 
P [99] << ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) + 
( (if SENSOR_CONNECTED^( 0 )
  and not MOTION_ARTIFACT^( 0 ) then SPO2^( 0 ) else 0 percent) ) = totalSpO2
  and ( (if SENSOR_CONNECTED^( 0 )
  and not MOTION_ARTIFACT^( 0 ) then SPO2^( 0 ) else 0 percent) ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) ) )  ) >>
S [103] ->
Q [123] << all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2599]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 947:
Theorem (947) [serial 2602] used for:
    normalization of [serial 2600] 


Theorem (949)                               [serial 2599] 
P [99] << ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) + 
( (if SENSOR_CONNECTED^( 0 )
  and not MOTION_ARTIFACT^( 0 ) then SPO2^( 0 ) else 0 percent) ) = totalSpO2
  and ( (if SENSOR_CONNECTED^( 0 )
  and not MOTION_ARTIFACT^( 0 ) then SPO2^( 0 ) else 0 percent) ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) )  ) >>
S [103] ->
Q [123] << all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2597]
Solved by:  Substitution of Assertion Labels
and theorem 948:
Theorem (948) [serial 2600] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2599] 


Theorem (950)                               [serial 2597] 
P [99] << ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) + SSQ(x : 0) = totalSpO2
  and SSQ(x : 0) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and GS()
  and WINDOW() >>
S [103] ->
Q [123] << all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:    normalization of [serial 2582]
Solved by:  Substitution of Assertion Labels
and theorem 949:
Theorem (949) [serial 2599] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2597] 


Theorem (951)                               [serial 2582] 
P [99] << ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) + SSQ(x : 0) = totalSpO2
  and SSQ(x : 0) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and GS()
  and WINDOW() >>
S [103] ->
Q [123] << ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2539]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 950:
Theorem (950) [serial 2597] used for:
    normalization of [serial 2582] 


Theorem (952)                               [serial 2612] 
P [99] << ( all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0)  ) = totalSpO2 >>
S [103] ->
Q [121] << ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 2611]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (953)                               [serial 2611] 
P [99] << ( all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0)  ) = totalSpO2 >>
S [103] ->
Q [121] << ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Remove units from quantities  [serial 2610]
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
and theorem 952:
Theorem (952) [serial 2612] used for:
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 2611] 


Theorem (954)                               [serial 2610] 
P [99] << ( all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 >>
S [103] ->
Q [121] << ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2608]
Solved by:  Remove units from quantities
and theorem 953:
Theorem (953) [serial 2611] used for:
  Remove units from quantities  [serial 2610] 


Theorem (955)                               [serial 2608] 
P [99] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 >>
S [103] ->
Q [121] << ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:    normalization of [serial 2606]
Solved by:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))
and theorem 954:
Theorem (954) [serial 2610] used for:
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2608] 


Theorem (956)                               [serial 2606] 
P [99] << ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) + 
( (if SENSOR_CONNECTED^( 0 )
  and not MOTION_ARTIFACT^( 0 ) then SPO2^( 0 ) else 0 percent) ) = totalSpO2
  and ( (if SENSOR_CONNECTED^( 0 )
  and not MOTION_ARTIFACT^( 0 ) then SPO2^( 0 ) else 0 percent) ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) ) )  ) >>
S [103] ->
Q [121] << ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2605]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 955:
Theorem (955) [serial 2608] used for:
    normalization of [serial 2606] 


Theorem (957)                               [serial 2605] 
P [99] << ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) + 
( (if SENSOR_CONNECTED^( 0 )
  and not MOTION_ARTIFACT^( 0 ) then SPO2^( 0 ) else 0 percent) ) = totalSpO2
  and ( (if SENSOR_CONNECTED^( 0 )
  and not MOTION_ARTIFACT^( 0 ) then SPO2^( 0 ) else 0 percent) ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) )  ) >>
S [103] ->
Q [121] << ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2583]
Solved by:  Substitution of Assertion Labels
and theorem 956:
Theorem (956) [serial 2606] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2605] 


Theorem (958)                               [serial 2583] 
P [99] << ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) + SSQ(x : 0) = totalSpO2
  and SSQ(x : 0) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and GS()
  and WINDOW() >>
S [103] ->
Q [121] << ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2539]
Solved by:  Substitution of Assertion Labels
and theorem 957:
Theorem (957) [serial 2605] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2583] 


Theorem (959)                               [serial 2620] 
P [99] << ( all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 >>
S [103] ->
Q [120] << ( sum k ~ quantity whole 
  in lb .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 >>
Why created:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 2619]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (960)                               [serial 2619] 
P [99] << ( all k ~ quantity whole 
  in lb .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 >>
S [103] ->
Q [120] << ( sum k ~ quantity whole 
  in lb .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 >>
Why created:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2617]
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
and theorem 959:
Theorem (959) [serial 2620] used for:
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 2619] 


Theorem (961)                               [serial 2617] 
P [99] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 >>
S [103] ->
Q [120] << ( sum k ~ quantity whole 
  in lb .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 >>
Why created:    normalization of [serial 2615]
Solved by:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))
and theorem 960:
Theorem (960) [serial 2619] used for:
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2617] 


Theorem (962)                               [serial 2615] 
P [99] << ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) + 
( (if SENSOR_CONNECTED^( 0 )
  and not MOTION_ARTIFACT^( 0 ) then SPO2^( 0 ) else 0 percent) ) = totalSpO2
  and ( (if SENSOR_CONNECTED^( 0 )
  and not MOTION_ARTIFACT^( 0 ) then SPO2^( 0 ) else 0 percent) ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) ) )  ) >>
S [103] ->
Q [120] << ( sum k ~ quantity whole 
  in lb .. ub 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) = totalSpO2 >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2614]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 961:
Theorem (961) [serial 2617] used for:
    normalization of [serial 2615] 


Theorem (963)                               [serial 2614] 
P [99] << ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) + 
( (if SENSOR_CONNECTED^( 0 )
  and not MOTION_ARTIFACT^( 0 ) then SPO2^( 0 ) else 0 percent) ) = totalSpO2
  and ( (if SENSOR_CONNECTED^( 0 )
  and not MOTION_ARTIFACT^( 0 ) then SPO2^( 0 ) else 0 percent) ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) )  ) >>
S [103] ->
Q [120] << ( sum k ~ quantity whole 
  in lb .. ub 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) = totalSpO2 >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2613]
Solved by:  Substitution of Assertion Labels
and theorem 962:
Theorem (962) [serial 2615] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2614] 


Theorem (964)                               [serial 2613] 
P [99] << ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) + SSQ(x : 0) = totalSpO2
  and SSQ(x : 0) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and GS()
  and WINDOW() >>
S [103] ->
Q [120] << ( sum k ~ quantity whole 
  in lb .. ub 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) = totalSpO2 >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2584]
Solved by:  Substitution of Assertion Labels
and theorem 963:
Theorem (963) [serial 2614] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2613] 


Theorem (965)                               [serial 2584] 
P [99] << ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) + SSQ(x : 0) = totalSpO2
  and SSQ(x : 0) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and GS()
  and WINDOW() >>
S [103] ->
Q [120] << ( sum k ~ quantity whole 
  in lb .. ub 
  of SSQ(k - ub)  ) = totalSpO2 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2539]
Solved by:  Substitution of Assertion Labels
and theorem 964:
Theorem (964) [serial 2613] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2584] 


Theorem (966)                               [serial 2539] 
P [99] << ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) + SSQ(x : 0) = totalSpO2
  and SSQ(x : 0) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and GS()
  and WINDOW() >>
S [103] ->
Q [118] << ( all k ~ quantity whole 
  in lb .. ub 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ub 
  of SSQ(k - ub)  ) = totalSpO2 >>
Why created:    normalization of [serial 2523]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 945 951 958 965:
Theorem (945) [serial 2581] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2539] 
Theorem (951) [serial 2582] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2539] 
Theorem (958) [serial 2583] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2539] 
Theorem (965) [serial 2584] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2539] 


Theorem (967)                               [serial 2523] 
P [99] << WINDOW()
  and ( ( spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x : 0) ) )
  and ( totalSpO2 = ( SSQ(x : 0) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) ) )
  and ( goodCount = ( (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) )
  and ( ( goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) ) )
  and GS() >>
S [103] ->
Q [118] << ( all k ~ quantity whole 
  in lb .. ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ub 
  of SSQ(k - ub)  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
Why created:  Q1 and Q2 and  . . . and Qn -> Q in concurrent composition for [serial 2521]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 966:
Theorem (966) [serial 2539] used for:
    normalization of [serial 2523] 


Theorem (968)                               [serial 2631] 
P [99] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) = totalSpO2 >>
S [101] ->
Q [57] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2629]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (969)                               [serial 2637] 
P [99] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) = totalSpO2 >>
S [101] ->
Q [103] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 2636]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (970)                               [serial 2636] 
P [99] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) = totalSpO2 >>
S [101] ->
Q [103] << (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then SPO2 else 0) = (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then SPO2 else 0) >>
Why created:  Replacing port names with BLESS::Value properties  [serial 2635]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 969:
Theorem (969) [serial 2637] used for:
  Equality Law (idistr):  a=a <-> true [serial 2636] 


Theorem (971)                               [serial 2635] 
P [99] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) = totalSpO2 >>
S [101] ->
Q [103] << (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then SPO2 else 0) = (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then SpO2 else 0) >>
Why created:  Remove units from quantities  [serial 2634]
Solved by:  Replacing port names with BLESS::Value properties
and theorem 970:
Theorem (970) [serial 2636] used for:
  Replacing port names with BLESS::Value properties  [serial 2635] 


Theorem (972)                               [serial 2634] 
P [99] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) = totalSpO2 >>
S [101] ->
Q [103] << (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then SPO2 else 0 percent) = (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then SpO2 else 0 percent) >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2633]
Solved by:  Remove units from quantities
and theorem 971:
Theorem (971) [serial 2635] used for:
  Remove units from quantities  [serial 2634] 


Theorem (973)                               [serial 2633] 
P [99] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) = totalSpO2 >>
S [101] ->
Q [103] << (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then SpO2 else 0 percent) = (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) >>
Why created:  Replacing port names with BLESS::Assertion properties  [serial 2632]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 972:
Theorem (972) [serial 2634] used for:
  Assume Present:  P = P@now = P^0   [serial 2633] 


Theorem (974)                               [serial 2632] 
P [99] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) = totalSpO2 >>
S [101] ->
Q [103] << (if SensorConnected
  and not MotionArtifact then SpO2 else 0 percent) = (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2629]
Solved by:  Replacing port names with BLESS::Assertion properties
and theorem 973:
Theorem (973) [serial 2633] used for:
  Replacing port names with BLESS::Assertion properties  [serial 2632] 


Theorem (975)                               [serial 2629] 
P [99] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) = totalSpO2 >>
S [101] ->
Q [103] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and (if SensorConnected
  and not MotionArtifact then SpO2 else 0 percent) = (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) >>
Why created:    normalization of [serial 2627]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 968 974:
Theorem (968) [serial 2631] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2629] 
Theorem (974) [serial 2632] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2629] 


Theorem (976)                               [serial 2627] 
P [99] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) = totalSpO2
  and ub - lb < window_size >>
S [101] ->
Q [103] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and (if SensorConnected
  and not MotionArtifact then SpO2 else 0 percent) = (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2625]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 975:
Theorem (975) [serial 2629] used for:
    normalization of [serial 2627] 


Theorem (977)                               [serial 2625] 
P [99] << ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) = totalSpO2 )
  and ub - lb < window_size >>
S [101] ->
Q [103] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and (if SensorConnected
  and not MotionArtifact then SpO2 else 0 percent) = (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) >>
Why created:    normalization of [serial 2623]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 976:
Theorem (976) [serial 2627] used for:
  Associativity: a.(b.c) = a.b.c [serial 2625] 


Theorem (978)                               [serial 2623] 
P [99] << ( ( ( ub - lb ) < window_size )
  and ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) ) ) >>
S [101] ->
Q [103] << (if SensorConnected
  and not MotionArtifact then SpO2 else 0 percent) = ( (if SENSOR_CONNECTED^( 0 )
  and not MOTION_ARTIFACT^( 0 ) then SPO2^( 0 ) else 0 percent) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) )  ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2622]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 977:
Theorem (977) [serial 2625] used for:
    normalization of [serial 2623] 


Theorem (979)                               [serial 2622] 
P [99] << ( ( ( ub - lb ) < window_size )
  and ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() ) ) >>
S [101] ->
Q [103] << (if SensorConnected
  and not MotionArtifact then SpO2 else 0 percent) = ( (if SENSOR_CONNECTED^( 0 )
  and not MOTION_ARTIFACT^( 0 ) then SPO2^( 0 ) else 0 percent) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) )  ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2621]
Solved by:  Substitution of Assertion Labels
and theorem 978:
Theorem (978) [serial 2623] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2622] 


Theorem (980)                               [serial 2621] 
P [99] << ( ( ( ub - lb ) < window_size )
  and INV_AV() ) >>
S [101] ->
Q [103] << (if SensorConnected
  and not MotionArtifact then SpO2 else 0 percent) = ( (if SENSOR_CONNECTED^( 0 )
  and not MOTION_ARTIFACT^( 0 ) then SPO2^( 0 ) else 0 percent) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) )  ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2541]
Solved by:  Substitution of Assertion Labels
and theorem 979:
Theorem (979) [serial 2622] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2621] 


Theorem (981)                               [serial 2541] 
P [99] << FW() >>
S [101] ->
Q [103] << (if SensorConnected
  and not MotionArtifact then SpO2 else 0 percent) = SSQ(x : 0)
  and WINDOW() >>
Why created:    normalization of [serial 2528]
Solved by:  Substitution of Assertion Labels
and theorem 980:
Theorem (980) [serial 2621] used for:
  Substituted assertions' predicates for labels  [serial 2541] 


Theorem (982)                               [serial 2528] 
P [99] << FW() >>
S [101] ->
Q [103] << WINDOW()
  and ( ( (if SensorConnected
  and not MotionArtifact then SpO2 else 0 percent) ) = SSQ(x : 0) ) >>
Why created:  applied wp for assignment [serial 2524]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 981:
Theorem (981) [serial 2541] used for:
    normalization of [serial 2528] 


Theorem (983)                               [serial 2524] 
P [99] << FW() >>
S [101] spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] := (if SensorConnected
  and not MotionArtifact then SpO2 else 0 percent)
Q [103] << WINDOW()
  and ( spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x : 0) ) >>
Why created:  <<P1>> S1 <<Q1>> in concurrent composition for [serial 2521]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 982:
Theorem (982) [serial 2528] used for:
  applied wp for assignment [serial 2524] 


Theorem (984)                               [serial 2661] 
P [97] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0)  ) = totalSpO2 >>
S [105] ->
Q [106] << ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0)  ) = totalSpO2 >>
Why created:  Remove units from quantities  [serial 2659]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (985)                               [serial 2659] 
P [97] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 >>
S [105] ->
Q [106] << ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0)  ) = totalSpO2 >>
Why created:    normalization of [serial 2657]
Solved by:  Remove units from quantities
and theorem 984:
Theorem (984) [serial 2661] used for:
  Remove units from quantities  [serial 2659] 


Theorem (986)                               [serial 2657] 
P [97] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb < window_size >>
S [105] ->
Q [106] << ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0)  ) = totalSpO2 >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2655]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 985:
Theorem (985) [serial 2659] used for:
    normalization of [serial 2657] 


Theorem (987)                               [serial 2655] 
P [97] << ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 )
  and ub - lb < window_size >>
S [105] ->
Q [106] << ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0)  ) = totalSpO2 >>
Why created:    normalization of [serial 2653]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 986:
Theorem (986) [serial 2657] used for:
  Associativity: a.(b.c) = a.b.c [serial 2655] 


Theorem (988)                               [serial 2653] 
P [97] << ( ( ( ub - lb ) < window_size )
  and ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) ) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) ) ) >>
S [105] ->
Q [106] << ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0)  ) = totalSpO2 >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2652]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 987:
Theorem (987) [serial 2655] used for:
    normalization of [serial 2653] 


Theorem (989)                               [serial 2652] 
P [97] << ( ( ( ub - lb ) < window_size )
  and ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) ) ) >>
S [105] ->
Q [106] << ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0)  ) = totalSpO2 >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2651]
Solved by:  Substitution of Assertion Labels
and theorem 988:
Theorem (988) [serial 2653] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2652] 


Theorem (990)                               [serial 2651] 
P [97] << ( ( ( ub - lb ) < window_size )
  and ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() ) ) >>
S [105] ->
Q [106] << ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0)  ) = totalSpO2 >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2650]
Solved by:  Substitution of Assertion Labels
and theorem 989:
Theorem (989) [serial 2652] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2651] 


Theorem (991)                               [serial 2650] 
P [97] << ( ( ( ub - lb ) < window_size )
  and INV_AV() ) >>
S [105] ->
Q [106] << ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0)  ) = totalSpO2 >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2648]
Solved by:  Substitution of Assertion Labels
and theorem 990:
Theorem (990) [serial 2651] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2650] 


Theorem (992)                               [serial 2648] 
P [97] << FW() >>
S [105] ->
Q [106] << ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0)  ) = totalSpO2 >>
Why created:    normalization of [serial 2646]
Solved by:  Substitution of Assertion Labels
and theorem 991:
Theorem (991) [serial 2650] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2648] 


Theorem (993)                               [serial 2646] 
P [97] << FW() >>
S [105] ->
Q [106] << ( ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0)  ) ) = ( totalSpO2 ) >>
Why created:  Add both sides of equality:  a=b -> x+a=x+b [serial 2645]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 992:
Theorem (992) [serial 2648] used for:
    normalization of [serial 2646] 


Theorem (994)                               [serial 2645] 
P [97] << FW() >>
S [105] ->
Q [106] << (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then SPO2 else 0) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0)  ) = 
(if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then SPO2 else 0) + totalSpO2 >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2644]
Solved by:  Add both sides of equality:  a=b -> x+a=x+b
and theorem 993:
Theorem (993) [serial 2646] used for:
  Add both sides of equality:  a=b -> x+a=x+b [serial 2645] 


Theorem (995)                               [serial 2644] 
P [97] << FW() >>
S [105] ->
Q [106] << (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then SPO2 else 0) + totalSpO2 = (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0)  ) >>
Why created:  Remove units from quantities  [serial 2643]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 994:
Theorem (994) [serial 2645] used for:
  Assume Present:  P = P@now = P^0   [serial 2644] 


Theorem (996)                               [serial 2643] 
P [97] << FW() >>
S [105] ->
Q [106] << (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then SPO2 else 0 percent) + totalSpO2 = (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) >>
Why created:  Replacing port names with BLESS::Value properties  [serial 2642]
Solved by:  Remove units from quantities
and theorem 995:
Theorem (995) [serial 2644] used for:
  Remove units from quantities  [serial 2643] 


Theorem (997)                               [serial 2642] 
P [97] << FW() >>
S [105] ->
Q [106] << (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then SpO2 else 0 percent) + totalSpO2 = (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) >>
Why created:  Replacing port names with BLESS::Assertion properties  [serial 2640]
Solved by:  Replacing port names with BLESS::Value properties
and theorem 996:
Theorem (996) [serial 2643] used for:
  Replacing port names with BLESS::Value properties  [serial 2642] 


Theorem (998)                               [serial 2640] 
P [97] << FW() >>
S [105] ->
Q [106] << (if SensorConnected
  and not MotionArtifact then SpO2 else 0 percent) + totalSpO2 = (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) >>
Why created:    normalization of [serial 2638]
Solved by:  Replacing port names with BLESS::Assertion properties
and theorem 997:
Theorem (997) [serial 2642] used for:
  Replacing port names with BLESS::Assertion properties  [serial 2640] 


Theorem (999)                               [serial 2638] 
P [97] << FW() >>
S [105] ->
Q [106] << (if SensorConnected
  and not MotionArtifact then SpO2 else 0 percent) + totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) + 
( (if SENSOR_CONNECTED^( 0 )
  and not MOTION_ARTIFACT^( 0 ) then SPO2^( 0 ) else 0 percent) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 2543]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 998:
Theorem (998) [serial 2640] used for:
    normalization of [serial 2638] 


Theorem (1000)                               [serial 2543] 
P [97] << FW() >>
S [105] ->
Q [106] << (if SensorConnected
  and not MotionArtifact then SpO2 else 0 percent) + totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) + SSQ(x : 0) >>
Why created:    normalization of [serial 2529]
Solved by:  Substitution of Assertion Labels
and theorem 999:
Theorem (999) [serial 2638] used for:
  Substituted assertions' predicates for labels in postconditions [serial 2543] 


Theorem (1001)                               [serial 2529] 
P [97] << FW() >>
S [105] ->
Q [106] << ( totalSpO2 + (if SensorConnected
  and not MotionArtifact then SpO2 else 0 percent) ) = ( SSQ(x : 0) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) ) >>
Why created:  applied wp for assignment [serial 2525]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1000:
Theorem (1000) [serial 2543] used for:
    normalization of [serial 2529] 


Theorem (1002)                               [serial 2525] 
P [97] << FW() >>
S [105] totalSpO2 := totalSpO2 + (if SensorConnected
  and not MotionArtifact then SpO2 else 0 percent)
Q [106] << totalSpO2 = ( SSQ(x : 0) + ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) ) >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 2521]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 1001:
Theorem (1001) [serial 2529] used for:
  applied wp for assignment [serial 2525] 


Theorem (1003)                               [serial 2673] 
P [97] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) = totalSpO2 >>
S [108] ->
Q [109] << ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:    normalization of [serial 2671]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1004)                               [serial 2671] 
P [97] << ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( ( ub - lb ) < window_size ) ) >>
S [108] ->
Q [109] << ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2670]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1003:
Theorem (1003) [serial 2673] used for:
    normalization of [serial 2671] 


Theorem (1005)                               [serial 2670] 
P [97] << ( ( ( ub - lb ) < window_size )
  and ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) ) ) >>
S [108] ->
Q [109] << ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2669]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 1004:
Theorem (1004) [serial 2671] used for:
  Associativity: a.(b.c) = a.b.c [serial 2670] 


Theorem (1006)                               [serial 2669] 
P [97] << ( ( ( ub - lb ) < window_size )
  and ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() ) ) >>
S [108] ->
Q [109] << ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2668]
Solved by:  Substitution of Assertion Labels
and theorem 1005:
Theorem (1005) [serial 2670] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2669] 


Theorem (1007)                               [serial 2668] 
P [97] << ( ( ( ub - lb ) < window_size )
  and INV_AV() ) >>
S [108] ->
Q [109] << ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2666]
Solved by:  Substitution of Assertion Labels
and theorem 1006:
Theorem (1006) [serial 2669] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2668] 


Theorem (1008)                               [serial 2666] 
P [97] << FW() >>
S [108] ->
Q [109] << ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:    normalization of [serial 2664]
Solved by:  Substitution of Assertion Labels
and theorem 1007:
Theorem (1007) [serial 2668] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2666] 


Theorem (1009)                               [serial 2664] 
P [97] << FW() >>
S [108] ->
Q [109] << ( ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) = ( goodCount ) >>
Why created:  Add both sides of equality:  a=b -> x+a=x+b [serial 2663]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1008:
Theorem (1008) [serial 2666] used for:
    normalization of [serial 2664] 


Theorem (1010)                               [serial 2663] 
P [97] << FW() >>
S [108] ->
Q [109] << (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then 1 else 0) + goodCount >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2662]
Solved by:  Add both sides of equality:  a=b -> x+a=x+b
and theorem 1009:
Theorem (1009) [serial 2664] used for:
  Add both sides of equality:  a=b -> x+a=x+b [serial 2663] 


Theorem (1011)                               [serial 2662] 
P [97] << FW() >>
S [108] ->
Q [109] << (if SENSOR_CONNECTED
  and not MOTION_ARTIFACT then 1 else 0) + goodCount = (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) >>
Why created:  Replacing port names with BLESS::Assertion properties  [serial 2545]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 1010:
Theorem (1010) [serial 2663] used for:
  Assume Present:  P = P@now = P^0   [serial 2662] 


Theorem (1012)                               [serial 2545] 
P [97] << FW() >>
S [108] ->
Q [109] << (if SensorConnected
  and not MotionArtifact then 1 else 0) + goodCount = (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) >>
Why created:    normalization of [serial 2530]
Solved by:  Replacing port names with BLESS::Assertion properties
and theorem 1011:
Theorem (1011) [serial 2662] used for:
  Replacing port names with BLESS::Assertion properties  [serial 2545] 


Theorem (1013)                               [serial 2530] 
P [97] << FW() >>
S [108] ->
Q [109] << ( ( goodCount + (if SensorConnected
  and not MotionArtifact then 1 else 0) ) ) = ( (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) >>
Why created:  applied wp for assignment [serial 2526]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1012:
Theorem (1012) [serial 2545] used for:
    normalization of [serial 2530] 


Theorem (1014)                               [serial 2526] 
P [97] << FW() >>
S [108] goodCount := ( goodCount + (if SensorConnected
  and not MotionArtifact then 1 else 0) )
Q [109] << goodCount = ( (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) >>
Why created:  <<P>> S3 <<Q3>> in concurrent composition for [serial 2521]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 1013:
Theorem (1013) [serial 2530] used for:
  applied wp for assignment [serial 2526] 


Theorem (1015)                               [serial 2689] 
P [97] << ub - lb < window_size
  and GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() >>
S [113] ->
Q [115] << GS() >>
Why created:    normalization of [serial 2687]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1016)                               [serial 2687] 
P [97] << ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS()
  and ( ( ub - lb ) < window_size ) ) >>
S [113] ->
Q [115] << GS() >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2686]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1015:
Theorem (1015) [serial 2689] used for:
    normalization of [serial 2687] 


Theorem (1017)                               [serial 2686] 
P [97] << ( ( ( ub - lb ) < window_size )
  and ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() ) ) >>
S [113] ->
Q [115] << GS() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2685]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 1016:
Theorem (1016) [serial 2687] used for:
  Associativity: a.(b.c) = a.b.c [serial 2686] 


Theorem (1018)                               [serial 2685] 
P [97] << ( ( ( ub - lb ) < window_size )
  and INV_AV() ) >>
S [113] ->
Q [115] << GS() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2683]
Solved by:  Substitution of Assertion Labels
and theorem 1017:
Theorem (1017) [serial 2686] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2685] 


Theorem (1019)                               [serial 2683] 
P [97] << FW() >>
S [113] ->
Q [115] << GS() >>
Why created:    normalization of [serial 2681]
Solved by:  Substitution of Assertion Labels
and theorem 1018:
Theorem (1018) [serial 2685] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2683] 


Theorem (1020)                               [serial 2681] 
P [97] << FW() >>
S [113] ->
Q [115] << ( GS() ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 2679]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1019:
Theorem (1019) [serial 2683] used for:
    normalization of [serial 2681] 


Theorem (1021)                               [serial 2679] 
P [97] << FW() >>
S [113] ->
Q [115] << GS()
  and true >>
Why created:    normalization of [serial 2677]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 1020:
Theorem (1020) [serial 2681] used for:
  Law of And-Simplification:  P and true is P [serial 2679] 


Theorem (1022)                               [serial 2677] 
P [97] << FW() >>
S [113] ->
Q [115] << ( true )
  and GS() >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 2676]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1021:
Theorem (1021) [serial 2679] used for:
    normalization of [serial 2677] 


Theorem (1023)                               [serial 2676] 
P [97] << FW() >>
S [113] ->
Q [115] << ( ( SENSOR_CONNECTED
  and not MOTION_ARTIFACT ) iff ( SENSOR_CONNECTED
  and not MOTION_ARTIFACT ) )
  and GS() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 2675]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 1022:
Theorem (1022) [serial 2677] used for:
  Equality Law (idistr):  a=a <-> true [serial 2676] 


Theorem (1024)                               [serial 2675] 
P [97] << FW() >>
S [113] ->
Q [115] << ( ( SENSOR_CONNECTED
  and not MOTION_ARTIFACT ) iff ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) )
  and GS() >>
Why created:  Replacing port names with BLESS::Assertion properties  [serial 2547]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 1023:
Theorem (1023) [serial 2676] used for:
  Assume Present:  P = P@now = P^0   [serial 2675] 


Theorem (1025)                               [serial 2547] 
P [97] << FW() >>
S [113] ->
Q [115] << ( ( SensorConnected
  and not MotionArtifact ) iff ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) )
  and GS() >>
Why created:    normalization of [serial 2531]
Solved by:  Replacing port names with BLESS::Assertion properties
and theorem 1024:
Theorem (1024) [serial 2675] used for:
  Replacing port names with BLESS::Assertion properties  [serial 2547] 


Theorem (1026)                               [serial 2531] 
P [97] << FW() >>
S [113] ->
Q [115] << ( ( ( SensorConnected
  and not MotionArtifact ) ) iff ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) )
  and GS() >>
Why created:  applied wp for assignment [serial 2527]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1025:
Theorem (1025) [serial 2547] used for:
    normalization of [serial 2531] 


Theorem (1027)                               [serial 2527] 
P [97] << FW() >>
S [113] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := ( SensorConnected
  and not MotionArtifact )
Q [115] << ( goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) )
  and GS() >>
Why created:  <<P>> S4 <<Q4>> in concurrent composition for [serial 2521]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 1026:
Theorem (1026) [serial 2531] used for:
  applied wp for assignment [serial 2527] 


Theorem (1028)                               [serial 2521] 
P [97] << FW() >>
S [99]   << FW() >>
  spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] := (if SensorConnected
    and not MotionArtifact then SpO2 else 0 percent)
  << WINDOW()
    and ( spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x : 0) ) >>
  &
  totalSpO2 := totalSpO2 + (if SensorConnected
    and not MotionArtifact then SpO2 else 0 percent)
  << totalSpO2 = ( SSQ(x : 0) + ( sum k ~ quantity whole 
    in lb .. ( ub - 1 ) 
    of SSQ(k - ub)  ) ) >>
  &
  goodCount := ( goodCount + (if SensorConnected
    and not MotionArtifact then 1 else 0) )
  << goodCount = ( (if SENSOR_CONNECTED^0
    and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
    in lb .. ( ub - 1 ) 
    that ( SENSOR_CONNECTED^( k - ub )
           and not MOTION_ARTIFACT^( k - ub ) )  ) ) >>
  &
  goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := ( SensorConnected
    and not MotionArtifact )
  << ( goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^0
    and not MOTION_ARTIFACT^0 ) )
    and GS() >> 
Q [118] << ( all k ~ quantity whole 
  in lb .. ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ub 
  of SSQ(k - ub)  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 2519]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 937 967 983 1002 1014 1027:
Theorem (937) [serial 2522] used for:
  P -> P1 in concurrent composition for [serial 2521] 
Theorem (967) [serial 2523] used for:
  Q1 and Q2 and  . . . and Qn -> Q in concurrent composition for [serial 2521] 
Theorem (983) [serial 2524] used for:
  <<P1>> S1 <<Q1>> in concurrent composition for [serial 2521] 
Theorem (1002) [serial 2525] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 2521] 
Theorem (1014) [serial 2526] used for:
  <<P>> S3 <<Q3>> in concurrent composition for [serial 2521] 
Theorem (1027) [serial 2527] used for:
  <<P>> S4 <<Q4>> in concurrent composition for [serial 2521] 


Theorem (1029)                               [serial 2519] 
P [97] << FW() >>
S [98]   {
    << FW() >>
    spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] := (if SensorConnected
      and not MotionArtifact then SpO2 else 0 percent)
    << WINDOW()
      and ( spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x : 0) ) >>
    &
    totalSpO2 := totalSpO2 + (if SensorConnected
      and not MotionArtifact then SpO2 else 0 percent)
    << totalSpO2 = ( SSQ(x : 0) + ( sum k ~ quantity whole 
      in lb .. ( ub - 1 ) 
      of SSQ(k - ub)  ) ) >>
    &
    goodCount := ( goodCount + (if SensorConnected
      and not MotionArtifact then 1 else 0) )
    << goodCount = ( (if SENSOR_CONNECTED^0
      and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
      in lb .. ( ub - 1 ) 
      that ( SENSOR_CONNECTED^( k - ub )
             and not MOTION_ARTIFACT^( k - ub ) )  ) ) >>
    &
    goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := ( SensorConnected
      and not MotionArtifact )
    << ( goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^0
      and not MOTION_ARTIFACT^0 ) )
      and GS() >> 
  } 
Q [118] << ( all k ~ quantity whole 
  in lb .. ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ub 
  of SSQ(k - ub)  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1049]
Solved by:  Introduction of Existential Quantification
and theorem 1028:
Theorem (1028) [serial 2521] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 2519] 


Theorem (1030)                               [serial 2568] 
P [118] << ( all k ~ quantity whole 
  in lb .. ub 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ub 
  of SSQ(k - ub)  ) = totalSpO2 >>
S [128] ->
Q [129] << ( all k ~ quantity whole 
  in lb .. ub 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ub 
  of SSQ(k - ub)  ) = totalSpO2 >>
Why created:    normalization of [serial 2558]
Solved by:  Identity (id):  P->P is tautology


Theorem (1031)                               [serial 2558] 
P [118] << ( all k ~ quantity whole 
  in lb .. ub 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ub 
  of SSQ(k - ub)  ) = totalSpO2 >>
S [128] ->
Q [129] << ( all k ~ quantity whole 
  in lb .. ub 
  are SSQ(( k ) - ( ub )) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( ( k ) - ( ub ) )
        and not MOTION_ARTIFACT^( ( k ) - ( ub ) ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( ( k ) - ( ub ) )
         and not MOTION_ARTIFACT^( ( k ) - ( ub ) ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ub 
  of SSQ(( k ) - ( ub ))  ) = totalSpO2 >>
Why created:  Add both sides of subtraction:  a-b is (x+a)-(x+b) [serial 2549]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1030:
Theorem (1030) [serial 2568] used for:
    normalization of [serial 2558] 


Theorem (1032)                               [serial 2549] 
P [118] << ( all k ~ quantity whole 
  in lb .. ub 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ub 
  of SSQ(k - ub)  ) = totalSpO2 >>
S [128] ->
Q [129] << ( all k ~ quantity whole 
  in lb .. ub 
  are SSQ(( 1 + k ) - ( 1 + ub )) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ( 1 + ub ) )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ( 1 + ub ) ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ( 1 + ub ) )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ( 1 + ub ) ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ub 
  of SSQ(( 1 + k ) - ( 1 + ub ))  ) = totalSpO2 >>
Why created:    normalization of [serial 2532]
Solved by:  Add both sides of subtraction:  a-b is (x+a)-(x+b)
and theorem 1031:
Theorem (1031) [serial 2558] used for:
  Add both sides of subtraction:  a-b is (x+a)-(x+b) [serial 2549] 


Theorem (1033)                               [serial 2532] 
P [118] << ( all k ~ quantity whole 
  in lb .. ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ub 
  of SSQ(k - ub)  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
S [128] ->
Q [129] << ( all k ~ quantity whole 
  in lb .. ( ( ub + 1 ) - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ( ( 
      ub + 1 ) - 1 ))  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ( ub + 1 ) - 1 ) 
  of SSQ(k - ( ( ub + 1 ) - 1 ))  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ( ub + 1 ) - 1 ) 
  that ( SENSOR_CONNECTED^( k - ( ( ub + 1 ) - 1 ) )
         and not MOTION_ARTIFACT^( k - ( ( ub + 1 ) - 1 ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ( ub + 1 ) - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ( ( 
      ub + 1 ) - 1 ) )
        and not MOTION_ARTIFACT^( k - ( ( ub + 1 ) - 1 ) ) )  ) >>
Why created:  applied wp for assignment [serial 2520]
Solved by:  Subtaction of Added Value:  (a+b)-a is b
  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1032:
Theorem (1032) [serial 2549] used for:
    normalization of [serial 2532] 


Theorem (1034)                               [serial 2520] 
P [118] << ( all k ~ quantity whole 
  in lb .. ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ub 
  of SSQ(k - ub)  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
S [128] ub := ub + 1
Q [129] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ( ub - 1 ))  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ( ub - 1 ))  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1049]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 1033:
Theorem (1033) [serial 2532] used for:
  applied wp for assignment [serial 2520] 


Theorem (1035)                               [serial 1049] 
P [77] << ( ( ub - lb ) < window_size )
  and INV_AV() >>
S [97]   << FW() >>
    {
      << FW() >>
      spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] := (if SensorConnected
        and not MotionArtifact then SpO2 else 0 percent)
      << WINDOW()
        and ( spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x : 0) ) >>
      &
      totalSpO2 := totalSpO2 + (if SensorConnected
        and not MotionArtifact then SpO2 else 0 percent)
      << totalSpO2 = ( SSQ(x : 0) + ( sum k ~ quantity whole 
        in lb .. ( ub - 1 ) 
        of SSQ(k - ub)  ) ) >>
      &
      goodCount := ( goodCount + (if SensorConnected
        and not MotionArtifact then 1 else 0) )
      << goodCount = ( (if SENSOR_CONNECTED^0
        and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
        in lb .. ( ub - 1 ) 
        that ( SENSOR_CONNECTED^( k - ub )
               and not MOTION_ARTIFACT^( k - ub ) )  ) ) >>
      &
      goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := ( SensorConnected
        and not MotionArtifact )
      << ( goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^0
        and not MOTION_ARTIFACT^0 ) )
        and GS() >> 
    } 
  << ( all k ~ quantity whole 
    in lb .. ub 
    are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)  )
    and ( totalSpO2 = ( sum k ~ quantity whole 
    in lb .. ub 
    of SSQ(k - ub)  ) )
    and ( goodCount = ( numberof k ~ quantity whole 
    in lb .. ub 
    that ( SENSOR_CONNECTED^( k - ub )
           and not MOTION_ARTIFACT^( k - ub ) )  ) )
    and ( all k ~ quantity whole 
    in lb .. ub 
    are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
          and not MOTION_ARTIFACT^( k - ub ) )  ) >>
  ;
  ub := ub + 1
  << ( all k ~ quantity whole 
    in lb .. ( ub - 1 ) 
    are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ( ub - 1 ))  )
    and ( totalSpO2 = ( sum k ~ quantity whole 
    in lb .. ( ub - 1 ) 
    of SSQ(k - ( ub - 1 ))  ) )
    and ( goodCount = ( numberof k ~ quantity whole 
    in lb .. ( ub - 1 ) 
    that ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
           and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) )
    and ( all k ~ quantity whole 
    in lb .. ( ub - 1 ) 
    are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
          and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) >> 
Q [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ( ub - 1 ))  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ( ub - 1 ))  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) >>
Why created:   <<M(fillingWindow) and x>> A <<M(chooseToRun)>> for SpAT1: fillingWindow-[x]->chooseToRun{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 934 936 1029 1034:
Theorem (934) [serial 2517] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1049] 
Theorem (936) [serial 2518] used for:
  <<Q2>> -> <<Q>> in sequential composition for [serial 1049] 
Theorem (1029) [serial 2519] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1049] 
Theorem (1034) [serial 2520] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1049] 


Theorem (1036)                               [serial 2733] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
S [139] ->
Q [77] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
Why created:  applied wp for simultaneous assignment [serial 2730]
Solved by:  Identity (id):  P->P is tautology
  Identity (id):  P->P is tautology


Theorem (1037)                               [serial 2730] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ub^1 - lb^1 < window_size^1
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1 >>
Why created:    normalization of [serial 2728]
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Simultaneous Assignment
and theorem 1036:
Theorem (1036) [serial 2733] used for:
  applied wp for simultaneous assignment [serial 2730] 


Theorem (1038)                               [serial 2728] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if not ( MOTION_ARTIFACT^( k - ub ) )^1
        and SENSOR_CONNECTED^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ub^1 - lb^1 < window_size^1
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if not ( MOTION_ARTIFACT^( k - ub ) )^1
       and SENSOR_CONNECTED^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2726]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Caret Compostition:  (x^a)^b is x^(a+b)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1037:
Theorem (1037) [serial 2730] used for:
    normalization of [serial 2728] 


Theorem (1039)                               [serial 2726] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if ( not MOTION_ARTIFACT^( k - ub ) )^1
        and SENSOR_CONNECTED^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ub^1 - lb^1 < window_size^1
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if ( not MOTION_ARTIFACT^( k - ub ) )^1
       and SENSOR_CONNECTED^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1 >>
Why created:    normalization of [serial 2724]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1038:
Theorem (1038) [serial 2728] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2726] 


Theorem (1040)                               [serial 2724] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if ( SENSOR_CONNECTED^( ( k - ub ) + 1 )
        and ( not MOTION_ARTIFACT^( k - ub ) )^1 ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( not ( MOTION_ARTIFACT^( k - ub ) )^1
        and SENSOR_CONNECTED^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ub^1 - lb^1 < window_size^1
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( not ( MOTION_ARTIFACT^( k - ub ) )^1
         and SENSOR_CONNECTED^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if ( SENSOR_CONNECTED^( ( k - ub ) + 1 )
       and ( not MOTION_ARTIFACT^( k - ub ) )^1 ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2722]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Caret Compostition:  (x^a)^b is x^(a+b)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1039:
Theorem (1039) [serial 2726] used for:
    normalization of [serial 2724] 


Theorem (1041)                               [serial 2722] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )^1 then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( ( not MOTION_ARTIFACT^( k - ub ) )^1
        and SENSOR_CONNECTED^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ub^1 - lb^1 < window_size^1
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( ( not MOTION_ARTIFACT^( k - ub ) )^1
         and SENSOR_CONNECTED^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if ( SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) )^1 then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1 >>
Why created:    normalization of [serial 2720]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1040:
Theorem (1040) [serial 2724] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2722] 


Theorem (1042)                               [serial 2720] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )^1 then SPO2^( ( k - ub ) + 
      1 ) else ( 0 percent )^1) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( k - ub ) + 1 )
        and ( not MOTION_ARTIFACT^( k - ub ) )^1 ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ub^1 - lb^1 < window_size^1
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( k - ub ) + 1 )
         and ( not MOTION_ARTIFACT^( k - ub ) )^1 )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if ( SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) )^1 then SPO2^( ( k - ub ) + 1 ) else ( 0 percent )^1)  ) = totalSpO2^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2718]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Constants are always the same
  Associativity: a.(b.c) = a.b.c
and theorem 1041:
Theorem (1041) [serial 2722] used for:
    normalization of [serial 2720] 


Theorem (1043)                               [serial 2718] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)^1 = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )^1 iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ub^1 - lb^1 < window_size^1
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )^1  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)^1  ) = totalSpO2^1 >>
Why created:    normalization of [serial 2716]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1042:
Theorem (1042) [serial 2720] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2718] 


Theorem (1044)                               [serial 2716] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)^1 = ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] )^1 )  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )^1 iff ( goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] )^1 )  )
  and ( ( ub )^1 - ( lb )^1 ) < window_size^1
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) ) )^1  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) )^1  ) = totalSpO2^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2714]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1043:
Theorem (1043) [serial 2718] used for:
    normalization of [serial 2716] 


Theorem (1045)                               [serial 2714] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] )^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] )^1  )
  and ( ub - lb )^1 < window_size^1
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )^1 = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  )^1 = totalSpO2^1 >>
Why created:    normalization of [serial 2712]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1044:
Theorem (1044) [serial 2716] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2714] 


Theorem (1046)                               [serial 2712] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( ( ub - lb )^1 < ( window_size )^1 )
  and ( ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )^1 = ( goodCount )^1 )
  and ( ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  )^1 = ( totalSpO2 )^1 )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] )^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] )^1  ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2710]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1045:
Theorem (1045) [serial 2714] used for:
    normalization of [serial 2712] 


Theorem (1047)                               [serial 2710] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( ub - lb < window_size )^1
  and ( ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount )^1
  and ( ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 )^1
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )^1
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )^1 >>
Why created:    normalization of [serial 2708]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1046:
Theorem (1046) [serial 2712] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2710] 


Theorem (1048)                               [serial 2708] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )^1
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )^1
  and ( ub - lb < window_size )^1
  and ( ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount )^1
  and ( ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2706]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1047:
Theorem (1047) [serial 2710] used for:
    normalization of [serial 2708] 


Theorem (1049)                               [serial 2706] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 )^1 >>
Why created:    normalization of [serial 2704]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1048:
Theorem (1048) [serial 2708] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2706] 


Theorem (1050)                               [serial 2704] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb < window_size )^1 >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2701]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1049:
Theorem (1049) [serial 2706] used for:
    normalization of [serial 2704] 


Theorem (1051)                               [serial 2701] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 )
  and ub - lb < window_size )^1 >>
Why created:    normalization of [serial 2699]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 1050:
Theorem (1050) [serial 2704] used for:
  Associativity: a.(b.c) = a.b.c [serial 2701] 


Theorem (1052)                               [serial 2699] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) ) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) = totalSpO2 )
  and ub - lb < window_size )^1 >>
Why created:  Substituted assertions' predicates for labels  [serial 2697]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1051:
Theorem (1051) [serial 2701] used for:
    normalization of [serial 2699] 


Theorem (1053)                               [serial 2697] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) = totalSpO2 )
  and ub - lb < window_size )^1 >>
Why created:    normalization of [serial 2695]
Solved by:  Substitution of Assertion Labels
and theorem 1052:
Theorem (1052) [serial 2699] used for:
  Substituted assertions' predicates for labels  [serial 2697] 


Theorem (1054)                               [serial 2695] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( ( ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) )  ) )
  and ub - lb < window_size )^1 >>
Why created:  Substituted assertions' predicates for labels  [serial 2693]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1053:
Theorem (1053) [serial 2697] used for:
    normalization of [serial 2695] 


Theorem (1055)                               [serial 2693] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ub - lb < window_size
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2 >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( ( GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() )
  and ub - lb < window_size )^1 >>
Why created:    normalization of [serial 2691]
Solved by:  Substitution of Assertion Labels
and theorem 1054:
Theorem (1054) [serial 2695] used for:
  Substituted assertions' predicates for labels  [serial 2693] 


Theorem (1056)                               [serial 2691] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ( (if SENSOR_CONNECTED^( ( k - ( ub - 1 ) ) )
        and not MOTION_ARTIFACT^( ( k - ( ub - 1 ) ) ) then SPO2^( ( k - ( ub - 1 ) ) ) else 0 percent) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ( ub - 1 ) ) )
       and not MOTION_ARTIFACT^( ( k - ( ub - 1 ) ) ) then SPO2^( ( k - ( ub - 1 ) ) ) else 0 percent) )  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  )
  and ( ( ub - lb ) < window_size ) >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( ( ( ub - lb ) < window_size )
  and ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() ) )^1 >>
Why created:  Substituted assertions' predicates for labels  [serial 1050]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1055:
Theorem (1055) [serial 2693] used for:
    normalization of [serial 2691] 


Theorem (1057)                               [serial 1050] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ( ub - 1 ))  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ( ub - 1 ))  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  )
  and ( ( ub - lb ) < window_size ) >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [77] << ( ( ( ub - lb ) < window_size )
  and INV_AV() )^1 >>
Why created:   <<M(chooseToRun) and x>> A <<M(fillingWindow)>> for SpAT2: chooseToRun-[x]->fillingWindow{A};
Solved by:  Substitution of Assertion Labels
and theorem 1056:
Theorem (1056) [serial 2691] used for:
  Substituted assertions' predicates for labels  [serial 1050] 


Theorem (1058)                               [serial 2773] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [142] ->
Q [88] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
Why created:  applied wp for simultaneous assignment [serial 2770]
Solved by:  Identity (id):  P->P is tautology
  Identity (id):  P->P is tautology


Theorem (1059)                               [serial 2770] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
Why created:    normalization of [serial 2768]
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Simultaneous Assignment
and theorem 1058:
Theorem (1058) [serial 2773] used for:
  applied wp for simultaneous assignment [serial 2770] 


Theorem (1060)                               [serial 2768] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if not ( MOTION_ARTIFACT^( k - ub ) )^1
        and SENSOR_CONNECTED^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if not ( MOTION_ARTIFACT^( k - ub ) )^1
       and SENSOR_CONNECTED^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2766]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Caret Compostition:  (x^a)^b is x^(a+b)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1059:
Theorem (1059) [serial 2770] used for:
    normalization of [serial 2768] 


Theorem (1061)                               [serial 2766] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if ( not MOTION_ARTIFACT^( k - ub ) )^1
        and SENSOR_CONNECTED^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if ( not MOTION_ARTIFACT^( k - ub ) )^1
       and SENSOR_CONNECTED^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
Why created:    normalization of [serial 2764]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1060:
Theorem (1060) [serial 2768] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2766] 


Theorem (1062)                               [serial 2764] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if ( SENSOR_CONNECTED^( ( k - ub ) + 1 )
        and ( not MOTION_ARTIFACT^( k - ub ) )^1 ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( not ( MOTION_ARTIFACT^( k - ub ) )^1
        and SENSOR_CONNECTED^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( not ( MOTION_ARTIFACT^( k - ub ) )^1
         and SENSOR_CONNECTED^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if ( SENSOR_CONNECTED^( ( k - ub ) + 1 )
       and ( not MOTION_ARTIFACT^( k - ub ) )^1 ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2762]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Caret Compostition:  (x^a)^b is x^(a+b)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1061:
Theorem (1061) [serial 2766] used for:
    normalization of [serial 2764] 


Theorem (1063)                               [serial 2762] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )^1 then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( ( not MOTION_ARTIFACT^( k - ub ) )^1
        and SENSOR_CONNECTED^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( ( not MOTION_ARTIFACT^( k - ub ) )^1
         and SENSOR_CONNECTED^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if ( SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) )^1 then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
Why created:    normalization of [serial 2760]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1062:
Theorem (1062) [serial 2764] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2762] 


Theorem (1064)                               [serial 2760] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )^1 then SPO2^( ( k - ub ) + 
      1 ) else ( 0 percent )^1) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( k - ub ) + 1 )
        and ( not MOTION_ARTIFACT^( k - ub ) )^1 ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( k - ub ) + 1 )
         and ( not MOTION_ARTIFACT^( k - ub ) )^1 )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if ( SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) )^1 then SPO2^( ( k - ub ) + 1 ) else ( 0 percent )^1)  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2758]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Constants are always the same
  Associativity: a.(b.c) = a.b.c
and theorem 1063:
Theorem (1063) [serial 2762] used for:
    normalization of [serial 2760] 


Theorem (1065)                               [serial 2758] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)^1 = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )^1 iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )^1  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)^1  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
Why created:    normalization of [serial 2756]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1064:
Theorem (1064) [serial 2760] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2758] 


Theorem (1066)                               [serial 2756] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)^1 = ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] )^1 )  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )^1 iff ( goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] )^1 )  )
  and ( ( ub )^1 - ( lb )^1 ) = window_size^1
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) ) )^1  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) )^1  ) = totalSpO2^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2754]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1065:
Theorem (1065) [serial 2758] used for:
    normalization of [serial 2756] 


Theorem (1067)                               [serial 2754] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] )^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] )^1  )
  and ( ub - lb )^1 = window_size^1
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )^1 = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  )^1 = totalSpO2^1 >>
Why created:    normalization of [serial 2752]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1066:
Theorem (1066) [serial 2756] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2754] 


Theorem (1068)                               [serial 2752] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )^1 = ( goodCount )^1 )
  and ( ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  )^1 = ( totalSpO2 )^1 )
  and ( ( ub - lb )^1 = ( window_size )^1 )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] )^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] )^1  ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2750]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1067:
Theorem (1067) [serial 2754] used for:
    normalization of [serial 2752] 


Theorem (1069)                               [serial 2750] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount )^1
  and ( ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 )^1
  and ( ub - lb = window_size )^1
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )^1
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )^1 >>
Why created:    normalization of [serial 2748]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1068:
Theorem (1068) [serial 2752] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2750] 


Theorem (1070)                               [serial 2748] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )^1
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )^1
  and ( ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount )^1
  and ( ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 )^1
  and ( ub - lb = window_size )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2747]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1069:
Theorem (1069) [serial 2750] used for:
    normalization of [serial 2748] 


Theorem (1071)                               [serial 2747] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size )^1 >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2744]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1070:
Theorem (1070) [serial 2748] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 2747] 


Theorem (1072)                               [serial 2744] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 )
  and ub - lb = window_size )^1 >>
Why created:    normalization of [serial 2742]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 1071:
Theorem (1071) [serial 2747] used for:
  Associativity: a.(b.c) = a.b.c [serial 2744] 


Theorem (1073)                               [serial 2742] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) ) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) = totalSpO2 )
  and ub - lb = window_size )^1 >>
Why created:  Substituted assertions' predicates for labels  [serial 2740]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1072:
Theorem (1072) [serial 2744] used for:
    normalization of [serial 2742] 


Theorem (1074)                               [serial 2740] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) = totalSpO2 )
  and ub - lb = window_size )^1 >>
Why created:    normalization of [serial 2738]
Solved by:  Substitution of Assertion Labels
and theorem 1073:
Theorem (1073) [serial 2742] used for:
  Substituted assertions' predicates for labels  [serial 2740] 


Theorem (1075)                               [serial 2738] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( ( ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) )  ) )
  and ub - lb = window_size )^1 >>
Why created:  Substituted assertions' predicates for labels  [serial 2736]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1074:
Theorem (1074) [serial 2740] used for:
    normalization of [serial 2738] 


Theorem (1076)                               [serial 2736] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( ( GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() )
  and ub - lb = window_size )^1 >>
Why created:    normalization of [serial 2734]
Solved by:  Substitution of Assertion Labels
and theorem 1075:
Theorem (1075) [serial 2738] used for:
  Substituted assertions' predicates for labels  [serial 2736] 


Theorem (1077)                               [serial 2734] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ( (if SENSOR_CONNECTED^( ( k - ( ub - 1 ) ) )
        and not MOTION_ARTIFACT^( ( k - ( ub - 1 ) ) ) then SPO2^( ( k - ( ub - 1 ) ) ) else 0 percent) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ( ub - 1 ) ) )
       and not MOTION_ARTIFACT^( ( k - ( ub - 1 ) ) ) then SPO2^( ( k - ( ub - 1 ) ) ) else 0 percent) )  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  )
  and ( ( ub - lb ) = window_size ) >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() )
  and ( ( ub - lb ) = window_size ) )^1 >>
Why created:  Substituted assertions' predicates for labels  [serial 1051]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1076:
Theorem (1076) [serial 2736] used for:
    normalization of [serial 2734] 


Theorem (1078)                               [serial 1051] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ( ub - 1 ))  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ( ub - 1 ))  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  )
  and ( ( ub - lb ) = window_size ) >>
S [142] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [88] << ( INV_AV()
  and ( ( ub - lb ) = window_size ) )^1 >>
Why created:   <<M(chooseToRun) and x>> A <<M(run)>> for SpAT3: chooseToRun-[x]->run{A};
Solved by:  Substitution of Assertion Labels
and theorem 1077:
Theorem (1077) [serial 2734] used for:
  Substituted assertions' predicates for labels  [serial 1051] 


Theorem (1079)                               [serial 2774] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ( ub - 1 ))  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ( ub - 1 ))  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  )
  and ( ( ub - lb ) > window_size ) >>
S [145] ->
Q [90] << true >>
Why created:  applied wp for simultaneous assignment [serial 1052]
Solved by:  True Conclusion Schema (tc): P->true
  True Conclusion Schema (tc): P->true


Theorem (1080)                               [serial 1052] 
P [79] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ( ub - 1 ))  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ( ub - 1 ))  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  )
  and ( ( ub - lb ) > window_size ) >>
S [145] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [90] << true >>
Why created:   <<M(chooseToRun) and x>> A <<M(fail)>> for SpAT3a: chooseToRun-[x]->fail{A};
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Simultaneous Assignment
and theorem 1079:
Theorem (1079) [serial 2774] used for:
  applied wp for simultaneous assignment [serial 1052] 


Theorem (1081)                               [serial 3090] 
P [88] << ub - lb = window_size
  and GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() >>
S [88] ->
Q [88] << ub - lb = window_size >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2971]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1082)                               [serial 3094] 
P [88] << ub - lb = window_size
  and GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() >>
S [88] ->
Q [88] << GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() >>
Why created:    normalization of [serial 3092]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (1083)                               [serial 3092] 
P [88] << ub - lb = window_size
  and GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() >>
S [88] ->
Q [88] << ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 3091]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1082:
Theorem (1082) [serial 3094] used for:
    normalization of [serial 3092] 


Theorem (1084)                               [serial 3091] 
P [88] << ub - lb = window_size
  and GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() >>
S [88] ->
Q [88] << INV_AV() >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2971]
Solved by:  Substitution of Assertion Labels
and theorem 1083:
Theorem (1083) [serial 3092] used for:
  Substituted assertions' predicates for labels in postconditions [serial 3091] 


Theorem (1085)                               [serial 2971] 
P [88] << ub - lb = window_size
  and GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() >>
S [88] ->
Q [148] << ub - lb = window_size
  and INV_AV() >>
Why created:    normalization of [serial 2954]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1081 1084:
Theorem (1081) [serial 3090] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2971] 
Theorem (1084) [serial 3091] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2971] 


Theorem (1086)                               [serial 2954] 
P [88] << GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW()
  and ub - lb = window_size >>
S [88] ->
Q [148] << ub - lb = window_size
  and INV_AV() >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2912]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1085:
Theorem (1085) [serial 2971] used for:
    normalization of [serial 2954] 


Theorem (1087)                               [serial 2912] 
P [88] << ( GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() )
  and ub - lb = window_size >>
S [88] ->
Q [148] << ub - lb = window_size
  and INV_AV() >>
Why created:    normalization of [serial 2894]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 1086:
Theorem (1086) [serial 2954] used for:
  Associativity: a.(b.c) = a.b.c [serial 2912] 


Theorem (1088)                               [serial 2894] 
P [88] << ub - lb = window_size
  and ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() ) >>
S [88] ->
Q [148] << ( INV_AV()
  and ( ( ub - lb ) = window_size ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2803]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1087:
Theorem (1087) [serial 2912] used for:
    normalization of [serial 2894] 


Theorem (1089)                               [serial 2803] 
P [88] << ub - lb = window_size
  and INV_AV() >>
S [88] ->
Q [148] << RUN_AV() >>
Why created:    normalization of [serial 2775]
Solved by:  Substitution of Assertion Labels
and theorem 1088:
Theorem (1088) [serial 2894] used for:
  Substituted assertions' predicates for labels  [serial 2803] 


Theorem (1090)                               [serial 2775] 
P [88] << INV_AV()
  and ( ( ub - lb ) = window_size ) >>
S [88] ->
Q [148] << RUN_AV() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1053]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1089:
Theorem (1089) [serial 2803] used for:
    normalization of [serial 2775] 


Theorem (1091)                               [serial 3211] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
S [88] ->
Q [16] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
Why created:    normalization of [serial 3209]
Solved by:  Identity (id):  P->P is tautology


Theorem (1092)                               [serial 3209] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
S [88] ->
Q [16] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if not ( MOTION_ARTIFACT^( k - ub ) )^1
        and SENSOR_CONNECTED^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if not ( MOTION_ARTIFACT^( k - ub ) )^1
       and SENSOR_CONNECTED^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 3207]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Caret Compostition:  (x^a)^b is x^(a+b)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1091:
Theorem (1091) [serial 3211] used for:
    normalization of [serial 3209] 


Theorem (1093)                               [serial 3207] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
S [88] ->
Q [16] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if ( not MOTION_ARTIFACT^( k - ub ) )^1
        and SENSOR_CONNECTED^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if ( not MOTION_ARTIFACT^( k - ub ) )^1
       and SENSOR_CONNECTED^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
Why created:    normalization of [serial 3205]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1092:
Theorem (1092) [serial 3209] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 3207] 


Theorem (1094)                               [serial 3205] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
S [88] ->
Q [16] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if ( SENSOR_CONNECTED^( ( k - ub ) + 1 )
        and ( not MOTION_ARTIFACT^( k - ub ) )^1 ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( not ( MOTION_ARTIFACT^( k - ub ) )^1
        and SENSOR_CONNECTED^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( not ( MOTION_ARTIFACT^( k - ub ) )^1
         and SENSOR_CONNECTED^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if ( SENSOR_CONNECTED^( ( k - ub ) + 1 )
       and ( not MOTION_ARTIFACT^( k - ub ) )^1 ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 3203]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Caret Compostition:  (x^a)^b is x^(a+b)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1093:
Theorem (1093) [serial 3207] used for:
    normalization of [serial 3205] 


Theorem (1095)                               [serial 3203] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
S [88] ->
Q [16] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )^1 then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( ( not MOTION_ARTIFACT^( k - ub ) )^1
        and SENSOR_CONNECTED^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( ( not MOTION_ARTIFACT^( k - ub ) )^1
         and SENSOR_CONNECTED^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if ( SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) )^1 then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
Why created:    normalization of [serial 3201]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1094:
Theorem (1094) [serial 3205] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 3203] 


Theorem (1096)                               [serial 3201] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
S [88] ->
Q [16] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )^1 then SPO2^( ( k - ub ) + 
      1 ) else ( 0 percent )^1) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( k - ub ) + 1 )
        and ( not MOTION_ARTIFACT^( k - ub ) )^1 ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( k - ub ) + 1 )
         and ( not MOTION_ARTIFACT^( k - ub ) )^1 )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if ( SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) )^1 then SPO2^( ( k - ub ) + 1 ) else ( 0 percent )^1)  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 3199]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Constants are always the same
  Associativity: a.(b.c) = a.b.c
and theorem 1095:
Theorem (1095) [serial 3203] used for:
    normalization of [serial 3201] 


Theorem (1097)                               [serial 3199] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
S [88] ->
Q [16] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)^1 = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )^1 iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )^1  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)^1  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
Why created:    normalization of [serial 3197]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1096:
Theorem (1096) [serial 3201] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 3199] 


Theorem (1098)                               [serial 3197] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
S [88] ->
Q [16] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)^1 = ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] )^1 )  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )^1 iff ( goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] )^1 )  )
  and ( ( ub )^1 - ( lb )^1 ) = window_size^1
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) ) )^1  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) )^1  ) = totalSpO2^1 >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 3195]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1097:
Theorem (1097) [serial 3199] used for:
    normalization of [serial 3197] 


Theorem (1099)                               [serial 3195] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
S [88] ->
Q [16] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] )^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] )^1  )
  and ( ub - lb )^1 = window_size^1
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )^1 = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  )^1 = totalSpO2^1 >>
Why created:    normalization of [serial 3193]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1098:
Theorem (1098) [serial 3197] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 3195] 


Theorem (1100)                               [serial 3193] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
S [88] ->
Q [16] << ( ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )^1 = ( goodCount )^1 )
  and ( ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  )^1 = ( totalSpO2 )^1 )
  and ( ( ub - lb )^1 = ( window_size )^1 )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] )^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] )^1  ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 3191]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1099:
Theorem (1099) [serial 3195] used for:
    normalization of [serial 3193] 


Theorem (1101)                               [serial 3191] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  ) = goodCount^1
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  ) = totalSpO2^1
  and ub^1 - lb^1 = window_size^1 >>
S [88] ->
Q [16] << ( ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount )^1
  and ( ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 )^1
  and ( ub - lb = window_size )^1
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )^1
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )^1 >>
Why created:    normalization of [serial 3189]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1100:
Theorem (1100) [serial 3193] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 3191] 


Theorem (1102)                               [serial 3189] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] )^1 = (if SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] )^1 iff ( SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and ( goodCount )^1 = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and ( totalSpO2 )^1 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and ( window_size )^1 = ( ub )^1 - ( lb )^1 >>
S [88] ->
Q [16] << ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )^1
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )^1
  and ( ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount )^1
  and ( ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 )^1
  and ( ub - lb = window_size )^1 ) >>
Why created:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 3186]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1101:
Theorem (1101) [serial 3191] used for:
    normalization of [serial 3189] 


Theorem (1103)                               [serial 3186] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' = (if SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]' iff ( SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and window_size' = ub' - lb' >>
S [88] ->
Q [16] << ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size )^1 >>
Why created:    normalization of [serial 3184]
Solved by:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1102:
Theorem (1102) [serial 3189] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k  [serial 3186] 


Theorem (1104)                               [serial 3184] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' = (if SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]' iff ( SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and window_size' = ub' - lb' >>
S [88] ->
Q [16] << ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) ) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) = totalSpO2
  and ub - lb = window_size )^1 >>
Why created:  Substituted assertions' predicates for labels  [serial 3182]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1103:
Theorem (1103) [serial 3186] used for:
    normalization of [serial 3184] 


Theorem (1105)                               [serial 3182] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' = (if SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]' iff ( SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and window_size' = ub' - lb' >>
S [88] ->
Q [16] << ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) = totalSpO2
  and ub - lb = window_size )^1 >>
Why created:    normalization of [serial 3180]
Solved by:  Substitution of Assertion Labels
and theorem 1104:
Theorem (1104) [serial 3184] used for:
  Substituted assertions' predicates for labels  [serial 3182] 


Theorem (1106)                               [serial 3180] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' = (if SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]' iff ( SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and window_size' = ub' - lb' >>
S [88] ->
Q [16] << ( ub - lb = window_size
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) )  ) )^1 >>
Why created:  Substituted assertions' predicates for labels  [serial 2983]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1105:
Theorem (1105) [serial 3182] used for:
    normalization of [serial 3180] 


Theorem (1107)                               [serial 2983] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' = (if SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]' iff ( SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and window_size' = ub' - lb' >>
S [88] ->
Q [16] << ( ub - lb = window_size
  and GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() )^1 >>
Why created:    normalization of [serial 2960]
Solved by:  Substitution of Assertion Labels
and theorem 1106:
Theorem (1106) [serial 3180] used for:
  Substituted assertions' predicates for labels  [serial 2983] 


Theorem (1108)                               [serial 2960] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' = (if SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]' iff ( SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and window_size' = ub' - lb' >>
S [88] ->
Q [16] << ( GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW()
  and ub - lb = window_size )^1 >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2934]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1107:
Theorem (1107) [serial 2983] used for:
    normalization of [serial 2960] 


Theorem (1109)                               [serial 2934] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' = (if SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]' iff ( SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and window_size' = ub' - lb' >>
S [88] ->
Q [16] << ( ( GOOD()
  and GS()
  and TOTAL_SPO2()
  and WINDOW() )
  and ub - lb = window_size )^1 >>
Why created:    normalization of [serial 2905]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 1108:
Theorem (1108) [serial 2960] used for:
  Associativity: a.(b.c) = a.b.c [serial 2934] 


Theorem (1110)                               [serial 2905] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' = ( (if SENSOR_CONNECTED^( ( ( 
      1 + k ) - ub ) )
        and not MOTION_ARTIFACT^( ( ( 1 + k ) - ub ) ) then SPO2^( ( ( 1 + 
      k ) - ub ) ) else 0 percent) )  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]' iff ( SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( ( 1 + k ) - ub ) )
       and not MOTION_ARTIFACT^( ( ( 1 + k ) - ub ) ) then SPO2^( ( ( 1 + 
     k ) - ub ) ) else 0 percent) )  )
  and window_size' = ub' - lb' >>
S [88] ->
Q [16] << ( ub - lb = window_size
  and ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() ) )^1 >>
Why created:  Substituted assertions' predicates for labels  [serial 2881]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1109:
Theorem (1109) [serial 2934] used for:
    normalization of [serial 2905] 


Theorem (1111)                               [serial 2881] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' = SSQ(( 
      1 + k ) - ub)  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]' iff ( SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(( 1 + k ) - ub)  )
  and window_size' = ub' - lb' >>
S [88] ->
Q [16] << ( ub - lb = window_size
  and INV_AV() )^1 >>
Why created:    normalization of [serial 2858]
Solved by:  Substitution of Assertion Labels
and theorem 1110:
Theorem (1110) [serial 2905] used for:
  Substituted assertions' predicates for labels  [serial 2881] 


Theorem (1112)                               [serial 2858] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' = SSQ(( 
      1 + k ) - ub)  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]' iff ( SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(( 1 + k ) - ub)  )
  and window_size' = ( ub' ) - ( lb' ) >>
S [88] ->
Q [16] << ( ub - lb = window_size
  and INV_AV() )^1 >>
Why created:  Add both sides of subtraction:  a-b is (x+a)-(x+b) [serial 2805]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1111:
Theorem (1111) [serial 2881] used for:
    normalization of [serial 2858] 


Theorem (1113)                               [serial 2805] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' = SSQ(( 
      1 + k ) - ub)  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]' iff ( SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(( 1 + k ) - ub)  )
  and window_size' = ( 1 + ub' ) - ( 1 + lb' ) >>
S [88] ->
Q [16] << ( ub - lb = window_size
  and INV_AV() )^1 >>
Why created:    normalization of [serial 2776]
Solved by:  Add both sides of subtraction:  a-b is (x+a)-(x+b)
and theorem 1112:
Theorem (1112) [serial 2858] used for:
  Add both sides of subtraction:  a-b is (x+a)-(x+b) [serial 2805] 


Theorem (1114)                               [serial 2776] 
P [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' = SSQ(k - ( ub - 1 ))  )
  and ( totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ( ub - 1 ))  ) )
  and ( ( ( ub' - 1 ) - ( lb' - 1 ) ) = window_size' )
  and ( goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]' iff ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) >>
S [88] ->
Q [16] << ( INV_AV()
  and ( ( ub - lb ) = window_size ) )^1 >>
Why created:  <<Q4>> -> <<Q>> in sequential composition for [serial 1053]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1113:
Theorem (1113) [serial 2805] used for:
    normalization of [serial 2776] 


Theorem (1115)                               [serial 3007] 
P [148] << ub - lb = window_size
  and INV_AV() >>
S [149] ->
Q [149] << true >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 3005]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (1116)                               [serial 3005] 
P [148] << ub - lb = window_size
  and INV_AV() >>
S [149] ->
Q [149] << 0 < goodCount or not ( 0 < goodCount ) >>
Why created:    normalization of [serial 3003]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 1115:
Theorem (1115) [serial 3007] used for:
  Law of Excluded Middle: P or not P is tautology [serial 3005] 


Theorem (1117)                               [serial 3003] 
P [148] << ub - lb = window_size
  and INV_AV() >>
S [149] ->
Q [149] << 0 < goodCount or ( not ( 0 < goodCount ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2914]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 1116:
Theorem (1116) [serial 3005] used for:
    normalization of [serial 3003] 


Theorem (1118)                               [serial 2914] 
P [148] << ub - lb = window_size
  and INV_AV() >>
S [149] ->
Q [149] << 0 < goodCount or goodCount <= 0 >>
Why created:    normalization of [serial 2895]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 1117:
Theorem (1117) [serial 3003] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 2914] 


Theorem (1119)                               [serial 2895] 
P [148] << ( INV_AV()
  and ( ( ub - lb ) = window_size ) ) >>
S [149] ->
Q [149] << 0 < goodCount or goodCount <= 0 >>
Why created:  Substituted assertions' predicates for labels  [serial 2807]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1118:
Theorem (1118) [serial 2914] used for:
    normalization of [serial 2895] 


Theorem (1120)                               [serial 2807] 
P [148] << RUN_AV() >>
S [149] ->
Q [149] << 0 < goodCount or goodCount <= 0 >>
Why created:    normalization of [serial 2781]
Solved by:  Substitution of Assertion Labels
and theorem 1119:
Theorem (1119) [serial 2895] used for:
  Substituted assertions' predicates for labels  [serial 2807] 


Theorem (1121)                               [serial 2781] 
P [148] << RUN_AV() >>
S [149] ->
Q [149] << ( goodCount > 0 ) or ( goodCount <= 0 ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 2777]
Solved by:  Irreflexivity of Greater Than: (a>b) = (b<a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1120:
Theorem (1120) [serial 2807] used for:
    normalization of [serial 2781] 


Theorem (1122)                               [serial 2861] 
P [149] << 0 < goodCount
  and RUN_AV() >>
S [149] ->
Q [151] << 0 < goodCount
  and RUN_AV() >>
Why created:  Law of And-Simplification:  P and true is P [serial 2834]
Solved by:  Identity (id):  P->P is tautology


Theorem (1123)                               [serial 2834] 
P [149] << 0 < goodCount
  and RUN_AV() >>
S [149] ->
Q [151] << 0 < goodCount
  and RUN_AV()
  and true >>
Why created:    normalization of [serial 2798]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 1122:
Theorem (1122) [serial 2861] used for:
  Law of And-Simplification:  P and true is P [serial 2834] 


Theorem (1124)                               [serial 2798] 
P [149] << RUN_AV()
  and ( goodCount > 0 ) >>
S [149] ->
Q [151] << RUN_AV()
  and ( goodCount > 0 )
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Irreflexivity of Greater Than: (a>b) = (b<a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1123:
Theorem (1123) [serial 2834] used for:
    normalization of [serial 2798] 


Theorem (1125)                               [serial 2861] 
P [149] << 0 < goodCount
  and RUN_AV() >>
S [149] ->
Q [151] << 0 < goodCount
  and RUN_AV() >>
Why created:  Law of And-Simplification:  P and true is P [serial 2834]
Solved by:  Identity (id):  P->P is tautology


Theorem (1126)                               [serial 2834] 
P [149] << 0 < goodCount
  and RUN_AV() >>
S [149] ->
Q [151] << 0 < goodCount
  and RUN_AV()
  and true >>
Why created:    normalization of [serial 2798]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 1125:
Theorem (1125) [serial 2861] used for:
  Law of And-Simplification:  P and true is P [serial 2834] 


Theorem (1127)                               [serial 2798] 
P [149] << RUN_AV()
  and ( goodCount > 0 ) >>
S [149] ->
Q [151] << RUN_AV()
  and ( goodCount > 0 )
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Irreflexivity of Greater Than: (a>b) = (b<a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1126:
Theorem (1126) [serial 2834] used for:
    normalization of [serial 2798] 


Theorem (1128)                               [serial 2782] 
P [149] << RUN_AV()
  and ( goodCount > 0 ) >>
S [149] ->
Q [151] << RUN_AV()
  and ( goodCount > 0 )
  and AXIOM_K2I() >>
Why created:    <<P and B0>> -> <<P0>> in alternative for [serial 2777]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 1127 1127:
Theorem (1127) [serial 2798] used for:
   add user-defined axioms to postcondition 
Theorem (1127) [serial 2798] used for:
   add user-defined axioms to postcondition 


Theorem (1129)                               [serial 3099] 
P [152] << 0 < goodCount
  and ub - lb = window_size
  and ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )
  and INV_AV()
  and ( SpO2Avg = ( totalSpO2 / goodCount ) )^0 >>
S [152] ->
Q [153] << ub - lb = window_size
  and INV_AV() >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 3096]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (1130)                               [serial 3096] 
P [152] << ( 0 < goodCount
  and ub - lb = window_size
  and ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )
  and INV_AV() )
  and ( SpO2Avg = ( totalSpO2 / goodCount ) )^0 >>
S [152] ->
Q [153] << ub - lb = window_size
  and INV_AV() >>
Why created:  applied port output <<pre and (SpO2Avg=totalSpO2 / goodCount)^0>> -> <<post>> [serial 2973]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 1129:
Theorem (1129) [serial 3099] used for:
  Associativity: a.(b.c) = a.b.c [serial 3096] 


Theorem (1131)                               [serial 3124] 
P [152] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and 0 < goodCount
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size
  and ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )
  and totalSpO2 / goodCount = SpO2Avg >>
S [152] ->
Q [152] << ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) >>
Why created:    normalization of [serial 3122]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1132)                               [serial 3122] 
P [152] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and 0 < goodCount
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size
  and ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )
  and totalSpO2 / goodCount = SpO2Avg >>
S [152] ->
Q [152] << ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( ( ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) ) / ( ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "goodCount" with its = "( ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )" in its postcondition [serial 3121]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1131:
Theorem (1131) [serial 3124] used for:
    normalization of [serial 3122] 


Theorem (1133)                               [serial 3121] 
P [152] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and 0 < goodCount
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size
  and ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )
  and totalSpO2 / goodCount = SpO2Avg >>
S [152] ->
Q [152] << ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( ( ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) ) / goodCount ) >>
Why created:  Guided Substitution of Equals 
 replacing "totalSpO2" with its = "( ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) )" in its postcondition [serial 3120]
Solved by:  Guided Substitution of Equals
and theorem 1132:
Theorem (1132) [serial 3122] used for:
  Guided Substitution of Equals 
 replacing "goodCount" with its = "( ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )" in its postcondition [serial 3121] 


Theorem (1134)                               [serial 3120] 
P [152] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and 0 < goodCount
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size
  and ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )
  and totalSpO2 / goodCount = SpO2Avg >>
S [152] ->
Q [152] << ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( totalSpO2 / goodCount ) >>
Why created:  Guided Substitution of Equals 
 replacing "SpO2Avg" with its = "( totalSpO2 / goodCount )" in its postcondition [serial 3119]
Solved by:  Guided Substitution of Equals
and theorem 1133:
Theorem (1133) [serial 3121] used for:
  Guided Substitution of Equals 
 replacing "totalSpO2" with its = "( ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) )" in its postcondition [serial 3120] 


Theorem (1135)                               [serial 3119] 
P [152] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and 0 < goodCount
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size
  and ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )
  and totalSpO2 / goodCount = SpO2Avg >>
S [152] ->
Q [152] << ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = SpO2Avg >>
Why created:  Assume Present:  P = P@now = P^0   [serial 3117]
Solved by:  Guided Substitution of Equals
and theorem 1134:
Theorem (1134) [serial 3120] used for:
  Guided Substitution of Equals 
 replacing "SpO2Avg" with its = "( totalSpO2 / goodCount )" in its postcondition [serial 3119] 


Theorem (1136)                               [serial 3117] 
P [152] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and 0 < goodCount
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size
  and ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( totalSpO2 / goodCount = SpO2Avg )^0 >>
S [152] ->
Q [152] << ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = SpO2Avg >>
Why created:    normalization of [serial 3115]
Solved by:  Assume Present:  P = P@now = P^0 
and theorem 1135:
Theorem (1135) [serial 3119] used for:
  Assume Present:  P = P@now = P^0   [serial 3117] 


Theorem (1137)                               [serial 3115] 
P [152] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) ) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  )
  and 0 < goodCount
  and ub - lb = window_size
  and ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( totalSpO2 / goodCount = SpO2Avg )^0 >>
S [152] ->
Q [152] << ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = SpO2Avg >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 3114]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1136:
Theorem (1136) [serial 3117] used for:
    normalization of [serial 3115] 


Theorem (1138)                               [serial 3114] 
P [152] << 0 < goodCount
  and ub - lb = window_size
  and ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) ) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( totalSpO2 / goodCount = SpO2Avg )^0 >>
S [152] ->
Q [152] << ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = SpO2Avg >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 3113]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 1137:
Theorem (1137) [serial 3115] used for:
  Associativity: a.(b.c) = a.b.c [serial 3114] 


Theorem (1139)                               [serial 3113] 
P [152] << 0 < goodCount
  and ub - lb = window_size
  and ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( totalSpO2 / goodCount = SpO2Avg )^0 >>
S [152] ->
Q [152] << ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = SpO2Avg >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 3112]
Solved by:  Substitution of Assertion Labels
and theorem 1138:
Theorem (1138) [serial 3114] used for:
  Substituted assertions' predicates for labels in preconditions [serial 3113] 


Theorem (1140)                               [serial 3112] 
P [152] << 0 < goodCount
  and ub - lb = window_size
  and ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )
  and ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() )
  and ( totalSpO2 / goodCount = SpO2Avg )^0 >>
S [152] ->
Q [152] << ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = SpO2Avg >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 3104]
Solved by:  Substitution of Assertion Labels
and theorem 1139:
Theorem (1139) [serial 3113] used for:
  Substituted assertions' predicates for labels in preconditions [serial 3112] 


Theorem (1141)                               [serial 3104] 
P [152] << 0 < goodCount
  and ub - lb = window_size
  and ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )
  and INV_AV()
  and ( totalSpO2 / goodCount = SpO2Avg )^0 >>
S [152] ->
Q [152] << ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = SpO2Avg >>
Why created:    normalization of [serial 3100]
Solved by:  Substitution of Assertion Labels
and theorem 1140:
Theorem (1140) [serial 3112] used for:
  Substituted assertions' predicates for labels in preconditions [serial 3104] 


Theorem (1142)                               [serial 3100] 
P [152] << 0 < goodCount
  and ub - lb = window_size
  and ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )
  and INV_AV()
  and ( SpO2Avg = ( totalSpO2 / goodCount ) )^0 >>
S [152] ->
Q [152] << SpO2Avg = ( ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^( i )
       and not MOTION_ARTIFACT^( i ) then SPO2^( i ) else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^( i )
         and not MOTION_ARTIFACT^( i ) )  ) ) >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 3097]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1141:
Theorem (1141) [serial 3104] used for:
    normalization of [serial 3100] 


Theorem (1143)                               [serial 3097] 
P [152] << ( 0 < goodCount
  and ub - lb = window_size
  and ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )
  and INV_AV() )
  and ( SpO2Avg = ( totalSpO2 / goodCount ) )^0 >>
S [152] ->
Q [152] << SpO2Avg = ( ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^( i )
       and not MOTION_ARTIFACT^( i ) then SPO2^( i ) else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^( i )
         and not MOTION_ARTIFACT^( i ) )  ) ) >>
Why created:  applied port output <<pre and (SpO2Avg=totalSpO2 / goodCount)^0>> -> <<(SpO2Avg=( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^( i )
       and not MOTION_ARTIFACT^( i ) then SPO2^( i ) else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^( i )
         and not MOTION_ARTIFACT^( i ) )  ))^0>> [serial 2973]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 1142:
Theorem (1142) [serial 3100] used for:
  Associativity: a.(b.c) = a.b.c [serial 3097] 


Theorem (1144)                               [serial 3110] 
P [151] << 0 < goodCount
  and ub - lb = window_size
  and ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )
  and INV_AV() >>
S [152] ->
Q [152] << 0 < goodCount or goodCount < 0 >>
Why created:    normalization of [serial 3107]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (1145)                               [serial 3107] 
P [151] << 0 < goodCount
  and ub - lb = window_size
  and ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )
  and INV_AV() >>
S [152] ->
Q [152] << ( ( goodCount < 0 ) or ( 0 < goodCount ) ) >>
Why created:  Replace not equality with inequality:  a<>b  iff  not(a=b)  [serial 3102]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
  Associativity: a.(b.c) = a.b.c
and theorem 1144:
Theorem (1144) [serial 3110] used for:
    normalization of [serial 3107] 


Theorem (1146)                               [serial 3102] 
P [151] << 0 < goodCount
  and ub - lb = window_size
  and ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )
  and INV_AV() >>
S [152] ->
Q [152] << 0 <> goodCount >>
Why created:    normalization of [serial 3098]
Solved by:  Replace not equality with inequality:  a<>b  iff  not(a=b)
and theorem 1145:
Theorem (1145) [serial 3107] used for:
  Replace not equality with inequality:  a<>b  iff  not(a=b)  [serial 3102] 


Theorem (1147)                               [serial 3098] 
P [151] << 0 < goodCount
  and ub - lb = window_size
  and ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )
  and INV_AV() >>
S [152] ->
Q [152] << goodCount <> 0 >>
Why created:  applied  <<pre>> -> <<d <> QUANTITY>> for <<pre>> SpO2Avg!(totalSpO2 / goodCount) <<post>> [serial 2973]
Solved by:  Reflexivity of Inequality: (a<>b) = (b<>a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1146:
Theorem (1146) [serial 3102] used for:
    normalization of [serial 3098] 


Theorem (1148)                               [serial 2973] 
P [151] << 0 < goodCount
  and ub - lb = window_size
  and ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  )
  and INV_AV() >>
S [152] SpO2Avg!(totalSpO2 / goodCount)
Q [153] << ub - lb = window_size
  and INV_AV() >>
Why created:    normalization of [serial 2955]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 1130 1143 1147:
Theorem (1130) [serial 3096] used for:
  applied port output <<pre and (SpO2Avg=totalSpO2 / goodCount)^0>> -> <<post>> [serial 2973] 
Theorem (1143) [serial 3097] used for:
  applied port output <<pre and (SpO2Avg=totalSpO2 / goodCount)^0>> -> <<(SpO2Avg=( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^( i )
       and not MOTION_ARTIFACT^( i ) then SPO2^( i ) else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^( i )
         and not MOTION_ARTIFACT^( i ) )  ))^0>> [serial 2973] 
Theorem (1147) [serial 3098] used for:
  applied  <<pre>> -> <<d <> QUANTITY>> for <<pre>> SpO2Avg!(totalSpO2 / goodCount) <<post>> [serial 2973] 


Theorem (1149)                               [serial 2955] 
P [151] << ub - lb = window_size
  and INV_AV()
  and 0 < goodCount
  and ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) >>
S [152] SpO2Avg!(totalSpO2 / goodCount)
Q [153] << ub - lb = window_size
  and INV_AV() >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2916]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1148:
Theorem (1148) [serial 2973] used for:
    normalization of [serial 2955] 


Theorem (1150)                               [serial 2916] 
P [151] << ( ub - lb = window_size
  and INV_AV() )
  and 0 < goodCount
  and ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^i
         and not MOTION_ARTIFACT^i )  ) = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) >>
S [152] SpO2Avg!(totalSpO2 / goodCount)
Q [153] << ub - lb = window_size
  and INV_AV() >>
Why created:    normalization of [serial 2896]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 1149:
Theorem (1149) [serial 2955] used for:
  Associativity: a.(b.c) = a.b.c [serial 2916] 


Theorem (1151)                               [serial 2896] 
P [151] << 0 < goodCount
  and ( ( ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) / ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) = ( ( sum i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  of (if SENSOR_CONNECTED^i
       and not MOTION_ARTIFACT^i then SPO2^i else 0 percent)  ) / ( numberof i ~ quantity whole 
  in - SPO2_MOVING_AVERAGE_WINDOW_SAMPLES .. -1 
  that ( SENSOR_CONNECTED^( i )
         and not MOTION_ARTIFACT^( i ) )  ) ) )
  and ( INV_AV()
  and ( ( ub - lb ) = window_size ) ) >>
S [152] SpO2Avg!(totalSpO2 / goodCount)
Q [153] << ( INV_AV()
  and ( ( ub - lb ) = window_size ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2809]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1150:
Theorem (1150) [serial 2916] used for:
    normalization of [serial 2896] 


Theorem (1152)                               [serial 2809] 
P [151] << 0 < goodCount
  and AXIOM_K2I()
  and RUN_AV() >>
S [152] SpO2Avg!(totalSpO2 / goodCount)
Q [153] << RUN_AV() >>
Why created:    normalization of [serial 2783]
Solved by:  Substitution of Assertion Labels
and theorem 1151:
Theorem (1151) [serial 2896] used for:
  Substituted assertions' predicates for labels  [serial 2809] 


Theorem (1153)                               [serial 2783] 
P [151] << RUN_AV()
  and ( goodCount > 0 )
  and AXIOM_K2I() >>
S [152] SpO2Avg!(totalSpO2 / goodCount)
Q [153] << RUN_AV() >>
Why created:    <<P0>> S0 <<Q0>> in alternative for [serial 2777]
Solved by:  Irreflexivity of Greater Than: (a>b) = (b<a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1152:
Theorem (1152) [serial 2809] used for:
    normalization of [serial 2783] 


Theorem (1154)                               [serial 2877] 
P [153] << RUN_AV() >>
S [149] ->
Q [158] << RUN_AV() >>
Why created:    normalization of [serial 2856]
Solved by:  Identity (id):  P->P is tautology


Theorem (1155)                               [serial 2856] 
P [153] << RUN_AV() >>
S [149] ->
Q [158] << ( RUN_AV() ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 2799]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1154:
Theorem (1154) [serial 2877] used for:
    normalization of [serial 2856] 


Theorem (1156)                               [serial 2799] 
P [153] << RUN_AV() >>
S [149] ->
Q [158] << RUN_AV()
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 1155:
Theorem (1155) [serial 2856] used for:
  Law of And-Simplification:  P and true is P [serial 2799] 


Theorem (1157)                               [serial 2877] 
P [153] << RUN_AV() >>
S [149] ->
Q [158] << RUN_AV() >>
Why created:    normalization of [serial 2856]
Solved by:  Identity (id):  P->P is tautology


Theorem (1158)                               [serial 2856] 
P [153] << RUN_AV() >>
S [149] ->
Q [158] << ( RUN_AV() ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 2799]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1157:
Theorem (1157) [serial 2877] used for:
    normalization of [serial 2856] 


Theorem (1159)                               [serial 2799] 
P [153] << RUN_AV() >>
S [149] ->
Q [158] << RUN_AV()
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 1158:
Theorem (1158) [serial 2856] used for:
  Law of And-Simplification:  P and true is P [serial 2799] 


Theorem (1160)                               [serial 2784] 
P [153] << RUN_AV() >>
S [149] ->
Q [158] << RUN_AV()
  and AXIOM_LB() >>
Why created:    <<Q0>> -> <<Q>> in alternative  for [serial 2777]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 1159 1159:
Theorem (1159) [serial 2799] used for:
   add user-defined axioms to postcondition 
Theorem (1159) [serial 2799] used for:
   add user-defined axioms to postcondition 


Theorem (1161)                               [serial 2811] 
P [149] << goodCount <= 0
  and RUN_AV() >>
S [149] ->
Q [155] << RUN_AV() >>
Why created:    normalization of [serial 2785]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1162)                               [serial 2785] 
P [149] << RUN_AV()
  and ( goodCount <= 0 ) >>
S [149] ->
Q [155] << RUN_AV() >>
Why created:    <<P and B1>> -> <<P1>> in alternative for [serial 2777]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1161:
Theorem (1161) [serial 2811] used for:
    normalization of [serial 2785] 


Theorem (1163)                               [serial 3002] 
P [155] << ub - lb = window_size
  and INV_AV() >>
S [155] ->
Q [155] << ub - lb = window_size
  and INV_AV() >>
Why created:    <<P>> -> <<Q>>
  for [serial 2910]
Solved by:  Identity (id):  P->P is tautology


Theorem (1164)                               [serial 2910] 
P [155] << ub - lb = window_size
  and INV_AV() >>
S [155] skip
Q [155] << ub - lb = window_size
  and INV_AV() >>
Why created:    normalization of [serial 2893]
Solved by:  Skip Means Implication:  <<P>> skip <<Q>>  is  <<P>> -> <<Q>>
and theorem 1163:
Theorem (1163) [serial 3002] used for:
    <<P>> -> <<Q>>
  for [serial 2910] 


Theorem (1165)                               [serial 2893] 
P [155] << ( INV_AV()
  and ( ( ub - lb ) = window_size ) ) >>
S [155] skip
Q [155] << ( INV_AV()
  and ( ( ub - lb ) = window_size ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2786]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1164:
Theorem (1164) [serial 2910] used for:
    normalization of [serial 2893] 


Theorem (1166)                               [serial 2786] 
P [155] << RUN_AV() >>
S [155] skip
Q [155] << RUN_AV() >>
Why created:    <<P1>> S1 <<Q1>> in alternative for [serial 2777]
Solved by:  Substitution of Assertion Labels
and theorem 1165:
Theorem (1165) [serial 2893] used for:
  Substituted assertions' predicates for labels  [serial 2786] 


Theorem (1167)                               [serial 2879] 
P [155] << RUN_AV() >>
S [149] ->
Q [158] << RUN_AV() >>
Why created:    normalization of [serial 2857]
Solved by:  Identity (id):  P->P is tautology


Theorem (1168)                               [serial 2857] 
P [155] << RUN_AV() >>
S [149] ->
Q [158] << ( RUN_AV() ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 2800]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1167:
Theorem (1167) [serial 2879] used for:
    normalization of [serial 2857] 


Theorem (1169)                               [serial 2800] 
P [155] << RUN_AV() >>
S [149] ->
Q [158] << RUN_AV()
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 1168:
Theorem (1168) [serial 2857] used for:
  Law of And-Simplification:  P and true is P [serial 2800] 


Theorem (1170)                               [serial 2879] 
P [155] << RUN_AV() >>
S [149] ->
Q [158] << RUN_AV() >>
Why created:    normalization of [serial 2857]
Solved by:  Identity (id):  P->P is tautology


Theorem (1171)                               [serial 2857] 
P [155] << RUN_AV() >>
S [149] ->
Q [158] << ( RUN_AV() ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 2800]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1170:
Theorem (1170) [serial 2879] used for:
    normalization of [serial 2857] 


Theorem (1172)                               [serial 2800] 
P [155] << RUN_AV() >>
S [149] ->
Q [158] << RUN_AV()
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 1171:
Theorem (1171) [serial 2857] used for:
  Law of And-Simplification:  P and true is P [serial 2800] 


Theorem (1173)                               [serial 2787] 
P [155] << RUN_AV() >>
S [149] ->
Q [158] << RUN_AV()
  and AXIOM_LB() >>
Why created:    <<Q1>> -> <<Q>> in alternative  for [serial 2777]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 1172 1172:
Theorem (1172) [serial 2800] used for:
   add user-defined axioms to postcondition 
Theorem (1172) [serial 2800] used for:
   add user-defined axioms to postcondition 


Theorem (1174)                               [serial 2777] 
P [148] << RUN_AV() >>
S [149]   if 
    (goodCount > 0)~> 
      << RUN_AV()
        and ( goodCount > 0 )
        and AXIOM_K2I() >>
      SpO2Avg!(totalSpO2 / goodCount)
      << RUN_AV() >> 
  []
    (goodCount <= 0)~> 
      << RUN_AV() >>
      skip
      << RUN_AV() >> 
  fi
Q [158] << RUN_AV()
  and AXIOM_LB() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1053]
Solved by:  Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>>
and theorems 1121 1128 1153 1160 1162 1166 1173:
Theorem (1121) [serial 2781] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 2777] 
Theorem (1128) [serial 2782] used for:
    <<P and B0>> -> <<P0>> in alternative for [serial 2777] 
Theorem (1153) [serial 2783] used for:
    <<P0>> S0 <<Q0>> in alternative for [serial 2777] 
Theorem (1160) [serial 2784] used for:
    <<Q0>> -> <<Q>> in alternative  for [serial 2777] 
Theorem (1162) [serial 2785] used for:
    <<P and B1>> -> <<P1>> in alternative for [serial 2777] 
Theorem (1166) [serial 2786] used for:
    <<P1>> S1 <<Q1>> in alternative for [serial 2777] 
Theorem (1173) [serial 2787] used for:
    <<Q1>> -> <<Q>> in alternative  for [serial 2777] 


Theorem (1175)                               [serial 3136] 
P [158] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and lb < 1 + lb
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [160] ->
Q [160] << all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:  Contract Universal Quantification Range  [serial 3134]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1176)                               [serial 3134] 
P [158] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and lb < 1 + lb
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [160] ->
Q [160] << all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:    normalization of [serial 3132]
Solved by:  Contract Universal Quantification Range
and theorem 1175:
Theorem (1175) [serial 3136] used for:
  Contract Universal Quantification Range  [serial 3134] 


Theorem (1177)                               [serial 3132] 
P [158] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and lb < 1 + lb
  and ub - lb = window_size >>
S [160] ->
Q [160] << all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 3130]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1176:
Theorem (1176) [serial 3134] used for:
    normalization of [serial 3132] 


Theorem (1178)                               [serial 3130] 
P [158] << ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 )
  and lb < 1 + lb
  and ub - lb = window_size >>
S [160] ->
Q [160] << all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:    normalization of [serial 3128]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 1177:
Theorem (1177) [serial 3132] used for:
  Associativity: a.(b.c) = a.b.c [serial 3130] 


Theorem (1179)                               [serial 3128] 
P [158] << lb < 1 + lb
  and ub - lb = window_size
  and ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) ) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) ) >>
S [160] ->
Q [160] << all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 3127]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1178:
Theorem (1178) [serial 3130] used for:
    normalization of [serial 3128] 


Theorem (1180)                               [serial 3127] 
P [158] << lb < 1 + lb
  and ub - lb = window_size
  and ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) ) >>
S [160] ->
Q [160] << all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 3126]
Solved by:  Substitution of Assertion Labels
and theorem 1179:
Theorem (1179) [serial 3128] used for:
  Substituted assertions' predicates for labels in preconditions [serial 3127] 


Theorem (1181)                               [serial 3126] 
P [158] << lb < 1 + lb
  and ub - lb = window_size
  and ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() ) >>
S [160] ->
Q [160] << all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2975]
Solved by:  Substitution of Assertion Labels
and theorem 1180:
Theorem (1180) [serial 3127] used for:
  Substituted assertions' predicates for labels in preconditions [serial 3126] 


Theorem (1182)                               [serial 2975] 
P [158] << lb < 1 + lb
  and ub - lb = window_size
  and INV_AV() >>
S [160] ->
Q [160] << all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:    normalization of [serial 2956]
Solved by:  Substitution of Assertion Labels
and theorem 1181:
Theorem (1181) [serial 3126] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2975] 


Theorem (1183)                               [serial 2956] 
P [158] << ub - lb = window_size
  and INV_AV()
  and lb < 1 + lb >>
S [160] ->
Q [160] << all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2918]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1182:
Theorem (1182) [serial 2975] used for:
    normalization of [serial 2956] 


Theorem (1184)                               [serial 2918] 
P [158] << ( ub - lb = window_size
  and INV_AV() )
  and lb < 1 + lb >>
S [160] ->
Q [160] << all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:    normalization of [serial 2897]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 1183:
Theorem (1183) [serial 2956] used for:
  Associativity: a.(b.c) = a.b.c [serial 2918] 


Theorem (1185)                               [serial 2897] 
P [158] << ( lb < ( lb + 1 ) )
  and ( INV_AV()
  and ( ( ub - lb ) = window_size ) ) >>
S [160] ->
Q [160] << all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) ) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:  Substituted assertions' predicates for labels  [serial 2814]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1184:
Theorem (1184) [serial 2918] used for:
    normalization of [serial 2897] 


Theorem (1186)                               [serial 2814] 
P [158] << AXIOM_LB()
  and RUN_AV() >>
S [160] ->
Q [160] << all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:    normalization of [serial 2789]
Solved by:  Substitution of Assertion Labels
and theorem 1185:
Theorem (1185) [serial 2897] used for:
  Substituted assertions' predicates for labels  [serial 2814] 


Theorem (1187)                               [serial 2789] 
P [158] << RUN_AV()
  and AXIOM_LB() >>
S [160] ->
Q [160] << all k ~ quantity whole 
  in ( lb + 1 ) .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)  >>
Why created:  P -> P1 in concurrent composition for [serial 2788]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1186:
Theorem (1186) [serial 2814] used for:
    normalization of [serial 2789] 


Theorem (1188)                               [serial 3150] 
P [158] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and lb < 1 + lb
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [169] ->
Q [170] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] >>
Why created:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 3147]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1189)                               [serial 3147] 
P [158] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and lb < 1 + lb
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [169] ->
Q [170] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3145]
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
and theorem 1188:
Theorem (1188) [serial 3150] used for:
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 3147] 


Theorem (1190)                               [serial 3151] 
P [158] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and lb < 1 + lb
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [169] ->
Q [169] << ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 >>
Why created:  No reason  [serial 3148]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1191)                               [serial 3148] 
P [158] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and lb < 1 + lb
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [169] ->
Q [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3145]
Solved by:  No reason
and theorem 1190:
Theorem (1190) [serial 3151] used for:
  No reason  [serial 3148] 


Theorem (1192)                               [serial 3149] 
P [158] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and lb < 1 + lb
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [169] ->
Q [171] << ub - lb = window_size >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3145]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1193)                               [serial 3145] 
P [158] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and lb < 1 + lb
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [169] ->
Q [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
Why created:    normalization of [serial 3143]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1189 1191 1192:
Theorem (1189) [serial 3147] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3145] 
Theorem (1191) [serial 3148] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3145] 
Theorem (1192) [serial 3149] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3145] 


Theorem (1194)                               [serial 3143] 
P [158] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and lb < 1 + lb
  and ub - lb = window_size >>
S [169] ->
Q [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 3141]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1193:
Theorem (1193) [serial 3145] used for:
    normalization of [serial 3143] 


Theorem (1195)                               [serial 3141] 
P [158] << ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 )
  and lb < 1 + lb
  and ub - lb = window_size >>
S [169] ->
Q [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
Why created:    normalization of [serial 3139]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 1194:
Theorem (1194) [serial 3143] used for:
  Associativity: a.(b.c) = a.b.c [serial 3141] 


Theorem (1196)                               [serial 3139] 
P [158] << lb < 1 + lb
  and ub - lb = window_size
  and ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) ) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) ) >>
S [169] ->
Q [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 3138]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1195:
Theorem (1195) [serial 3141] used for:
    normalization of [serial 3139] 


Theorem (1197)                               [serial 3138] 
P [158] << lb < 1 + lb
  and ub - lb = window_size
  and ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) ) >>
S [169] ->
Q [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 3137]
Solved by:  Substitution of Assertion Labels
and theorem 1196:
Theorem (1196) [serial 3139] used for:
  Substituted assertions' predicates for labels in preconditions [serial 3138] 


Theorem (1198)                               [serial 3137] 
P [158] << lb < 1 + lb
  and ub - lb = window_size
  and ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() ) >>
S [169] ->
Q [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2977]
Solved by:  Substitution of Assertion Labels
and theorem 1197:
Theorem (1197) [serial 3138] used for:
  Substituted assertions' predicates for labels in preconditions [serial 3137] 


Theorem (1199)                               [serial 2977] 
P [158] << lb < 1 + lb
  and ub - lb = window_size
  and INV_AV() >>
S [169] ->
Q [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
Why created:    normalization of [serial 2957]
Solved by:  Substitution of Assertion Labels
and theorem 1198:
Theorem (1198) [serial 3137] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2977] 


Theorem (1200)                               [serial 2957] 
P [158] << ub - lb = window_size
  and INV_AV()
  and lb < 1 + lb >>
S [169] ->
Q [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2920]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1199:
Theorem (1199) [serial 2977] used for:
    normalization of [serial 2957] 


Theorem (1201)                               [serial 2920] 
P [158] << ( ub - lb = window_size
  and INV_AV() )
  and lb < 1 + lb >>
S [169] ->
Q [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
Why created:    normalization of [serial 2898]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 1200:
Theorem (1200) [serial 2957] used for:
  Associativity: a.(b.c) = a.b.c [serial 2920] 


Theorem (1202)                               [serial 2898] 
P [158] << ( lb < ( lb + 1 ) )
  and ( INV_AV()
  and ( ( ub - lb ) = window_size ) ) >>
S [169] ->
Q [169] << ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) + 
( (if SENSOR_CONNECTED^( ( lb - ub ) )
  and not MOTION_ARTIFACT^( ( lb - ub ) ) then SPO2^( ( lb - ub ) ) else 0 percent) ) = totalSpO2
  and ub - lb = window_size
  and ( (if SENSOR_CONNECTED^( ( lb - ub ) )
  and not MOTION_ARTIFACT^( ( lb - ub ) ) then SPO2^( ( lb - ub ) ) else 0 percent) ) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] >>
Why created:  Substituted assertions' predicates for labels  [serial 2816]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1201:
Theorem (1201) [serial 2920] used for:
    normalization of [serial 2898] 


Theorem (1203)                               [serial 2816] 
P [158] << AXIOM_LB()
  and RUN_AV() >>
S [169] ->
Q [169] << ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of SSQ(k - ub)  ) + SSQ(lb - ub) = totalSpO2
  and ub - lb = window_size
  and SSQ(lb - ub) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] >>
Why created:    normalization of [serial 2790]
Solved by:  Substitution of Assertion Labels
and theorem 1202:
Theorem (1202) [serial 2898] used for:
  Substituted assertions' predicates for labels  [serial 2816] 


Theorem (1204)                               [serial 2790] 
P [158] << RUN_AV()
  and AXIOM_LB() >>
S [169] ->
Q [169] << ( totalSpO2 = ( SSQ(lb - ub) + ( sum k ~ quantity whole 
  in ( lb + 1 ) .. ( ub - 1 ) 
  of SSQ(k - ub)  ) ) )
  and ( spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] = SSQ(lb - ub) )
  and ( ( ub - lb ) = window_size ) >>
Why created:  P -> P2 in concurrent composition for [serial 2788]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1203:
Theorem (1203) [serial 2816] used for:
    normalization of [serial 2790] 


Theorem (1205)                               [serial 3169] 
P [158] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] )
  and lb < 1 + lb
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [176] ->
Q [179] << ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] >>
Why created:  Member of Universal Quantification: all k:t in l..u are p(k) -> p(l) and p(u)  [serial 3165]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1206)                               [serial 3165] 
P [158] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and lb < 1 + lb
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [176] ->
Q [179] << ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] >>
Why created:    normalization of [serial 3162]
Solved by:  Member of Universal Quantification: all k:t in l..u are p(k) -> p(l) and p(u)
and theorem 1205:
Theorem (1205) [serial 3169] used for:
  Member of Universal Quantification: all k:t in l..u are p(k) -> p(l) and p(u)  [serial 3165] 


Theorem (1207)                               [serial 3162] 
P [158] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and lb < 1 + lb
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [176] ->
Q [179] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3160]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1206:
Theorem (1206) [serial 3165] used for:
    normalization of [serial 3162] 


Theorem (1208)                               [serial 3168] 
P [158] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and lb < 1 + lb
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [176] ->
Q [176] << ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 3163]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1209)                               [serial 3163] 
P [158] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and lb < 1 + lb
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [176] ->
Q [176] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) + ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3160]
Solved by:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))
and theorem 1208:
Theorem (1208) [serial 3168] used for:
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 3163] 


Theorem (1210)                               [serial 3160] 
P [158] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and lb < 1 + lb
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [176] ->
Q [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) + ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:    normalization of [serial 3158]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1207 1209:
Theorem (1207) [serial 3162] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3160] 
Theorem (1209) [serial 3163] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3160] 


Theorem (1211)                               [serial 3158] 
P [158] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and lb < 1 + lb
  and ub - lb = window_size >>
S [176] ->
Q [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) + ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 3156]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1210:
Theorem (1210) [serial 3160] used for:
    normalization of [serial 3158] 


Theorem (1212)                               [serial 3156] 
P [158] << ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 )
  and lb < 1 + lb
  and ub - lb = window_size >>
S [176] ->
Q [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) + ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:    normalization of [serial 3154]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 1211:
Theorem (1211) [serial 3158] used for:
  Associativity: a.(b.c) = a.b.c [serial 3156] 


Theorem (1213)                               [serial 3154] 
P [158] << lb < 1 + lb
  and ub - lb = window_size
  and ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) ) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) ) >>
S [176] ->
Q [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) + ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 3153]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1212:
Theorem (1212) [serial 3156] used for:
    normalization of [serial 3154] 


Theorem (1214)                               [serial 3153] 
P [158] << lb < 1 + lb
  and ub - lb = window_size
  and ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) ) >>
S [176] ->
Q [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) + ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 3152]
Solved by:  Substitution of Assertion Labels
and theorem 1213:
Theorem (1213) [serial 3154] used for:
  Substituted assertions' predicates for labels in preconditions [serial 3153] 


Theorem (1215)                               [serial 3152] 
P [158] << lb < 1 + lb
  and ub - lb = window_size
  and ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() ) >>
S [176] ->
Q [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) + ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2979]
Solved by:  Substitution of Assertion Labels
and theorem 1214:
Theorem (1214) [serial 3153] used for:
  Substituted assertions' predicates for labels in preconditions [serial 3152] 


Theorem (1216)                               [serial 2979] 
P [158] << lb < 1 + lb
  and ub - lb = window_size
  and INV_AV() >>
S [176] ->
Q [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) + ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:    normalization of [serial 2958]
Solved by:  Substitution of Assertion Labels
and theorem 1215:
Theorem (1215) [serial 3152] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2979] 


Theorem (1217)                               [serial 2958] 
P [158] << ub - lb = window_size
  and INV_AV()
  and lb < 1 + lb >>
S [176] ->
Q [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) + ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2922]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1216:
Theorem (1216) [serial 2979] used for:
    normalization of [serial 2958] 


Theorem (1218)                               [serial 2922] 
P [158] << ( ub - lb = window_size
  and INV_AV() )
  and lb < 1 + lb >>
S [176] ->
Q [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) + ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:    normalization of [serial 2899]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 1217:
Theorem (1217) [serial 2958] used for:
  Associativity: a.(b.c) = a.b.c [serial 2922] 


Theorem (1219)                               [serial 2899] 
P [158] << ( lb < ( lb + 1 ) )
  and ( INV_AV()
  and ( ( ub - lb ) = window_size ) ) >>
S [176] ->
Q [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) + ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Substituted assertions' predicates for labels  [serial 2818]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1218:
Theorem (1218) [serial 2922] used for:
    normalization of [serial 2899] 


Theorem (1220)                               [serial 2818] 
P [158] << AXIOM_LB()
  and RUN_AV() >>
S [176] ->
Q [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) + ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:    normalization of [serial 2791]
Solved by:  Substitution of Assertion Labels
and theorem 1219:
Theorem (1219) [serial 2899] used for:
  Substituted assertions' predicates for labels  [serial 2818] 


Theorem (1221)                               [serial 2791] 
P [158] << RUN_AV()
  and AXIOM_LB() >>
S [176] ->
Q [176] << ( goodCount = ( (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) + ( numberof k ~ quantity whole 
  in ( lb + 1 ) .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) )
  and ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] ) >>
Why created:  P -> P3 in concurrent composition for [serial 2788]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1220:
Theorem (1220) [serial 2818] used for:
    normalization of [serial 2791] 


Theorem (1222)                               [serial 3178] 
P [158] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and lb < 1 + lb
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [188] ->
Q [188] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:    normalization of [serial 3176]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1223)                               [serial 3176] 
P [158] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and lb < 1 + lb
  and ub - lb = window_size >>
S [188] ->
Q [188] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 3174]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1222:
Theorem (1222) [serial 3178] used for:
    normalization of [serial 3176] 


Theorem (1224)                               [serial 3174] 
P [158] << ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 )
  and lb < 1 + lb
  and ub - lb = window_size >>
S [188] ->
Q [188] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:    normalization of [serial 3172]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 1223:
Theorem (1223) [serial 3176] used for:
  Associativity: a.(b.c) = a.b.c [serial 3174] 


Theorem (1225)                               [serial 3172] 
P [158] << lb < 1 + lb
  and ub - lb = window_size
  and ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) ) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) ) >>
S [188] ->
Q [188] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 3171]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1224:
Theorem (1224) [serial 3174] used for:
    normalization of [serial 3172] 


Theorem (1226)                               [serial 3171] 
P [158] << lb < 1 + lb
  and ub - lb = window_size
  and ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) )  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ub)  ) )
  and ( goodCount = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) ) >>
S [188] ->
Q [188] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 3170]
Solved by:  Substitution of Assertion Labels
and theorem 1225:
Theorem (1225) [serial 3172] used for:
  Substituted assertions' predicates for labels in preconditions [serial 3171] 


Theorem (1227)                               [serial 3170] 
P [158] << lb < 1 + lb
  and ub - lb = window_size
  and ( WINDOW()
  and TOTAL_SPO2()
  and GOOD()
  and GS() ) >>
S [188] ->
Q [188] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 2981]
Solved by:  Substitution of Assertion Labels
and theorem 1226:
Theorem (1226) [serial 3171] used for:
  Substituted assertions' predicates for labels in preconditions [serial 3170] 


Theorem (1228)                               [serial 2981] 
P [158] << lb < 1 + lb
  and ub - lb = window_size
  and INV_AV() >>
S [188] ->
Q [188] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:    normalization of [serial 2959]
Solved by:  Substitution of Assertion Labels
and theorem 1227:
Theorem (1227) [serial 3170] used for:
  Substituted assertions' predicates for labels in preconditions [serial 2981] 


Theorem (1229)                               [serial 2959] 
P [158] << ub - lb = window_size
  and INV_AV()
  and lb < 1 + lb >>
S [188] ->
Q [188] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:  Associativity: a.(b.c) = a.b.c [serial 2924]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1228:
Theorem (1228) [serial 2981] used for:
    normalization of [serial 2959] 


Theorem (1230)                               [serial 2924] 
P [158] << ( ub - lb = window_size
  and INV_AV() )
  and lb < 1 + lb >>
S [188] ->
Q [188] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:    normalization of [serial 2900]
Solved by:  Associativity: a.(b.c) = a.b.c
and theorem 1229:
Theorem (1229) [serial 2959] used for:
  Associativity: a.(b.c) = a.b.c [serial 2924] 


Theorem (1231)                               [serial 2900] 
P [158] << ( lb < ( lb + 1 ) )
  and ( INV_AV()
  and ( ( ub - lb ) = window_size ) ) >>
S [188] ->
Q [188] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2820]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1230:
Theorem (1230) [serial 2924] used for:
    normalization of [serial 2900] 


Theorem (1232)                               [serial 2820] 
P [158] << AXIOM_LB()
  and RUN_AV() >>
S [188] ->
Q [188] << GS() >>
Why created:    normalization of [serial 2792]
Solved by:  Substitution of Assertion Labels
and theorem 1231:
Theorem (1231) [serial 2900] used for:
  Substituted assertions' predicates for labels  [serial 2820] 


Theorem (1233)                               [serial 2792] 
P [158] << RUN_AV()
  and AXIOM_LB() >>
S [188] ->
Q [188] << GS() >>
Why created:  P -> P4 in concurrent composition for [serial 2788]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1232:
Theorem (1232) [serial 2820] used for:
    normalization of [serial 2792] 


Theorem (1234)                               [serial 3013] 
P [160] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and lb < 1 + lb
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) = goodCount
  and ub - lb = window_size >>
S [165] ->
Q [194] << all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 3008]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1235)                               [serial 3008] 
P [160] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and lb < 1 + lb
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ( (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) = goodCount
  and ub - lb = window_size >>
S [165] ->
Q [194] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2926]
Solved by:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))
and theorem 1234:
Theorem (1234) [serial 3013] used for:
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 3008] 


Theorem (1236)                               [serial 3022] 
P [160] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and lb < 1 + lb
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [165] ->
Q [198] << all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:  Contract Universal Quantification Range  [serial 3020]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1237)                               [serial 3020] 
P [160] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and lb < 1 + lb
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [165] ->
Q [198] << all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 3017]
Solved by:  Contract Universal Quantification Range
and theorem 1236:
Theorem (1236) [serial 3022] used for:
  Contract Universal Quantification Range  [serial 3020] 


Theorem (1238)                               [serial 3017] 
P [160] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and lb < 1 + lb
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [165] ->
Q [198] << all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))  [serial 3014]
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
and theorem 1237:
Theorem (1237) [serial 3020] used for:
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 3017] 


Theorem (1239)                               [serial 3014] 
P [160] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and lb < 1 + lb
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) = goodCount
  and ub - lb = window_size >>
S [165] ->
Q [198] << all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 3009]
Solved by:  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))
and theorem 1238:
Theorem (1238) [serial 3017] used for:
  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))  [serial 3014] 


Theorem (1240)                               [serial 3009] 
P [160] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and lb < 1 + lb
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ( (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) = goodCount
  and ub - lb = window_size >>
S [165] ->
Q [198] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2926]
Solved by:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))
and theorem 1239:
Theorem (1239) [serial 3014] used for:
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 3009] 


Theorem (1241)                               [serial 3018] 
P [160] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and lb < 1 + lb
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [165] ->
Q [197] << ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))  [serial 3015]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1242)                               [serial 3015] 
P [160] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and lb < 1 + lb
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) = goodCount
  and ub - lb = window_size >>
S [165] ->
Q [197] << ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 3010]
Solved by:  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))
and theorem 1241:
Theorem (1241) [serial 3018] used for:
  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))  [serial 3015] 


Theorem (1243)                               [serial 3010] 
P [160] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and lb < 1 + lb
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ( (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) = goodCount
  and ub - lb = window_size >>
S [165] ->
Q [197] << ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2926]
Solved by:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))
and theorem 1242:
Theorem (1242) [serial 3015] used for:
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 3010] 


Theorem (1244)                               [serial 3021] 
P [160] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and lb < 1 + lb
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [165] ->
Q [196] << ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 >>
Why created:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 3019]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1245)                               [serial 3019] 
P [160] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and lb < 1 + lb
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [165] ->
Q [196] << ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 >>
Why created:  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))  [serial 3016]
Solved by:  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
and theorem 1244:
Theorem (1244) [serial 3021] used for:
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)  [serial 3019] 


Theorem (1246)                               [serial 3016] 
P [160] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and lb < 1 + lb
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) = goodCount
  and ub - lb = window_size >>
S [165] ->
Q [196] << ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 >>
Why created:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 3011]
Solved by:  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))
and theorem 1245:
Theorem (1245) [serial 3019] used for:
  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))  [serial 3016] 


Theorem (1247)                               [serial 3011] 
P [160] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and lb < 1 + lb
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ( (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) = goodCount
  and ub - lb = window_size >>
S [165] ->
Q [196] << ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2926]
Solved by:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))
and theorem 1246:
Theorem (1246) [serial 3016] used for:
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 3011] 


Theorem (1248)                               [serial 3012] 
P [160] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and lb < 1 + lb
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ( (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) = goodCount
  and ub - lb = window_size >>
S [165] ->
Q [196] << ub - lb = window_size >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2926]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1249)                               [serial 2926] 
P [160] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and lb < 1 + lb
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ( (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) = goodCount
  and ub - lb = window_size >>
S [165] ->
Q [194] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
Why created:    normalization of [serial 2901]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1235 1240 1243 1247 1248:
Theorem (1235) [serial 3008] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2926] 
Theorem (1240) [serial 3009] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2926] 
Theorem (1243) [serial 3010] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2926] 
Theorem (1247) [serial 3011] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2926] 
Theorem (1248) [serial 3012] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2926] 


Theorem (1250)                               [serial 2901] 
P [160] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) ) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) + 
( (if SENSOR_CONNECTED^( 0 )
  and not MOTION_ARTIFACT^( 0 ) then SPO2^( 0 ) else 0 percent) ) = totalSpO2
  and ( (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) = goodCount
  and ub - lb = window_size
  and ( (if SENSOR_CONNECTED^( 0 )
  and not MOTION_ARTIFACT^( 0 ) then SPO2^( 0 ) else 0 percent) ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and ( lb < ( lb + 1 ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
S [165] ->
Q [194] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) ) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) = totalSpO2
  and ub - lb = window_size >>
Why created:  Substituted assertions' predicates for labels  [serial 2822]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1249:
Theorem (1249) [serial 2926] used for:
    normalization of [serial 2901] 


Theorem (1251)                               [serial 2822] 
P [160] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of SSQ(k - ub)  ) + SSQ(x : 0) = totalSpO2
  and ( (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) = goodCount
  and ub - lb = window_size
  and SSQ(x : 0) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples]
  and AXIOM_LB()
  and GS() >>
S [165] ->
Q [194] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of SSQ(k - ub)  ) = totalSpO2
  and ub - lb = window_size >>
Why created:    normalization of [serial 2793]
Solved by:  Substitution of Assertion Labels
and theorem 1250:
Theorem (1250) [serial 2901] used for:
  Substituted assertions' predicates for labels  [serial 2822] 


Theorem (1252)                               [serial 2793] 
P [160] << ( ( all k ~ quantity whole 
  in ( lb + 1 ) .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)  ) )
  and ( ( spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x : 0) ) )
  and ( ( totalSpO2 = ( SSQ(x : 0) + ( sum k ~ quantity whole 
  in ( lb + 1 ) .. ( ub - 1 ) 
  of SSQ(k - ub)  ) ) ) )
  and ( ( ( ub - lb ) = window_size ) )
  and ( goodCount = ( ( (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) ) )
  and ( ( goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) ) )
  and GS()
  and AXIOM_LB() >>
S [165] ->
Q [194] << ( all k ~ quantity whole 
  in ( lb + 1 ) .. ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in ( lb + 1 ) .. ub 
  of SSQ(k - ub)  ) )
  and ( ( ub - lb ) = window_size )
  and ( goodCount = ( numberof k ~ quantity whole 
  in ( lb + 1 ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in ( lb + 1 ) .. ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
Why created:  Q1 and Q2 and  . . . and Qn -> Q in concurrent composition for [serial 2788]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1251:
Theorem (1251) [serial 2822] used for:
    normalization of [serial 2793] 


Theorem (1253)                               [serial 3030] 
P [160] << all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [163] ->
Q [165] << all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:    normalization of [serial 3028]
Solved by:  Identity (id):  P->P is tautology


Theorem (1254)                               [serial 3028] 
P [160] << all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [163] ->
Q [165] << ( ( all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  ) ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 3027]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1253:
Theorem (1253) [serial 3030] used for:
    normalization of [serial 3028] 


Theorem (1255)                               [serial 3027] 
P [160] << all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [163] ->
Q [165] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 3025]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 1254:
Theorem (1254) [serial 3028] used for:
  Law of And-Simplification:  P and true is P [serial 3027] 


Theorem (1256)                               [serial 3025] 
P [160] << all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [163] ->
Q [165] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) >>
Why created:    normalization of [serial 3023]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 1255:
Theorem (1255) [serial 3027] used for:
  Equality Law (idistr):  a=a <-> true [serial 3025] 


Theorem (1257)                               [serial 3023] 
P [160] << all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [163] ->
Q [165] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = ( (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) ) >>
Why created:  applied wp for assignment [serial 2928]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1256:
Theorem (1256) [serial 3025] used for:
    normalization of [serial 3023] 


Theorem (1258)                               [serial 2928] 
P [160] << all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [163] spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] := (if SensorConnected?
  and not MotionArtifact? then SpO2? else 0 percent)
Q [165] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] >>
Why created:    normalization of [serial 2902]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 1257:
Theorem (1257) [serial 3023] used for:
  applied wp for assignment [serial 2928] 


Theorem (1259)                               [serial 2902] 
P [160] << all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) ) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [163] spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] := (if SensorConnected?
  and not MotionArtifact? then SpO2? else 0 percent)
Q [165] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) ) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( (if SENSOR_CONNECTED^( 0 )
  and not MOTION_ARTIFACT^( 0 ) then SPO2^( 0 ) else 0 percent) ) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] >>
Why created:  Substituted assertions' predicates for labels  [serial 2824]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1258:
Theorem (1258) [serial 2928] used for:
    normalization of [serial 2902] 


Theorem (1260)                               [serial 2824] 
P [160] << all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [163] spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] := (if SensorConnected?
  and not MotionArtifact? then SpO2? else 0 percent)
Q [165] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and SSQ(x : 0) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] >>
Why created:    normalization of [serial 2794]
Solved by:  Substitution of Assertion Labels
and theorem 1259:
Theorem (1259) [serial 2902] used for:
  Substituted assertions' predicates for labels  [serial 2824] 


Theorem (1261)                               [serial 2794] 
P [160] << all k ~ quantity whole 
  in ( lb + 1 ) .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)  >>
S [163] spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] := (if SensorConnected?
  and not MotionArtifact? then SpO2? else 0 percent)
Q [165] << ( all k ~ quantity whole 
  in ( lb + 1 ) .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)  )
  and ( spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x : 0) ) >>
Why created:  <<P1>> S1 <<Q1>> in concurrent composition for [serial 2788]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1260:
Theorem (1260) [serial 2824] used for:
    normalization of [serial 2794] 


Theorem (1262)                               [serial 3055] 
P [169] << (if SENSOR_CONNECTED^( - ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^( - ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( - ub + k )
       and not MOTION_ARTIFACT^( - ub + k ) then SPO2^( - ub + k ) else 0 percent)  ) = totalSpO2
  and - lb + ub = window_size >>
S [172] ->
Q [174] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 3053]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (1263)                               [serial 3053] 
P [169] << (if SENSOR_CONNECTED^( - ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^( - ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( - ub + k )
       and not MOTION_ARTIFACT^( - ub + k ) then SPO2^( - ub + k ) else 0 percent)  ) = totalSpO2
  and - lb + ub = window_size >>
S [172] ->
Q [174] << ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( - ub + k )
       and not MOTION_ARTIFACT^( - ub + k ) then SPO2^( - ub + k ) else 0 percent)  ) = ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( - ub + k )
       and not MOTION_ARTIFACT^( - ub + k ) then SPO2^( - ub + k ) else 0 percent)  ) >>
Why created:    normalization of [serial 3051]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 1262:
Theorem (1262) [serial 3055] used for:
  Equality Law (idistr):  a=a <-> true [serial 3053] 


Theorem (1264)                               [serial 3051] 
P [169] << (if SENSOR_CONNECTED^( - ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^( - ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub + - 1 ) 
  of (if SENSOR_CONNECTED^( - ub + k )
       and not MOTION_ARTIFACT^( - ub + k ) then SPO2^( - ub + k ) else 0 percent)  ) = totalSpO2
  and - lb + ub = window_size >>
S [172] ->
Q [174] << ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub + - 1 ) 
  of (if SENSOR_CONNECTED^( - ub + k )
       and not MOTION_ARTIFACT^( - ub + k ) then SPO2^( - ub + k ) else 0 percent)  ) = 
(if SENSOR_CONNECTED^( - ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub + - 1 ) 
  of (if SENSOR_CONNECTED^( - ub + k )
       and not MOTION_ARTIFACT^( - ub + k ) then SPO2^( - ub + k ) else 0 percent)  ) + 
- ( (if SENSOR_CONNECTED^( - ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0 percent) ) >>
Why created:   changing adding negation to subtraction  [serial 3050]
Solved by:  Subtaction of Added Value:  (a+b)-a is b
  Reflexivity of Addition: a+b=b+a
  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1263:
Theorem (1263) [serial 3053] used for:
    normalization of [serial 3051] 


Theorem (1265)                               [serial 3050] 
P [169] << (if SENSOR_CONNECTED^( - ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^( - ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( - ub + k )
       and not MOTION_ARTIFACT^( - ub + k ) then SPO2^( - ub + k ) else 0 percent)  ) = totalSpO2
  and - lb + ub = window_size >>
S [172] ->
Q [174] << ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( - ub + k )
       and not MOTION_ARTIFACT^( - ub + k ) then SPO2^( - ub + k ) else 0 percent)  ) = ( 
(if SENSOR_CONNECTED^( - ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( - ub + k )
       and not MOTION_ARTIFACT^( - ub + k ) then SPO2^( - ub + k ) else 0 percent)  ) ) - (if SENSOR_CONNECTED^( 
- ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0 percent) >>
Why created:  Guided Substitution of Equals 
 replacing "totalSpO2" with its = "( (if SENSOR_CONNECTED^( - ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( - ub + k )
       and not MOTION_ARTIFACT^( - ub + k ) then SPO2^( - ub + k ) else 0 percent)  ) )" in its postcondition [serial 3048]
Solved by:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 1264:
Theorem (1264) [serial 3051] used for:
   changing adding negation to subtraction  [serial 3050] 


Theorem (1266)                               [serial 3048] 
P [169] << (if SENSOR_CONNECTED^( - ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^( - ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( - ub + k )
       and not MOTION_ARTIFACT^( - ub + k ) then SPO2^( - ub + k ) else 0 percent)  ) = totalSpO2
  and - lb + ub = window_size >>
S [172] ->
Q [174] << ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( - ub + k )
       and not MOTION_ARTIFACT^( - ub + k ) then SPO2^( - ub + k ) else 0 percent)  ) = totalSpO2 - (if SENSOR_CONNECTED^( 
- ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0 percent) >>
Why created:    normalization of [serial 3046]
Solved by:  Guided Substitution of Equals
and theorem 1265:
Theorem (1265) [serial 3050] used for:
  Guided Substitution of Equals 
 replacing "totalSpO2" with its = "( (if SENSOR_CONNECTED^( - ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( - ub + k )
       and not MOTION_ARTIFACT^( - ub + k ) then SPO2^( - ub + k ) else 0 percent)  ) )" in its postcondition [serial 3048] 


Theorem (1267)                               [serial 3046] 
P [169] << (if SENSOR_CONNECTED^( - ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^( - ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( - ub + k )
       and not MOTION_ARTIFACT^( - ub + k ) then SPO2^( - ub + k ) else 0 percent)  ) = totalSpO2
  and - lb + ub = window_size >>
S [172] ->
Q [174] << ( ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( - ub + k )
       and not MOTION_ARTIFACT^( - ub + k ) then SPO2^( - ub + k ) else 0 percent)  ) ) = ( 
- (if SENSOR_CONNECTED^( - ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0 percent) + 
totalSpO2 ) >>
Why created:  Add both sides of equality:  a=b -> x+a=x+b [serial 3044]
Solved by:  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1266:
Theorem (1266) [serial 3048] used for:
    normalization of [serial 3046] 


Theorem (1268)                               [serial 3044] 
P [169] << (if SENSOR_CONNECTED^( - ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^( - ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( - ub + k )
       and not MOTION_ARTIFACT^( - ub + k ) then SPO2^( - ub + k ) else 0 percent)  ) = totalSpO2
  and - lb + ub = window_size >>
S [172] ->
Q [174] << (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( - ub + k )
       and not MOTION_ARTIFACT^( - ub + k ) then SPO2^( - ub + k ) else 0 percent)  ) = 
(if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + - (if SENSOR_CONNECTED^( 
- ub + lb )
  and not MOTION_ARTIFACT^( - ub + lb ) then SPO2^( - ub + lb ) else 0 percent) + 
totalSpO2 >>
Why created:    normalization of [serial 3042]
Solved by:  Add both sides of equality:  a=b -> x+a=x+b
and theorem 1267:
Theorem (1267) [serial 3046] used for:
  Add both sides of equality:  a=b -> x+a=x+b [serial 3044] 


Theorem (1269)                               [serial 3042] 
P [169] << (if SENSOR_CONNECTED^( lb + - ub )
  and not MOTION_ARTIFACT^( lb + - ub ) then SPO2^( lb + - ub ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^( lb + - ub )
  and not MOTION_ARTIFACT^( lb + - ub ) then SPO2^( lb + - ub ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub + - 1 ) 
  of (if SENSOR_CONNECTED^( k + - ub )
       and not MOTION_ARTIFACT^( k + - ub ) then SPO2^( k + - ub ) else 0 percent)  ) = totalSpO2
  and ub + - lb = window_size >>
S [172] ->
Q [174] << (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub + - 1 ) 
  of (if SENSOR_CONNECTED^( k + - ub )
       and not MOTION_ARTIFACT^( k + - ub ) then SPO2^( k + - ub ) else 0 percent)  ) = 
(if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + totalSpO2 + - ( (if SENSOR_CONNECTED^( 
lb + - ub )
  and not MOTION_ARTIFACT^( lb + - ub ) then SPO2^( lb + - ub ) else 0 percent) ) >>
Why created:   changing adding negation to subtraction  [serial 3040]
Solved by:  Reflexivity of Addition: a+b=b+a
  Addition of unary minus:  (-j + i) is (i-j)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1268:
Theorem (1268) [serial 3044] used for:
    normalization of [serial 3042] 


Theorem (1270)                               [serial 3040] 
P [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [172] ->
Q [174] << (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = ( 
(if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + totalSpO2 ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) >>
Why created:    normalization of [serial 3038]
Solved by:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 1269:
Theorem (1269) [serial 3042] used for:
   changing adding negation to subtraction  [serial 3040] 


Theorem (1271)                               [serial 3038] 
P [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [172] ->
Q [174] << (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = ( 
(if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + totalSpO2 ) - ( (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) ) >>
Why created:  Guided Substitution of Equals 
 replacing "spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]" with its = "( (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) )" in its postcondition [serial 3036]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1270:
Theorem (1270) [serial 3040] used for:
    normalization of [serial 3038] 


Theorem (1272)                               [serial 3036] 
P [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [172] ->
Q [174] << (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = ( 
(if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + totalSpO2 ) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3034]
Solved by:  Guided Substitution of Equals
and theorem 1271:
Theorem (1271) [serial 3038] used for:
  Guided Substitution of Equals 
 replacing "spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]" with its = "( (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) )" in its postcondition [serial 3036] 


Theorem (1273)                               [serial 3037] 
P [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [172] ->
Q [174] << ub - lb = window_size >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3034]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (1274)                               [serial 3034] 
P [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [172] ->
Q [174] << (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = ( 
(if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + totalSpO2 ) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and ub - lb = window_size >>
Why created:    normalization of [serial 3032]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1272 1273:
Theorem (1272) [serial 3036] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3034] 
Theorem (1273) [serial 3037] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3034] 


Theorem (1275)                               [serial 3032] 
P [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [172] ->
Q [174] << (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = ( ( 
(if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + totalSpO2 ) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] )
  and ub - lb = window_size >>
Why created:  applied wp for assignment [serial 2930]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1274:
Theorem (1274) [serial 3034] used for:
    normalization of [serial 3032] 


Theorem (1276)                               [serial 2930] 
P [169] << (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then SPO2^( lb - ub ) else 0 percent) + 
( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [172] totalSpO2 := ( (if SensorConnected?
  and not MotionArtifact? then SpO2? else 0 percent) + totalSpO2 ) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
Q [174] << (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then SPO2^0 else 0 percent) + ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
Why created:    normalization of [serial 2903]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 1275:
Theorem (1275) [serial 3032] used for:
  applied wp for assignment [serial 2930] 


Theorem (1277)                               [serial 2903] 
P [169] << ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) + 
( (if SENSOR_CONNECTED^( ( lb - ub ) )
  and not MOTION_ARTIFACT^( ( lb - ub ) ) then SPO2^( ( lb - ub ) ) else 0 percent) ) = totalSpO2
  and ub - lb = window_size
  and ( (if SENSOR_CONNECTED^( ( lb - ub ) )
  and not MOTION_ARTIFACT^( ( lb - ub ) ) then SPO2^( ( lb - ub ) ) else 0 percent) ) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] >>
S [172] totalSpO2 := ( (if SensorConnected?
  and not MotionArtifact? then SpO2? else 0 percent) + totalSpO2 ) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
Q [174] << ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) + 
( (if SENSOR_CONNECTED^( 0 )
  and not MOTION_ARTIFACT^( 0 ) then SPO2^( 0 ) else 0 percent) ) = totalSpO2
  and ub - lb = window_size >>
Why created:  Substituted assertions' predicates for labels  [serial 2826]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1276:
Theorem (1276) [serial 2930] used for:
    normalization of [serial 2903] 


Theorem (1278)                               [serial 2826] 
P [169] << ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of SSQ(k - ub)  ) + SSQ(lb - ub) = totalSpO2
  and ub - lb = window_size
  and SSQ(lb - ub) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] >>
S [172] totalSpO2 := ( (if SensorConnected?
  and not MotionArtifact? then SpO2? else 0 percent) + totalSpO2 ) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
Q [174] << ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  of SSQ(k - ub)  ) + SSQ(x : 0) = totalSpO2
  and ub - lb = window_size >>
Why created:    normalization of [serial 2795]
Solved by:  Substitution of Assertion Labels
and theorem 1277:
Theorem (1277) [serial 2903] used for:
  Substituted assertions' predicates for labels  [serial 2826] 


Theorem (1279)                               [serial 2795] 
P [169] << ( totalSpO2 = ( SSQ(lb - ub) + ( sum k ~ quantity whole 
  in ( lb + 1 ) .. ( ub - 1 ) 
  of SSQ(k - ub)  ) ) )
  and ( spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] = SSQ(lb - ub) )
  and ( ( ub - lb ) = window_size ) >>
S [172] totalSpO2 := ( totalSpO2 + (if SensorConnected?
  and not MotionArtifact? then SpO2? else 0 percent) ) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
Q [174] << ( totalSpO2 = ( SSQ(x : 0) + ( sum k ~ quantity whole 
  in ( lb + 1 ) .. ( ub - 1 ) 
  of SSQ(k - ub)  ) ) )
  and ( ( ub - lb ) = window_size ) >>
Why created:  <<P2>> S2 <<Q2>> in concurrent composition for [serial 2788]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1278:
Theorem (1278) [serial 2826] used for:
    normalization of [serial 2795] 


Theorem (1280)                               [serial 3001] 
P [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
S [181] ->
Q [183] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 3000]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (1281)                               [serial 3000] 
P [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
S [181] ->
Q [183] << ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) >>
Why created:  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))  [serial 2999]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 1280:
Theorem (1280) [serial 3001] used for:
  Equality Law (idistr):  a=a <-> true [serial 3000] 


Theorem (1282)                               [serial 2999] 
P [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
S [181] ->
Q [183] << ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) >>
Why created:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2998]
Solved by:  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))
and theorem 1281:
Theorem (1281) [serial 3000] used for:
  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))  [serial 2999] 


Theorem (1283)                               [serial 2998] 
P [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
S [181] ->
Q [183] << ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = ( (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) >>
Why created:  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>> 
 replacing "goodCount"
 with its ="
 ( ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )" [serial 2997]
Solved by:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))
and theorem 1282:
Theorem (1282) [serial 2999] used for:
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2998] 


Theorem (1284)                               [serial 2997] 
P [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
S [181] ->
Q [183] << ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = ( (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + goodCount ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) >>
Why created:  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))  [serial 2996]
Solved by:  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
and theorem 1283:
Theorem (1283) [serial 2998] used for:
  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>> 
 replacing "goodCount"
 with its ="
 ( ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )" [serial 2997] 


Theorem (1285)                               [serial 2996] 
P [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
S [181] ->
Q [183] << ( (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + goodCount ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) = ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) >>
Why created:  Substitution of Equivalents:
  <<...P[a|b] and (a iff b)>> S <<Q>>
  ----------------------
   <<...P and (a iff b)>> S <<Q>> 
 replacing "goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples]"
 with its iff"
 ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) )" [serial 2995]
Solved by:  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))
and theorem 1284:
Theorem (1284) [serial 2997] used for:
  Extend Numberof:  
if P(ub)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub-1 that P(j))
if P(lb)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb+1..ub that P(j))  [serial 2996] 


Theorem (1286)                               [serial 2995] 
P [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] )
  and ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
S [181] ->
Q [183] << ( (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + goodCount ) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] then 1 else 0) = ( numberof k ~ quantity whole 
  in lb .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) >>
Why created:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2993]
Solved by:  Substitution of Equivalents:
  <<...P[a|b] and (a iff b)>> S <<Q>>
  ----------------------
   <<...P and (a iff b)>> S <<Q>>
and theorem 1285:
Theorem (1285) [serial 2996] used for:
  Substitution of Equivalents:
  <<...P[a|b] and (a iff b)>> S <<Q>>
  ----------------------
   <<...P and (a iff b)>> S <<Q>> 
 replacing "goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples]"
 with its iff"
 ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) )" [serial 2995] 


Theorem (1287)                               [serial 2993] 
P [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) + ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
S [181] ->
Q [183] << ( (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) = ( (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + goodCount ) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] then 1 else 0) >>
Why created:    normalization of [serial 2991]
Solved by:  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))
and theorem 1286:
Theorem (1286) [serial 2995] used for:
  Contract Numberof:  
if P(ub+1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb..ub+1 that P(j))
if P(lb-1)=term -> (numberof j:integer in lb..ub that P(j))-(term??1:0) = (numberof j:integer in lb-1..ub that P(j))  [serial 2993] 


Theorem (1288)                               [serial 2991] 
P [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) + ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
S [181] ->
Q [183] << ( (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) = ( ( (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + goodCount ) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] then 1 else 0) ) >>
Why created:  applied wp for assignment [serial 2828]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1287:
Theorem (1287) [serial 2993] used for:
    normalization of [serial 2991] 


Theorem (1289)                               [serial 2828] 
P [176] << ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] )
  and (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) + ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount >>
S [181] goodCount := ( (if SensorConnected?
  and not MotionArtifact? then 1 else 0) + goodCount ) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] then 1 else 0)
Q [183] << ( (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) = goodCount >>
Why created:    normalization of [serial 2796]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 1288:
Theorem (1288) [serial 2991] used for:
  applied wp for assignment [serial 2828] 


Theorem (1290)                               [serial 2796] 
P [176] << ( goodCount = ( (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) + ( numberof k ~ quantity whole 
  in ( lb + 1 ) .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) )
  and ( ( SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] ) >>
S [181] goodCount := ( goodCount + (if ( SensorConnected?
  and not MotionArtifact? ) then 1 else 0) ) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] then 1 else 0)
Q [183] << goodCount = ( ( (if SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
  and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) ) >>
Why created:  <<P3>> S3 <<Q3>> in concurrent composition for [serial 2788]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1289:
Theorem (1289) [serial 2828] used for:
    normalization of [serial 2796] 


Theorem (1291)                               [serial 3066] 
P [188] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [189] ->
Q [191] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:    normalization of [serial 3064]
Solved by:  Identity (id):  P->P is tautology


Theorem (1292)                               [serial 3064] 
P [188] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [189] ->
Q [191] << ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  ) ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 3062]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1291:
Theorem (1291) [serial 3066] used for:
    normalization of [serial 3064] 


Theorem (1293)                               [serial 3062] 
P [188] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [189] ->
Q [191] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and true >>
Why created:    normalization of [serial 3060]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 1292:
Theorem (1292) [serial 3064] used for:
  Law of And-Simplification:  P and true is P [serial 3062] 


Theorem (1294)                               [serial 3060] 
P [188] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [189] ->
Q [191] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( true ) >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 3058]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1293:
Theorem (1293) [serial 3062] used for:
    normalization of [serial 3060] 


Theorem (1295)                               [serial 3058] 
P [188] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [189] ->
Q [191] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) ) >>
Why created:    normalization of [serial 3056]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 1294:
Theorem (1294) [serial 3060] used for:
  Equality Law (idistr):  a=a <-> true [serial 3058] 


Theorem (1296)                               [serial 3056] 
P [188] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [189] ->
Q [191] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) ) ) >>
Why created:  applied wp for assignment [serial 2932]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1295:
Theorem (1295) [serial 3058] used for:
    normalization of [serial 3056] 


Theorem (1297)                               [serial 2932] 
P [188] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [189] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := ( SensorConnected?
  and not MotionArtifact? )
Q [191] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] ) >>
Why created:    normalization of [serial 2904]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 1296:
Theorem (1296) [serial 3056] used for:
  applied wp for assignment [serial 2932] 


Theorem (1298)                               [serial 2904] 
P [188] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
S [189] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := ( SensorConnected?
  and not MotionArtifact? )
Q [191] << ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2862]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1297:
Theorem (1297) [serial 2932] used for:
    normalization of [serial 2904] 


Theorem (1299)                               [serial 2862] 
P [188] << GS() >>
S [189] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := ( SensorConnected?
  and not MotionArtifact? )
Q [191] << ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and GS() >>
Why created:  Law of And-Simplification:  P and true is P [serial 2838]
Solved by:  Substitution of Assertion Labels
and theorem 1298:
Theorem (1298) [serial 2904] used for:
  Substituted assertions' predicates for labels  [serial 2862] 


Theorem (1300)                               [serial 2838] 
P [188] << GS() >>
S [189] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := ( SensorConnected?
  and not MotionArtifact? )
Q [191] << ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and GS()
  and true >>
Why created:    normalization of [serial 2801]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 1299:
Theorem (1299) [serial 2862] used for:
  Law of And-Simplification:  P and true is P [serial 2838] 


Theorem (1301)                               [serial 2801] 
P [188] << GS() >>
S [189] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := ( SensorConnected?
  and not MotionArtifact? )
Q [191] << ( goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) )
  and GS()
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Associativity: a.(b.c) = a.b.c
and theorem 1300:
Theorem (1300) [serial 2838] used for:
    normalization of [serial 2801] 


Theorem (1302)                               [serial 3066] 
P [188] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [189] ->
Q [191] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
Why created:    normalization of [serial 3064]
Solved by:  Identity (id):  P->P is tautology


Theorem (1303)                               [serial 3064] 
P [188] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [189] ->
Q [191] << ( ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  ) ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 3062]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1302:
Theorem (1302) [serial 3066] used for:
    normalization of [serial 3064] 


Theorem (1304)                               [serial 3062] 
P [188] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [189] ->
Q [191] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and true >>
Why created:    normalization of [serial 3060]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 1303:
Theorem (1303) [serial 3064] used for:
  Law of And-Simplification:  P and true is P [serial 3062] 


Theorem (1305)                               [serial 3060] 
P [188] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [189] ->
Q [191] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( true ) >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 3058]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1304:
Theorem (1304) [serial 3062] used for:
    normalization of [serial 3060] 


Theorem (1306)                               [serial 3058] 
P [188] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [189] ->
Q [191] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) ) >>
Why created:    normalization of [serial 3056]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 1305:
Theorem (1305) [serial 3060] used for:
  Equality Law (idistr):  a=a <-> true [serial 3058] 


Theorem (1307)                               [serial 3056] 
P [188] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [189] ->
Q [191] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) ) ) >>
Why created:  applied wp for assignment [serial 2932]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1306:
Theorem (1306) [serial 3058] used for:
    normalization of [serial 3056] 


Theorem (1308)                               [serial 2932] 
P [188] << all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [189] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := ( SensorConnected?
  and not MotionArtifact? )
Q [191] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] ) >>
Why created:    normalization of [serial 2904]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 1307:
Theorem (1307) [serial 3056] used for:
  applied wp for assignment [serial 2932] 


Theorem (1309)                               [serial 2904] 
P [188] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
S [189] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := ( SensorConnected?
  and not MotionArtifact? )
Q [191] << ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
Why created:  Substituted assertions' predicates for labels  [serial 2862]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1308:
Theorem (1308) [serial 2932] used for:
    normalization of [serial 2904] 


Theorem (1310)                               [serial 2862] 
P [188] << GS() >>
S [189] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := ( SensorConnected?
  and not MotionArtifact? )
Q [191] << ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and GS() >>
Why created:  Law of And-Simplification:  P and true is P [serial 2838]
Solved by:  Substitution of Assertion Labels
and theorem 1309:
Theorem (1309) [serial 2904] used for:
  Substituted assertions' predicates for labels  [serial 2862] 


Theorem (1311)                               [serial 2838] 
P [188] << GS() >>
S [189] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := ( SensorConnected?
  and not MotionArtifact? )
Q [191] << ( ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) iff goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] )
  and GS()
  and true >>
Why created:    normalization of [serial 2801]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 1310:
Theorem (1310) [serial 2862] used for:
  Law of And-Simplification:  P and true is P [serial 2838] 


Theorem (1312)                               [serial 2801] 
P [188] << GS() >>
S [189] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := ( SensorConnected?
  and not MotionArtifact? )
Q [191] << ( goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) )
  and GS()
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Associativity: a.(b.c) = a.b.c
and theorem 1311:
Theorem (1311) [serial 2838] used for:
    normalization of [serial 2801] 


Theorem (1313)                               [serial 2797] 
P [188] << GS() >>
S [189] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := ( SensorConnected?
  and not MotionArtifact? )
Q [191] << ( goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^0
  and not MOTION_ARTIFACT^0 ) )
  and GS()
  and AXIOM_LB() >>
Why created:  <<P4>> S4 <<Q4>> in concurrent composition for [serial 2788]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 1312 1312:
Theorem (1312) [serial 2801] used for:
   add user-defined axioms to postcondition 
Theorem (1312) [serial 2801] used for:
   add user-defined axioms to postcondition 


Theorem (1314)                               [serial 2788] 
P [158] << RUN_AV()
  and AXIOM_LB() >>
S [160]   << all k ~ quantity whole 
    in ( lb + 1 ) .. ( ub - 1 ) 
    are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)  >>
  spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] := (if SensorConnected?
    and not MotionArtifact? then SpO2? else 0 percent)
  << ( all k ~ quantity whole 
    in ( lb + 1 ) .. ( ub - 1 ) 
    are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)  )
    and ( spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x : 0) ) >>
  &
  << ( totalSpO2 = ( SSQ(lb - ub) + ( sum k ~ quantity whole 
    in ( lb + 1 ) .. ( ub - 1 ) 
    of SSQ(k - ub)  ) ) )
    and ( spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] = SSQ(lb - ub) )
    and ( ( ub - lb ) = window_size ) >>
  totalSpO2 := ( totalSpO2 + (if SensorConnected?
    and not MotionArtifact? then SpO2? else 0 percent) ) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
  << ( totalSpO2 = ( SSQ(x : 0) + ( sum k ~ quantity whole 
    in ( lb + 1 ) .. ( ub - 1 ) 
    of SSQ(k - ub)  ) ) )
    and ( ( ub - lb ) = window_size ) >>
  &
  << ( goodCount = ( (if SENSOR_CONNECTED^( lb - ub )
    and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) + ( numberof k ~ quantity whole 
    in ( lb + 1 ) .. ( ub - 1 ) 
    that ( SENSOR_CONNECTED^( k - ub )
           and not MOTION_ARTIFACT^( k - ub ) )  ) ) )
    and ( ( SENSOR_CONNECTED^( lb - ub )
    and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] ) >>
  goodCount := ( goodCount + (if ( SensorConnected?
    and not MotionArtifact? ) then 1 else 0) ) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] then 1 else 0)
  << goodCount = ( ( (if SENSOR_CONNECTED^0
    and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
    in lb .. ( ub - 1 ) 
    that ( SENSOR_CONNECTED^( k - ub )
           and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
    and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) ) >>
  &
  << GS() >>
  goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := ( SensorConnected?
    and not MotionArtifact? )
  << ( goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^0
    and not MOTION_ARTIFACT^0 ) )
    and GS()
    and AXIOM_LB() >> 
Q [194] << ( all k ~ quantity whole 
  in ( lb + 1 ) .. ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in ( lb + 1 ) .. ub 
  of SSQ(k - ub)  ) )
  and ( ( ub - lb ) = window_size )
  and ( goodCount = ( numberof k ~ quantity whole 
  in ( lb + 1 ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in ( lb + 1 ) .. ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 2778]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 1187 1204 1221 1233 1252 1261 1279 1290 1313:
Theorem (1187) [serial 2789] used for:
  P -> P1 in concurrent composition for [serial 2788] 
Theorem (1204) [serial 2790] used for:
  P -> P2 in concurrent composition for [serial 2788] 
Theorem (1221) [serial 2791] used for:
  P -> P3 in concurrent composition for [serial 2788] 
Theorem (1233) [serial 2792] used for:
  P -> P4 in concurrent composition for [serial 2788] 
Theorem (1252) [serial 2793] used for:
  Q1 and Q2 and  . . . and Qn -> Q in concurrent composition for [serial 2788] 
Theorem (1261) [serial 2794] used for:
  <<P1>> S1 <<Q1>> in concurrent composition for [serial 2788] 
Theorem (1279) [serial 2795] used for:
  <<P2>> S2 <<Q2>> in concurrent composition for [serial 2788] 
Theorem (1290) [serial 2796] used for:
  <<P3>> S3 <<Q3>> in concurrent composition for [serial 2788] 
Theorem (1313) [serial 2797] used for:
  <<P4>> S4 <<Q4>> in concurrent composition for [serial 2788] 


Theorem (1315)                               [serial 2778] 
P [158] << RUN_AV()
  and AXIOM_LB() >>
S [159]   {
    << all k ~ quantity whole 
      in ( lb + 1 ) .. ( ub - 1 ) 
      are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)  >>
    spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] := (if SensorConnected?
      and not MotionArtifact? then SpO2? else 0 percent)
    << ( all k ~ quantity whole 
      in ( lb + 1 ) .. ( ub - 1 ) 
      are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)  )
      and ( spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x : 0) ) >>
    &
    << ( totalSpO2 = ( SSQ(lb - ub) + ( sum k ~ quantity whole 
      in ( lb + 1 ) .. ( ub - 1 ) 
      of SSQ(k - ub)  ) ) )
      and ( spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] = SSQ(lb - ub) )
      and ( ( ub - lb ) = window_size ) >>
    totalSpO2 := ( totalSpO2 + (if SensorConnected?
      and not MotionArtifact? then SpO2? else 0 percent) ) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
    << ( totalSpO2 = ( SSQ(x : 0) + ( sum k ~ quantity whole 
      in ( lb + 1 ) .. ( ub - 1 ) 
      of SSQ(k - ub)  ) ) )
      and ( ( ub - lb ) = window_size ) >>
    &
    << ( goodCount = ( (if SENSOR_CONNECTED^( lb - ub )
      and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) + ( numberof k ~ quantity whole 
      in ( lb + 1 ) .. ( ub - 1 ) 
      that ( SENSOR_CONNECTED^( k - ub )
             and not MOTION_ARTIFACT^( k - ub ) )  ) ) )
      and ( ( SENSOR_CONNECTED^( lb - ub )
      and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] ) >>
    goodCount := ( goodCount + (if ( SensorConnected?
      and not MotionArtifact? ) then 1 else 0) ) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] then 1 else 0)
    << goodCount = ( ( (if SENSOR_CONNECTED^0
      and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
      in lb .. ( ub - 1 ) 
      that ( SENSOR_CONNECTED^( k - ub )
             and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
      and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) ) >>
    &
    << GS() >>
    goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := ( SensorConnected?
      and not MotionArtifact? )
    << ( goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^0
      and not MOTION_ARTIFACT^0 ) )
      and GS()
      and AXIOM_LB() >> 
  } 
Q [194] << ( all k ~ quantity whole 
  in ( lb + 1 ) .. ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in ( lb + 1 ) .. ub 
  of SSQ(k - ub)  ) )
  and ( ( ub - lb ) = window_size )
  and ( goodCount = ( numberof k ~ quantity whole 
  in ( lb + 1 ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in ( lb + 1 ) .. ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1053]
Solved by:  Introduction of Existential Quantification
and theorem 1314:
Theorem (1314) [serial 2788] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 2778] 


Theorem (1316)                               [serial 3078] 
P [194] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [203] ->
Q [204] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
Why created:    normalization of [serial 3075]
Solved by:  Identity (id):  P->P is tautology


Theorem (1317)                               [serial 3075] 
P [194] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [203] ->
Q [204] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( ( k ) - ( ub ) )
        and not MOTION_ARTIFACT^( ( k ) - ( ub ) ) then SPO2^( ( k ) - ( ub ) ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( ( k ) - ( ub ) )
        and not MOTION_ARTIFACT^( ( k ) - ( ub ) ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( ( k ) - ( ub ) )
         and not MOTION_ARTIFACT^( ( k ) - ( ub ) ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of (if SENSOR_CONNECTED^( ( k ) - ( ub ) )
       and not MOTION_ARTIFACT^( ( k ) - ( ub ) ) then SPO2^( ( k ) - ( ub ) ) else 0 percent)  ) = totalSpO2
  and ( ub ) - ( lb ) = window_size >>
Why created:  Add both sides of subtraction:  a-b is (x+a)-(x+b) [serial 3070]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1316:
Theorem (1316) [serial 3078] used for:
    normalization of [serial 3075] 


Theorem (1318)                               [serial 3070] 
P [194] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [203] ->
Q [204] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ( 1 + ub ) )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ( 1 + ub ) ) then SPO2^( ( 
      1 + k ) - ( 1 + ub ) ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ( 1 + ub ) )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ( 1 + ub ) ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ( 1 + ub ) )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ( 1 + ub ) ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ( 1 + ub ) )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ( 1 + ub ) ) then SPO2^( ( 
     1 + k ) - ( 1 + ub ) ) else 0 percent)  ) = totalSpO2
  and ( 1 + ub ) - ( 1 + lb ) = window_size >>
Why created:    normalization of [serial 3068]
Solved by:  Add both sides of subtraction:  a-b is (x+a)-(x+b)
and theorem 1317:
Theorem (1317) [serial 3075] used for:
  Add both sides of subtraction:  a-b is (x+a)-(x+b) [serial 3070] 


Theorem (1319)                               [serial 3080] 
P [194] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [203] ->
Q [204] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
Why created:    normalization of [serial 3076]
Solved by:  Identity (id):  P->P is tautology


Theorem (1320)                               [serial 3076] 
P [194] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [203] ->
Q [204] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( ( k ) - ( ub ) )
        and not MOTION_ARTIFACT^( ( k ) - ( ub ) ) then SPO2^( ( k ) - ( ub ) ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( ( k ) - ( ub ) )
        and not MOTION_ARTIFACT^( ( k ) - ( ub ) ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( ( k ) - ( ub ) )
         and not MOTION_ARTIFACT^( ( k ) - ( ub ) ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of (if SENSOR_CONNECTED^( ( k ) - ( ub ) )
       and not MOTION_ARTIFACT^( ( k ) - ( ub ) ) then SPO2^( ( k ) - ( ub ) ) else 0 percent)  ) = totalSpO2
  and ( ub ) - ( lb ) = window_size >>
Why created:  Add both sides of subtraction:  a-b is (x+a)-(x+b) [serial 3072]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1319:
Theorem (1319) [serial 3080] used for:
    normalization of [serial 3076] 


Theorem (1321)                               [serial 3072] 
P [194] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [203] ->
Q [204] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ( 1 + ub ) )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ( 1 + ub ) ) then SPO2^( ( 
      1 + k ) - ( 1 + ub ) ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ( 1 + ub ) )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ( 1 + ub ) ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ( 1 + ub ) )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ( 1 + ub ) ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ( 1 + ub ) )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ( 1 + ub ) ) then SPO2^( ( 
     1 + k ) - ( 1 + ub ) ) else 0 percent)  ) = totalSpO2
  and ( 1 + ub ) - ( 1 + lb ) = window_size >>
Why created:    normalization of [serial 3068]
Solved by:  Add both sides of subtraction:  a-b is (x+a)-(x+b)
and theorem 1320:
Theorem (1320) [serial 3076] used for:
  Add both sides of subtraction:  a-b is (x+a)-(x+b) [serial 3072] 


Theorem (1322)                               [serial 3068] 
P [194] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [203] ->
Q [204] << ( all k ~ quantity whole 
  in ( ( 1 + lb ) ) .. ( ( ( 1 + ub ) ) - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ( ( 1 + ub ) ) )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ( ( 1 + ub ) ) ) then SPO2^( ( 
      1 + k ) - ( ( 1 + ub ) ) ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in ( ( 1 + lb ) ) .. ( ( ( 1 + ub ) ) - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ( ( 1 + ub ) ) )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ( ( 1 + ub ) ) ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and goodCount = ( numberof k ~ quantity whole 
  in ( ( 1 + lb ) ) .. ( ( ( 1 + ub ) ) - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ( ( 1 + ub ) ) )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ( ( 1 + ub ) ) ) )  )
  and totalSpO2 = ( sum k ~ quantity whole 
  in ( ( 1 + lb ) ) .. ( ( ( 1 + ub ) ) - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ( ( 1 + ub ) ) )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ( ( 1 + ub ) ) ) then SPO2^( ( 
     1 + k ) - ( ( 1 + ub ) ) ) else 0 percent)  )
  and window_size = ( ( 1 + ub ) ) - ( ( 1 + lb ) ) >>
Why created:  applied wp for simultaneous assignment [serial 2936]
Solved by:  Subtaction of Added Value:  (a+b)-a is b
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
  Subtaction of Added Value:  (a+b)-a is b
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorems 1318 1321:
Theorem (1318) [serial 3070] used for:
    normalization of [serial 3068] 
Theorem (1321) [serial 3072] used for:
    normalization of [serial 3068] 


Theorem (1323)                               [serial 2936] 
P [194] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are (if SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of (if SENSOR_CONNECTED^( k - ub )
       and not MOTION_ARTIFACT^( k - ub ) then SPO2^( k - ub ) else 0 percent)  ) = totalSpO2
  and ub - lb = window_size >>
S [203] |ub,lb,window_size',totalSpO2',goodCount' := 1 + ub,1 + lb,window_size,totalSpO2,goodCount|  
Q [204] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and window_size' = ub - lb >>
Why created:    normalization of [serial 2906]
Solved by:  Simultaneous Assignment
and theorem 1322:
Theorem (1322) [serial 3068] used for:
  applied wp for simultaneous assignment [serial 2936] 


Theorem (1324)                               [serial 2906] 
P [194] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( (if SENSOR_CONNECTED^( ( k - ub ) )
        and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) ) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of ( (if SENSOR_CONNECTED^( ( k - ub ) )
       and not MOTION_ARTIFACT^( ( k - ub ) ) then SPO2^( ( k - ub ) ) else 0 percent) )  ) = totalSpO2
  and ub - lb = window_size >>
S [203] |ub,lb,window_size',totalSpO2',goodCount' := 1 + ub,1 + lb,window_size,totalSpO2,goodCount|  
Q [204] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( (if SENSOR_CONNECTED^( ( ( 1 + k ) - ub ) )
        and not MOTION_ARTIFACT^( ( ( 1 + k ) - ub ) ) then SPO2^( ( ( 1 + 
      k ) - ub ) ) else 0 percent) ) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( ( 1 + k ) - ub ) )
       and not MOTION_ARTIFACT^( ( ( 1 + k ) - ub ) ) then SPO2^( ( ( 1 + 
     k ) - ub ) ) else 0 percent) )  )
  and window_size' = ub - lb >>
Why created:  Substituted assertions' predicates for labels  [serial 2883]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1323:
Theorem (1323) [serial 2936] used for:
    normalization of [serial 2906] 


Theorem (1325)                               [serial 2883] 
P [194] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of SSQ(k - ub)  ) = totalSpO2
  and ub - lb = window_size >>
S [203] |ub,lb,window_size',totalSpO2',goodCount' := 1 + ub,1 + lb,window_size,totalSpO2,goodCount|  
Q [204] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(( 1 + k ) - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(( 1 + k ) - ub)  )
  and window_size' = ub - lb >>
Why created:    normalization of [serial 2859]
Solved by:  Substitution of Assertion Labels
and theorem 1324:
Theorem (1324) [serial 2906] used for:
  Substituted assertions' predicates for labels  [serial 2883] 


Theorem (1326)                               [serial 2859] 
P [194] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of SSQ(k - ub)  ) = totalSpO2
  and ub - lb = window_size >>
S [203] |ub,lb,window_size',totalSpO2',goodCount' := 1 + ub,1 + lb,window_size,totalSpO2,goodCount|  
Q [204] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(( 1 + k ) - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(( 1 + k ) - ub)  )
  and window_size' = ( ub ) - ( lb ) >>
Why created:  Add both sides of subtraction:  a-b is (x+a)-(x+b) [serial 2830]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1325:
Theorem (1325) [serial 2883] used for:
    normalization of [serial 2859] 


Theorem (1327)                               [serial 2830] 
P [194] << ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are SSQ(k - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  are ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( numberof k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) = goodCount
  and ( sum k ~ quantity whole 
  in ( 1 + lb ) .. ub 
  of SSQ(k - ub)  ) = totalSpO2
  and ub - lb = window_size >>
S [203] |ub,lb,window_size',totalSpO2',goodCount' := 1 + ub,1 + lb,window_size,totalSpO2,goodCount|  
Q [204] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(( 1 + k ) - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(( 1 + k ) - ub)  )
  and window_size' = ( 1 + ub ) - ( 1 + lb ) >>
Why created:    normalization of [serial 2779]
Solved by:  Add both sides of subtraction:  a-b is (x+a)-(x+b)
and theorem 1326:
Theorem (1326) [serial 2859] used for:
  Add both sides of subtraction:  a-b is (x+a)-(x+b) [serial 2830] 


Theorem (1328)                               [serial 2779] 
P [194] << ( all k ~ quantity whole 
  in ( lb + 1 ) .. ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)  )
  and ( totalSpO2 = ( sum k ~ quantity whole 
  in ( lb + 1 ) .. ub 
  of SSQ(k - ub)  ) )
  and ( ( ub - lb ) = window_size )
  and ( goodCount = ( numberof k ~ quantity whole 
  in ( lb + 1 ) .. ub 
  that ( SENSOR_CONNECTED^( k - ub )
         and not MOTION_ARTIFACT^( k - ub ) )  ) )
  and ( all k ~ quantity whole 
  in ( lb + 1 ) .. ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
        and not MOTION_ARTIFACT^( k - ub ) )  ) >>
S [203] |ub,lb,window_size',totalSpO2',goodCount' := ub + 1,lb + 1,window_size,totalSpO2,goodCount|  
Q [204] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ( ub - 1 ))  )
  and ( totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ( ub - 1 ))  ) )
  and ( ( ( ub - 1 ) - ( lb - 1 ) ) = window_size' )
  and ( goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1053]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1327:
Theorem (1327) [serial 2830] used for:
    normalization of [serial 2779] 


Theorem (1329)                               [serial 3085] 
P [204] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and window_size' = ub - lb >>
S [214] ->
Q [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and window_size' = ub - lb >>
Why created:    normalization of [serial 3083]
Solved by:  Identity (id):  P->P is tautology


Theorem (1330)                               [serial 3087] 
P [204] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and window_size' = ub - lb >>
S [214] ->
Q [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and window_size' = ub - lb >>
Why created:    normalization of [serial 3083]
Solved by:  Identity (id):  P->P is tautology


Theorem (1331)                               [serial 3083] 
P [204] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and window_size' = ub - lb >>
S [214] ->
Q [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = (if SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and window_size' = ub - lb >>
Why created:  applied wp for simultaneous assignment [serial 2938]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorems 1329 1330:
Theorem (1329) [serial 3085] used for:
    normalization of [serial 3083] 
Theorem (1330) [serial 3087] used for:
    normalization of [serial 3083] 


Theorem (1332)                               [serial 2938] 
P [204] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and window_size' = ub - lb >>
S [214] |spo2_hist',goodSamp',ub',lb' := spo2_hist,goodSamp,ub,lb|  
Q [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' = (if SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]' iff ( SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of (if SENSOR_CONNECTED^( ( 1 + k ) - ub )
       and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) then SPO2^( ( 1 + k ) - ub ) else 0 percent)  )
  and window_size' = ub' - lb' >>
Why created:    normalization of [serial 2907]
Solved by:  Simultaneous Assignment
and theorem 1331:
Theorem (1331) [serial 3083] used for:
  applied wp for simultaneous assignment [serial 2938] 


Theorem (1333)                               [serial 2907] 
P [204] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( (if SENSOR_CONNECTED^( ( ( 1 + k ) - ub ) )
        and not MOTION_ARTIFACT^( ( ( 1 + k ) - ub ) ) then SPO2^( ( ( 1 + 
      k ) - ub ) ) else 0 percent) ) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( ( 1 + k ) - ub ) )
       and not MOTION_ARTIFACT^( ( ( 1 + k ) - ub ) ) then SPO2^( ( ( 1 + 
     k ) - ub ) ) else 0 percent) )  )
  and window_size' = ub - lb >>
S [214] |spo2_hist',goodSamp',ub',lb' := spo2_hist,goodSamp,ub,lb|  
Q [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' = ( (if SENSOR_CONNECTED^( ( ( 
      1 + k ) - ub ) )
        and not MOTION_ARTIFACT^( ( ( 1 + k ) - ub ) ) then SPO2^( ( ( 1 + 
      k ) - ub ) ) else 0 percent) )  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]' iff ( SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of ( (if SENSOR_CONNECTED^( ( ( 1 + k ) - ub ) )
       and not MOTION_ARTIFACT^( ( ( 1 + k ) - ub ) ) then SPO2^( ( ( 1 + 
     k ) - ub ) ) else 0 percent) )  )
  and window_size' = ub' - lb' >>
Why created:  Substituted assertions' predicates for labels  [serial 2885]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1332:
Theorem (1332) [serial 2938] used for:
    normalization of [serial 2907] 


Theorem (1334)                               [serial 2885] 
P [204] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(( 1 + k ) - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(( 1 + k ) - ub)  )
  and window_size' = ub - lb >>
S [214] |spo2_hist',goodSamp',ub',lb' := spo2_hist,goodSamp,ub,lb|  
Q [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' = SSQ(( 
      1 + k ) - ub)  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]' iff ( SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(( 1 + k ) - ub)  )
  and window_size' = ub' - lb' >>
Why created:    normalization of [serial 2860]
Solved by:  Substitution of Assertion Labels
and theorem 1333:
Theorem (1333) [serial 2907] used for:
  Substituted assertions' predicates for labels  [serial 2885] 


Theorem (1335)                               [serial 2860] 
P [204] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(( 1 + k ) - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(( 1 + k ) - ub)  )
  and window_size' = ( ub ) - ( lb ) >>
S [214] |spo2_hist',goodSamp',ub',lb' := spo2_hist,goodSamp,ub,lb|  
Q [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' = SSQ(( 
      1 + k ) - ub)  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]' iff ( SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(( 1 + k ) - ub)  )
  and window_size' = ( ub' ) - ( lb' ) >>
Why created:  Add both sides of subtraction:  a-b is (x+a)-(x+b) [serial 2832]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Associativity: a.(b.c) = a.b.c
and theorem 1334:
Theorem (1334) [serial 2885] used for:
    normalization of [serial 2860] 


Theorem (1336)                               [serial 2832] 
P [204] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are SSQ(( 1 + k ) - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) ) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(( 1 + k ) - ub)  )
  and window_size' = ( 1 + ub ) - ( 1 + lb ) >>
S [214] |spo2_hist',goodSamp',ub',lb' := spo2_hist,goodSamp,ub,lb|  
Q [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' = SSQ(( 
      1 + k ) - ub)  )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]' iff ( SENSOR_CONNECTED^( ( 
      1 + k ) - ub )
        and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( ( 1 + k ) - ub )
         and not MOTION_ARTIFACT^( ( 1 + k ) - ub ) )  )
  and totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(( 1 + k ) - ub)  )
  and window_size' = ( 1 + ub' ) - ( 1 + lb' ) >>
Why created:    normalization of [serial 2780]
Solved by:  Add both sides of subtraction:  a-b is (x+a)-(x+b)
and theorem 1335:
Theorem (1335) [serial 2860] used for:
  Add both sides of subtraction:  a-b is (x+a)-(x+b) [serial 2832] 


Theorem (1337)                               [serial 2780] 
P [204] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ( ub - 1 ))  )
  and ( totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ( ub - 1 ))  ) )
  and ( ( ( ub - 1 ) - ( lb - 1 ) ) = window_size' )
  and ( goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) >>
S [214] |spo2_hist',goodSamp',ub',lb' := spo2_hist,goodSamp,ub,lb|  
Q [215] << ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' = SSQ(k - ( ub - 1 ))  )
  and ( totalSpO2' = ( sum k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  of SSQ(k - ( ub - 1 ))  ) )
  and ( ( ( ub' - 1 ) - ( lb' - 1 ) ) = window_size' )
  and ( goodCount' = ( numberof k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  that ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
         and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) )
  and ( all k ~ quantity whole 
  in lb .. ( ub - 1 ) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]' iff ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
        and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) >>
Why created:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1053]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Associativity: a.(b.c) = a.b.c
and theorem 1336:
Theorem (1336) [serial 2832] used for:
    normalization of [serial 2780] 


Theorem (1338)                               [serial 1053] 
P [88] << INV_AV()
  and ( ( ub - lb ) = window_size ) >>
S [148]   << RUN_AV() >>
    if 
      (goodCount > 0)~> 
        << RUN_AV()
          and ( goodCount > 0 )
          and AXIOM_K2I() >>
        SpO2Avg!(totalSpO2 / goodCount)
        << RUN_AV() >> 
    []
      (goodCount <= 0)~> 
        << RUN_AV() >>
        skip
        << RUN_AV() >> 
    fi
  ;
  << RUN_AV()
    and AXIOM_LB() >>
    {
      << all k ~ quantity whole 
        in ( lb + 1 ) .. ( ub - 1 ) 
        are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)  >>
      spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] := (if SensorConnected?
        and not MotionArtifact? then SpO2? else 0 percent)
      << ( all k ~ quantity whole 
        in ( lb + 1 ) .. ( ub - 1 ) 
        are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)  )
        and ( spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x : 0) ) >>
      &
      << ( totalSpO2 = ( SSQ(lb - ub) + ( sum k ~ quantity whole 
        in ( lb + 1 ) .. ( ub - 1 ) 
        of SSQ(k - ub)  ) ) )
        and ( spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] = SSQ(lb - ub) )
        and ( ( ub - lb ) = window_size ) >>
      totalSpO2 := ( totalSpO2 + (if SensorConnected?
        and not MotionArtifact? then SpO2? else 0 percent) ) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
      << ( totalSpO2 = ( SSQ(x : 0) + ( sum k ~ quantity whole 
        in ( lb + 1 ) .. ( ub - 1 ) 
        of SSQ(k - ub)  ) ) )
        and ( ( ub - lb ) = window_size ) >>
      &
      << ( goodCount = ( (if SENSOR_CONNECTED^( lb - ub )
        and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) + ( numberof k ~ quantity whole 
        in ( lb + 1 ) .. ( ub - 1 ) 
        that ( SENSOR_CONNECTED^( k - ub )
               and not MOTION_ARTIFACT^( k - ub ) )  ) ) )
        and ( ( SENSOR_CONNECTED^( lb - ub )
        and not MOTION_ARTIFACT^( lb - ub ) ) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] ) >>
      goodCount := ( goodCount + (if ( SensorConnected?
        and not MotionArtifact? ) then 1 else 0) ) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] then 1 else 0)
      << goodCount = ( ( (if SENSOR_CONNECTED^0
        and not MOTION_ARTIFACT^0 then 1 else 0) + ( numberof k ~ quantity whole 
        in lb .. ( ub - 1 ) 
        that ( SENSOR_CONNECTED^( k - ub )
               and not MOTION_ARTIFACT^( k - ub ) )  ) ) - (if SENSOR_CONNECTED^( lb - ub )
        and not MOTION_ARTIFACT^( lb - ub ) then 1 else 0) ) >>
      &
      << GS() >>
      goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := ( SensorConnected?
        and not MotionArtifact? )
      << ( goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^0
        and not MOTION_ARTIFACT^0 ) )
        and GS()
        and AXIOM_LB() >> 
    } 
  << ( all k ~ quantity whole 
    in ( lb + 1 ) .. ub 
    are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)  )
    and ( totalSpO2 = ( sum k ~ quantity whole 
    in ( lb + 1 ) .. ub 
    of SSQ(k - ub)  ) )
    and ( ( ub - lb ) = window_size )
    and ( goodCount = ( numberof k ~ quantity whole 
    in ( lb + 1 ) .. ub 
    that ( SENSOR_CONNECTED^( k - ub )
           and not MOTION_ARTIFACT^( k - ub ) )  ) )
    and ( all k ~ quantity whole 
    in ( lb + 1 ) .. ub 
    are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ub )
          and not MOTION_ARTIFACT^( k - ub ) )  ) >>
  ;
  |ub,lb,window_size',totalSpO2',goodCount' := ub + 1,lb + 1,window_size,totalSpO2,goodCount|  
  << ( all k ~ quantity whole 
    in lb .. ( ub - 1 ) 
    are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ( ub - 1 ))  )
    and ( totalSpO2' = ( sum k ~ quantity whole 
    in lb .. ( ub - 1 ) 
    of SSQ(k - ( ub - 1 ))  ) )
    and ( ( ( ub - 1 ) - ( lb - 1 ) ) = window_size' )
    and ( goodCount' = ( numberof k ~ quantity whole 
    in lb .. ( ub - 1 ) 
    that ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
           and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) )
    and ( all k ~ quantity whole 
    in lb .. ( ub - 1 ) 
    are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
          and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) >>
  ;
  |spo2_hist',goodSamp',ub',lb' := spo2_hist,goodSamp,ub,lb|  
  << ( all k ~ quantity whole 
    in lb .. ( ub - 1 ) 
    are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' = SSQ(k - ( ub - 1 ))  )
    and ( totalSpO2' = ( sum k ~ quantity whole 
    in lb .. ( ub - 1 ) 
    of SSQ(k - ( ub - 1 ))  ) )
    and ( ( ( ub' - 1 ) - ( lb' - 1 ) ) = window_size' )
    and ( goodCount' = ( numberof k ~ quantity whole 
    in lb .. ( ub - 1 ) 
    that ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
           and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) )
    and ( all k ~ quantity whole 
    in lb .. ( ub - 1 ) 
    are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]' iff ( SENSOR_CONNECTED^( k - ( ub - 1 ) )
          and not MOTION_ARTIFACT^( k - ( ub - 1 ) ) )  ) >> 
Q [88] << ( INV_AV()
  and ( ( ub - lb ) = window_size ) )^1 >>
Why created:   <<M(run) and x>> A <<M(run)>> for SpAt4: run-[x]->run{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 1090 1114 1174 1315 1328 1337:
Theorem (1090) [serial 2775] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1053] 
Theorem (1114) [serial 2776] used for:
  <<Q4>> -> <<Q>> in sequential composition for [serial 1053] 
Theorem (1174) [serial 2777] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1053] 
Theorem (1315) [serial 2778] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1053] 
Theorem (1328) [serial 2779] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1053] 
Theorem (1337) [serial 2780] used for:
  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1053] 


Theorem (1339)                               [serial 1042] 
P [34] <<   >>
S [51] ->
Q [34] << SpO2AverageThread.imp proof obligations >>
Why created:  Initial proof obligations for SpO2AverageThread.imp
Solved by:  Component verification conditions
and theorems 830 833 836 840 923 925 1035 1057 1078 1080 1338:
Theorem (830) [serial 1043] used for:
  <<M(fillingWindow)>> -> <<I>> from invariant I when complete state fillingWindow has Assertion <<M(fillingWindow)>> in its definition. 
Theorem (833) [serial 1044] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (836) [serial 1045] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state chooseToRun, <<M(chooseToRun)>> -> <<e1 or e2 or . . . en>> 
Theorem (840) [serial 1046] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (923) [serial 1047] used for:
   <<M(start) and x>> A <<M(fillingWindow)>> for SpAT0: start-[x]->fillingWindow{A}; 
Theorem (925) [serial 1048] used for:
   <<M(start) and x>> A <<M(fail)>> for SpAT0a: start-[x]->fail{A}; 
Theorem (1035) [serial 1049] used for:
   <<M(fillingWindow) and x>> A <<M(chooseToRun)>> for SpAT1: fillingWindow-[x]->chooseToRun{A}; 
Theorem (1057) [serial 1050] used for:
   <<M(chooseToRun) and x>> A <<M(fillingWindow)>> for SpAT2: chooseToRun-[x]->fillingWindow{A}; 
Theorem (1078) [serial 1051] used for:
   <<M(chooseToRun) and x>> A <<M(run)>> for SpAT3: chooseToRun-[x]->run{A}; 
Theorem (1080) [serial 1052] used for:
   <<M(chooseToRun) and x>> A <<M(fail)>> for SpAT3a: chooseToRun-[x]->fail{A}; 
Theorem (1338) [serial 1053] used for:
   <<M(run) and x>> A <<M(run)>> for SpAt4: run-[x]->run{A}; 


Theorem (1340)                               [serial 1054] 
P [1] << SpO2Avg = SPO2_AVERAGE() >>
S [2] ->
Q [1] << SpO2Avg = SPO2_AVERAGE() >>
Why created:  Composition of Subcomponents via Directional Connection av.SpO2Avg -> so.SpO2Avg:
 SpO2Avg -> SpO2Avg
Solved by:  Identity (id):  P->P is tautology


Theorem (1341)                               [serial 1055] 
P [1] << SpO2Avg_AverageSpO2 = SPO2_AVERAGE() >>
S [2] ->
Q [1] << SpO2Avg_AverageSpO2 = SPO2_AVERAGE() >>
Why created:  Composition of Subcomponents via Directional Connection av.SpO2Avg -> rd.AverageSpO2:
 SpO2Avg -> AverageSpO2
Solved by:  Identity (id):  P->P is tautology


Theorem (1342)                               [serial 1056] 
P [1] << HEART_RATE_LOWER_LIMIT_ALARM() >>
S [2] ->
Q [1] << HEART_RATE_LOWER_LIMIT_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection po.HeartRateLowerLimitViolated -> ui.uit.HeartRateLowerLimitViolated:
 HeartRateLowerLimitViolated -> HeartRateLowerLimitViolated
Solved by:  Identity (id):  P->P is tautology


Theorem (1343)                               [serial 1057] 
P [1] << HEART_RATE_UPPER_LIMIT_ALARM() >>
S [2] ->
Q [1] << HEART_RATE_UPPER_LIMIT_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection po.HeartRateUpperLimitViolated -> ui.uit.HeartRateUpperLimitViolated:
 HeartRateUpperLimitViolated -> HeartRateUpperLimitViolated
Solved by:  Identity (id):  P->P is tautology


Theorem (1344)                               [serial 1058] 
P [1] << MOTION_ARTIFACT_ALARM() >>
S [2] ->
Q [1] << MOTION_ARTIFACT_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection app.tg.ma.MotionArtifactAlarm -> ui.uit.MotionArtifactAlarm:
 MotionArtifactAlarm -> MotionArtifactAlarm
Solved by:  Identity (id):  P->P is tautology


Theorem (1345)                               [serial 1059] 
P [1] << SUPPL_O2_ALARM() >>
S [2] ->
Q [1] << SUPPL_O2_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection app.tg.so.SpO2DerivedLowerLimitAlarm -> ui.uit.SpO2DerivedLowerLimitAlarm:
 SpO2DerivedLowerLimitAlarm -> SpO2DerivedLowerLimitAlarm
Solved by:  Identity (id):  P->P is tautology


Theorem (1346)                               [serial 1060] 
P [1] << RAPID_DECLINE_ALARM() >>
S [2] ->
Q [1] << RAPID_DECLINE_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection app.tg.rd.RapidSpO2DeclineAlarm -> ui.uit.RapidSpO2DeclineAlarm:
 RapidSpO2DeclineAlarm -> RapidSpO2DeclineAlarm
Solved by:  Identity (id):  P->P is tautology


Theorem (1347)                               [serial 1061] 
P [1] << SPO2_TREND() >>
S [2] ->
Q [1] << SPO2_TREND() >>
Why created:  Composition of Subcomponents via Directional Connection app.tg.tr.SpO2Trend -> ui.uit.SpO2Trend:
 SpO2Trend -> SpO2Trend
Solved by:  Identity (id):  P->P is tautology


Theorem (1348)                               [serial 1062] 
P [1] << HeartRateTrend = HEART_RATE_HISTORY >>
S [2] ->
Q [1] << HeartRateTrend = HEART_RATE_HISTORY >>
Why created:  Composition of Subcomponents via Directional Connection app.tg.hrt.HeartRateTrend -> ui.uit.HeartRateTrend:
 HeartRateTrend -> HeartRateTrend
Solved by:  Identity (id):  P->P is tautology


Theorem (1349)                               [serial 1063] 
P [1] << SpO2Avg = SPO2_AVERAGE() >>
S [2] ->
Q [1] << SpO2Avg = SPO2_AVERAGE() >>
Why created:  Composition of Subcomponents via Directional Connection app.tg.av.SpO2Avg -> ui.uit.SpO2Avg:
 SpO2Avg -> SpO2Avg
Solved by:  Identity (id):  P->P is tautology


Theorem (1350)                               [serial 1064] 
P [235] << HEART_RATE_LOWER_LIMIT_ALARM() >>
S [130] ->
Q [347] << HEART_RATE_LOWER_LIMIT_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.heart_rate_lower_limit_violated:
 HeartRateLowerLimitViolated -> HeartRateLowerLimitViolated
Solved by:  Identity (id):  P->P is tautology


Theorem (1351)                               [serial 1065] 
P [250] << HEART_RATE_UPPER_LIMIT_ALARM() >>
S [134] ->
Q [354] << HEART_RATE_UPPER_LIMIT_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.heart_rate_upper_limit_violated:
 HeartRateUpperLimitViolated -> HeartRateUpperLimitViolated
Solved by:  Identity (id):  P->P is tautology


Theorem (1352)                               [serial 1066] 
P [546] << HeartRateTrend = HEART_RATE_HISTORY >>
S [137] ->
Q [357] << HeartRateTrend = HEART_RATE_HISTORY >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.heart_rate_trend:
 HeartRateTrend -> HeartRateTrend
Solved by:  Identity (id):  P->P is tautology


Theorem (1353)                               [serial 1067] 
P [569] << SUPPL_O2_ALARM() >>
S [143] ->
Q [382] << SUPPL_O2_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.supplemental_oxygen_alarm:
 SpO2DerivedLowerLimitAlarm -> SpO2DerivedLowerLimitAlarm
Solved by:  Identity (id):  P->P is tautology


Theorem (1354)                               [serial 1068] 
P [577] << RAPID_DECLINE_ALARM() >>
S [149] ->
Q [398] << RAPID_DECLINE_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.rapid_spo2_decline_alarm:
 RapidSpO2DeclineAlarm -> RapidSpO2DeclineAlarm
Solved by:  Identity (id):  P->P is tautology


Theorem (1355)                               [serial 1069] 
P [554] << MOTION_ARTIFACT_ALARM() >>
S [160] ->
Q [405] << MOTION_ARTIFACT_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.motion_artifact_alarm:
 MotionArtifactAlarm -> MotionArtifactAlarm
Solved by:  Identity (id):  P->P is tautology


Theorem (1356)                               [serial 1070] 
P [583] << SPO2_TREND() >>
S [166] ->
Q [411] << SPO2_TREND() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.spO2_Trend:
 SpO2Trend -> SpO2Trend
Solved by:  Identity (id):  P->P is tautology


Theorem (1357)                               [serial 1071] 
P [561] << SpO2Avg = SPO2_AVERAGE() >>
S [167] ->
Q [368] << SpO2Avg = SPO2_AVERAGE() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.spO2_Average:
 SpO2Avg -> SpO2Avg
Solved by:  Identity (id):  P->P is tautology


Theorem (1358)                               [serial 1072] 
P [326] << SPO2_LOWER_LIMIT_ALARM() >>
S [431] ->
Q [467] << SPO2_LOWER_LIMIT_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_spo2_llv:
 SpO2LowerLimitViolated -> SpO2LowerLimitViolated
Solved by:  Identity (id):  P->P is tautology


Theorem (1359)                               [serial 1073] 
P [347] << HEART_RATE_LOWER_LIMIT_ALARM() >>
S [434] ->
Q [475] << HEART_RATE_LOWER_LIMIT_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_heartrate_llv:
 HeartRateLowerLimitViolated -> HeartRateLowerLimitViolated
Solved by:  Identity (id):  P->P is tautology


Theorem (1360)                               [serial 1074] 
P [354] << HEART_RATE_UPPER_LIMIT_ALARM() >>
S [436] ->
Q [479] << HEART_RATE_UPPER_LIMIT_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_heartrate_ulv:
 HeartRateUpperLimitViolated -> HeartRateUpperLimitViolated
Solved by:  Identity (id):  P->P is tautology


Theorem (1361)                               [serial 1075] 
P [357] << HeartRateTrend = HEART_RATE_HISTORY >>
S [437] ->
Q [482] << HeartRateTrend = HEART_RATE_HISTORY >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_heartrate_trend:
 HeartRateTrend -> HeartRateTrend
Solved by:  Identity (id):  P->P is tautology


Theorem (1362)                               [serial 1076] 
P [382] << SUPPL_O2_ALARM() >>
S [440] ->
Q [490] << SUPPL_O2_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_spo2derived_lla:
 SpO2DerivedLowerLimitAlarm -> SpO2DerivedLowerLimitAlarm
Solved by:  Identity (id):  P->P is tautology


Theorem (1363)                               [serial 1077] 
P [368] << SpO2Avg = SPO2_AVERAGE() >>
S [442] ->
Q [497] << SpO2Avg = SPO2_AVERAGE() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_spo2avg:
 SpO2Avg -> SpO2Avg
Solved by:  Identity (id):  P->P is tautology


Theorem (1364)                               [serial 1078] 
P [398] << RAPID_DECLINE_ALARM() >>
S [445] ->
Q [505] << RAPID_DECLINE_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_rapiddeclinealarm:
 RapidSpO2DeclineAlarm -> RapidSpO2DeclineAlarm
Solved by:  Identity (id):  P->P is tautology


Theorem (1365)                               [serial 1079] 
P [405] << MOTION_ARTIFACT_ALARM() >>
S [447] ->
Q [512] << MOTION_ARTIFACT_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_motionartifactalarm:
 MotionArtifactAlarm -> MotionArtifactAlarm
Solved by:  Identity (id):  P->P is tautology


Theorem (1366)                               [serial 1080] 
P [411] << SPO2_TREND() >>
S [448] ->
Q [518] << SPO2_TREND() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_spo2trend:
 SpO2Trend -> SpO2Trend
Solved by:  Identity (id):  P->P is tautology


Theorem (1367)                               [serial 1081] 
P [634] << HeartRateTrend = HEART_RATE_HISTORY >>
S [595] ->
Q [546] << HeartRateTrend = HEART_RATE_HISTORY >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoAppProcess.imp.ap_heartrate_trend:
 HeartRateTrend -> HeartRateTrend
Solved by:  Identity (id):  P->P is tautology


Theorem (1368)                               [serial 1082] 
P [642] << MOTION_ARTIFACT_ALARM() >>
S [598] ->
Q [554] << MOTION_ARTIFACT_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoAppProcess.imp.ap_maa:
 MotionArtifactAlarm -> MotionArtifactAlarm
Solved by:  Identity (id):  P->P is tautology


Theorem (1369)                               [serial 1083] 
P [657] << SUPPL_O2_ALARM() >>
S [601] ->
Q [569] << SUPPL_O2_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoAppProcess.imp.ap_spo2derived_lla:
 SpO2DerivedLowerLimitAlarm -> SpO2DerivedLowerLimitAlarm
Solved by:  Identity (id):  P->P is tautology


Theorem (1370)                               [serial 1084] 
P [665] << RAPID_DECLINE_ALARM() >>
S [604] ->
Q [577] << RAPID_DECLINE_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoAppProcess.imp.ap_rda:
 RapidSpO2DeclineAlarm -> RapidSpO2DeclineAlarm
Solved by:  Identity (id):  P->P is tautology


Theorem (1371)                               [serial 1085] 
P [671] << SPO2_TREND() >>
S [605] ->
Q [583] << SPO2_TREND() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoAppProcess.imp.ap_spo2trend:
 SpO2Trend -> SpO2Trend
Solved by:  Identity (id):  P->P is tautology


Theorem (1372)                               [serial 1086] 
P [649] << SpO2Avg = SPO2_AVERAGE() >>
S [606] ->
Q [561] << SpO2Avg = SPO2_AVERAGE() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoAppProcess.imp.ap_spo2average:
 SpO2Avg -> SpO2Avg
Solved by:  Identity (id):  P->P is tautology


Theorem (1373)                               [serial 1087] 
P [13] << MOTION_ARTIFACT_ALARM() >>
S [694] ->
Q [642] << MOTION_ARTIFACT_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.maa:
 MotionArtifactAlarm -> MotionArtifactAlarm
Solved by:  Identity (id):  P->P is tautology


Theorem (1374)                               [serial 1088] 
P [17] << SpO2Avg = SPO2_AVERAGE() >>
S [698] ->
Q [649] << SpO2Avg = SPO2_AVERAGE() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.avout:
 SpO2Avg -> SpO2Avg
Solved by:  Identity (id):  P->P is tautology


Theorem (1375)                               [serial 1089] 
P [17] << SpO2Avg = SPO2_AVERAGE() >>
S [699] ->
Q [9] << SpO2Avg = SPO2_AVERAGE() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.avso:
 SpO2Avg -> SpO2Avg
Solved by:  Identity (id):  P->P is tautology


Theorem (1376)                               [serial 1090] 
P [17] << SUPPL_O2_ALARM() >>
S [703] ->
Q [657] << SUPPL_O2_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.soalarm:
 SpO2DerivedLowerLimitAlarm -> SpO2DerivedLowerLimitAlarm
Solved by:  Identity (id):  P->P is tautology


Theorem (1377)                               [serial 1091] 
P [22] << RAPID_DECLINE_ALARM() >>
S [706] ->
Q [665] << RAPID_DECLINE_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.rdalarm:
 RapidSpO2DeclineAlarm -> RapidSpO2DeclineAlarm
Solved by:  Identity (id):  P->P is tautology


Theorem (1378)                               [serial 1092] 
P [15] << SPO2_TREND() >>
S [707] ->
Q [671] << SPO2_TREND() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.sptrend:
 SpO2Trend -> SpO2Trend
Solved by:  Identity (id):  P->P is tautology


Theorem (1379)                               [serial 1093] 
P [15] << HeartRateTrend = HEART_RATE_HISTORY >>
S [709] ->
Q [634] << HeartRateTrend = HEART_RATE_HISTORY >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.hrtr:
 HeartRateTrend -> HeartRateTrend
Solved by:  Identity (id):  P->P is tautology


Theorem (1380)                               [serial 1094] 
P [17] << SpO2Avg_AverageSpO2 = SPO2_AVERAGE() >>
S [711] ->
Q [20] << SpO2Avg_AverageSpO2 = SPO2_AVERAGE() >>
Why created:  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.spo2av:
 SpO2Avg -> AverageSpO2
Solved by:  Identity (id):  P->P is tautology


Theorem (1381)                               [serial 1001] 
Why created:  All verification conditions have been proved correct. 
Solved by:  Component and Connection Proofs
and theorems 24 353 709 803 827 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380:
Theorem (24) [serial 1002] used for:
  Initial proof obligations for RapidDeclineThread.imp 
Theorem (353) [serial 1007] used for:
  Initial proof obligations for HeartRateTrendThread.imp 
Theorem (709) [serial 1018] used for:
  Initial proof obligations for SpO2TrendThread.imp 
Theorem (803) [serial 1029] used for:
  Initial proof obligations for MotionArtifactThread.imp 
Theorem (827) [serial 1034] used for:
  Initial proof obligations for SupplemetalOxygenThread.imp 
Theorem (1339) [serial 1042] used for:
  Initial proof obligations for SpO2AverageThread.imp 
Theorem (1340) [serial 1054] used for:
  Composition of Subcomponents via Directional Connection av.SpO2Avg -> so.SpO2Avg:
 SpO2Avg -> SpO2Avg 
Theorem (1341) [serial 1055] used for:
  Composition of Subcomponents via Directional Connection av.SpO2Avg -> rd.AverageSpO2:
 SpO2Avg -> AverageSpO2 
Theorem (1342) [serial 1056] used for:
  Composition of Subcomponents via Directional Connection po.HeartRateLowerLimitViolated -> ui.uit.HeartRateLowerLimitViolated:
 HeartRateLowerLimitViolated -> HeartRateLowerLimitViolated 
Theorem (1343) [serial 1057] used for:
  Composition of Subcomponents via Directional Connection po.HeartRateUpperLimitViolated -> ui.uit.HeartRateUpperLimitViolated:
 HeartRateUpperLimitViolated -> HeartRateUpperLimitViolated 
Theorem (1344) [serial 1058] used for:
  Composition of Subcomponents via Directional Connection app.tg.ma.MotionArtifactAlarm -> ui.uit.MotionArtifactAlarm:
 MotionArtifactAlarm -> MotionArtifactAlarm 
Theorem (1345) [serial 1059] used for:
  Composition of Subcomponents via Directional Connection app.tg.so.SpO2DerivedLowerLimitAlarm -> ui.uit.SpO2DerivedLowerLimitAlarm:
 SpO2DerivedLowerLimitAlarm -> SpO2DerivedLowerLimitAlarm 
Theorem (1346) [serial 1060] used for:
  Composition of Subcomponents via Directional Connection app.tg.rd.RapidSpO2DeclineAlarm -> ui.uit.RapidSpO2DeclineAlarm:
 RapidSpO2DeclineAlarm -> RapidSpO2DeclineAlarm 
Theorem (1347) [serial 1061] used for:
  Composition of Subcomponents via Directional Connection app.tg.tr.SpO2Trend -> ui.uit.SpO2Trend:
 SpO2Trend -> SpO2Trend 
Theorem (1348) [serial 1062] used for:
  Composition of Subcomponents via Directional Connection app.tg.hrt.HeartRateTrend -> ui.uit.HeartRateTrend:
 HeartRateTrend -> HeartRateTrend 
Theorem (1349) [serial 1063] used for:
  Composition of Subcomponents via Directional Connection app.tg.av.SpO2Avg -> ui.uit.SpO2Avg:
 SpO2Avg -> SpO2Avg 
Theorem (1350) [serial 1064] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.heart_rate_lower_limit_violated:
 HeartRateLowerLimitViolated -> HeartRateLowerLimitViolated 
Theorem (1351) [serial 1065] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.heart_rate_upper_limit_violated:
 HeartRateUpperLimitViolated -> HeartRateUpperLimitViolated 
Theorem (1352) [serial 1066] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.heart_rate_trend:
 HeartRateTrend -> HeartRateTrend 
Theorem (1353) [serial 1067] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.supplemental_oxygen_alarm:
 SpO2DerivedLowerLimitAlarm -> SpO2DerivedLowerLimitAlarm 
Theorem (1354) [serial 1068] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.rapid_spo2_decline_alarm:
 RapidSpO2DeclineAlarm -> RapidSpO2DeclineAlarm 
Theorem (1355) [serial 1069] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.motion_artifact_alarm:
 MotionArtifactAlarm -> MotionArtifactAlarm 
Theorem (1356) [serial 1070] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.spO2_Trend:
 SpO2Trend -> SpO2Trend 
Theorem (1357) [serial 1071] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoSystem.imp.spO2_Average:
 SpO2Avg -> SpO2Avg 
Theorem (1358) [serial 1072] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_spo2_llv:
 SpO2LowerLimitViolated -> SpO2LowerLimitViolated 
Theorem (1359) [serial 1073] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_heartrate_llv:
 HeartRateLowerLimitViolated -> HeartRateLowerLimitViolated 
Theorem (1360) [serial 1074] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_heartrate_ulv:
 HeartRateUpperLimitViolated -> HeartRateUpperLimitViolated 
Theorem (1361) [serial 1075] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_heartrate_trend:
 HeartRateTrend -> HeartRateTrend 
Theorem (1362) [serial 1076] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_spo2derived_lla:
 SpO2DerivedLowerLimitAlarm -> SpO2DerivedLowerLimitAlarm 
Theorem (1363) [serial 1077] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_spo2avg:
 SpO2Avg -> SpO2Avg 
Theorem (1364) [serial 1078] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_rapiddeclinealarm:
 RapidSpO2DeclineAlarm -> RapidSpO2DeclineAlarm 
Theorem (1365) [serial 1079] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_motionartifactalarm:
 MotionArtifactAlarm -> MotionArtifactAlarm 
Theorem (1366) [serial 1080] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoUIprocess.imp.ui_spo2trend:
 SpO2Trend -> SpO2Trend 
Theorem (1367) [serial 1081] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoAppProcess.imp.ap_heartrate_trend:
 HeartRateTrend -> HeartRateTrend 
Theorem (1368) [serial 1082] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoAppProcess.imp.ap_maa:
 MotionArtifactAlarm -> MotionArtifactAlarm 
Theorem (1369) [serial 1083] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoAppProcess.imp.ap_spo2derived_lla:
 SpO2DerivedLowerLimitAlarm -> SpO2DerivedLowerLimitAlarm 
Theorem (1370) [serial 1084] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoAppProcess.imp.ap_rda:
 RapidSpO2DeclineAlarm -> RapidSpO2DeclineAlarm 
Theorem (1371) [serial 1085] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoAppProcess.imp.ap_spo2trend:
 SpO2Trend -> SpO2Trend 
Theorem (1372) [serial 1086] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoAppProcess.imp.ap_spo2average:
 SpO2Avg -> SpO2Avg 
Theorem (1373) [serial 1087] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.maa:
 MotionArtifactAlarm -> MotionArtifactAlarm 
Theorem (1374) [serial 1088] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.avout:
 SpO2Avg -> SpO2Avg 
Theorem (1375) [serial 1089] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.avso:
 SpO2Avg -> SpO2Avg 
Theorem (1376) [serial 1090] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.soalarm:
 SpO2DerivedLowerLimitAlarm -> SpO2DerivedLowerLimitAlarm 
Theorem (1377) [serial 1091] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.rdalarm:
 RapidSpO2DeclineAlarm -> RapidSpO2DeclineAlarm 
Theorem (1378) [serial 1092] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.sptrend:
 SpO2Trend -> SpO2Trend 
Theorem (1379) [serial 1093] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.hrtr:
 HeartRateTrend -> HeartRateTrend 
Theorem (1380) [serial 1094] used for:
  Composition of Subcomponents via Directional Connection PO::ICEpoApp.imp.spo2av:
 SpO2Avg -> AverageSpO2 


closing proof.txt file 