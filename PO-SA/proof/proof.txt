This file, proof.txt, was produced the BLESS Proof Assistant v3.1
  at Sun Jan 10 11:11:31 CST 2021 by brianlarson

Theorem (1)                               [serial 2407] 
P [39] << all j~quantity whole
  in 1..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
S [34] ->
Q [34] << all j~quantity whole
  in 1..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
by Identity (id):  P->P is tautology


Theorem (2)                               [serial 2405] 
P [39] << (all j~quantity whole
  in 1..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) ) >>
S [34] ->
Q [34] << all j~quantity whole
  in 1..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1:
Theorem (1) [serial 2407] used for:
    normalization of [serial 2405]
 


Theorem (3)                               [serial 1003] 
P [39] << MOINV() >>
S [34] ->
Q [34] << all j~quantity whole
  in 1..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
by Substitution of Assertion Labels
and theorem 2:
Theorem (2) [serial 2405] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1003]
 


Theorem (4)                               [serial 1004] 
P [38] << (numBadReadings = 0) >>
S [38] ->
Q [38] << true >>
by True Conclusion Schema (tc): P->true


Theorem (5)                               [serial 2428] 
P [38] << numBadReadings = 0 >>
S [42] ->
Q [39] << true >>
by True Conclusion Schema (tc): P->true


Theorem (6)                               [serial 2425] 
P [38] << numBadReadings = 0 >>
S [42] ->
Q [39] << all j~quantity whole
  in false 
  are MOTION_ARTIFACT^(1-j) or not SENSOR_CONNECTED^(1-j)  >>
by Empty Range Law All: all a:t in false are V is tautology
and theorem 5:
Theorem (5) [serial 2428] used for:
  Empty Range Law All: all a:t in false are V is tautology [serial 2425]
 


Theorem (7)                               [serial 2423] 
P [38] << numBadReadings = 0 >>
S [42] ->
Q [39] << all j~quantity whole
  in false 
  are MOTION_ARTIFACT^(1-j) or not (SENSOR_CONNECTED^(- j))^1  >>
by Normalization
  Normalization Axioms:
    Caret Compostition:  (x^a)^b is x^(a+b)
    Associativity: (b.c).a = a.b.c
and theorem 6:
Theorem (6) [serial 2425] used for:
    normalization of [serial 2423]
 


Theorem (8)                               [serial 2421] 
P [38] << numBadReadings = 0 >>
S [42] ->
Q [39] << all j~quantity whole
  in false 
  are MOTION_ARTIFACT^(1-j) or (not SENSOR_CONNECTED^(- j))^1  >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 7:
Theorem (7) [serial 2423] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2421]
 


Theorem (9)                               [serial 2419] 
P [38] << numBadReadings = 0 >>
S [42] ->
Q [39] << all j~quantity whole
  in false 
  are (MOTION_ARTIFACT^((- j)+1) or (not SENSOR_CONNECTED^(- j))^1)  >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Associativity: (b.c).a = a.b.c
and theorem 8:
Theorem (8) [serial 2421] used for:
    normalization of [serial 2419]
 


Theorem (10)                               [serial 2417] 
P [38] << numBadReadings = 0 >>
S [42] ->
Q [39] << all j~quantity whole
  in false 
  are (MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j))^1  >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 9:
Theorem (9) [serial 2419] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2417]
 


Theorem (11)                               [serial 2415] 
P [38] << numBadReadings = 0 >>
S [42] ->
Q [39] << (all j~quantity whole
  in false 
  are (MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j))^1 ) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 10:
Theorem (10) [serial 2417] used for:
    normalization of [serial 2415]
 


Theorem (12)                               [serial 2414] 
P [38] << numBadReadings = 0 >>
S [42] ->
Q [39] << (all j~quantity whole
  in false 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) )^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 11:
Theorem (11) [serial 2415] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2414]
 


Theorem (13)                               [serial 2413] 
P [38] << numBadReadings = 0 >>
S [42] ->
Q [39] << (all j~quantity whole
  in 1..0 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) )^1 >>
by Empty Range
and theorem 12:
Theorem (12) [serial 2414] used for:
  Empty Range [serial 2413]
 


Theorem (14)                               [serial 2411] 
P [38] << numBadReadings = 0 >>
S [42] ->
Q [39] << (all j~quantity whole
  in 1..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) )^1 >>
by Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
and theorem 13:
Theorem (13) [serial 2413] used for:
  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
 replacing "numBadReadings"
 with its ="
 (0)" [serial 2411]
 


Theorem (15)                               [serial 2409] 
P [38] << (numBadReadings = 0) >>
S [42] ->
Q [39] << ((all j~quantity whole
  in 1..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) ))^1 >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 14:
Theorem (14) [serial 2411] used for:
    normalization of [serial 2409]
 


Theorem (16)                               [serial 1005] 
P [38] << (numBadReadings = 0) >>
S [42] ->
Q [39] << (MOINV())^1 >>
by Substitution of Assertion Labels
and theorem 15:
Theorem (15) [serial 2409] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 1005]
 


Theorem (17)                               [serial 2429] 
P [39] << MOINV() >>
S [39] ->
Q [44] << MOINV() >>
by Identity (id):  P->P is tautology


Theorem (18)                               [serial 2593] 
P [68] << all j~quantity whole
  in 0..numBadReadings - 1 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
S [39] ->
Q [21] << all j~quantity whole
  in 0..numBadReadings - 1 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
by Identity (id):  P->P is tautology


Theorem (19)                               [serial 2591] 
P [68] << all j~quantity whole
  in 0..((numBadReadings - 1) - 0) 
  are MOTION_ARTIFACT^(- (j+0)) or not SENSOR_CONNECTED^(- (j+0))  >>
S [39] ->
Q [21] << all j~quantity whole
  in 0..(numBadReadings - 1) 
  are MOTION_ARTIFACT^(1-(j+1)) or not SENSOR_CONNECTED^(1-(j+1))  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Subtaction of Added Value:  (a+b)-a is b
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Associativity: (b.c).a = a.b.c
and theorem 18:
Theorem (18) [serial 2593] used for:
    normalization of [serial 2591]
 


Theorem (20)                               [serial 2588] 
P [68] << all j~quantity whole
  in 0..numBadReadings - 1 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
S [39] ->
Q [21] << all j~quantity whole
  in 1..numBadReadings 
  are MOTION_ARTIFACT^(1-j) or not SENSOR_CONNECTED^(1-j)  >>
by Shift Quantification Range so Lower Bound is Zero
and theorem 19:
Theorem (19) [serial 2591] used for:
  Shift Quantification Range so Lower Bound is Zero [serial 2588]
 


Theorem (21)                               [serial 2586] 
P [68] << all j~quantity whole
  in 0..numBadReadings - 1 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
S [39] ->
Q [21] << all j~quantity whole
  in 1..numBadReadings 
  are MOTION_ARTIFACT^(1-j) or not (SENSOR_CONNECTED^(- j))^1  >>
by Normalization
  Normalization Axioms:
    Caret Compostition:  (x^a)^b is x^(a+b)
    Associativity: (b.c).a = a.b.c
and theorem 20:
Theorem (20) [serial 2588] used for:
    normalization of [serial 2586]
 


Theorem (22)                               [serial 2584] 
P [68] << all j~quantity whole
  in 0..numBadReadings - 1 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
S [39] ->
Q [21] << all j~quantity whole
  in 1..numBadReadings 
  are MOTION_ARTIFACT^(1-j) or (not SENSOR_CONNECTED^(- j))^1  >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 21:
Theorem (21) [serial 2586] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2584]
 


Theorem (23)                               [serial 2582] 
P [68] << all j~quantity whole
  in 0..numBadReadings - 1 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
S [39] ->
Q [21] << all j~quantity whole
  in 1..numBadReadings 
  are (MOTION_ARTIFACT^((- j)+1) or (not SENSOR_CONNECTED^(- j))^1)  >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Associativity: (b.c).a = a.b.c
and theorem 22:
Theorem (22) [serial 2584] used for:
    normalization of [serial 2582]
 


Theorem (24)                               [serial 2580] 
P [68] << all j~quantity whole
  in 0..numBadReadings - 1 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
S [39] ->
Q [21] << all j~quantity whole
  in 1..numBadReadings 
  are (MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j))^1  >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 23:
Theorem (23) [serial 2582] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2580]
 


Theorem (25)                               [serial 2578] 
P [68] << all j~quantity whole
  in 0..numBadReadings - 1 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
S [39] ->
Q [21] << (all j~quantity whole
  in 1..numBadReadings 
  are (MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j))^1 ) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 24:
Theorem (24) [serial 2580] used for:
    normalization of [serial 2578]
 


Theorem (26)                               [serial 2557] 
P [68] << all j~quantity whole
  in 0..numBadReadings - 1 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
S [39] ->
Q [21] << (all j~quantity whole
  in 1..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) )^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 25:
Theorem (25) [serial 2578] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2557]
 


Theorem (27)                               [serial 2546] 
P [68] << (all j~quantity whole
  in 0..(numBadReadings - 1) 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) ) >>
S [39] ->
Q [21] << (all j~quantity whole
  in 1..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) )^1 >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 26:
Theorem (26) [serial 2557] used for:
    normalization of [serial 2546]
 


Theorem (28)                               [serial 2513] 
P [68] << NUMBAD() >>
S [39] ->
Q [21] << (all j~quantity whole
  in 1..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) )^1 >>
by Substitution of Assertion Labels
and theorem 27:
Theorem (27) [serial 2546] used for:
  substituted Assertions' predicates for  labels  [serial 2513]
 


Theorem (29)                               [serial 2499] 
P [68] << NUMBAD() >>
S [39] ->
Q [21] << ((all j~quantity whole
  in 1..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) ))^1 >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 28:
Theorem (28) [serial 2513] used for:
    normalization of [serial 2499]
 


Theorem (30)                               [serial 2430] 
P [68] << NUMBAD() >>
S [39] ->
Q [21] << (MOINV())^1 >>
by Substitution of Assertion Labels
and theorem 29:
Theorem (29) [serial 2499] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 2430]
 


Theorem (31)                               [serial 2575] 
P [44] << all j~quantity whole
  in 1..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
S [45] ->
Q [45] << true >>
by True Conclusion Schema (tc): P->true


Theorem (32)                               [serial 2573] 
P [44] << all j~quantity whole
  in 1..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
S [45] ->
Q [45] << (true) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 31:
Theorem (31) [serial 2575] used for:
    normalization of [serial 2573]
 


Theorem (33)                               [serial 2572] 
P [44] << all j~quantity whole
  in 1..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
S [45] ->
Q [45] << (true) and (true) >>
by Law of And-Simplification:  P and P is P
and theorem 32:
Theorem (32) [serial 2573] used for:
  Law of And-Simplification:  P and P is P [serial 2572]
 


Theorem (34)                               [serial 2571] 
P [44] << all j~quantity whole
  in 1..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
S [45] ->
Q [45] << (SENSOR_CONNECTED^0 or MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and 
(not MOTION_ARTIFACT^0 or MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Law of Excluded Middle: P or not P is tautology
and theorem 33:
Theorem (33) [serial 2572] used for:
  Law of Excluded Middle: P or not P is tautology [serial 2571]
 


Theorem (35)                               [serial 2553] 
P [44] << all j~quantity whole
  in 1..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
S [45] ->
Q [45] << MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 or (SENSOR_CONNECTED^0 and 
not MOTION_ARTIFACT^0) >>
by Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 34:
Theorem (34) [serial 2571] used for:
  Distributing Postcondition Or-Over-And [serial 2553]
 


Theorem (36)                               [serial 2544] 
P [44] << (all j~quantity whole
  in 1..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) ) >>
S [45] ->
Q [45] << MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 or (SENSOR_CONNECTED^0 and 
not MOTION_ARTIFACT^0) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 35:
Theorem (35) [serial 2553] used for:
    normalization of [serial 2544]
 


Theorem (37)                               [serial 2479] 
P [44] << MOINV() >>
S [45] ->
Q [45] << MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 or (SENSOR_CONNECTED^0 and 
not MOTION_ARTIFACT^0) >>
by Substitution of Assertion Labels
and theorem 36:
Theorem (36) [serial 2544] used for:
  substituted Assertions' predicates for  labels  [serial 2479]
 


Theorem (38)                               [serial 2450] 
P [44] << MOINV() >>
S [45] ->
Q [45] << (SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0) or (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) >>
by Associativity: (b.c).a = a.b.c
and theorem 37:
Theorem (37) [serial 2479] used for:
  Associativity: (b.c).a = a.b.c [serial 2450]
 


Theorem (39)                               [serial 2433] 
P [44] << MOINV() >>
S [45] ->
Q [45] << ((SENSOR_CONNECTED)^0 and not (MOTION_ARTIFACT)^0) or ((MOTION_ARTIFACT)^0 or 
not (SENSOR_CONNECTED)^0) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 38:
Theorem (38) [serial 2450] used for:
    normalization of [serial 2433]
 


Theorem (40)                               [serial 2497] 
P [45] << SENSOR_CONNECTED^0 and MOINV() and not MOTION_ARTIFACT^0 >>
S [45] ->
Q [48] << SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (41)                               [serial 2480] 
P [45] << SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 and MOINV() >>
S [45] ->
Q [48] << SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 40:
Theorem (40) [serial 2497] used for:
    normalization of [serial 2480]
 


Theorem (42)                               [serial 2452] 
P [45] << MOINV() and (SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0) >>
S [45] ->
Q [48] << SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 >>
by Associativity: (b.c).a = a.b.c
and theorem 41:
Theorem (41) [serial 2480] used for:
  Associativity: (b.c).a = a.b.c [serial 2452]
 


Theorem (43)                               [serial 2434] 
P [45] << (MOINV()) and ((SENSOR_CONNECTED)^0 and not (MOTION_ARTIFACT)^0) >>
S [45] ->
Q [48] << SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 42:
Theorem (42) [serial 2452] used for:
    normalization of [serial 2434]
 


Theorem (44)                               [serial 2541] 
P [48] << SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 >>
S [49] ->
Q [50] << true >>
by True Conclusion Schema (tc): P->true


Theorem (45)                               [serial 2528] 
P [48] << SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 >>
S [49] ->
Q [50] << all j~quantity whole
  in false 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
by Empty Range Law All: all a:t in false are V is tautology
and theorem 44:
Theorem (44) [serial 2541] used for:
  Empty Range Law All: all a:t in false are V is tautology [serial 2528]
 


Theorem (46)                               [serial 2515] 
P [48] << SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 >>
S [49] ->
Q [50] << all j~quantity whole
  in 0..-1 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
by Empty Range
and theorem 45:
Theorem (45) [serial 2528] used for:
  Empty Range [serial 2515]
 


Theorem (47)                               [serial 2504] 
P [48] << SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 >>
S [49] ->
Q [50] << (all j~quantity whole
  in 0..(0 - 1) 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) ) >>
by Normalization
  Normalization Axioms:
    Unary Minus:  -(x-y) is (y-x)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 46:
Theorem (46) [serial 2515] used for:
    normalization of [serial 2504]
 


Theorem (48)                               [serial 2500] 
P [48] << SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 >>
S [49] numBadReadings := 0
Q [50] << (all j~quantity whole
  in 0..(numBadReadings - 1) 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) ) >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 47:
Theorem (47) [serial 2504] used for:
  applied wp for assignment [serial 2500]
 


Theorem (49)                               [serial 2435] 
P [48] << SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 >>
S [49] numBadReadings := 0
Q [50] << NUMBAD() >>
by Substitution of Assertion Labels
and theorem 48:
Theorem (48) [serial 2500] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 2435]
 


Theorem (50)                               [serial 2436] 
P [50] << NUMBAD() >>
S [45] ->
Q [57] << NUMBAD() >>
by Identity (id):  P->P is tautology


Theorem (51)                               [serial 2568] 
P [53] << all j~quantity whole
  in 0..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
S [45] ->
Q [53] << all j~quantity whole
  in 0..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
by Identity (id):  P->P is tautology


Theorem (52)                               [serial 2542] 
P [45] << (all j~quantity whole
  in 1..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) ) and (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) >>
S [45] ->
Q [53] << all j~quantity whole
  in 0..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
by Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
and theorem 51:
Theorem (51) [serial 2568] used for:
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j) [serial 2542]
 


Theorem (53)                               [serial 2456] 
P [45] << MOINV() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [45] ->
Q [53] << all j~quantity whole
  in 0..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
by Substitution of Assertion Labels
and theorem 52:
Theorem (52) [serial 2542] used for:
  substituted Assertions' predicates for  labels  [serial 2456]
 


Theorem (54)                               [serial 2437] 
P [45] << (MOINV()) and ((MOTION_ARTIFACT)^0 or not (SENSOR_CONNECTED)^0) >>
S [45] ->
Q [53] << all j~quantity whole
  in 0..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 53:
Theorem (53) [serial 2456] used for:
    normalization of [serial 2437]
 


Theorem (55)                               [serial 2519] 
P [53] << all j~quantity whole
  in 0..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
S [54] ->
Q [55] << all j~quantity whole
  in 0..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
by Identity (id):  P->P is tautology


Theorem (56)                               [serial 2506] 
P [53] << all j~quantity whole
  in 0..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
S [54] ->
Q [55] << (all j~quantity whole
  in 0..((1 + numBadReadings) - 1) 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) ) >>
by Normalization
  Normalization Axioms:
    Subtaction of Added Value:  (a+b)-a is b
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 55:
Theorem (55) [serial 2519] used for:
    normalization of [serial 2506]
 


Theorem (57)                               [serial 2502] 
P [53] << all j~quantity whole
  in 0..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
S [54] numBadReadings := 1 + numBadReadings
Q [55] << (all j~quantity whole
  in 0..(numBadReadings - 1) 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) ) >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 56:
Theorem (56) [serial 2506] used for:
  applied wp for assignment [serial 2502]
 


Theorem (58)                               [serial 2458] 
P [53] << all j~quantity whole
  in 0..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
S [54] numBadReadings := 1 + numBadReadings
Q [55] << NUMBAD() >>
by Substitution of Assertion Labels
and theorem 57:
Theorem (57) [serial 2502] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 2458]
 


Theorem (59)                               [serial 2438] 
P [53] << all j~quantity whole
  in 0..numBadReadings 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
S [54] numBadReadings := numBadReadings + 1
Q [55] << NUMBAD() >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
and theorem 58:
Theorem (58) [serial 2458] used for:
    normalization of [serial 2438]
 


Theorem (60)                               [serial 2439] 
P [55] << NUMBAD() >>
S [45] ->
Q [57] << NUMBAD() >>
by Identity (id):  P->P is tautology


Theorem (61)                               [serial 2431] 
P [44] << MOINV() >>
S [45] if 
(SensorConnected? and not MotionArtifact?)~> 
  << SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 >>
  numBadReadings := 0
  << NUMBAD() >> 
[]
(MotionArtifact? or not SensorConnected?)~> 
  << all j~quantity whole
    in 0..numBadReadings 
    are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
  numBadReadings := numBadReadings + 1
  << NUMBAD() >> 
fi
Q [57] << NUMBAD() >>
by Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>> (bl.iffi)
and theorems 39 43 49 50 54 59 60:
Theorem (39) [serial 2433] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>>  in if-[]-fi  for [serial 2431]
 
Theorem (43) [serial 2434] used for:
    <<P and B0>> -> <<P0>>  for [serial 2431]
 
Theorem (49) [serial 2435] used for:
    <<P0>> S0 <<Q0>>  for [serial 2431]
 
Theorem (50) [serial 2436] used for:
    <<Q0>> -> <<Q>>  for [serial 2431]
 
Theorem (54) [serial 2437] used for:
    <<P and B1>> -> <<P1>>  for [serial 2431]
 
Theorem (59) [serial 2438] used for:
    <<P1>> S1 <<Q1>>  for [serial 2431]
 
Theorem (60) [serial 2439] used for:
    <<Q1>> -> <<Q>>  for [serial 2431]
 


Theorem (62)                               [serial 2570] 
P [57] << all j~quantity whole
  in 0..numBadReadings - 1 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
S [59] ->
Q [59] << true >>
by True Conclusion Schema (tc): P->true


Theorem (63)                               [serial 2569] 
P [57] << all j~quantity whole
  in 0..numBadReadings - 1 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
S [59] ->
Q [59] << (not ((numBadReadings - 1) < #PulseOx_Properties::Motion_Artifact_Sample_Limit)) or 
(numBadReadings - 1) < #PulseOx_Properties::Motion_Artifact_Sample_Limit >>
by Law of Excluded Middle: P or not P is tautology
and theorem 62:
Theorem (62) [serial 2570] used for:
  Law of Excluded Middle: P or not P is tautology [serial 2569]
 


Theorem (64)                               [serial 2551] 
P [57] << all j~quantity whole
  in 0..numBadReadings - 1 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
S [59] ->
Q [59] << #PulseOx_Properties::Motion_Artifact_Sample_Limit <= (numBadReadings - 1) or 
(numBadReadings - 1) < #PulseOx_Properties::Motion_Artifact_Sample_Limit >>
by At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 63:
Theorem (63) [serial 2569] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a) [serial 2551]
 


Theorem (65)                               [serial 2543] 
P [57] << (all j~quantity whole
  in 0..(numBadReadings - 1) 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) ) >>
S [59] ->
Q [59] << #PulseOx_Properties::Motion_Artifact_Sample_Limit <= (numBadReadings - 1) or 
(numBadReadings - 1) < #PulseOx_Properties::Motion_Artifact_Sample_Limit >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 64:
Theorem (64) [serial 2551] used for:
    normalization of [serial 2543]
 


Theorem (66)                               [serial 2461] 
P [57] << NUMBAD() >>
S [59] ->
Q [59] << #PulseOx_Properties::Motion_Artifact_Sample_Limit <= (numBadReadings - 1) or 
(numBadReadings - 1) < #PulseOx_Properties::Motion_Artifact_Sample_Limit >>
by Substitution of Assertion Labels
and theorem 65:
Theorem (65) [serial 2543] used for:
  substituted Assertions' predicates for  labels  [serial 2461]
 


Theorem (67)                               [serial 2440] 
P [57] << NUMBAD() >>
S [59] ->
Q [59] << (((numBadReadings - 1) < #PulseOx_Properties::Motion_Artifact_Sample_Limit)) or 
(((numBadReadings - 1) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit)) >>
by Normalization
  Normalization Axioms:
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 66:
Theorem (66) [serial 2461] used for:
    normalization of [serial 2440]
 


Theorem (68)                               [serial 2463] 
P [59] << NUMBAD() and (numBadReadings - 1) < #PulseOx_Properties::Motion_Artifact_Sample_Limit >>
S [59] ->
Q [61] << NUMBAD() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (69)                               [serial 2441] 
P [59] << (NUMBAD()) and (((numBadReadings - 1) < #PulseOx_Properties::Motion_Artifact_Sample_Limit)) >>
S [59] ->
Q [61] << NUMBAD() >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 68:
Theorem (68) [serial 2463] used for:
    normalization of [serial 2441]
 


Theorem (70)                               [serial 2559] 
P [61] << all j~quantity whole
  in 0..numBadReadings - 1 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
S [61] ->
Q [61] << all j~quantity whole
  in 0..numBadReadings - 1 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
by Identity (id):  P->P is tautology


Theorem (71)                               [serial 2547] 
P [61] << (all j~quantity whole
  in 0..(numBadReadings - 1) 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) ) >>
S [61] ->
Q [61] << all j~quantity whole
  in 0..numBadReadings - 1 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 70:
Theorem (70) [serial 2559] used for:
    normalization of [serial 2547]
 


Theorem (72)                               [serial 2517] 
P [61] << NUMBAD() >>
S [61] ->
Q [61] << all j~quantity whole
  in 0..numBadReadings - 1 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
by Substitution of Assertion Labels
and theorem 71:
Theorem (71) [serial 2547] used for:
  substituted Assertions' predicates for  labels  [serial 2517]
 


Theorem (73)                               [serial 2505] 
P [61] << NUMBAD() >>
S [61] ->
Q [61] << (all j~quantity whole
  in 0..(numBadReadings - 1) 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) ) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 72:
Theorem (72) [serial 2517] used for:
    normalization of [serial 2505]
 


Theorem (74)                               [serial 2501] 
P [61] << NUMBAD() >>
S [61] skip
Q [61] << (all j~quantity whole
  in 0..(numBadReadings - 1) 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) ) >>
by Skip Means Implication:  <<P>> skip <<Q>>  is  <<P>> -> <<Q>> (bl.skip)
and theorem 73:
Theorem (73) [serial 2505] used for:
    <<P>> -> <<Q>>
  for [serial 2501]
 


Theorem (75)                               [serial 2442] 
P [61] << NUMBAD() >>
S [61] skip
Q [61] << NUMBAD() >>
by Substitution of Assertion Labels
and theorem 74:
Theorem (74) [serial 2501] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 2442]
 


Theorem (76)                               [serial 2443] 
P [61] << NUMBAD() >>
S [59] ->
Q [68] << NUMBAD() >>
by Identity (id):  P->P is tautology


Theorem (77)                               [serial 2467] 
P [59] << #PulseOx_Properties::Motion_Artifact_Sample_Limit <= (numBadReadings - 1) and 
NUMBAD() >>
S [59] ->
Q [64] << #PulseOx_Properties::Motion_Artifact_Sample_Limit <= (numBadReadings - 1) and 
NUMBAD() >>
by Identity (id):  P->P is tautology


Theorem (78)                               [serial 2444] 
P [59] << (NUMBAD()) and (((numBadReadings - 1) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit)) >>
S [59] ->
Q [64] << NUMBAD() and (((numBadReadings - 1) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit)) >>
by Normalization
  Normalization Axioms:
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 77:
Theorem (77) [serial 2467] used for:
    normalization of [serial 2444]
 


Theorem (79)                               [serial 2577] 
P [64] << #PulseOx_Properties::Motion_Artifact_Sample_Limit <= (numBadReadings - 1) and 
(all j~quantity whole
  in 0..#PulseOx_Properties::Motion_Artifact_Sample_Limit 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) ) >>
S [65] ->
Q [13] << all j~quantity whole
  in 0..#PulseOx_Properties::Motion_Artifact_Sample_Limit 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (80)                               [serial 2555] 
P [64] << #PulseOx_Properties::Motion_Artifact_Sample_Limit <= (numBadReadings - 1) and 
(all j~quantity whole
  in 0..numBadReadings - 1 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) ) >>
S [65] ->
Q [13] << all j~quantity whole
  in 0..#PulseOx_Properties::Motion_Artifact_Sample_Limit 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
by Contract Universal Quantification Range
and theorem 79:
Theorem (79) [serial 2577] used for:
  Contract Universal Quantification Range [serial 2555]
 


Theorem (81)                               [serial 2545] 
P [64] << #PulseOx_Properties::Motion_Artifact_Sample_Limit <= (numBadReadings - 1) and 
(all j~quantity whole
  in 0..(numBadReadings - 1) 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) ) >>
S [65] ->
Q [13] << (all j~quantity whole
  in 0..#PulseOx_Properties::Motion_Artifact_Sample_Limit 
  are (MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)) ) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 80:
Theorem (80) [serial 2555] used for:
    normalization of [serial 2545]
 


Theorem (82)                               [serial 2507] 
P [64] << #PulseOx_Properties::Motion_Artifact_Sample_Limit <= (numBadReadings - 1) and 
NUMBAD() >>
S [65] ->
Q [13] << MOTION_ARTIFACT_ALARM() >>
by Substitution of Assertion Labels
and theorem 81:
Theorem (81) [serial 2545] used for:
  substituted Assertions' predicates for  labels  [serial 2507]
 


Theorem (83)                               [serial 2561] 
P [65] << #PulseOx_Properties::Motion_Artifact_Sample_Limit <= (numBadReadings - 1) and 
MotionArtifactAlarm^0 and (all j~quantity whole
  in 0..numBadReadings - 1 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) ) >>
S [65] ->
Q [66] << all j~quantity whole
  in 0..numBadReadings - 1 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (84)                               [serial 2548] 
P [65] << #PulseOx_Properties::Motion_Artifact_Sample_Limit <= (numBadReadings - 1) and 
MotionArtifactAlarm^0 and (all j~quantity whole
  in 0..(numBadReadings - 1) 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) ) >>
S [65] ->
Q [66] << all j~quantity whole
  in 0..numBadReadings - 1 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
and theorem 83:
Theorem (83) [serial 2561] used for:
    normalization of [serial 2548]
 


Theorem (85)                               [serial 2539] 
P [65] << #PulseOx_Properties::Motion_Artifact_Sample_Limit <= (numBadReadings - 1) and 
MotionArtifactAlarm^0 and NUMBAD() >>
S [65] ->
Q [66] << all j~quantity whole
  in 0..numBadReadings - 1 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
by Substitution of Assertion Labels
and theorem 84:
Theorem (84) [serial 2548] used for:
  substituted Assertions' predicates for  labels  [serial 2539]
 


Theorem (86)                               [serial 2529] 
P [65] << #PulseOx_Properties::Motion_Artifact_Sample_Limit <= (numBadReadings - 1) and 
NUMBAD() and MotionArtifactAlarm^0 >>
S [65] ->
Q [66] << all j~quantity whole
  in 0..numBadReadings - 1 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 85:
Theorem (85) [serial 2539] used for:
    normalization of [serial 2529]
 


Theorem (87)                               [serial 2522] 
P [65] << MotionArtifactAlarm^0 and (#PulseOx_Properties::Motion_Artifact_Sample_Limit <= (numBadReadings - 1) and 
NUMBAD()) >>
S [65] ->
Q [66] << all j~quantity whole
  in 0..numBadReadings - 1 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
by Associativity: (b.c).a = a.b.c
and theorem 86:
Theorem (86) [serial 2529] used for:
  Associativity: (b.c).a = a.b.c [serial 2522]
 


Theorem (88)                               [serial 2508] 
P [65] << (#PulseOx_Properties::Motion_Artifact_Sample_Limit <= (numBadReadings - 1) and 
NUMBAD()) and MotionArtifactAlarm^0 >>
S [65] ->
Q [66] << (all j~quantity whole
  in 0..(numBadReadings - 1) 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) ) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 87:
Theorem (87) [serial 2522] used for:
    normalization of [serial 2508]
 


Theorem (89)                               [serial 2503] 
P [64] << #PulseOx_Properties::Motion_Artifact_Sample_Limit <= (numBadReadings - 1) and 
NUMBAD() >>
S [65] MotionArtifactAlarm!
Q [66] << (all j~quantity whole
  in 0..(numBadReadings - 1) 
  are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j) ) >>
by Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
and theorems 82 88:
Theorem (82) [serial 2507] used for:
  applied port output <<pre>> -> <<M(MotionArtifactAlarm)>> [serial 2503]
 
Theorem (88) [serial 2508] used for:
  applied port output <<pre and MotionArtifactAlarm^0>> -> <<post>> [serial 2503]
 


Theorem (90)                               [serial 2469] 
P [64] << #PulseOx_Properties::Motion_Artifact_Sample_Limit <= (numBadReadings - 1) and 
NUMBAD() >>
S [65] MotionArtifactAlarm!
Q [66] << NUMBAD() >>
by Substitution of Assertion Labels
and theorem 89:
Theorem (89) [serial 2503] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 2469]
 


Theorem (91)                               [serial 2445] 
P [64] << NUMBAD() and (((numBadReadings - 1) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit)) >>
S [65] MotionArtifactAlarm!
Q [66] << NUMBAD() >>
by Normalization
  Normalization Axioms:
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 90:
Theorem (90) [serial 2469] used for:
    normalization of [serial 2445]
 


Theorem (92)                               [serial 2446] 
P [66] << NUMBAD() >>
S [59] ->
Q [68] << NUMBAD() >>
by Identity (id):  P->P is tautology


Theorem (93)                               [serial 2432] 
P [57] << NUMBAD() >>
S [59] if 
(((numBadReadings - 1) < #PulseOx_Properties::Motion_Artifact_Sample_Limit))~> 
  << NUMBAD() >>
  skip
  << NUMBAD() >> 
[]
(((numBadReadings - 1) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit))~> 
  << NUMBAD() and (((numBadReadings - 1) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit)) >>
  MotionArtifactAlarm!
  << NUMBAD() >> 
fi
Q [68] << NUMBAD() >>
by Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>> (bl.iffi)
and theorems 67 69 75 76 78 91 92:
Theorem (67) [serial 2440] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>>  in if-[]-fi  for [serial 2432]
 
Theorem (69) [serial 2441] used for:
    <<P and B0>> -> <<P0>>  for [serial 2432]
 
Theorem (75) [serial 2442] used for:
    <<P0>> S0 <<Q0>>  for [serial 2432]
 
Theorem (76) [serial 2443] used for:
    <<Q0>> -> <<Q>>  for [serial 2432]
 
Theorem (78) [serial 2444] used for:
    <<P and B1>> -> <<P1>>  for [serial 2432]
 
Theorem (91) [serial 2445] used for:
    <<P1>> S1 <<Q1>>  for [serial 2432]
 
Theorem (92) [serial 2446] used for:
    <<Q1>> -> <<Q>>  for [serial 2432]
 


Theorem (94)                               [serial 1006] 
P [39] << MOINV() >>
S [44] << MOINV() >>
if 
(SensorConnected? and not MotionArtifact?)~> 
  << SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 >>
  numBadReadings := 0
  << NUMBAD() >> 
[]
(MotionArtifact? or not SensorConnected?)~> 
  << all j~quantity whole
    in 0..numBadReadings 
    are MOTION_ARTIFACT^(- j) or not SENSOR_CONNECTED^(- j)  >>
  numBadReadings := numBadReadings + 1
  << NUMBAD() >> 
fi
<< NUMBAD() >>
;
if 
(((numBadReadings - 1) < #PulseOx_Properties::Motion_Artifact_Sample_Limit))~> 
  << NUMBAD() >>
  skip
  << NUMBAD() >> 
[]
(((numBadReadings - 1) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit))~> 
  << NUMBAD() and (((numBadReadings - 1) >= #PulseOx_Properties::Motion_Artifact_Sample_Limit)) >>
  MotionArtifactAlarm!
  << NUMBAD() >> 
fi
<< NUMBAD() >>
Q [39] << (MOINV())^1 >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 17 30 61 93:
Theorem (17) [serial 2429] used for:
  P -> P1 in sequential composition for [serial 1006]
 
Theorem (30) [serial 2430] used for:
  Q1 -> Q in sequential composition for [serial 1006]
 
Theorem (61) [serial 2431] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1006]
 
Theorem (93) [serial 2432] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1006]
 


Theorem (95)                               [serial 1007] 
P [70] << (MOINV()) and stop@now and not (exists u~time
  in tops,,now 
  that true ) and not (exists u~time
  in tops,,now 
  that stop@u ) >>
S [70] ->
Q [40] << true >>
by True Conclusion Schema (tc): P->true


Theorem (96)                               [serial 1002] 
P [31] <<   >>
S [34] ->
Q [31] << MotionArtifactThread.imp proof obligations >>
by Initial Thread Obligations
and theorems 3 4 16 94 95:
Theorem (3) [serial 1003] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
 
Theorem (4) [serial 1004] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
 
Theorem (16) [serial 1005] used for:
   <<M(start)>> -> <<M(run)>> for mat0:start-[ ]->run{};
 
Theorem (94) [serial 1006] used for:
   <<M(run) and x>> A <<M(run)>> for mat1:run-[x]->run{A};
 
Theorem (95) [serial 1007] used for:
   <<M(run) and x>> -> <<M(halt)>> for mat2:run-[x]->halt{};
 


Theorem (97)                               [serial 1108] 
P [71] << WINDOW() and TOTAL_SPO2() and GOOD() and GS() and (((ub - lb) < window_size)) >>
S [45] ->
Q [45] << WINDOW() and TOTAL_SPO2() and GOOD() and GS() >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (98)                               [serial 1107] 
P [71] << (((ub - lb) < window_size)) and (WINDOW() and TOTAL_SPO2() and GOOD() and 
GS()) >>
S [45] ->
Q [45] << WINDOW() and TOTAL_SPO2() and GOOD() and GS() >>
by Associativity: (b.c).a = a.b.c
and theorem 97:
Theorem (97) [serial 1108] used for:
  Associativity: (b.c).a = a.b.c [serial 1107]
 


Theorem (99)                               [serial 1009] 
P [71] << (((ub - lb) < window_size)) and INV_AV() >>
S [45] ->
Q [45] << WINDOW() and TOTAL_SPO2() and GOOD() and GS() >>
by Substitution of Assertion Labels
and theorem 98:
Theorem (98) [serial 1107] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1009]
 


Theorem (100)                               [serial 1110] 
P [82] << WINDOW() and TOTAL_SPO2() and GOOD() and GS() and (((ub - lb) = window_size)) >>
S [45] ->
Q [45] << WINDOW() and TOTAL_SPO2() and GOOD() and GS() >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (101)                               [serial 1109] 
P [82] << (WINDOW() and TOTAL_SPO2() and GOOD() and GS()) and (((ub - lb) = window_size)) >>
S [45] ->
Q [45] << WINDOW() and TOTAL_SPO2() and GOOD() and GS() >>
by Associativity: (b.c).a = a.b.c
and theorem 100:
Theorem (100) [serial 1110] used for:
  Associativity: (b.c).a = a.b.c [serial 1109]
 


Theorem (102)                               [serial 1010] 
P [82] << INV_AV() and (((ub - lb) = window_size)) >>
S [45] ->
Q [45] << WINDOW() and TOTAL_SPO2() and GOOD() and GS() >>
by Substitution of Assertion Labels
and theorem 101:
Theorem (101) [serial 1109] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1010]
 


Theorem (103)                               [serial 1114] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ((1 + k) - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ((1 + 
      k) - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [73] ->
Q [73] << true >>
by True Conclusion Schema (tc): P->true


Theorem (104)                               [serial 1112] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ((1 + k) - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ((1 + 
      k) - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [73] ->
Q [73] << window_size = (ub - lb) or window_size < (ub - lb) or (ub - lb) < window_size >>
by Less than, greater than, or equal:  |-a<b or b<a or a=b
and theorem 103:
Theorem (103) [serial 1114] used for:
  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1112]
 


Theorem (105)                               [serial 1011] 
P [73] << (all k~quantity whole
  in lb..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - (ub - 1))) ) and 
((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - (ub - 1)) ))) and ((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-(ub-1)) and not MOTION_ARTIFACT^(k-(ub-1))) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-(ub-1)) and 
      not MOTION_ARTIFACT^(k-(ub-1))) ) >>
S [73] ->
Q [73] << (((ub - lb) < window_size)) or (((ub - lb) = window_size)) or (((ub - lb) > window_size)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Reflexivity of Disjunction: (m or k) = (k or m)
    Associativity: (b.c).a = a.b.c
and theorem 104:
Theorem (104) [serial 1112] used for:
    normalization of [serial 1011]
 


Theorem (106)                               [serial 1119] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 >>
S [68] ->
Q [68] << true >>
by True Conclusion Schema (tc): P->true


Theorem (107)                               [serial 1118] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 >>
S [68] ->
Q [68] << (not ((ub - lb) < window_size)) or (ub - lb) < window_size >>
by Law of Excluded Middle: P or not P is tautology
and theorem 106:
Theorem (106) [serial 1119] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1118]
 


Theorem (108)                               [serial 1116] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 >>
S [68] ->
Q [68] << window_size <= (ub - lb) or (ub - lb) < window_size >>
by At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 107:
Theorem (107) [serial 1118] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a) [serial 1116]
 


Theorem (109)                               [serial 1012] 
P [68] << ((numSamplesInWindow = 0)) and ((ub = 0)) and ((oldestSample = 0)) and 
((totalSpO2 = 0)) and ((lb = 0)) and ((goodCount = 0)) >>
S [68] ->
Q [68] << (((ub - lb) < window_size)) or (((ub - lb) >= window_size)) >>
by Normalization
  Normalization Axioms:
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 108:
Theorem (108) [serial 1116] used for:
    normalization of [serial 1012]
 


Theorem (110)                               [serial 1197] 
P [68] << (goodCount = 0) and (lb = 0) and (numSamplesInWindow = 0) and (oldestSample = 0) and 
(totalSpO2 = 0) and (ub = 0) and (0 < window_size) >>
S [87] ->
Q [71] << 0 < window_size >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (111)                               [serial 1192] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and ub < window_size >>
S [87] ->
Q [71] << 0 < window_size >>
by Substituting Equals Within Conjunction
and theorem 110:
Theorem (110) [serial 1197] used for:
  Substituting Equals Within Conjunction [serial 1192]
 


Theorem (112)                               [serial 1189] 
P [68] << (goodCount = 0) and (lb = 0) and (numSamplesInWindow = 0) and (oldestSample = 0) and 
(totalSpO2 = 0) and (ub = 0) and ((ub - 0) < window_size) >>
S [87] ->
Q [71] << 0 < window_size >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 111:
Theorem (111) [serial 1192] used for:
    normalization of [serial 1189]
 


Theorem (113)                               [serial 1184] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] ->
Q [71] << 0 < window_size >>
by Substituting Equals Within Conjunction
and theorem 112:
Theorem (112) [serial 1189] used for:
  Substituting Equals Within Conjunction [serial 1184]
 


Theorem (114)                               [serial 1181] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] ->
Q [71] << (0 < window_size) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 113:
Theorem (113) [serial 1184] used for:
    normalization of [serial 1181]
 


Theorem (115)                               [serial 1179] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] ->
Q [71] << true and true and true and true and 0 < window_size >>
by Law of And-Simplification:  P and true is P
and theorem 114:
Theorem (114) [serial 1181] used for:
  Law of And-Simplification:  P and true is P [serial 1179]
 


Theorem (116)                               [serial 1174] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] ->
Q [71] << 0 = 0 and 0 = 0 and true and true and 0 < window_size >>
by Equality Law (idistr):  a=a <-> true
and theorem 115:
Theorem (115) [serial 1179] used for:
  Equality Law (idistr):  a=a <-> true [serial 1174]
 


Theorem (117)                               [serial 1171] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] ->
Q [71] << 0 = (0) and 0 = (0) and (true) and (true) and 0 < window_size >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 116:
Theorem (116) [serial 1174] used for:
    normalization of [serial 1171]
 


Theorem (118)                               [serial 1169] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] ->
Q [71] << 0 = (numberof k~quantity whole
  in false 
  that (SENSOR_CONNECTED^((1+k)-0) and not MOTION_ARTIFACT^((1+k)-0)) ) and 
0 = (sum k~quantity whole
  in false 
  of (if SENSOR_CONNECTED^((1+k)-0) and not MOTION_ARTIFACT^((1+k)-0) then SPO2^((1+k)-0) else 0) ) and 
(all k~quantity whole
  in false 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-0) and 
      not MOTION_ARTIFACT^((1+k)-0) then SPO2^((1+k)-0) else 0) ) and (all k~quantity whole
  in false 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-0) and 
      not MOTION_ARTIFACT^((1+k)-0)) ) and 0 < window_size >>
by Empty Range Law All: all a:t in false are V is tautology
and theorem 117:
Theorem (117) [serial 1171] used for:
  Empty Range Law All: all a:t in false are V is tautology [serial 1169]
 


Theorem (119)                               [serial 1164] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] ->
Q [71] << 0 = (numberof k~quantity whole
  in 0..-1 
  that (SENSOR_CONNECTED^((1+k)-0) and not MOTION_ARTIFACT^((1+k)-0)) ) and 
0 = (sum k~quantity whole
  in 0..-1 
  of (if SENSOR_CONNECTED^((1+k)-0) and not MOTION_ARTIFACT^((1+k)-0) then SPO2^((1+k)-0) else 0) ) and 
(all k~quantity whole
  in 0..-1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-0) and 
      not MOTION_ARTIFACT^((1+k)-0) then SPO2^((1+k)-0) else 0) ) and (all k~quantity whole
  in 0..-1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-0) and 
      not MOTION_ARTIFACT^((1+k)-0)) ) and 0 < window_size >>
by Empty Range
and theorem 118:
Theorem (118) [serial 1169] used for:
  Empty Range [serial 1164]
 


Theorem (120)                               [serial 1161] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] ->
Q [71] << 0^1 = (numberof k~quantity whole
  in 0..0 - 1 
  that (SENSOR_CONNECTED^((1+k)-0) and not MOTION_ARTIFACT^((1+k)-0)) ) and 
0^1 = (sum k~quantity whole
  in 0..0 - 1 
  of (if SENSOR_CONNECTED^((1+k)-0) and not MOTION_ARTIFACT^((1+k)-0) then SPO2^((1+k)-0) else 0) ) and 
(all k~quantity whole
  in 0..0 - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-0) and 
      not MOTION_ARTIFACT^((1+k)-0) then SPO2^((1+k)-0) else 0) ) and (all k~quantity whole
  in 0..0 - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-0) and 
      not MOTION_ARTIFACT^((1+k)-0)) ) and (0 - 0) < window_size >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Unary Minus:  -(x-y) is (y-x)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
and theorem 119:
Theorem (119) [serial 1164] used for:
    normalization of [serial 1161]
 


Theorem (121)                               [serial 1159] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] ->
Q [71] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
by Substitution in Postcondition of All Equivalents in Precondition
and theorem 120:
Theorem (120) [serial 1161] used for:
  Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1159]
 


Theorem (122)                               [serial 1198] 
P [68] << (goodCount = 0) and (lb = 0) and (numSamplesInWindow = 0) and (oldestSample = 0) and 
(totalSpO2 = 0) and (ub = 0) and (0 < window_size) >>
S [87] ->
Q [71] << 0 < window_size >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (123)                               [serial 1194] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and ub < window_size >>
S [87] ->
Q [71] << 0 < window_size >>
by Substituting Equals Within Conjunction
and theorem 122:
Theorem (122) [serial 1198] used for:
  Substituting Equals Within Conjunction [serial 1194]
 


Theorem (124)                               [serial 1190] 
P [68] << (goodCount = 0) and (lb = 0) and (numSamplesInWindow = 0) and (oldestSample = 0) and 
(totalSpO2 = 0) and (ub = 0) and ((ub - 0) < window_size) >>
S [87] ->
Q [71] << 0 < window_size >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 123:
Theorem (123) [serial 1194] used for:
    normalization of [serial 1190]
 


Theorem (125)                               [serial 1186] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] ->
Q [71] << 0 < window_size >>
by Substituting Equals Within Conjunction
and theorem 124:
Theorem (124) [serial 1190] used for:
  Substituting Equals Within Conjunction [serial 1186]
 


Theorem (126)                               [serial 1182] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] ->
Q [71] << (0 < window_size) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 125:
Theorem (125) [serial 1186] used for:
    normalization of [serial 1182]
 


Theorem (127)                               [serial 1180] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] ->
Q [71] << true and true and true and true and 0 < window_size >>
by Law of And-Simplification:  P and true is P
and theorem 126:
Theorem (126) [serial 1182] used for:
  Law of And-Simplification:  P and true is P [serial 1180]
 


Theorem (128)                               [serial 1176] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] ->
Q [71] << 0 = 0 and 0 = 0 and true and true and 0 < window_size >>
by Equality Law (idistr):  a=a <-> true
and theorem 127:
Theorem (127) [serial 1180] used for:
  Equality Law (idistr):  a=a <-> true [serial 1176]
 


Theorem (129)                               [serial 1172] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] ->
Q [71] << 0 = (0) and 0 = (0) and (true) and (true) and 0 < window_size >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 128:
Theorem (128) [serial 1176] used for:
    normalization of [serial 1172]
 


Theorem (130)                               [serial 1170] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] ->
Q [71] << 0 = (numberof k~quantity whole
  in false 
  that (SENSOR_CONNECTED^((1+k)-0) and not MOTION_ARTIFACT^((1+k)-0)) ) and 
0 = (sum k~quantity whole
  in false 
  of (if SENSOR_CONNECTED^((1+k)-0) and not MOTION_ARTIFACT^((1+k)-0) then SPO2^((1+k)-0) else 0) ) and 
(all k~quantity whole
  in false 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-0) and 
      not MOTION_ARTIFACT^((1+k)-0) then SPO2^((1+k)-0) else 0) ) and (all k~quantity whole
  in false 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-0) and 
      not MOTION_ARTIFACT^((1+k)-0)) ) and 0 < window_size >>
by Empty Range Law All: all a:t in false are V is tautology
and theorem 129:
Theorem (129) [serial 1172] used for:
  Empty Range Law All: all a:t in false are V is tautology [serial 1170]
 


Theorem (131)                               [serial 1166] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] ->
Q [71] << 0 = (numberof k~quantity whole
  in 0..-1 
  that (SENSOR_CONNECTED^((1+k)-0) and not MOTION_ARTIFACT^((1+k)-0)) ) and 
0 = (sum k~quantity whole
  in 0..-1 
  of (if SENSOR_CONNECTED^((1+k)-0) and not MOTION_ARTIFACT^((1+k)-0) then SPO2^((1+k)-0) else 0) ) and 
(all k~quantity whole
  in 0..-1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-0) and 
      not MOTION_ARTIFACT^((1+k)-0) then SPO2^((1+k)-0) else 0) ) and (all k~quantity whole
  in 0..-1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-0) and 
      not MOTION_ARTIFACT^((1+k)-0)) ) and 0 < window_size >>
by Empty Range
and theorem 130:
Theorem (130) [serial 1170] used for:
  Empty Range [serial 1166]
 


Theorem (132)                               [serial 1162] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] ->
Q [71] << 0^1 = (numberof k~quantity whole
  in 0..0 - 1 
  that (SENSOR_CONNECTED^((1+k)-0) and not MOTION_ARTIFACT^((1+k)-0)) ) and 
0^1 = (sum k~quantity whole
  in 0..0 - 1 
  of (if SENSOR_CONNECTED^((1+k)-0) and not MOTION_ARTIFACT^((1+k)-0) then SPO2^((1+k)-0) else 0) ) and 
(all k~quantity whole
  in 0..0 - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-0) and 
      not MOTION_ARTIFACT^((1+k)-0) then SPO2^((1+k)-0) else 0) ) and (all k~quantity whole
  in 0..0 - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-0) and 
      not MOTION_ARTIFACT^((1+k)-0)) ) and (0 - 0) < window_size >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Unary Minus:  -(x-y) is (y-x)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
and theorem 131:
Theorem (131) [serial 1166] used for:
    normalization of [serial 1162]
 


Theorem (133)                               [serial 1160] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] ->
Q [71] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
by Substitution in Postcondition of All Equivalents in Precondition
and theorem 132:
Theorem (132) [serial 1162] used for:
  Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1160]
 


Theorem (134)                               [serial 1158] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] ->
Q [71] << (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) )) and (ub - lb) < window_size >>
by Associativity: (b.c).a = a.b.c
and theorems 121 133:
Theorem (121) [serial 1159] used for:
  Associativity: (b.c).a = a.b.c [serial 1158]
 
Theorem (133) [serial 1160] used for:
  Associativity: (b.c).a = a.b.c [serial 1158]
 


Theorem (135)                               [serial 1155] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] |ub',lb',window_size' := ub,lb,window_size|  
Q [71] << (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) )) and (ub^1 - lb^1) < window_size^1 >>
by Simultaneous Assignment
and theorem 134:
Theorem (134) [serial 1158] used for:
  applied wp for simultaneous assignment [serial 1155]
 


Theorem (136)                               [serial 1153] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] |ub',lb',window_size' := ub,lb,window_size|  
Q [71] << (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not (MOTION_ARTIFACT^(k-ub))^1 then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not (MOTION_ARTIFACT^(k-ub))^1 then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) )) and (ub^1 - lb^1) < window_size^1 >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Caret Compostition:  (x^a)^b is x^(a+b)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Associativity: (b.c).a = a.b.c
and theorem 135:
Theorem (135) [serial 1155] used for:
    normalization of [serial 1153]
 


Theorem (137)                               [serial 1151] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] |ub',lb',window_size' := ub,lb,window_size|  
Q [71] << (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and (not MOTION_ARTIFACT^(k-ub))^1 then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      (not MOTION_ARTIFACT^(k-ub))^1 then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) )) and (ub^1 - lb^1) < window_size^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 136:
Theorem (136) [serial 1153] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1151]
 


Theorem (138)                               [serial 1149] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] |ub',lb',window_size' := ub,lb,window_size|  
Q [71] << (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not (MOTION_ARTIFACT^(k-ub))^1) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if (SENSOR_CONNECTED^((k-ub)+1) and (not MOTION_ARTIFACT^(k-ub))^1) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if (
      SENSOR_CONNECTED^((k-ub)+1) and (not MOTION_ARTIFACT^(k-ub))^1) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not (MOTION_ARTIFACT^(k-ub))^1) )) and (ub^1 - lb^1) < window_size^1 >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Caret Compostition:  (x^a)^b is x^(a+b)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Associativity: (b.c).a = a.b.c
and theorem 137:
Theorem (137) [serial 1151] used for:
    normalization of [serial 1149]
 


Theorem (139)                               [serial 1147] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] |ub',lb',window_size' := ub,lb,window_size|  
Q [71] << (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and (not MOTION_ARTIFACT^(k-ub))^1) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub))^1 then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if (
      SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub))^1 then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      (not MOTION_ARTIFACT^(k-ub))^1) )) and (ub^1 - lb^1) < window_size^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 138:
Theorem (138) [serial 1149] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1147]
 


Theorem (140)                               [serial 1145] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] |ub',lb',window_size' := ub,lb,window_size|  
Q [71] << (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((k-ub)+1) and (not MOTION_ARTIFACT^(k-ub))^1) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub))^1 then SPO2^((k-ub)+1) else (0)^1) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub))^1 then SPO2^((k-ub)+1) else (0)^1) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((k-ub)+1) and 
      (not MOTION_ARTIFACT^(k-ub))^1) )) and (ub^1 - lb^1) < window_size^1 >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
    Associativity: (b.c).a = a.b.c
and theorem 139:
Theorem (139) [serial 1147] used for:
    normalization of [serial 1145]
 


Theorem (141)                               [serial 1143] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] |ub',lb',window_size' := ub,lb,window_size|  
Q [71] << (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub))^1 ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)^1 ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)^1 = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))^1 )) and (ub^1 - lb^1) < window_size^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 140:
Theorem (140) [serial 1145] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1143]
 


Theorem (142)                               [serial 1141] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] |ub',lb',window_size' := ub,lb,window_size|  
Q [71] << (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that ((SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)))^1 ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0))^1 ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0))^1 = (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples])^1) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are ((goodSamp[k mod #PulseOx_Properties::Max_Window_Samples])^1 iff (
      SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub))^1) )) and 
(ub^1 - lb^1) < window_size^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 141:
Theorem (141) [serial 1143] used for:
    normalization of [serial 1141]
 


Theorem (143)                               [serial 1139] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] |ub',lb',window_size' := ub,lb,window_size|  
Q [71] << (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )^1 and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )^1 and 
(all k~quantity whole
  in lb..ub - 1 
  are ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples])^1 ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)))^1 )) and (ub^1 - lb^1) < window_size^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 142:
Theorem (142) [serial 1141] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1139]
 


Theorem (144)                               [serial 1137] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] |ub',lb',window_size' := ub,lb,window_size|  
Q [71] << (((goodCount)^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )^1) and 
((totalSpO2)^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )^1) and 
(all k~quantity whole
  in lb..ub - 1 
  are ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples])^1 ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)))^1 )) and ((ub)^1 - (lb)^1) < window_size^1 >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 143:
Theorem (143) [serial 1139] used for:
    normalization of [serial 1137]
 


Theorem (145)                               [serial 1135] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] |ub',lb',window_size' := ub,lb,window_size|  
Q [71] << ((goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))^1 and 
(totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ))^1 and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] )^1 and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )^1) and (ub - lb)^1 < window_size^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 144:
Theorem (144) [serial 1137] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1135]
 


Theorem (146)                               [serial 1133] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] |ub',lb',window_size' := ub,lb,window_size|  
Q [71] << ((goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))^1 and 
(totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ))^1 and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] )^1 and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )^1) and ((ub - lb)^1 < (window_size)^1) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 145:
Theorem (145) [serial 1135] used for:
    normalization of [serial 1133]
 


Theorem (147)                               [serial 1131] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] |ub',lb',window_size' := ub,lb,window_size|  
Q [71] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ))^1 and ((ub - lb) < window_size)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 146:
Theorem (146) [serial 1133] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1131]
 


Theorem (148)                               [serial 1129] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] |ub',lb',window_size' := ub,lb,window_size|  
Q [71] << ((((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and ((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are ((spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if 
      SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)))) ))^1 and 
((ub - lb) < window_size)^1) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 147:
Theorem (147) [serial 1131] used for:
    normalization of [serial 1129]
 


Theorem (149)                               [serial 1128] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] |ub',lb',window_size' := ub,lb,window_size|  
Q [71] << ((((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and ((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are ((spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if 
      SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)))) )) and 
(ub - lb) < window_size)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 148:
Theorem (148) [serial 1129] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1128]
 


Theorem (150)                               [serial 1127] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] |ub',lb',window_size' := ub,lb,window_size|  
Q [71] << ((((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and ((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - ub) ))) and (all k~quantity whole
  in lb..(ub - 1) 
  are ((spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub))) )) and 
(ub - lb) < window_size)^1 >>
by Substitution of Assertion Labels
and theorem 149:
Theorem (149) [serial 1128] used for:
  substituted Assertions' predicates for  labels  [serial 1127]
 


Theorem (151)                               [serial 1125] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] |ub',lb',window_size' := ub,lb,window_size|  
Q [71] << ((GOOD() and GS() and TOTAL_SPO2() and WINDOW()) and (ub - lb) < window_size)^1 >>
by Substitution of Assertion Labels
and theorem 150:
Theorem (150) [serial 1127] used for:
  substituted Assertions' predicates for  labels  [serial 1125]
 


Theorem (152)                               [serial 1123] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] |ub',lb',window_size' := ub,lb,window_size|  
Q [71] << ((WINDOW() and TOTAL_SPO2() and GOOD() and GS()) and (ub - lb) < window_size)^1 >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 151:
Theorem (151) [serial 1125] used for:
    normalization of [serial 1123]
 


Theorem (153)                               [serial 1121] 
P [68] << goodCount = 0 and lb = 0 and numSamplesInWindow = 0 and oldestSample = 0 and 
totalSpO2 = 0 and ub = 0 and (ub - lb) < window_size >>
S [87] |ub',lb',window_size' := ub,lb,window_size|  
Q [71] << (INV_AV() and (ub - lb) < window_size)^1 >>
by Substitution of Assertion Labels
and theorem 152:
Theorem (152) [serial 1123] used for:
  substituted Assertions' predicates for  labels  [serial 1121]
 


Theorem (154)                               [serial 1013] 
P [68] << ((numSamplesInWindow = 0)) and ((ub = 0)) and ((oldestSample = 0)) and 
((totalSpO2 = 0)) and ((lb = 0)) and ((goodCount = 0)) and (((ub - lb) < window_size)) >>
S [87] |ub',lb',window_size' := ub,lb,window_size|  
Q [71] << ((((ub - lb) < window_size)) and INV_AV())^1 >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 153:
Theorem (153) [serial 1121] used for:
    normalization of [serial 1013]
 


Theorem (155)                               [serial 1199] 
P [68] << ((numSamplesInWindow = 0)) and ((ub = 0)) and ((oldestSample = 0)) and 
((totalSpO2 = 0)) and ((lb = 0)) and ((goodCount = 0)) and (((ub - lb) >= window_size)) >>
S [89] ->
Q [84] << true >>
by True Conclusion Schema (tc): P->true


Theorem (156)                               [serial 1014] 
P [68] << ((numSamplesInWindow = 0)) and ((ub = 0)) and ((oldestSample = 0)) and 
((totalSpO2 = 0)) and ((lb = 0)) and ((goodCount = 0)) and (((ub - lb) >= window_size)) >>
S [89] |ub',lb',window_size' := ub,lb,window_size|  
Q [84] << true >>
by Simultaneous Assignment
and theorem 155:
Theorem (155) [serial 1199] used for:
  applied wp for simultaneous assignment [serial 1014]
 


Theorem (157)                               [serial 1355] 
P [71] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (ub - lb) < window_size >>
S [71] ->
Q [91] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (ub - lb) < window_size >>
by Identity (id):  P->P is tautology


Theorem (158)                               [serial 1335] 
P [71] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size >>
S [71] ->
Q [91] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size >>
by Associativity: (b.c).a = a.b.c
and theorem 157:
Theorem (157) [serial 1355] used for:
  Associativity: (b.c).a = a.b.c [serial 1335]
 


Theorem (159)                               [serial 1328] 
P [71] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size >>
S [71] ->
Q [91] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 158:
Theorem (158) [serial 1335] used for:
    normalization of [serial 1328]
 


Theorem (160)                               [serial 1314] 
P [71] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size >>
S [71] ->
Q [91] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size >>
by Substitution of Assertion Labels
and theorem 159:
Theorem (159) [serial 1328] used for:
  substituted Assertions' predicates for  labels  [serial 1314]
 


Theorem (161)                               [serial 1307] 
P [71] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size >>
S [71] ->
Q [91] << (((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and ((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - ub) ))) and (all k~quantity whole
  in lb..(ub - 1) 
  are ((spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub))) )) and 
(ub - lb) < window_size >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 160:
Theorem (160) [serial 1314] used for:
    normalization of [serial 1307]
 


Theorem (162)                               [serial 1290] 
P [71] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size >>
S [71] ->
Q [91] << (GOOD() and GS() and TOTAL_SPO2() and WINDOW()) and (ub - lb) < window_size >>
by Substitution of Assertion Labels
and theorem 161:
Theorem (161) [serial 1307] used for:
  substituted Assertions' predicates for  labels  [serial 1290]
 


Theorem (163)                               [serial 1283] 
P [71] << (((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and ((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - ub) ))) and (all k~quantity whole
  in lb..(ub - 1) 
  are ((spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub))) )) and 
(ub - lb) < window_size >>
S [71] ->
Q [91] << (WINDOW() and TOTAL_SPO2() and GOOD() and GS()) and (ub - lb) < window_size >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 162:
Theorem (162) [serial 1290] used for:
    normalization of [serial 1283]
 


Theorem (164)                               [serial 1266] 
P [71] << (GOOD() and GS() and TOTAL_SPO2() and WINDOW()) and (ub - lb) < window_size >>
S [71] ->
Q [91] << INV_AV() and (ub - lb) < window_size >>
by Substitution of Assertion Labels
and theorem 163:
Theorem (163) [serial 1283] used for:
  substituted Assertions' predicates for  labels  [serial 1266]
 


Theorem (165)                               [serial 1259] 
P [71] << (WINDOW() and TOTAL_SPO2() and GOOD() and GS()) and (ub - lb) < window_size >>
S [71] ->
Q [91] << ((((ub - lb) < window_size)) and INV_AV()) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 164:
Theorem (164) [serial 1266] used for:
    normalization of [serial 1259]
 


Theorem (166)                               [serial 1217] 
P [71] << INV_AV() and (ub - lb) < window_size >>
S [71] ->
Q [91] << FW() >>
by Substitution of Assertion Labels
and theorem 165:
Theorem (165) [serial 1259] used for:
  substituted Assertions' predicates for  labels  [serial 1217]
 


Theorem (167)                               [serial 1200] 
P [71] << (((ub - lb) < window_size)) and INV_AV() >>
S [71] ->
Q [91] << FW() >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 166:
Theorem (166) [serial 1217] used for:
    normalization of [serial 1200]
 


Theorem (168)                               [serial 1219] 
P [123] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ((1 + k) - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ((1 + 
      k) - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [73] ->
Q [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ((1 + k) - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ((1 + 
      k) - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
by Identity (id):  P->P is tautology


Theorem (169)                               [serial 1201] 
P [123] << (all k~quantity whole
  in lb..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - (ub - 1))) ) and 
((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - (ub - 1)) ))) and ((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-(ub-1)) and not MOTION_ARTIFACT^(k-(ub-1))) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-(ub-1)) and 
      not MOTION_ARTIFACT^(k-(ub-1))) ) >>
S [73] ->
Q [73] << (all k~quantity whole
  in lb..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - (ub - 1))) ) and 
((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - (ub - 1)) ))) and ((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-(ub-1)) and not MOTION_ARTIFACT^(k-(ub-1))) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-(ub-1)) and 
      not MOTION_ARTIFACT^(k-(ub-1))) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Associativity: (b.c).a = a.b.c
and theorem 168:
Theorem (168) [serial 1219] used for:
    normalization of [serial 1201]
 


Theorem (170)                               [serial 1205] 
P [91] << FW() >>
S [93] ->
Q [93] << FW() >>
by Identity (id):  P->P is tautology


Theorem (171)                               [serial 1376] 
P [112] << goodCount = (numberof k~quantity whole
  in lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
S [97] ->
Q [112] << goodCount = (numberof k~quantity whole
  in lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Identity (id):  P->P is tautology


Theorem (172)                               [serial 1292] 
P [93] << (if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] and 
goodCount = ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + 
(numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and totalSpO2 = (
(if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0)) >>
S [97] ->
Q [112] << goodCount = (numberof k~quantity whole
  in lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
and theorem 171:
Theorem (171) [serial 1376] used for:
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j) [serial 1292]
 


Theorem (173)                               [serial 1284] 
P [93] << (if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] and 
goodCount = ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + 
(numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and totalSpO2 = (
(if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0)) >>
S [97] ->
Q [112] << goodCount = (numberof k~quantity whole
  in lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 172:
Theorem (172) [serial 1292] used for:
    normalization of [serial 1284]
 


Theorem (174)                               [serial 1268] 
P [93] << (if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] and 
goodCount = ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + 
(numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and totalSpO2 = (
(if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0)) >>
S [97] ->
Q [112] << goodCount = (numberof k~quantity whole
  in lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Substitution of Assertion Labels
and theorem 173:
Theorem (173) [serial 1284] used for:
  substituted Assertions' predicates for  labels  [serial 1268]
 


Theorem (175)                               [serial 1260] 
P [93] << goodCount = ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + 
(numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = ((if 
SENSOR_CONNECTED^(0) and not MOTION_ARTIFACT^(0) then SPO2^(0) else 0)) and 
totalSpO2 = (((if SENSOR_CONNECTED^(0) and not MOTION_ARTIFACT^(0) then SPO2^(0) else 0)) + 
(sum k~quantity whole
  in lb..ub - 1 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) )) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (all k~quantity whole
  in lb..(ub - 1) 
  are ((spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub))) ) and 
(goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^0 and 
not MOTION_ARTIFACT^0)) >>
S [97] ->
Q [112] << goodCount = (numberof k~quantity whole
  in lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and 
(all k~quantity whole
  in lb..ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and (all k~quantity whole
  in lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 174:
Theorem (174) [serial 1268] used for:
    normalization of [serial 1260]
 


Theorem (176)                               [serial 1222] 
P [93] << goodCount = ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + 
(numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x:0) and 
totalSpO2 = (SSQ(x:0) + (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) )) and GS() and WINDOW() and (goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0)) >>
S [97] ->
Q [112] << goodCount = (numberof k~quantity whole
  in lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub 
  of SSQ(k - ub) ) and (all k~quantity whole
  in lb..ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Substitution of Assertion Labels
and theorem 175:
Theorem (175) [serial 1260] used for:
  substituted Assertions' predicates for  labels  [serial 1222]
 


Theorem (177)                               [serial 1206] 
P [93] << (WINDOW()) and (((spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x:0)))) and 
((totalSpO2 = (SSQ(x:0) + (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - ub) )))) and ((goodCount = ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + 
(numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )))) and 
((goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^0 and 
not MOTION_ARTIFACT^0))) and (GS()) >>
S [97] ->
Q [112] << (all k~quantity whole
  in lb..ub 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)) ) and 
((totalSpO2 = (sum k~quantity whole
  in lb..ub 
  of SSQ(k - ub) ))) and ((goodCount = (numberof k~quantity whole
  in lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 176:
Theorem (176) [serial 1222] used for:
    normalization of [serial 1206]
 


Theorem (178)                               [serial 1372] 
P [93] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (ub - lb) < window_size >>
S [95] ->
Q [97] << all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (179)                               [serial 1363] 
P [93] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (ub - lb) < window_size >>
S [95] ->
Q [97] << ((all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] )) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 178:
Theorem (178) [serial 1372] used for:
    normalization of [serial 1363]
 


Theorem (180)                               [serial 1360] 
P [93] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size >>
S [95] ->
Q [97] << ((all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] )) >>
by Associativity: (b.c).a = a.b.c
and theorem 179:
Theorem (179) [serial 1363] used for:
  Associativity: (b.c).a = a.b.c [serial 1360]
 


Theorem (181)                               [serial 1356] 
P [93] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size >>
S [95] ->
Q [97] << true and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
by Law of And-Simplification:  P and true is P
and theorem 180:
Theorem (180) [serial 1360] used for:
  Law of And-Simplification:  P and true is P [serial 1356]
 


Theorem (182)                               [serial 1337] 
P [93] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size >>
S [95] ->
Q [97] << (if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) = (if 
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
by Equality Law (idistr):  a=a <-> true
and theorem 181:
Theorem (181) [serial 1356] used for:
  Equality Law (idistr):  a=a <-> true [serial 1337]
 


Theorem (183)                               [serial 1329] 
P [93] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size >>
S [95] ->
Q [97] << (if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) = (if 
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 182:
Theorem (182) [serial 1337] used for:
    normalization of [serial 1329]
 


Theorem (184)                               [serial 1316] 
P [93] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size >>
S [95] ->
Q [97] << (if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) = (if 
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
by Substitution of Assertion Labels
and theorem 183:
Theorem (183) [serial 1329] used for:
  substituted Assertions' predicates for  labels  [serial 1316]
 


Theorem (185)                               [serial 1308] 
P [93] << (((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and ((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - ub) ))) and (all k~quantity whole
  in lb..(ub - 1) 
  are ((spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub))) )) and 
(ub - lb) < window_size >>
S [95] ->
Q [97] << (if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) = (if 
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 184:
Theorem (184) [serial 1316] used for:
    normalization of [serial 1308]
 


Theorem (186)                               [serial 1294] 
P [93] << (GOOD() and GS() and TOTAL_SPO2() and WINDOW()) and (ub - lb) < window_size >>
S [95] ->
Q [97] << (if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) = (if 
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
by Substitution of Assertion Labels
and theorem 185:
Theorem (185) [serial 1308] used for:
  substituted Assertions' predicates for  labels  [serial 1294]
 


Theorem (187)                               [serial 1285] 
P [93] << (WINDOW() and TOTAL_SPO2() and GOOD() and GS()) and (ub - lb) < window_size >>
S [95] ->
Q [97] << (if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) = (if 
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 186:
Theorem (186) [serial 1294] used for:
    normalization of [serial 1285]
 


Theorem (188)                               [serial 1270] 
P [93] << INV_AV() and (ub - lb) < window_size >>
S [95] ->
Q [97] << (if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) = (if 
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) >>
by Substitution of Assertion Labels
and theorem 187:
Theorem (187) [serial 1285] used for:
  substituted Assertions' predicates for  labels  [serial 1270]
 


Theorem (189)                               [serial 1261] 
P [93] << ((((ub - lb) < window_size)) and INV_AV()) >>
S [95] ->
Q [97] << (if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) = ((if 
SENSOR_CONNECTED^(0) and not MOTION_ARTIFACT^(0) then SPO2^(0) else 0)) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are ((spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub))) ) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 188:
Theorem (188) [serial 1270] used for:
    normalization of [serial 1261]
 


Theorem (190)                               [serial 1224] 
P [93] << FW() >>
S [95] ->
Q [97] << (if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) = SSQ(x:0) and 
WINDOW() >>
by Substitution of Assertion Labels
and theorem 189:
Theorem (189) [serial 1261] used for:
  substituted Assertions' predicates for  labels  [serial 1224]
 


Theorem (191)                               [serial 1211] 
P [93] << FW() >>
S [95] ->
Q [97] << WINDOW() and ((((if (SENSOR_CONNECTED)^0 and not (MOTION_ARTIFACT)^0 then (SPO2)^0 else 0)) = SSQ(x:0))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 190:
Theorem (190) [serial 1224] used for:
    normalization of [serial 1211]
 


Theorem (192)                               [serial 1207] 
P [93] << FW() >>
S [95] spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] := (if SensorConnected? and 
not MotionArtifact? then SpO2? else 0)
Q [97] << WINDOW() and ((spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x:0))) >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 191:
Theorem (191) [serial 1211] used for:
  applied wp for assignment [serial 1207]
 


Theorem (193)                               [serial 1368] 
P [91] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (ub - lb) < window_size >>
S [99] ->
Q [100] << totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (194)                               [serial 1361] 
P [91] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (ub - lb) < window_size >>
S [99] ->
Q [100] << (totalSpO2) = ((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 193:
Theorem (193) [serial 1368] used for:
    normalization of [serial 1361]
 


Theorem (195)                               [serial 1357] 
P [91] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (ub - lb) < window_size >>
S [99] ->
Q [100] << ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + 
totalSpO2) = ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + 
(sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) >>
by Add both sides of equality:  a=b -> x+a=x+b
and theorem 194:
Theorem (194) [serial 1361] used for:
  Add both sides of equality:  a=b -> x+a=x+b [serial 1357]
 


Theorem (196)                               [serial 1339] 
P [91] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size >>
S [99] ->
Q [100] << ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + 
totalSpO2) = ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + 
(sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) >>
by Associativity: (b.c).a = a.b.c
and theorem 195:
Theorem (195) [serial 1357] used for:
  Associativity: (b.c).a = a.b.c [serial 1339]
 


Theorem (197)                               [serial 1330] 
P [91] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size >>
S [99] ->
Q [100] << ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + 
totalSpO2) = ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + 
(sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 196:
Theorem (196) [serial 1339] used for:
    normalization of [serial 1330]
 


Theorem (198)                               [serial 1318] 
P [91] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size >>
S [99] ->
Q [100] << ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + 
totalSpO2) = ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + 
(sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) >>
by Substitution of Assertion Labels
and theorem 197:
Theorem (197) [serial 1330] used for:
  substituted Assertions' predicates for  labels  [serial 1318]
 


Theorem (199)                               [serial 1309] 
P [91] << (((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and ((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - ub) ))) and (all k~quantity whole
  in lb..(ub - 1) 
  are ((spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub))) )) and 
(ub - lb) < window_size >>
S [99] ->
Q [100] << ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + 
totalSpO2) = ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + 
(sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 198:
Theorem (198) [serial 1318] used for:
    normalization of [serial 1309]
 


Theorem (200)                               [serial 1296] 
P [91] << (GOOD() and GS() and TOTAL_SPO2() and WINDOW()) and (ub - lb) < window_size >>
S [99] ->
Q [100] << ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + 
totalSpO2) = ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + 
(sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) >>
by Substitution of Assertion Labels
and theorem 199:
Theorem (199) [serial 1309] used for:
  substituted Assertions' predicates for  labels  [serial 1296]
 


Theorem (201)                               [serial 1286] 
P [91] << (WINDOW() and TOTAL_SPO2() and GOOD() and GS()) and (ub - lb) < window_size >>
S [99] ->
Q [100] << ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + 
totalSpO2) = ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + 
(sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 200:
Theorem (200) [serial 1296] used for:
    normalization of [serial 1286]
 


Theorem (202)                               [serial 1272] 
P [91] << INV_AV() and (ub - lb) < window_size >>
S [99] ->
Q [100] << ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + 
totalSpO2) = ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + 
(sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) >>
by Substitution of Assertion Labels
and theorem 201:
Theorem (201) [serial 1286] used for:
  substituted Assertions' predicates for  labels  [serial 1272]
 


Theorem (203)                               [serial 1262] 
P [91] << ((((ub - lb) < window_size)) and INV_AV()) >>
S [99] ->
Q [100] << ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + 
totalSpO2) = (((if SENSOR_CONNECTED^(0) and not MOTION_ARTIFACT^(0) then SPO2^(0) else 0)) + 
(sum k~quantity whole
  in lb..ub - 1 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) )) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 202:
Theorem (202) [serial 1272] used for:
    normalization of [serial 1262]
 


Theorem (204)                               [serial 1226] 
P [91] << FW() >>
S [99] ->
Q [100] << ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + 
totalSpO2) = (SSQ(x:0) + (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) )) >>
by Substitution of Assertion Labels
and theorem 203:
Theorem (203) [serial 1262] used for:
  substituted Assertions' predicates for  labels  [serial 1226]
 


Theorem (205)                               [serial 1212] 
P [91] << FW() >>
S [99] ->
Q [100] << ((totalSpO2 + (if (SENSOR_CONNECTED)^0 and not (MOTION_ARTIFACT)^0 then (SPO2)^0 else 0)) = (
SSQ(x:0) + (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - ub) ))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 204:
Theorem (204) [serial 1226] used for:
    normalization of [serial 1212]
 


Theorem (206)                               [serial 1208] 
P [91] << FW() >>
S [99] totalSpO2 := totalSpO2 + (if SensorConnected? and not MotionArtifact? then SpO2? else 0)
Q [100] << (totalSpO2 = (SSQ(x:0) + (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - ub) ))) >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 205:
Theorem (205) [serial 1212] used for:
  applied wp for assignment [serial 1208]
 


Theorem (207)                               [serial 1358] 
P [91] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (ub - lb) < window_size >>
S [102] ->
Q [103] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (208)                               [serial 1341] 
P [91] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size >>
S [102] ->
Q [103] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) >>
by Associativity: (b.c).a = a.b.c
and theorem 207:
Theorem (207) [serial 1358] used for:
  Associativity: (b.c).a = a.b.c [serial 1341]
 


Theorem (209)                               [serial 1331] 
P [91] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size >>
S [102] ->
Q [103] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 208:
Theorem (208) [serial 1341] used for:
    normalization of [serial 1331]
 


Theorem (210)                               [serial 1320] 
P [91] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size >>
S [102] ->
Q [103] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) >>
by Substitution of Assertion Labels
and theorem 209:
Theorem (209) [serial 1331] used for:
  substituted Assertions' predicates for  labels  [serial 1320]
 


Theorem (211)                               [serial 1310] 
P [91] << (((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and ((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - ub) ))) and (all k~quantity whole
  in lb..(ub - 1) 
  are ((spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub))) )) and 
(ub - lb) < window_size >>
S [102] ->
Q [103] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 210:
Theorem (210) [serial 1320] used for:
    normalization of [serial 1310]
 


Theorem (212)                               [serial 1298] 
P [91] << (GOOD() and GS() and TOTAL_SPO2() and WINDOW()) and (ub - lb) < window_size >>
S [102] ->
Q [103] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) >>
by Substitution of Assertion Labels
and theorem 211:
Theorem (211) [serial 1310] used for:
  substituted Assertions' predicates for  labels  [serial 1298]
 


Theorem (213)                               [serial 1287] 
P [91] << (WINDOW() and TOTAL_SPO2() and GOOD() and GS()) and (ub - lb) < window_size >>
S [102] ->
Q [103] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 212:
Theorem (212) [serial 1298] used for:
    normalization of [serial 1287]
 


Theorem (214)                               [serial 1274] 
P [91] << INV_AV() and (ub - lb) < window_size >>
S [102] ->
Q [103] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) >>
by Substitution of Assertion Labels
and theorem 213:
Theorem (213) [serial 1287] used for:
  substituted Assertions' predicates for  labels  [serial 1274]
 


Theorem (215)                               [serial 1263] 
P [91] << ((((ub - lb) < window_size)) and INV_AV()) >>
S [102] ->
Q [103] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 214:
Theorem (214) [serial 1274] used for:
    normalization of [serial 1263]
 


Theorem (216)                               [serial 1251] 
P [91] << FW() >>
S [102] ->
Q [103] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) >>
by Substitution of Assertion Labels
and theorem 215:
Theorem (215) [serial 1263] used for:
  substituted Assertions' predicates for  labels  [serial 1251]
 


Theorem (217)                               [serial 1241] 
P [91] << FW() >>
S [102] ->
Q [103] << (goodCount) = ((numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 216:
Theorem (216) [serial 1251] used for:
    normalization of [serial 1241]
 


Theorem (218)                               [serial 1228] 
P [91] << FW() >>
S [102] ->
Q [103] << ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + goodCount) = (
(if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) >>
by Add both sides of equality:  a=b -> x+a=x+b
and theorem 217:
Theorem (217) [serial 1241] used for:
  Add both sides of equality:  a=b -> x+a=x+b [serial 1228]
 


Theorem (219)                               [serial 1213] 
P [91] << FW() >>
S [102] ->
Q [103] << (((goodCount + (if (SENSOR_CONNECTED)^0 and not (MOTION_ARTIFACT)^0 then 1 else 0))) = (
(if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 218:
Theorem (218) [serial 1228] used for:
    normalization of [serial 1213]
 


Theorem (220)                               [serial 1209] 
P [91] << FW() >>
S [102] goodCount := (goodCount + (if SensorConnected? and not MotionArtifact? then 1 else 0))
Q [103] << (goodCount = ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + 
(numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 219:
Theorem (219) [serial 1213] used for:
  applied wp for assignment [serial 1209]
 


Theorem (221)                               [serial 1370] 
P [91] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (ub - lb) < window_size >>
S [107] ->
Q [109] << all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (222)                               [serial 1362] 
P [91] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (ub - lb) < window_size >>
S [107] ->
Q [109] << ((all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 221:
Theorem (221) [serial 1370] used for:
    normalization of [serial 1362]
 


Theorem (223)                               [serial 1359] 
P [91] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size >>
S [107] ->
Q [109] << ((all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) >>
by Associativity: (b.c).a = a.b.c
and theorem 222:
Theorem (222) [serial 1362] used for:
  Associativity: (b.c).a = a.b.c [serial 1359]
 


Theorem (224)                               [serial 1343] 
P [91] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size >>
S [107] ->
Q [109] << true and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Law of And-Simplification:  P and true is P
and theorem 223:
Theorem (223) [serial 1359] used for:
  Law of And-Simplification:  P and true is P [serial 1343]
 


Theorem (225)                               [serial 1332] 
P [91] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size >>
S [107] ->
Q [109] << true and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 224:
Theorem (224) [serial 1343] used for:
    normalization of [serial 1332]
 


Theorem (226)                               [serial 1322] 
P [91] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size >>
S [107] ->
Q [109] << true and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Substitution of Assertion Labels
and theorem 225:
Theorem (225) [serial 1332] used for:
  substituted Assertions' predicates for  labels  [serial 1322]
 


Theorem (227)                               [serial 1311] 
P [91] << (((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and ((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - ub) ))) and (all k~quantity whole
  in lb..(ub - 1) 
  are ((spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub))) )) and 
(ub - lb) < window_size >>
S [107] ->
Q [109] << true and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 226:
Theorem (226) [serial 1322] used for:
    normalization of [serial 1311]
 


Theorem (228)                               [serial 1300] 
P [91] << (GOOD() and GS() and TOTAL_SPO2() and WINDOW()) and (ub - lb) < window_size >>
S [107] ->
Q [109] << true and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Substitution of Assertion Labels
and theorem 227:
Theorem (227) [serial 1311] used for:
  substituted Assertions' predicates for  labels  [serial 1300]
 


Theorem (229)                               [serial 1288] 
P [91] << (WINDOW() and TOTAL_SPO2() and GOOD() and GS()) and (ub - lb) < window_size >>
S [107] ->
Q [109] << true and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 228:
Theorem (228) [serial 1300] used for:
    normalization of [serial 1288]
 


Theorem (230)                               [serial 1276] 
P [91] << INV_AV() and (ub - lb) < window_size >>
S [107] ->
Q [109] << true and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Substitution of Assertion Labels
and theorem 229:
Theorem (229) [serial 1288] used for:
  substituted Assertions' predicates for  labels  [serial 1276]
 


Theorem (231)                               [serial 1264] 
P [91] << ((((ub - lb) < window_size)) and INV_AV()) >>
S [107] ->
Q [109] << (all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and true >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 230:
Theorem (230) [serial 1276] used for:
    normalization of [serial 1264]
 


Theorem (232)                               [serial 1253] 
P [91] << FW() >>
S [107] ->
Q [109] << GS() and true >>
by Substitution of Assertion Labels
and theorem 231:
Theorem (231) [serial 1264] used for:
  substituted Assertions' predicates for  labels  [serial 1253]
 


Theorem (233)                               [serial 1242] 
P [91] << FW() >>
S [107] ->
Q [109] << GS() and (true) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 232:
Theorem (232) [serial 1253] used for:
    normalization of [serial 1242]
 


Theorem (234)                               [serial 1230] 
P [91] << FW() >>
S [107] ->
Q [109] << GS() and ((SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0) iff (SENSOR_CONNECTED^0 and 
not MOTION_ARTIFACT^0)) >>
by Equality Law (idistr):  a=a <-> true
and theorem 233:
Theorem (233) [serial 1242] used for:
  Equality Law (idistr):  a=a <-> true [serial 1230]
 


Theorem (235)                               [serial 1214] 
P [91] << FW() >>
S [107] ->
Q [109] << ((((SENSOR_CONNECTED)^0 and not (MOTION_ARTIFACT)^0)) iff (SENSOR_CONNECTED^0 and 
not MOTION_ARTIFACT^0)) and GS() >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 234:
Theorem (234) [serial 1230] used for:
    normalization of [serial 1214]
 


Theorem (236)                               [serial 1210] 
P [91] << FW() >>
S [107] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := (SensorConnected? and 
not MotionArtifact?)
Q [109] << (goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^0 and 
not MOTION_ARTIFACT^0)) and GS() >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 235:
Theorem (235) [serial 1214] used for:
  applied wp for assignment [serial 1210]
 


Theorem (237)                               [serial 1204] 
P [91] << FW() >>
S [93] << FW() >>
spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] := (if SensorConnected? and not MotionArtifact? then SpO2? else 0)
<< WINDOW() and ((spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x:0))) >>
&
totalSpO2 := totalSpO2 + (if SensorConnected? and not MotionArtifact? then SpO2? else 0)
<< (totalSpO2 = (SSQ(x:0) + (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - ub) ))) >>
&
goodCount := (goodCount + (if SensorConnected? and not MotionArtifact? then 1 else 0))
<< (goodCount = ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) >>
&
goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := (SensorConnected? and not MotionArtifact?)
<< (goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0)) and GS() >>
Q [112] << (all k~quantity whole
  in lb..ub 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)) ) and 
((totalSpO2 = (sum k~quantity whole
  in lb..ub 
  of SSQ(k - ub) ))) and ((goodCount = (numberof k~quantity whole
  in lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>> (bl.cck)
and theorems 170 177 192 206 220 236:
Theorem (170) [serial 1205] used for:
  P -> P1 in concurrent composition for [serial 1204]
 
Theorem (177) [serial 1206] used for:
  Q1 and Q2 and  . . . and Qn -> Q in concurrent composition for [serial 1204]
 
Theorem (192) [serial 1207] used for:
  <<P1>> S1 <<Q1>> in concurrent composition for [serial 1204]
 
Theorem (206) [serial 1208] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1204]
 
Theorem (220) [serial 1209] used for:
  <<P>> S3 <<Q3>> in concurrent composition for [serial 1204]
 
Theorem (236) [serial 1210] used for:
  <<P>> S4 <<Q4>> in concurrent composition for [serial 1204]
 


Theorem (238)                               [serial 1202] 
P [91] << FW() >>
S [92] {
<< FW() >>
spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] := (if SensorConnected? and not MotionArtifact? then SpO2? else 0)
<< WINDOW() and ((spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x:0))) >>
&
totalSpO2 := totalSpO2 + (if SensorConnected? and not MotionArtifact? then SpO2? else 0)
<< (totalSpO2 = (SSQ(x:0) + (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - ub) ))) >>
&
goodCount := (goodCount + (if SensorConnected? and not MotionArtifact? then 1 else 0))
<< (goodCount = ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) >>
&
goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := (SensorConnected? and not MotionArtifact?)
<< (goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0)) and GS() >>
} 
Q [112] << (all k~quantity whole
  in lb..ub 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)) ) and 
((totalSpO2 = (sum k~quantity whole
  in lb..ub 
  of SSQ(k - ub) ))) and ((goodCount = (numberof k~quantity whole
  in lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Introduction of Existential Quantification (bl.elq)
and theorem 237:
Theorem (237) [serial 1204] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1202]
 


Theorem (239)                               [serial 1255] 
P [112] << goodCount = (numberof k~quantity whole
  in lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub 
  of SSQ(k - ub) ) and (all k~quantity whole
  in lb..ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
S [122] ->
Q [123] << goodCount = (numberof k~quantity whole
  in lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub 
  of SSQ(k - ub) ) and (all k~quantity whole
  in lb..ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Identity (id):  P->P is tautology


Theorem (240)                               [serial 1243] 
P [112] << goodCount = (numberof k~quantity whole
  in lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub 
  of SSQ(k - ub) ) and (all k~quantity whole
  in lb..ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
S [122] ->
Q [123] << goodCount = (numberof k~quantity whole
  in lb..ub 
  that (SENSOR_CONNECTED^((k)-(ub)) and not MOTION_ARTIFACT^((k)-(ub))) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub 
  of SSQ((k) - (ub)) ) and (all k~quantity whole
  in lb..ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ((k) - (ub)) ) and 
(all k~quantity whole
  in lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((k)-(ub)) and 
      not MOTION_ARTIFACT^((k)-(ub))) ) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 239:
Theorem (239) [serial 1255] used for:
    normalization of [serial 1243]
 


Theorem (241)                               [serial 1232] 
P [112] << goodCount = (numberof k~quantity whole
  in lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub 
  of SSQ(k - ub) ) and (all k~quantity whole
  in lb..ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
S [122] ->
Q [123] << goodCount = (numberof k~quantity whole
  in lb..ub 
  that (SENSOR_CONNECTED^((1+k)-(1+ub)) and not MOTION_ARTIFACT^((1+k)-(1+ub))) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub 
  of SSQ((1 + k) - (1 + ub)) ) and (all k~quantity whole
  in lb..ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ((1 + 
      k) - (1 + ub)) ) and (all k~quantity whole
  in lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-(1+ub)) and 
      not MOTION_ARTIFACT^((1+k)-(1+ub))) ) >>
by Add both sides of subtraction:  a-b is (x+a)-(x+b)
and theorem 240:
Theorem (240) [serial 1243] used for:
  Add both sides of subtraction:  a-b is (x+a)-(x+b) [serial 1232]
 


Theorem (242)                               [serial 1215] 
P [112] << (all k~quantity whole
  in lb..ub 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)) ) and 
((totalSpO2 = (sum k~quantity whole
  in lb..ub 
  of SSQ(k - ub) ))) and ((goodCount = (numberof k~quantity whole
  in lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
S [122] ->
Q [123] << (all k~quantity whole
  in lb..((ub + 1) - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ((
      ub + 1) - 1))) ) and ((totalSpO2 = (sum k~quantity whole
  in lb..((ub + 1) - 1) 
  of SSQ(k - ((ub + 1) - 1)) ))) and ((goodCount = (numberof k~quantity whole
  in lb..((ub + 1) - 1) 
  that (SENSOR_CONNECTED^(k-((ub+1)-1)) and not MOTION_ARTIFACT^(k-((ub+1)-1))) ))) and 
(all k~quantity whole
  in lb..((ub + 1) - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-((ub+1)-1)) and 
      not MOTION_ARTIFACT^(k-((ub+1)-1))) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Subtaction of Added Value:  (a+b)-a is b
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Associativity: (b.c).a = a.b.c
and theorem 241:
Theorem (241) [serial 1232] used for:
    normalization of [serial 1215]
 


Theorem (243)                               [serial 1203] 
P [112] << (all k~quantity whole
  in lb..ub 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)) ) and 
((totalSpO2 = (sum k~quantity whole
  in lb..ub 
  of SSQ(k - ub) ))) and ((goodCount = (numberof k~quantity whole
  in lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
S [122] ub := ub + 1
Q [123] << (all k~quantity whole
  in lb..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - (ub - 1))) ) and 
((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - (ub - 1)) ))) and ((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-(ub-1)) and not MOTION_ARTIFACT^(k-(ub-1))) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-(ub-1)) and 
      not MOTION_ARTIFACT^(k-(ub-1))) ) >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 242:
Theorem (242) [serial 1215] used for:
  applied wp for assignment [serial 1203]
 


Theorem (244)                               [serial 1015] 
P [71] << (((ub - lb) < window_size)) and INV_AV() >>
S [91] << FW() >>
{
<< FW() >>
spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] := (if SensorConnected? and not MotionArtifact? then SpO2? else 0)
<< WINDOW() and ((spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x:0))) >>
&
totalSpO2 := totalSpO2 + (if SensorConnected? and not MotionArtifact? then SpO2? else 0)
<< (totalSpO2 = (SSQ(x:0) + (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - ub) ))) >>
&
goodCount := (goodCount + (if SensorConnected? and not MotionArtifact? then 1 else 0))
<< (goodCount = ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) >>
&
goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := (SensorConnected? and not MotionArtifact?)
<< (goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0)) and GS() >>
} 
<< (all k~quantity whole
  in lb..ub 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)) ) and ((totalSpO2 = (sum k~quantity whole
  in lb..ub 
  of SSQ(k - ub) ))) and ((goodCount = (numberof k~quantity whole
  in lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and (all k~quantity whole
  in lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) >>
;
ub := ub + 1
<< (all k~quantity whole
  in lb..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - (ub - 1))) ) and ((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - (ub - 1)) ))) and ((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-(ub-1)) and not MOTION_ARTIFACT^(k-(ub-1))) ))) and (all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-(ub-1)) and not MOTION_ARTIFACT^(k-(ub-1))) ) >>
Q [73] << (all k~quantity whole
  in lb..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - (ub - 1))) ) and 
((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - (ub - 1)) ))) and ((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-(ub-1)) and not MOTION_ARTIFACT^(k-(ub-1))) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-(ub-1)) and 
      not MOTION_ARTIFACT^(k-(ub-1))) ) >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 167 169 238 243:
Theorem (167) [serial 1200] used for:
  P -> P1 in sequential composition for [serial 1015]
 
Theorem (169) [serial 1201] used for:
  Q1 -> Q in sequential composition for [serial 1015]
 
Theorem (238) [serial 1202] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1015]
 
Theorem (243) [serial 1203] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1015]
 


Theorem (245)                               [serial 1422] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
S [133] ->
Q [71] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
by Identity (id):  P->P is tautology


Theorem (246)                               [serial 1424] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
S [133] ->
Q [71] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
by Identity (id):  P->P is tautology


Theorem (247)                               [serial 1420] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
S [133] ->
Q [71] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorems 245 246:
Theorem (245) [serial 1422] used for:
    normalization of [serial 1420]
 
Theorem (246) [serial 1424] used for:
    normalization of [serial 1420]
 


Theorem (248)                               [serial 1419] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
S [133] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [71] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub^1 - lb^1) < window_size^1 >>
by Simultaneous Assignment
and theorem 247:
Theorem (247) [serial 1420] used for:
  applied wp for simultaneous assignment [serial 1419]
 


Theorem (249)                               [serial 1416] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
S [133] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [71] << (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) )) and (ub^1 - lb^1) < window_size^1 >>
by Associativity: (b.c).a = a.b.c
and theorem 248:
Theorem (248) [serial 1419] used for:
  Associativity: (b.c).a = a.b.c [serial 1416]
 


Theorem (250)                               [serial 1414] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
S [133] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [71] << (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not (MOTION_ARTIFACT^(k-ub))^1 then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not (MOTION_ARTIFACT^(k-ub))^1 then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) )) and (ub^1 - lb^1) < window_size^1 >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Caret Compostition:  (x^a)^b is x^(a+b)
    Associativity: (b.c).a = a.b.c
and theorem 249:
Theorem (249) [serial 1416] used for:
    normalization of [serial 1414]
 


Theorem (251)                               [serial 1412] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
S [133] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [71] << (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and (not MOTION_ARTIFACT^(k-ub))^1 then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      (not MOTION_ARTIFACT^(k-ub))^1 then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) )) and (ub^1 - lb^1) < window_size^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 250:
Theorem (250) [serial 1414] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1412]
 


Theorem (252)                               [serial 1410] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
S [133] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [71] << (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not (MOTION_ARTIFACT^(k-ub))^1) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if (SENSOR_CONNECTED^((k-ub)+1) and (not MOTION_ARTIFACT^(k-ub))^1) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if (
      SENSOR_CONNECTED^((k-ub)+1) and (not MOTION_ARTIFACT^(k-ub))^1) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not (MOTION_ARTIFACT^(k-ub))^1) )) and (ub^1 - lb^1) < window_size^1 >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Caret Compostition:  (x^a)^b is x^(a+b)
    Associativity: (b.c).a = a.b.c
and theorem 251:
Theorem (251) [serial 1412] used for:
    normalization of [serial 1410]
 


Theorem (253)                               [serial 1408] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
S [133] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [71] << (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and (not MOTION_ARTIFACT^(k-ub))^1) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub))^1 then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if (
      SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub))^1 then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      (not MOTION_ARTIFACT^(k-ub))^1) )) and (ub^1 - lb^1) < window_size^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 252:
Theorem (252) [serial 1410] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1408]
 


Theorem (254)                               [serial 1406] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
S [133] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [71] << (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((k-ub)+1) and (not MOTION_ARTIFACT^(k-ub))^1) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub))^1 then SPO2^((k-ub)+1) else (0)^1) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub))^1 then SPO2^((k-ub)+1) else (0)^1) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((k-ub)+1) and 
      (not MOTION_ARTIFACT^(k-ub))^1) )) and (ub^1 - lb^1) < window_size^1 >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
    Associativity: (b.c).a = a.b.c
and theorem 253:
Theorem (253) [serial 1408] used for:
    normalization of [serial 1406]
 


Theorem (255)                               [serial 1404] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
S [133] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [71] << (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub))^1 ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)^1 ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)^1 = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))^1 )) and (ub^1 - lb^1) < window_size^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 254:
Theorem (254) [serial 1406] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1404]
 


Theorem (256)                               [serial 1402] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
S [133] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [71] << (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that ((SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)))^1 ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0))^1 ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0))^1 = (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples])^1) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are ((goodSamp[k mod #PulseOx_Properties::Max_Window_Samples])^1 iff (
      SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub))^1) )) and 
(ub^1 - lb^1) < window_size^1 >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 255:
Theorem (255) [serial 1404] used for:
    normalization of [serial 1402]
 


Theorem (257)                               [serial 1400] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
S [133] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [71] << (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )^1 and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )^1 and 
(all k~quantity whole
  in lb..ub - 1 
  are ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples])^1 ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)))^1 )) and (ub^1 - lb^1) < window_size^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 256:
Theorem (256) [serial 1402] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1400]
 


Theorem (258)                               [serial 1398] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
S [133] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [71] << (((goodCount)^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )^1) and 
((totalSpO2)^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )^1) and 
(all k~quantity whole
  in lb..ub - 1 
  are ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples])^1 ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)))^1 )) and ((ub)^1 - (lb)^1) < window_size^1 >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 257:
Theorem (257) [serial 1400] used for:
    normalization of [serial 1398]
 


Theorem (259)                               [serial 1396] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
S [133] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [71] << ((goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))^1 and 
(totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ))^1 and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] )^1 and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )^1) and (ub - lb)^1 < window_size^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 258:
Theorem (258) [serial 1398] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1396]
 


Theorem (260)                               [serial 1394] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
S [133] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [71] << ((goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))^1 and 
(totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ))^1 and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] )^1 and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )^1) and ((ub - lb)^1 < (window_size)^1) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 259:
Theorem (259) [serial 1396] used for:
    normalization of [serial 1394]
 


Theorem (261)                               [serial 1392] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
S [133] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [71] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ))^1 and ((ub - lb) < window_size)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 260:
Theorem (260) [serial 1394] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1392]
 


Theorem (262)                               [serial 1390] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
S [133] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [71] << ((goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ))^1 and ((ub - lb) < window_size)^1) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 261:
Theorem (261) [serial 1392] used for:
    normalization of [serial 1390]
 


Theorem (263)                               [serial 1387] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
S [133] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [71] << ((goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 262:
Theorem (262) [serial 1390] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1387]
 


Theorem (264)                               [serial 1385] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
S [133] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [71] << ((goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size)^1 >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 263:
Theorem (263) [serial 1387] used for:
    normalization of [serial 1385]
 


Theorem (265)                               [serial 1383] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
S [133] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [71] << ((goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and (ub - lb) < window_size)^1 >>
by Substitution of Assertion Labels
and theorem 264:
Theorem (264) [serial 1385] used for:
  substituted Assertions' predicates for  labels  [serial 1383]
 


Theorem (266)                               [serial 1381] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
S [133] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [71] << ((((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and ((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - ub) ))) and (all k~quantity whole
  in lb..(ub - 1) 
  are ((spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub))) )) and 
(ub - lb) < window_size)^1 >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 265:
Theorem (265) [serial 1383] used for:
    normalization of [serial 1381]
 


Theorem (267)                               [serial 1379] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and (ub - lb) < window_size >>
S [133] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [71] << ((GOOD() and GS() and TOTAL_SPO2() and WINDOW()) and (ub - lb) < window_size)^1 >>
by Substitution of Assertion Labels
and theorem 266:
Theorem (266) [serial 1381] used for:
  substituted Assertions' predicates for  labels  [serial 1379]
 


Theorem (268)                               [serial 1377] 
P [73] << (all k~quantity whole
  in lb..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(k-(ub-1)) and 
      not MOTION_ARTIFACT^(k-(ub-1)) then SPO2^(k-(ub-1)) else 0))) ) and 
((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of ((if SENSOR_CONNECTED^(k-(ub-1)) and not MOTION_ARTIFACT^(k-(ub-1)) then SPO2^(k-(ub-1)) else 0)) ))) and 
((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-(ub-1)) and not MOTION_ARTIFACT^(k-(ub-1))) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-(ub-1)) and 
      not MOTION_ARTIFACT^(k-(ub-1))) ) and (((ub - lb) < window_size)) >>
S [133] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [71] << ((((ub - lb) < window_size)) and (WINDOW() and TOTAL_SPO2() and GOOD() and 
GS()))^1 >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Associativity: (b.c).a = a.b.c
and theorem 267:
Theorem (267) [serial 1379] used for:
    normalization of [serial 1377]
 


Theorem (269)                               [serial 1016] 
P [73] << (all k~quantity whole
  in lb..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - (ub - 1))) ) and 
((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - (ub - 1)) ))) and ((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-(ub-1)) and not MOTION_ARTIFACT^(k-(ub-1))) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-(ub-1)) and 
      not MOTION_ARTIFACT^(k-(ub-1))) ) and (((ub - lb) < window_size)) >>
S [133] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [71] << ((((ub - lb) < window_size)) and INV_AV())^1 >>
by Substitution of Assertion Labels
and theorem 268:
Theorem (268) [serial 1377] used for:
  substituted Assertions' predicates for  labels  [serial 1016]
 


Theorem (270)                               [serial 1475] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [136] ->
Q [82] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
by Identity (id):  P->P is tautology


Theorem (271)                               [serial 1477] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [136] ->
Q [82] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
by Identity (id):  P->P is tautology


Theorem (272)                               [serial 1473] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [136] ->
Q [82] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorems 270 271:
Theorem (270) [serial 1475] used for:
    normalization of [serial 1473]
 
Theorem (271) [serial 1477] used for:
    normalization of [serial 1473]
 


Theorem (273)                               [serial 1471] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [136] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [82] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size^1 = (ub^1 - lb^1) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
by Simultaneous Assignment
and theorem 272:
Theorem (272) [serial 1473] used for:
  applied wp for simultaneous assignment [serial 1471]
 


Theorem (274)                               [serial 1469] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [136] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [82] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) and window_size^1 = (ub^1 - lb^1) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 273:
Theorem (273) [serial 1471] used for:
    normalization of [serial 1469]
 


Theorem (275)                               [serial 1466] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [136] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [82] << window_size^1 = (ub^1 - lb^1) and (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) )) >>
by Associativity: (b.c).a = a.b.c
and theorem 274:
Theorem (274) [serial 1469] used for:
  Associativity: (b.c).a = a.b.c [serial 1466]
 


Theorem (276)                               [serial 1464] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [136] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [82] << window_size^1 = (ub^1 - lb^1) and (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not (MOTION_ARTIFACT^(k-ub))^1 then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not (MOTION_ARTIFACT^(k-ub))^1 then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) )) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Caret Compostition:  (x^a)^b is x^(a+b)
    Associativity: (b.c).a = a.b.c
and theorem 275:
Theorem (275) [serial 1466] used for:
    normalization of [serial 1464]
 


Theorem (277)                               [serial 1462] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [136] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [82] << window_size^1 = (ub^1 - lb^1) and (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and (not MOTION_ARTIFACT^(k-ub))^1 then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      (not MOTION_ARTIFACT^(k-ub))^1 then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) )) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 276:
Theorem (276) [serial 1464] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1462]
 


Theorem (278)                               [serial 1460] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [136] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [82] << window_size^1 = (ub^1 - lb^1) and (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not (MOTION_ARTIFACT^(k-ub))^1) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if (SENSOR_CONNECTED^((k-ub)+1) and (not MOTION_ARTIFACT^(k-ub))^1) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if (
      SENSOR_CONNECTED^((k-ub)+1) and (not MOTION_ARTIFACT^(k-ub))^1) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not (MOTION_ARTIFACT^(k-ub))^1) )) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Caret Compostition:  (x^a)^b is x^(a+b)
    Associativity: (b.c).a = a.b.c
and theorem 277:
Theorem (277) [serial 1462] used for:
    normalization of [serial 1460]
 


Theorem (279)                               [serial 1458] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [136] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [82] << window_size^1 = (ub^1 - lb^1) and (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and (not MOTION_ARTIFACT^(k-ub))^1) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub))^1 then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if (
      SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub))^1 then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      (not MOTION_ARTIFACT^(k-ub))^1) )) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 278:
Theorem (278) [serial 1460] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1458]
 


Theorem (280)                               [serial 1456] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [136] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [82] << window_size^1 = (ub^1 - lb^1) and (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((k-ub)+1) and (not MOTION_ARTIFACT^(k-ub))^1) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub))^1 then SPO2^((k-ub)+1) else (0)^1) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub))^1 then SPO2^((k-ub)+1) else (0)^1) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((k-ub)+1) and 
      (not MOTION_ARTIFACT^(k-ub))^1) )) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
    Associativity: (b.c).a = a.b.c
and theorem 279:
Theorem (279) [serial 1458] used for:
    normalization of [serial 1456]
 


Theorem (281)                               [serial 1454] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [136] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [82] << window_size^1 = (ub^1 - lb^1) and (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub))^1 ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)^1 ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)^1 = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))^1 )) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 280:
Theorem (280) [serial 1456] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1454]
 


Theorem (282)                               [serial 1452] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [136] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [82] << window_size^1 = (ub^1 - lb^1) and (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that ((SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)))^1 ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0))^1 ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0))^1 = (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples])^1) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are ((goodSamp[k mod #PulseOx_Properties::Max_Window_Samples])^1 iff (
      SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub))^1) )) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 281:
Theorem (281) [serial 1454] used for:
    normalization of [serial 1452]
 


Theorem (283)                               [serial 1450] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [136] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [82] << window_size^1 = (ub^1 - lb^1) and (goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )^1 and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )^1 and 
(all k~quantity whole
  in lb..ub - 1 
  are ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples])^1 ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)))^1 )) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 282:
Theorem (282) [serial 1452] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1450]
 


Theorem (284)                               [serial 1448] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [136] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [82] << window_size^1 = ((ub)^1 - (lb)^1) and (((goodCount)^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )^1) and 
((totalSpO2)^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )^1) and 
(all k~quantity whole
  in lb..ub - 1 
  are ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples])^1 ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)))^1 )) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 283:
Theorem (283) [serial 1450] used for:
    normalization of [serial 1448]
 


Theorem (285)                               [serial 1446] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [136] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [82] << window_size^1 = (ub - lb)^1 and ((goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))^1 and 
(totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ))^1 and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] )^1 and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )^1) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 284:
Theorem (284) [serial 1448] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1446]
 


Theorem (286)                               [serial 1444] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [136] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [82] << ((window_size)^1 = (ub - lb)^1) and ((goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))^1 and 
(totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ))^1 and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] )^1 and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )^1) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 285:
Theorem (285) [serial 1446] used for:
    normalization of [serial 1444]
 


Theorem (287)                               [serial 1442] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [136] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [82] << (window_size = (ub - lb))^1 and (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 286:
Theorem (286) [serial 1444] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1442]
 


Theorem (288)                               [serial 1440] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [136] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [82] << ((window_size = (ub - lb))^1 and (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ))^1) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 287:
Theorem (287) [serial 1442] used for:
    normalization of [serial 1440]
 


Theorem (289)                               [serial 1437] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [136] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [82] << (window_size = (ub - lb) and (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 288:
Theorem (288) [serial 1440] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1437]
 


Theorem (290)                               [serial 1435] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [136] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [82] << (window_size = (ub - lb) and (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )))^1 >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 289:
Theorem (289) [serial 1437] used for:
    normalization of [serial 1435]
 


Theorem (291)                               [serial 1433] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [136] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [82] << (window_size = (ub - lb) and (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )))^1 >>
by Substitution of Assertion Labels
and theorem 290:
Theorem (290) [serial 1435] used for:
  substituted Assertions' predicates for  labels  [serial 1433]
 


Theorem (292)                               [serial 1431] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [136] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [82] << (window_size = (ub - lb) and (((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and ((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - ub) ))) and (all k~quantity whole
  in lb..(ub - 1) 
  are ((spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub))) )))^1 >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 291:
Theorem (291) [serial 1433] used for:
    normalization of [serial 1431]
 


Theorem (293)                               [serial 1429] 
P [73] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [136] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [82] << (window_size = (ub - lb) and (GOOD() and GS() and TOTAL_SPO2() and WINDOW()))^1 >>
by Substitution of Assertion Labels
and theorem 292:
Theorem (292) [serial 1431] used for:
  substituted Assertions' predicates for  labels  [serial 1429]
 


Theorem (294)                               [serial 1427] 
P [73] << (all k~quantity whole
  in lb..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(k-(ub-1)) and 
      not MOTION_ARTIFACT^(k-(ub-1)) then SPO2^(k-(ub-1)) else 0))) ) and 
((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of ((if SENSOR_CONNECTED^(k-(ub-1)) and not MOTION_ARTIFACT^(k-(ub-1)) then SPO2^(k-(ub-1)) else 0)) ))) and 
((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-(ub-1)) and not MOTION_ARTIFACT^(k-(ub-1))) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-(ub-1)) and 
      not MOTION_ARTIFACT^(k-(ub-1))) ) and (((ub - lb) = window_size)) >>
S [136] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [82] << ((WINDOW() and TOTAL_SPO2() and GOOD() and GS()) and (((ub - lb) = window_size)))^1 >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Associativity: (b.c).a = a.b.c
and theorem 293:
Theorem (293) [serial 1429] used for:
    normalization of [serial 1427]
 


Theorem (295)                               [serial 1017] 
P [73] << (all k~quantity whole
  in lb..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - (ub - 1))) ) and 
((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - (ub - 1)) ))) and ((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-(ub-1)) and not MOTION_ARTIFACT^(k-(ub-1))) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-(ub-1)) and 
      not MOTION_ARTIFACT^(k-(ub-1))) ) and (((ub - lb) = window_size)) >>
S [136] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [82] << (INV_AV() and (((ub - lb) = window_size)))^1 >>
by Substitution of Assertion Labels
and theorem 294:
Theorem (294) [serial 1427] used for:
  substituted Assertions' predicates for  labels  [serial 1017]
 


Theorem (296)                               [serial 1480] 
P [73] << (all k~quantity whole
  in lb..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - (ub - 1))) ) and 
((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - (ub - 1)) ))) and ((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-(ub-1)) and not MOTION_ARTIFACT^(k-(ub-1))) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-(ub-1)) and 
      not MOTION_ARTIFACT^(k-(ub-1))) ) and (((ub - lb) > window_size)) >>
S [139] ->
Q [84] << true >>
by True Conclusion Schema (tc): P->true


Theorem (297)                               [serial 1018] 
P [73] << (all k~quantity whole
  in lb..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - (ub - 1))) ) and 
((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - (ub - 1)) ))) and ((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-(ub-1)) and not MOTION_ARTIFACT^(k-(ub-1))) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-(ub-1)) and 
      not MOTION_ARTIFACT^(k-(ub-1))) ) and (((ub - lb) > window_size)) >>
S [139] |ub',lb',window_size',totalSpO2',goodCount',goodSamp',spo2_hist' := ub,lb,window_size,totalSpO2,goodCount,goodSamp,spo2_hist|  
Q [84] << true >>
by Simultaneous Assignment
and theorem 296:
Theorem (296) [serial 1480] used for:
  applied wp for simultaneous assignment [serial 1018]
 


Theorem (298)                               [serial 1741] 
P [82] << window_size = (ub - lb) and GOOD() and GS() and TOTAL_SPO2() and WINDOW() >>
S [82] ->
Q [142] << window_size = (ub - lb) and GOOD() and GS() and TOTAL_SPO2() and WINDOW() >>
by Identity (id):  P->P is tautology


Theorem (299)                               [serial 1739] 
P [82] << window_size = (ub - lb) and GOOD() and GS() and TOTAL_SPO2() and WINDOW() >>
S [82] ->
Q [142] << WINDOW() and TOTAL_SPO2() and GOOD() and GS() and window_size = (ub - lb) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 298:
Theorem (298) [serial 1741] used for:
    normalization of [serial 1739]
 


Theorem (300)                               [serial 1738] 
P [82] << window_size = (ub - lb) and GOOD() and GS() and TOTAL_SPO2() and WINDOW() >>
S [82] ->
Q [142] << window_size = (ub - lb) and (WINDOW() and TOTAL_SPO2() and GOOD() and 
GS()) >>
by Associativity: (b.c).a = a.b.c
and theorem 299:
Theorem (299) [serial 1739] used for:
  Associativity: (b.c).a = a.b.c [serial 1738]
 


Theorem (301)                               [serial 1637] 
P [82] << window_size = (ub - lb) and GOOD() and GS() and TOTAL_SPO2() and WINDOW() >>
S [82] ->
Q [142] << window_size = (ub - lb) and INV_AV() >>
by Substitution of Assertion Labels
and theorem 300:
Theorem (300) [serial 1738] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 1637]
 


Theorem (302)                               [serial 1612] 
P [82] << WINDOW() and TOTAL_SPO2() and GOOD() and GS() and window_size = (ub - lb) >>
S [82] ->
Q [142] << (INV_AV() and (((ub - lb) = window_size))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 301:
Theorem (301) [serial 1637] used for:
    normalization of [serial 1612]
 


Theorem (303)                               [serial 1598] 
P [82] << window_size = (ub - lb) and (WINDOW() and TOTAL_SPO2() and GOOD() and 
GS()) >>
S [82] ->
Q [142] << (INV_AV() and (((ub - lb) = window_size))) >>
by Associativity: (b.c).a = a.b.c
and theorem 302:
Theorem (302) [serial 1612] used for:
  Associativity: (b.c).a = a.b.c [serial 1598]
 


Theorem (304)                               [serial 1509] 
P [82] << window_size = (ub - lb) and INV_AV() >>
S [82] ->
Q [142] << RUN_AV() >>
by Substitution of Assertion Labels
and theorem 303:
Theorem (303) [serial 1598] used for:
  substituted Assertions' predicates for  labels  [serial 1509]
 


Theorem (305)                               [serial 1481] 
P [82] << INV_AV() and (((ub - lb) = window_size)) >>
S [82] ->
Q [142] << RUN_AV() >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 304:
Theorem (304) [serial 1509] used for:
    normalization of [serial 1481]
 


Theorem (306)                               [serial 1863] 
P [209] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size^1 = (ub^1 - lb^1) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [82] ->
Q [21] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size^1 = (ub^1 - lb^1) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
by Identity (id):  P->P is tautology


Theorem (307)                               [serial 1861] 
P [209] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size^1 = (ub^1 - lb^1) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [82] ->
Q [21] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not (MOTION_ARTIFACT^(k-ub))^1 then SPO2^((1+k)-ub) else 0) ) and 
window_size^1 = (ub^1 - lb^1) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not (MOTION_ARTIFACT^(k-ub))^1 then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Caret Compostition:  (x^a)^b is x^(a+b)
    Associativity: (b.c).a = a.b.c
and theorem 306:
Theorem (306) [serial 1863] used for:
    normalization of [serial 1861]
 


Theorem (308)                               [serial 1859] 
P [209] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size^1 = (ub^1 - lb^1) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [82] ->
Q [21] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and (not MOTION_ARTIFACT^(k-ub))^1 then SPO2^((1+k)-ub) else 0) ) and 
window_size^1 = (ub^1 - lb^1) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      (not MOTION_ARTIFACT^(k-ub))^1 then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 307:
Theorem (307) [serial 1861] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1859]
 


Theorem (309)                               [serial 1857] 
P [209] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size^1 = (ub^1 - lb^1) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [82] ->
Q [21] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not (MOTION_ARTIFACT^(k-ub))^1) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if (SENSOR_CONNECTED^((k-ub)+1) and (not MOTION_ARTIFACT^(k-ub))^1) then SPO2^((1+k)-ub) else 0) ) and 
window_size^1 = (ub^1 - lb^1) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if (
      SENSOR_CONNECTED^((k-ub)+1) and (not MOTION_ARTIFACT^(k-ub))^1) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not (MOTION_ARTIFACT^(k-ub))^1) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Caret Compostition:  (x^a)^b is x^(a+b)
    Associativity: (b.c).a = a.b.c
and theorem 308:
Theorem (308) [serial 1859] used for:
    normalization of [serial 1857]
 


Theorem (310)                               [serial 1855] 
P [209] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size^1 = (ub^1 - lb^1) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [82] ->
Q [21] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and (not MOTION_ARTIFACT^(k-ub))^1) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub))^1 then SPO2^((1+k)-ub) else 0) ) and 
window_size^1 = (ub^1 - lb^1) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if (
      SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub))^1 then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      (not MOTION_ARTIFACT^(k-ub))^1) ) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 309:
Theorem (309) [serial 1857] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1855]
 


Theorem (311)                               [serial 1853] 
P [209] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size^1 = (ub^1 - lb^1) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [82] ->
Q [21] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((k-ub)+1) and (not MOTION_ARTIFACT^(k-ub))^1) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub))^1 then SPO2^((k-ub)+1) else (0)^1) ) and 
window_size^1 = (ub^1 - lb^1) and (all k~quantity whole
  in lb..ub - 1 
  are (if (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub))^1 then SPO2^((k-ub)+1) else (0)^1) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((k-ub)+1) and 
      (not MOTION_ARTIFACT^(k-ub))^1) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
    Associativity: (b.c).a = a.b.c
and theorem 310:
Theorem (310) [serial 1855] used for:
    normalization of [serial 1853]
 


Theorem (312)                               [serial 1851] 
P [209] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size^1 = (ub^1 - lb^1) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [82] ->
Q [21] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub))^1 ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)^1 ) and 
window_size^1 = (ub^1 - lb^1) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)^1 = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))^1 ) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 311:
Theorem (311) [serial 1853] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1851]
 


Theorem (313)                               [serial 1849] 
P [209] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size^1 = (ub^1 - lb^1) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [82] ->
Q [21] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that ((SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)))^1 ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0))^1 ) and 
window_size^1 = ((ub)^1 - (lb)^1) and (all k~quantity whole
  in lb..ub - 1 
  are (((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0))^1 = (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples])^1) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are ((goodSamp[k mod #PulseOx_Properties::Max_Window_Samples])^1 iff (
      SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub))^1) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 312:
Theorem (312) [serial 1851] used for:
    normalization of [serial 1849]
 


Theorem (314)                               [serial 1847] 
P [209] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size^1 = (ub^1 - lb^1) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [82] ->
Q [21] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )^1 and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )^1 and 
window_size^1 = (ub - lb)^1 and (all k~quantity whole
  in lb..ub - 1 
  are ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples])^1 ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)))^1 ) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 313:
Theorem (313) [serial 1849] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1847]
 


Theorem (315)                               [serial 1845] 
P [209] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size^1 = (ub^1 - lb^1) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [82] ->
Q [21] << ((goodCount)^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )^1) and 
((totalSpO2)^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )^1) and 
((window_size)^1 = (ub - lb)^1) and (all k~quantity whole
  in lb..ub - 1 
  are ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples])^1 ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)))^1 ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 314:
Theorem (314) [serial 1847] used for:
    normalization of [serial 1845]
 


Theorem (316)                               [serial 1843] 
P [209] << goodCount^1 = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) and 
totalSpO2^1 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
window_size^1 = (ub^1 - lb^1) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]^1 = (if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples]^1 iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [82] ->
Q [21] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))^1 and 
(totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ))^1 and 
(window_size = (ub - lb))^1 and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] )^1 and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 315:
Theorem (315) [serial 1845] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1843]
 


Theorem (317)                               [serial 1841] 
P [209] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = (goodCount)^1 and 
(sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) = (totalSpO2)^1 and 
(((ub)^1) - ((lb)^1)) = (window_size)^1 and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples])^1 ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) iff (goodSamp[k mod #PulseOx_Properties::Max_Window_Samples])^1 ) >>
S [82] ->
Q [21] << ((goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))^1 and 
(totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ))^1 and 
(window_size = (ub - lb))^1 and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] )^1 and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )^1) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 316:
Theorem (316) [serial 1843] used for:
    normalization of [serial 1841]
 


Theorem (318)                               [serial 1838] 
P [209] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) = totalSpO2' and 
((ub') - (lb')) = window_size' and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) iff \'goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
S [82] ->
Q [21] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 317:
Theorem (317) [serial 1841] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1838]
 


Theorem (319)                               [serial 1836] 
P [209] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) = totalSpO2' and 
((ub') - (lb')) = window_size' and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) iff \'goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
S [82] ->
Q [21] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ))^1 >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 318:
Theorem (318) [serial 1838] used for:
    normalization of [serial 1836]
 


Theorem (320)                               [serial 1834] 
P [209] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) = totalSpO2' and 
((ub') - (lb')) = window_size' and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) iff \'goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
S [82] ->
Q [21] << (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) ) and window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ))^1 >>
by Substitution of Assertion Labels
and theorem 319:
Theorem (319) [serial 1836] used for:
  substituted Assertions' predicates for  labels  [serial 1834]
 


Theorem (321)                               [serial 1832] 
P [209] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) = totalSpO2' and 
((ub') - (lb')) = window_size' and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) iff \'goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
S [82] ->
Q [21] << (window_size = (ub - lb) and ((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and ((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - ub) ))) and (all k~quantity whole
  in lb..(ub - 1) 
  are ((spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub))) ))^1 >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 320:
Theorem (320) [serial 1834] used for:
    normalization of [serial 1832]
 


Theorem (322)                               [serial 1649] 
P [209] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) = totalSpO2' and 
((ub') - (lb')) = window_size' and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) iff \'goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
S [82] ->
Q [21] << (window_size = (ub - lb) and GOOD() and GS() and TOTAL_SPO2() and WINDOW())^1 >>
by Substitution of Assertion Labels
and theorem 321:
Theorem (321) [serial 1832] used for:
  substituted Assertions' predicates for  labels  [serial 1649]
 


Theorem (323)                               [serial 1618] 
P [209] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of ((if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0)) ) = totalSpO2' and 
((ub') - (lb')) = window_size' and (all k~quantity whole
  in lb..ub - 1 
  are ((if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0)) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) iff \'goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
S [82] ->
Q [21] << (WINDOW() and TOTAL_SPO2() and GOOD() and GS() and window_size = (ub - lb))^1 >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 322:
Theorem (322) [serial 1649] used for:
    normalization of [serial 1618]
 


Theorem (324)                               [serial 1608] 
P [209] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of ((if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0)) ) = totalSpO2' and 
((ub') - (lb')) = window_size' and (all k~quantity whole
  in lb..ub - 1 
  are ((if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0)) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) iff \'goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
S [82] ->
Q [21] << (window_size = (ub - lb) and (WINDOW() and TOTAL_SPO2() and GOOD() and 
GS()))^1 >>
by Associativity: (b.c).a = a.b.c
and theorem 323:
Theorem (323) [serial 1618] used for:
  Associativity: (b.c).a = a.b.c [serial 1608]
 


Theorem (325)                               [serial 1564] 
P [209] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of SSQ((1 + k) - ub) ) = totalSpO2' and ((ub') - (lb')) = window_size' and 
(all k~quantity whole
  in lb..ub - 1 
  are SSQ((1 + k) - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) iff \'goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
S [82] ->
Q [21] << (window_size = (ub - lb) and INV_AV())^1 >>
by Substitution of Assertion Labels
and theorem 324:
Theorem (324) [serial 1608] used for:
  substituted Assertions' predicates for  labels  [serial 1564]
 


Theorem (326)                               [serial 1511] 
P [209] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of SSQ((1 + k) - ub) ) = totalSpO2' and ((1 + ub') - (1 + lb')) = window_size' and 
(all k~quantity whole
  in lb..ub - 1 
  are SSQ((1 + k) - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) iff \'goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
S [82] ->
Q [21] << (window_size = (ub - lb) and INV_AV())^1 >>
by Add both sides of subtraction:  a-b is (x+a)-(x+b)
and theorem 325:
Theorem (325) [serial 1564] used for:
  Add both sides of subtraction:  a-b is (x+a)-(x+b) [serial 1511]
 


Theorem (327)                               [serial 1482] 
P [209] << (all k~quantity whole
  in lb..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' = SSQ(k - (ub - 1))) ) and 
((totalSpO2' = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - (ub - 1)) ))) and ((((ub' - 1) - (lb' - 1)) = window_size')) and 
((goodCount' = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-(ub-1)) and not MOTION_ARTIFACT^(k-(ub-1))) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are \'goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-(ub-1)) and 
      not MOTION_ARTIFACT^(k-(ub-1))) ) >>
S [82] ->
Q [21] << (INV_AV() and (((ub - lb) = window_size)))^1 >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Associativity: (b.c).a = a.b.c
and theorem 326:
Theorem (326) [serial 1511] used for:
    normalization of [serial 1482]
 


Theorem (328)                               [serial 1680] 
P [142] << window_size = (ub - lb) and INV_AV() >>
S [143] ->
Q [143] << true >>
by True Conclusion Schema (tc): P->true


Theorem (329)                               [serial 1678] 
P [142] << window_size = (ub - lb) and INV_AV() >>
S [143] ->
Q [143] << not 0 < goodCount or 0 < goodCount >>
by Law of Excluded Middle: P or not P is tautology
and theorem 328:
Theorem (328) [serial 1680] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1678]
 


Theorem (330)                               [serial 1676] 
P [142] << window_size = (ub - lb) and INV_AV() >>
S [143] ->
Q [143] << (not (0 < goodCount)) or 0 < goodCount >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 329:
Theorem (329) [serial 1678] used for:
    normalization of [serial 1676]
 


Theorem (331)                               [serial 1623] 
P [142] << window_size = (ub - lb) and INV_AV() >>
S [143] ->
Q [143] << goodCount <= 0 or 0 < goodCount >>
by At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 330:
Theorem (330) [serial 1676] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a) [serial 1623]
 


Theorem (332)                               [serial 1599] 
P [142] << (INV_AV() and (((ub - lb) = window_size))) >>
S [143] ->
Q [143] << goodCount <= 0 or 0 < goodCount >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 331:
Theorem (331) [serial 1623] used for:
    normalization of [serial 1599]
 


Theorem (333)                               [serial 1513] 
P [142] << RUN_AV() >>
S [143] ->
Q [143] << goodCount <= 0 or 0 < goodCount >>
by Substitution of Assertion Labels
and theorem 332:
Theorem (332) [serial 1599] used for:
  substituted Assertions' predicates for  labels  [serial 1513]
 


Theorem (334)                               [serial 1487] 
P [142] << RUN_AV() >>
S [143] ->
Q [143] << ((goodCount > 0)) or ((goodCount <= 0)) >>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 333:
Theorem (333) [serial 1513] used for:
    normalization of [serial 1487]
 


Theorem (335)                               [serial 1567] 
P [143] << RUN_AV() and 0 < goodCount >>
S [143] ->
Q [145] << RUN_AV() and 0 < goodCount >>
by Identity (id):  P->P is tautology


Theorem (336)                               [serial 1540] 
P [143] << RUN_AV() and 0 < goodCount >>
S [143] ->
Q [145] << RUN_AV() and true and 0 < goodCount >>
by Law of And-Simplification:  P and true is P
and theorem 335:
Theorem (335) [serial 1567] used for:
  Law of And-Simplification:  P and true is P [serial 1540]
 


Theorem (337)                               [serial 1504] 
P [143] << (RUN_AV()) and ((goodCount > 0)) >>
S [143] ->
Q [145] << RUN_AV() and ((goodCount > 0)) and true >>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 336:
Theorem (336) [serial 1540] used for:
    normalization of [serial 1504]
 


Theorem (338)                               [serial 1567] 
P [143] << RUN_AV() and 0 < goodCount >>
S [143] ->
Q [145] << RUN_AV() and 0 < goodCount >>
by Identity (id):  P->P is tautology


Theorem (339)                               [serial 1540] 
P [143] << RUN_AV() and 0 < goodCount >>
S [143] ->
Q [145] << RUN_AV() and true and 0 < goodCount >>
by Law of And-Simplification:  P and true is P
and theorem 338:
Theorem (338) [serial 1567] used for:
  Law of And-Simplification:  P and true is P [serial 1540]
 


Theorem (340)                               [serial 1504] 
P [143] << (RUN_AV()) and ((goodCount > 0)) >>
S [143] ->
Q [145] << RUN_AV() and ((goodCount > 0)) and true >>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 339:
Theorem (339) [serial 1540] used for:
    normalization of [serial 1504]
 


Theorem (341)                               [serial 1488] 
P [143] << (RUN_AV()) and ((goodCount > 0)) >>
S [143] ->
Q [145] << RUN_AV() and ((goodCount > 0)) and AXIOM_K2I() >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 340 340:
Theorem (340) [serial 1504] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (340) [serial 1504] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (342)                               [serial 1757] 
P [146] << (SpO2Avg = (totalSpO2 / goodCount))^0 and window_size = (ub - lb) and 
((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) = ((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and INV_AV() and 
0 < goodCount >>
S [146] ->
Q [147] << window_size = (ub - lb) and INV_AV() >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (343)                               [serial 1753] 
P [146] << window_size = (ub - lb) and ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) = ((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and INV_AV() and 
0 < goodCount and (SpO2Avg = (totalSpO2 / goodCount))^0 >>
S [146] ->
Q [147] << window_size = (ub - lb) and INV_AV() >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 342:
Theorem (342) [serial 1757] used for:
    normalization of [serial 1753]
 


Theorem (344)                               [serial 1747] 
P [146] << (SpO2Avg = (totalSpO2 / goodCount))^0 and (window_size = (ub - lb) and 
((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) = ((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and INV_AV() and 
0 < goodCount) >>
S [146] ->
Q [147] << window_size = (ub - lb) and INV_AV() >>
by Associativity: (b.c).a = a.b.c
and theorem 343:
Theorem (343) [serial 1753] used for:
  Associativity: (b.c).a = a.b.c [serial 1747]
 


Theorem (345)                               [serial 1743] 
P [146] << (window_size = (ub - lb) and ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) = ((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and INV_AV() and 
0 < goodCount) and (SpO2Avg = (totalSpO2 / goodCount))^0 >>
S [146] ->
Q [147] << window_size = (ub - lb) and INV_AV() >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 344:
Theorem (344) [serial 1747] used for:
    normalization of [serial 1743]
 


Theorem (346)                               [serial 1779] 
P [146] << SpO2Avg = (totalSpO2 / goodCount) and goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
window_size = (ub - lb) and ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) = ((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and 0 < goodCount >>
S [146] ->
Q [146] << ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) = ((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (347)                               [serial 1777] 
P [146] << SpO2Avg = (totalSpO2 / goodCount) and goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
window_size = (ub - lb) and ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) = ((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and 0 < goodCount >>
S [146] ->
Q [146] << (((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) / ((numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) = ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 346:
Theorem (346) [serial 1779] used for:
    normalization of [serial 1777]
 


Theorem (348)                               [serial 1776] 
P [146] << SpO2Avg = (totalSpO2 / goodCount) and goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
window_size = (ub - lb) and ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) = ((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and 0 < goodCount >>
S [146] ->
Q [146] << (((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) / goodCount) = ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) >>
by Guided Substitution of Equals
and theorem 347:
Theorem (347) [serial 1777] used for:
  Guided Substitution of Equals
 replacing "goodCount" with its = "((numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))" in its postcondition [serial 1776]
 


Theorem (349)                               [serial 1775] 
P [146] << SpO2Avg = (totalSpO2 / goodCount) and goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
window_size = (ub - lb) and ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) = ((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and 0 < goodCount >>
S [146] ->
Q [146] << (totalSpO2 / goodCount) = ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) >>
by Guided Substitution of Equals
and theorem 348:
Theorem (348) [serial 1776] used for:
  Guided Substitution of Equals
 replacing "totalSpO2" with its = "((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ))" in its postcondition [serial 1775]
 


Theorem (350)                               [serial 1774] 
P [146] << SpO2Avg = (totalSpO2 / goodCount) and goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
window_size = (ub - lb) and ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) = ((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and 0 < goodCount >>
S [146] ->
Q [146] << SpO2Avg = ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) >>
by Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
and theorem 349:
Theorem (349) [serial 1775] used for:
  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
 replacing "SpO2Avg"
 with its ="
 ((totalSpO2 / goodCount))" [serial 1774]
 


Theorem (351)                               [serial 1773] 
P [146] << (SpO2Avg = (totalSpO2 / goodCount))^0 and goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and 
window_size = (ub - lb) and ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) = ((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and 0 < goodCount >>
S [146] ->
Q [146] << SpO2Avg = ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) >>
by Assume Present:  P = P@now = P^0 
and theorem 350:
Theorem (350) [serial 1774] used for:
  Assume Present:  P = P@now = P^0  [serial 1773]
 


Theorem (352)                               [serial 1771] 
P [146] << (SpO2Avg = (totalSpO2 / goodCount))^0 and goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) ) and window_size = (ub - lb) and ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) = ((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and 0 < goodCount >>
S [146] ->
Q [146] << SpO2Avg = ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) >>
by Substitution of Assertion Labels
and theorem 351:
Theorem (351) [serial 1773] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1771]
 


Theorem (353)                               [serial 1769] 
P [146] << (all k~quantity whole
  in lb..(ub - 1) 
  are ((spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub))) ) and 
((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - ub) ))) and ((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (SpO2Avg = (totalSpO2 / goodCount))^0 and 
window_size = (ub - lb) and ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) = ((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and 0 < goodCount >>
S [146] ->
Q [146] << SpO2Avg = ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 352:
Theorem (352) [serial 1771] used for:
    normalization of [serial 1769]
 


Theorem (354)                               [serial 1768] 
P [146] << (SpO2Avg = (totalSpO2 / goodCount))^0 and window_size = (ub - lb) and 
((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) = ((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and (
(all k~quantity whole
  in lb..(ub - 1) 
  are ((spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub))) ) and 
((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - ub) ))) and ((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and 0 < goodCount >>
S [146] ->
Q [146] << SpO2Avg = ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) >>
by Associativity: (b.c).a = a.b.c
and theorem 353:
Theorem (353) [serial 1769] used for:
  Associativity: (b.c).a = a.b.c [serial 1768]
 


Theorem (355)                               [serial 1767] 
P [146] << (SpO2Avg = (totalSpO2 / goodCount))^0 and window_size = (ub - lb) and 
((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) = ((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and (
WINDOW() and TOTAL_SPO2() and GOOD() and GS()) and 0 < goodCount >>
S [146] ->
Q [146] << SpO2Avg = ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) >>
by Substitution of Assertion Labels
and theorem 354:
Theorem (354) [serial 1768] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1767]
 


Theorem (356)                               [serial 1759] 
P [146] << (SpO2Avg = (totalSpO2 / goodCount))^0 and window_size = (ub - lb) and 
((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) = ((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and INV_AV() and 
0 < goodCount >>
S [146] ->
Q [146] << SpO2Avg = ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) >>
by Substitution of Assertion Labels
and theorem 355:
Theorem (355) [serial 1767] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1759]
 


Theorem (357)                               [serial 1754] 
P [146] << window_size = (ub - lb) and ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) = ((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and INV_AV() and 
0 < goodCount and (SpO2Avg = (totalSpO2 / goodCount))^0 >>
S [146] ->
Q [146] << SpO2Avg = ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 356:
Theorem (356) [serial 1759] used for:
    normalization of [serial 1754]
 


Theorem (358)                               [serial 1749] 
P [146] << (SpO2Avg = (totalSpO2 / goodCount))^0 and (window_size = (ub - lb) and 
((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) = ((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and INV_AV() and 
0 < goodCount) >>
S [146] ->
Q [146] << SpO2Avg = ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) >>
by Associativity: (b.c).a = a.b.c
and theorem 357:
Theorem (357) [serial 1754] used for:
  Associativity: (b.c).a = a.b.c [serial 1749]
 


Theorem (359)                               [serial 1744] 
P [146] << (window_size = (ub - lb) and ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) = ((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and INV_AV() and 
0 < goodCount) and (SpO2Avg = (totalSpO2 / goodCount))^0 >>
S [146] ->
Q [146] << SpO2Avg = ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^(i) and not MOTION_ARTIFACT^(i) then SPO2^(i) else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^(i) and not MOTION_ARTIFACT^(i)) )) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 358:
Theorem (358) [serial 1749] used for:
    normalization of [serial 1744]
 


Theorem (360)                               [serial 1765] 
P [145] << window_size = (ub - lb) and ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) = ((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and INV_AV() and 
0 < goodCount >>
S [146] ->
Q [146] << goodCount < 0 or 0 < goodCount >>
by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (361)                               [serial 1762] 
P [145] << window_size = (ub - lb) and ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) = ((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and INV_AV() and 
0 < goodCount >>
S [146] ->
Q [146] << ((0 < goodCount) or (goodCount < 0)) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 360:
Theorem (360) [serial 1765] used for:
    normalization of [serial 1762]
 


Theorem (362)                               [serial 1745] 
P [145] << window_size = (ub - lb) and ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) = ((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and INV_AV() and 
0 < goodCount >>
S [146] ->
Q [146] << goodCount <> 0 >>
by Replace inequality with not equality:  a<>b  iff  not(a=b)
and theorem 361:
Theorem (361) [serial 1762] used for:
  Replace inequality with not equality:  a<>b  iff  not(a=b) [serial 1745]
 


Theorem (363)                               [serial 1639] 
P [145] << window_size = (ub - lb) and ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i) )) = ((sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and INV_AV() and 
0 < goodCount >>
S [146] SpO2Avg!(totalSpO2 / goodCount)
Q [147] << window_size = (ub - lb) and INV_AV() >>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 345 359 362:
Theorem (345) [serial 1743] used for:
  applied port output <<pre and (SpO2Avg=totalSpO2 / goodCount)^0>> -> <<post>> [serial 1639]
 
Theorem (359) [serial 1744] used for:
  applied port output <<pre and (SpO2Avg=totalSpO2 / goodCount)^0>> -> <<(SpO2Avg=(sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^(i) and not MOTION_ARTIFACT^(i) then SPO2^(i) else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^(i) and not MOTION_ARTIFACT^(i)) ))^0>> [serial 1639]
 
Theorem (362) [serial 1745] used for:
  applied  <<pre>> -> <<d <> 0>> for <<pre>> SpO2Avg!(totalSpO2 / goodCount) <<post>> [serial 1639]
 


Theorem (364)                               [serial 1613] 
P [145] << INV_AV() and (((ub - lb) = window_size)) and ((((sum k~quantity whole
  in lb..(ub - 1) 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) = ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^(i) and not MOTION_ARTIFACT^(i)) )))) and 0 < goodCount >>
S [146] SpO2Avg!(totalSpO2 / goodCount)
Q [147] << (INV_AV() and (((ub - lb) = window_size))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 363:
Theorem (363) [serial 1639] used for:
    normalization of [serial 1613]
 


Theorem (365)                               [serial 1600] 
P [145] << ((((sum k~quantity whole
  in lb..(ub - 1) 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) / (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) = ((sum i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  of (if SENSOR_CONNECTED^i and not MOTION_ARTIFACT^i then SPO2^i else 0) ) / (numberof i~quantity whole
  in  -SPO2_MOVING_AVERAGE_WINDOW_SAMPLES..-1 
  that (SENSOR_CONNECTED^(i) and not MOTION_ARTIFACT^(i)) )))) and (INV_AV() and 
(((ub - lb) = window_size))) and 0 < goodCount >>
S [146] SpO2Avg!(totalSpO2 / goodCount)
Q [147] << (INV_AV() and (((ub - lb) = window_size))) >>
by Associativity: (b.c).a = a.b.c
and theorem 364:
Theorem (364) [serial 1613] used for:
  Associativity: (b.c).a = a.b.c [serial 1600]
 


Theorem (366)                               [serial 1515] 
P [145] << AXIOM_K2I() and RUN_AV() and 0 < goodCount >>
S [146] SpO2Avg!(totalSpO2 / goodCount)
Q [147] << RUN_AV() >>
by Substitution of Assertion Labels
and theorem 365:
Theorem (365) [serial 1600] used for:
  substituted Assertions' predicates for  labels  [serial 1515]
 


Theorem (367)                               [serial 1489] 
P [145] << RUN_AV() and ((goodCount > 0)) and AXIOM_K2I() >>
S [146] SpO2Avg!(totalSpO2 / goodCount)
Q [147] << RUN_AV() >>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 366:
Theorem (366) [serial 1515] used for:
    normalization of [serial 1489]
 


Theorem (368)                               [serial 1583] 
P [147] << RUN_AV() >>
S [143] ->
Q [152] << RUN_AV() >>
by Identity (id):  P->P is tautology


Theorem (369)                               [serial 1562] 
P [147] << RUN_AV() >>
S [143] ->
Q [152] << (RUN_AV()) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 368:
Theorem (368) [serial 1583] used for:
    normalization of [serial 1562]
 


Theorem (370)                               [serial 1505] 
P [147] << RUN_AV() >>
S [143] ->
Q [152] << RUN_AV() and true >>
by Law of And-Simplification:  P and true is P
and theorem 369:
Theorem (369) [serial 1562] used for:
  Law of And-Simplification:  P and true is P [serial 1505]
 


Theorem (371)                               [serial 1583] 
P [147] << RUN_AV() >>
S [143] ->
Q [152] << RUN_AV() >>
by Identity (id):  P->P is tautology


Theorem (372)                               [serial 1562] 
P [147] << RUN_AV() >>
S [143] ->
Q [152] << (RUN_AV()) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 371:
Theorem (371) [serial 1583] used for:
    normalization of [serial 1562]
 


Theorem (373)                               [serial 1505] 
P [147] << RUN_AV() >>
S [143] ->
Q [152] << RUN_AV() and true >>
by Law of And-Simplification:  P and true is P
and theorem 372:
Theorem (372) [serial 1562] used for:
  Law of And-Simplification:  P and true is P [serial 1505]
 


Theorem (374)                               [serial 1490] 
P [147] << RUN_AV() >>
S [143] ->
Q [152] << RUN_AV() and AXIOM_LB() >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 373 373:
Theorem (373) [serial 1505] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (373) [serial 1505] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (375)                               [serial 1517] 
P [143] << goodCount <= 0 and RUN_AV() >>
S [143] ->
Q [149] << RUN_AV() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (376)                               [serial 1491] 
P [143] << (RUN_AV()) and ((goodCount <= 0)) >>
S [143] ->
Q [149] << RUN_AV() >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 375:
Theorem (375) [serial 1517] used for:
    normalization of [serial 1491]
 


Theorem (377)                               [serial 1675] 
P [149] << window_size = (ub - lb) and INV_AV() >>
S [149] ->
Q [149] << window_size = (ub - lb) and INV_AV() >>
by Identity (id):  P->P is tautology


Theorem (378)                               [serial 1621] 
P [149] << window_size = (ub - lb) and INV_AV() >>
S [149] skip
Q [149] << window_size = (ub - lb) and INV_AV() >>
by Skip Means Implication:  <<P>> skip <<Q>>  is  <<P>> -> <<Q>> (bl.skip)
and theorem 377:
Theorem (377) [serial 1675] used for:
    <<P>> -> <<Q>>
  for [serial 1621]
 


Theorem (379)                               [serial 1597] 
P [149] << (INV_AV() and (((ub - lb) = window_size))) >>
S [149] skip
Q [149] << (INV_AV() and (((ub - lb) = window_size))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 378:
Theorem (378) [serial 1621] used for:
    normalization of [serial 1597]
 


Theorem (380)                               [serial 1492] 
P [149] << RUN_AV() >>
S [149] skip
Q [149] << RUN_AV() >>
by Substitution of Assertion Labels
and theorem 379:
Theorem (379) [serial 1597] used for:
  substituted Assertions' predicates for  labels  [serial 1492]
 


Theorem (381)                               [serial 1585] 
P [149] << RUN_AV() >>
S [143] ->
Q [152] << RUN_AV() >>
by Identity (id):  P->P is tautology


Theorem (382)                               [serial 1563] 
P [149] << RUN_AV() >>
S [143] ->
Q [152] << (RUN_AV()) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 381:
Theorem (381) [serial 1585] used for:
    normalization of [serial 1563]
 


Theorem (383)                               [serial 1506] 
P [149] << RUN_AV() >>
S [143] ->
Q [152] << RUN_AV() and true >>
by Law of And-Simplification:  P and true is P
and theorem 382:
Theorem (382) [serial 1563] used for:
  Law of And-Simplification:  P and true is P [serial 1506]
 


Theorem (384)                               [serial 1585] 
P [149] << RUN_AV() >>
S [143] ->
Q [152] << RUN_AV() >>
by Identity (id):  P->P is tautology


Theorem (385)                               [serial 1563] 
P [149] << RUN_AV() >>
S [143] ->
Q [152] << (RUN_AV()) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 384:
Theorem (384) [serial 1585] used for:
    normalization of [serial 1563]
 


Theorem (386)                               [serial 1506] 
P [149] << RUN_AV() >>
S [143] ->
Q [152] << RUN_AV() and true >>
by Law of And-Simplification:  P and true is P
and theorem 385:
Theorem (385) [serial 1563] used for:
  Law of And-Simplification:  P and true is P [serial 1506]
 


Theorem (387)                               [serial 1493] 
P [149] << RUN_AV() >>
S [143] ->
Q [152] << RUN_AV() and AXIOM_LB() >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 386 386:
Theorem (386) [serial 1506] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (386) [serial 1506] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (388)                               [serial 1483] 
P [142] << RUN_AV() >>
S [143] if 
((goodCount > 0))~> 
  << RUN_AV() and ((goodCount > 0)) and AXIOM_K2I() >>
  SpO2Avg!(totalSpO2 / goodCount)
  << RUN_AV() >> 
[]
((goodCount <= 0))~> 
  << RUN_AV() >>
  skip
  << RUN_AV() >> 
fi
Q [152] << RUN_AV() and AXIOM_LB() >>
by Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>> (bl.iffi)
and theorems 334 341 367 374 376 380 387:
Theorem (334) [serial 1487] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>>  in if-[]-fi  for [serial 1483]
 
Theorem (341) [serial 1488] used for:
    <<P and B0>> -> <<P0>>  for [serial 1483]
 
Theorem (367) [serial 1489] used for:
    <<P0>> S0 <<Q0>>  for [serial 1483]
 
Theorem (374) [serial 1490] used for:
    <<Q0>> -> <<Q>>  for [serial 1483]
 
Theorem (376) [serial 1491] used for:
    <<P and B1>> -> <<P1>>  for [serial 1483]
 
Theorem (380) [serial 1492] used for:
    <<P1>> S1 <<Q1>>  for [serial 1483]
 
Theorem (387) [serial 1493] used for:
    <<Q1>> -> <<Q>>  for [serial 1483]
 


Theorem (389)                               [serial 1795] 
P [152] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in 1 + lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in 1 + lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and window_size = (ub - lb) and lb < (
1 + lb) >>
S [154] ->
Q [154] << all k~quantity whole
  in 1 + lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (390)                               [serial 1794] 
P [152] << window_size = (ub - lb) and (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in 1 + lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in 1 + lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and lb < (1 + lb) >>
S [154] ->
Q [154] << all k~quantity whole
  in 1 + lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
by Associativity: (b.c).a = a.b.c
and theorem 389:
Theorem (389) [serial 1795] used for:
  Associativity: (b.c).a = a.b.c [serial 1794]
 


Theorem (391)                               [serial 1791] 
P [152] << window_size = (ub - lb) and (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and lb < (1 + lb) >>
S [154] ->
Q [154] << all k~quantity whole
  in 1 + lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
by Contract Universal Quantification Range
and theorem 390:
Theorem (390) [serial 1794] used for:
  Contract Universal Quantification Range [serial 1791]
 


Theorem (392)                               [serial 1789] 
P [152] << window_size = (ub - lb) and (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and lb < (1 + lb) >>
S [154] ->
Q [154] << all k~quantity whole
  in 1 + lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 391:
Theorem (391) [serial 1791] used for:
    normalization of [serial 1789]
 


Theorem (393)                               [serial 1787] 
P [152] << window_size = (ub - lb) and (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and lb < (1 + lb) >>
S [154] ->
Q [154] << all k~quantity whole
  in 1 + lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
by Substitution of Assertion Labels
and theorem 392:
Theorem (392) [serial 1789] used for:
  substituted Assertions' predicates for  labels  [serial 1787]
 


Theorem (394)                               [serial 1785] 
P [152] << window_size = (ub - lb) and (((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and ((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - ub) ))) and (all k~quantity whole
  in lb..(ub - 1) 
  are ((spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub))) )) and 
lb < (1 + lb) >>
S [154] ->
Q [154] << all k~quantity whole
  in 1 + lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 393:
Theorem (393) [serial 1787] used for:
    normalization of [serial 1785]
 


Theorem (395)                               [serial 1783] 
P [152] << window_size = (ub - lb) and (GOOD() and GS() and TOTAL_SPO2() and WINDOW()) and 
lb < (1 + lb) >>
S [154] ->
Q [154] << all k~quantity whole
  in 1 + lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
by Substitution of Assertion Labels
and theorem 394:
Theorem (394) [serial 1785] used for:
  substituted Assertions' predicates for  labels  [serial 1783]
 


Theorem (396)                               [serial 1781] 
P [152] << window_size = (ub - lb) and (WINDOW() and TOTAL_SPO2() and GOOD() and 
GS()) and lb < (1 + lb) >>
S [154] ->
Q [154] << all k~quantity whole
  in 1 + lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 395:
Theorem (395) [serial 1783] used for:
    normalization of [serial 1781]
 


Theorem (397)                               [serial 1641] 
P [152] << window_size = (ub - lb) and INV_AV() and lb < (1 + lb) >>
S [154] ->
Q [154] << all k~quantity whole
  in 1 + lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
by Substitution of Assertion Labels
and theorem 396:
Theorem (396) [serial 1781] used for:
  substituted Assertions' predicates for  labels  [serial 1641]
 


Theorem (398)                               [serial 1614] 
P [152] << INV_AV() and (((ub - lb) = window_size)) and ((lb < (lb + 1))) >>
S [154] ->
Q [154] << all k~quantity whole
  in 1 + lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0))  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 397:
Theorem (397) [serial 1641] used for:
    normalization of [serial 1614]
 


Theorem (399)                               [serial 1601] 
P [152] << ((lb < (lb + 1))) and (INV_AV() and (((ub - lb) = window_size))) >>
S [154] ->
Q [154] << all k~quantity whole
  in 1 + lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0))  >>
by Associativity: (b.c).a = a.b.c
and theorem 398:
Theorem (398) [serial 1614] used for:
  Associativity: (b.c).a = a.b.c [serial 1601]
 


Theorem (400)                               [serial 1520] 
P [152] << AXIOM_LB() and RUN_AV() >>
S [154] ->
Q [154] << all k~quantity whole
  in 1 + lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)  >>
by Substitution of Assertion Labels
and theorem 399:
Theorem (399) [serial 1601] used for:
  substituted Assertions' predicates for  labels  [serial 1520]
 


Theorem (401)                               [serial 1495] 
P [152] << RUN_AV() and AXIOM_LB() >>
S [154] ->
Q [154] << all k~quantity whole
  in (lb + 1)..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub))  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 400:
Theorem (400) [serial 1520] used for:
    normalization of [serial 1495]
 


Theorem (402)                               [serial 1805] 
P [163] << (if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
window_size = (ub - lb) >>
S [163] ->
Q [163] << (if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] and 
totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
window_size = (ub - lb) >>
by Identity (id):  P->P is tautology


Theorem (403)                               [serial 1803] 
REMAINS UNSOLVED!
P [152] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) ) and window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and lb < (1 + lb) >>
S [163] ->
Q [163] << (if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] and 
totalSpO2 = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) and 
window_size = (ub - lb) >>
by  ingenuity of whomever proves this unsolved obligation.
and theorem 402:
Theorem (402) [serial 1805] used for:
  No reason [serial 1803]
 


Theorem (404)                               [serial 1801] 
P [152] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and window_size = (ub - lb) and lb < (
1 + lb) >>
S [163] ->
Q [163] << (if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] and 
totalSpO2 = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) and 
window_size = (ub - lb) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 403:
Theorem (403) [serial 1803] used for:
    normalization of [serial 1801]
 


Theorem (405)                               [serial 1799] 
P [152] << window_size = (ub - lb) and (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and lb < (1 + lb) >>
S [163] ->
Q [163] << (if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] and 
totalSpO2 = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) and 
window_size = (ub - lb) >>
by Associativity: (b.c).a = a.b.c
and theorem 404:
Theorem (404) [serial 1801] used for:
  Associativity: (b.c).a = a.b.c [serial 1799]
 


Theorem (406)                               [serial 1797] 
P [152] << window_size = (ub - lb) and ((all k~quantity whole
  in lb..(ub - 1) 
  are ((spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub))) ) and 
((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - ub) ))) and ((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and lb < (1 + lb) >>
S [163] ->
Q [163] << (if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] and 
totalSpO2 = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) and 
window_size = (ub - lb) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 405:
Theorem (405) [serial 1799] used for:
    normalization of [serial 1797]
 


Theorem (407)                               [serial 1796] 
P [152] << window_size = (ub - lb) and (WINDOW() and TOTAL_SPO2() and GOOD() and 
GS()) and lb < (1 + lb) >>
S [163] ->
Q [163] << (if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] and 
totalSpO2 = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) and 
window_size = (ub - lb) >>
by Substitution of Assertion Labels
and theorem 406:
Theorem (406) [serial 1797] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1796]
 


Theorem (408)                               [serial 1643] 
P [152] << window_size = (ub - lb) and INV_AV() and lb < (1 + lb) >>
S [163] ->
Q [163] << (if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] and 
totalSpO2 = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) and 
window_size = (ub - lb) >>
by Substitution of Assertion Labels
and theorem 407:
Theorem (407) [serial 1796] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1643]
 


Theorem (409)                               [serial 1615] 
P [152] << INV_AV() and (((ub - lb) = window_size)) and ((lb < (lb + 1))) >>
S [163] ->
Q [163] << spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(lb-ub) and 
not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0)) and totalSpO2 = (
((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0)) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) )) and 
window_size = (ub - lb) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 408:
Theorem (408) [serial 1643] used for:
    normalization of [serial 1615]
 


Theorem (410)                               [serial 1602] 
P [152] << ((lb < (lb + 1))) and (INV_AV() and (((ub - lb) = window_size))) >>
S [163] ->
Q [163] << spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(lb-ub) and 
not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0)) and totalSpO2 = (
((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0)) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) )) and 
window_size = (ub - lb) >>
by Associativity: (b.c).a = a.b.c
and theorem 409:
Theorem (409) [serial 1615] used for:
  Associativity: (b.c).a = a.b.c [serial 1602]
 


Theorem (411)                               [serial 1522] 
P [152] << AXIOM_LB() and RUN_AV() >>
S [163] ->
Q [163] << spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] = SSQ(lb - ub) and 
totalSpO2 = (SSQ(lb - ub) + (sum k~quantity whole
  in 1 + lb..ub - 1 
  of SSQ(k - ub) )) and window_size = (ub - lb) >>
by Substitution of Assertion Labels
and theorem 410:
Theorem (410) [serial 1602] used for:
  substituted Assertions' predicates for  labels  [serial 1522]
 


Theorem (412)                               [serial 1496] 
P [152] << RUN_AV() and AXIOM_LB() >>
S [163] ->
Q [163] << ((totalSpO2 = (SSQ(lb - ub) + (sum k~quantity whole
  in (lb + 1)..(ub - 1) 
  of SSQ(k - ub) )))) and ((spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] = SSQ(lb - ub))) and 
(((ub - lb) = window_size)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 411:
Theorem (411) [serial 1522] used for:
    normalization of [serial 1496]
 


Theorem (413)                               [serial 1821] 
P [152] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) ) and window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and lb < (1 + lb) >>
S [170] ->
Q [170] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (414)                               [serial 1815] 
P [152] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) ) and window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and lb < (1 + lb) >>
S [170] ->
Q [170] << goodCount = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0) + 
(numberof k~quantity whole
  in 1 + lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) >>
by Extend Summation: 
if P(ub)=term -> (sum j:integer in lb..ub of P(j))-term = (sum j:integer in lb..ub-1 of P(j))
if P(lb)=term -> (sum j:integer in lb..ub of P(j))-term = (sum j:integer in lb+1..ub of P(j))
and theorem 413:
Theorem (413) [serial 1821] used for:
  Extend Summation: 
if P(ub)=term -> (sum j:integer in lb..ub of P(j))-term = (sum j:integer in lb..ub-1 of P(j))
if P(lb)=term -> (sum j:integer in lb..ub of P(j))-term = (sum j:integer in lb+1..ub of P(j)) [serial 1815]
 


Theorem (415)                               [serial 1822] 
P [173] << goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(lb-ub) and 
not MOTION_ARTIFACT^(lb-ub)) >>
S [170] ->
Q [173] << goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(lb-ub) and 
not MOTION_ARTIFACT^(lb-ub)) >>
by Identity (id):  P->P is tautology


Theorem (416)                               [serial 1819] 
P [152] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) ) and window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and lb < (1 + lb) >>
S [170] ->
Q [173] << goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(lb-ub) and 
not MOTION_ARTIFACT^(lb-ub)) >>
by Member of Universal Quantification: all k:t in l..u are p(k) -> p(l) and p(u)
and theorem 415:
Theorem (415) [serial 1822] used for:
  Member of Universal Quantification: all k:t in l..u are p(k) -> p(l) and p(u) [serial 1819]
 


Theorem (417)                               [serial 1816] 
P [152] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) ) and window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and lb < (1 + lb) >>
S [170] ->
Q [173] << (goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(lb-ub) and 
not MOTION_ARTIFACT^(lb-ub))) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 416:
Theorem (416) [serial 1819] used for:
    normalization of [serial 1816]
 


Theorem (418)                               [serial 1813] 
P [152] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) ) and window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and lb < (1 + lb) >>
S [170] ->
Q [170] << goodCount = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0) + 
(numberof k~quantity whole
  in 1 + lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and (goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub))) >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 414 417:
Theorem (414) [serial 1815] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1813]
 
Theorem (417) [serial 1816] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1813]
 


Theorem (419)                               [serial 1811] 
P [152] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and window_size = (ub - lb) and lb < (
1 + lb) >>
S [170] ->
Q [170] << goodCount = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0) + 
(numberof k~quantity whole
  in 1 + lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and (goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub))) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 418:
Theorem (418) [serial 1813] used for:
    normalization of [serial 1811]
 


Theorem (420)                               [serial 1809] 
P [152] << window_size = (ub - lb) and (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and lb < (1 + lb) >>
S [170] ->
Q [170] << goodCount = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0) + 
(numberof k~quantity whole
  in 1 + lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and (goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub))) >>
by Associativity: (b.c).a = a.b.c
and theorem 419:
Theorem (419) [serial 1811] used for:
  Associativity: (b.c).a = a.b.c [serial 1809]
 


Theorem (421)                               [serial 1807] 
P [152] << window_size = (ub - lb) and ((all k~quantity whole
  in lb..(ub - 1) 
  are ((spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub))) ) and 
((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - ub) ))) and ((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and lb < (1 + lb) >>
S [170] ->
Q [170] << goodCount = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0) + 
(numberof k~quantity whole
  in 1 + lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and (goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub))) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 420:
Theorem (420) [serial 1809] used for:
    normalization of [serial 1807]
 


Theorem (422)                               [serial 1806] 
P [152] << window_size = (ub - lb) and (WINDOW() and TOTAL_SPO2() and GOOD() and 
GS()) and lb < (1 + lb) >>
S [170] ->
Q [170] << goodCount = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0) + 
(numberof k~quantity whole
  in 1 + lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and (goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub))) >>
by Substitution of Assertion Labels
and theorem 421:
Theorem (421) [serial 1807] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1806]
 


Theorem (423)                               [serial 1645] 
P [152] << window_size = (ub - lb) and INV_AV() and lb < (1 + lb) >>
S [170] ->
Q [170] << goodCount = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0) + 
(numberof k~quantity whole
  in 1 + lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and (goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub))) >>
by Substitution of Assertion Labels
and theorem 422:
Theorem (422) [serial 1806] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1645]
 


Theorem (424)                               [serial 1616] 
P [152] << INV_AV() and (((ub - lb) = window_size)) and ((lb < (lb + 1))) >>
S [170] ->
Q [170] << goodCount = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0) + 
(numberof k~quantity whole
  in 1 + lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and (goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub))) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 423:
Theorem (423) [serial 1645] used for:
    normalization of [serial 1616]
 


Theorem (425)                               [serial 1603] 
P [152] << ((lb < (lb + 1))) and (INV_AV() and (((ub - lb) = window_size))) >>
S [170] ->
Q [170] << goodCount = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0) + 
(numberof k~quantity whole
  in 1 + lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and (goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub))) >>
by Associativity: (b.c).a = a.b.c
and theorem 424:
Theorem (424) [serial 1616] used for:
  Associativity: (b.c).a = a.b.c [serial 1603]
 


Theorem (426)                               [serial 1524] 
P [152] << AXIOM_LB() and RUN_AV() >>
S [170] ->
Q [170] << goodCount = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0) + 
(numberof k~quantity whole
  in 1 + lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and (goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub))) >>
by Substitution of Assertion Labels
and theorem 425:
Theorem (425) [serial 1603] used for:
  substituted Assertions' predicates for  labels  [serial 1524]
 


Theorem (427)                               [serial 1497] 
P [152] << RUN_AV() and AXIOM_LB() >>
S [170] ->
Q [170] << ((goodCount = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0) + 
(numberof k~quantity whole
  in (lb + 1)..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )))) and 
((SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub)) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples]) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 426:
Theorem (426) [serial 1524] used for:
    normalization of [serial 1497]
 


Theorem (428)                               [serial 1830] 
P [152] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) ) and window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and lb < (1 + lb) >>
S [182] ->
Q [182] << all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (429)                               [serial 1828] 
P [152] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and window_size = (ub - lb) and lb < (
1 + lb) >>
S [182] ->
Q [182] << all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 428:
Theorem (428) [serial 1830] used for:
    normalization of [serial 1828]
 


Theorem (430)                               [serial 1826] 
P [152] << window_size = (ub - lb) and (goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in lb..ub - 1 
  of SSQ(k - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and lb < (1 + lb) >>
S [182] ->
Q [182] << all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))  >>
by Associativity: (b.c).a = a.b.c
and theorem 429:
Theorem (429) [serial 1828] used for:
  Associativity: (b.c).a = a.b.c [serial 1826]
 


Theorem (431)                               [serial 1824] 
P [152] << window_size = (ub - lb) and ((all k~quantity whole
  in lb..(ub - 1) 
  are ((spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub))) ) and 
((totalSpO2 = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - ub) ))) and ((goodCount = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) and lb < (1 + lb) >>
S [182] ->
Q [182] << all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 430:
Theorem (430) [serial 1826] used for:
    normalization of [serial 1824]
 


Theorem (432)                               [serial 1823] 
P [152] << window_size = (ub - lb) and (WINDOW() and TOTAL_SPO2() and GOOD() and 
GS()) and lb < (1 + lb) >>
S [182] ->
Q [182] << all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))  >>
by Substitution of Assertion Labels
and theorem 431:
Theorem (431) [serial 1824] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1823]
 


Theorem (433)                               [serial 1647] 
P [152] << window_size = (ub - lb) and INV_AV() and lb < (1 + lb) >>
S [182] ->
Q [182] << all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))  >>
by Substitution of Assertion Labels
and theorem 432:
Theorem (432) [serial 1823] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1647]
 


Theorem (434)                               [serial 1617] 
P [152] << INV_AV() and (((ub - lb) = window_size)) and ((lb < (lb + 1))) >>
S [182] ->
Q [182] << (all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 433:
Theorem (433) [serial 1647] used for:
    normalization of [serial 1617]
 


Theorem (435)                               [serial 1604] 
P [152] << ((lb < (lb + 1))) and (INV_AV() and (((ub - lb) = window_size))) >>
S [182] ->
Q [182] << (all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Associativity: (b.c).a = a.b.c
and theorem 434:
Theorem (434) [serial 1617] used for:
  Associativity: (b.c).a = a.b.c [serial 1604]
 


Theorem (436)                               [serial 1526] 
P [152] << AXIOM_LB() and RUN_AV() >>
S [182] ->
Q [182] << GS() >>
by Substitution of Assertion Labels
and theorem 435:
Theorem (435) [serial 1604] used for:
  substituted Assertions' predicates for  labels  [serial 1526]
 


Theorem (437)                               [serial 1498] 
P [152] << RUN_AV() and AXIOM_LB() >>
S [182] ->
Q [182] << GS() >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 436:
Theorem (436) [serial 1526] used for:
    normalization of [serial 1498]
 


Theorem (438)                               [serial 1681] 
P [188] << goodCount = (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in 1 + lb..ub 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in 1 + lb..ub 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in 1 + lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
S [159] ->
Q [188] << goodCount = (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in 1 + lb..ub 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in 1 + lb..ub 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in 1 + lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Identity (id):  P->P is tautology


Theorem (439)                               [serial 1625] 
P [154] << (if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] and 
goodCount = (((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + 
(numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) - (if 
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0)) and 
totalSpO2 = ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) and 
window_size = (ub - lb) and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (all k~quantity whole
  in 1 + lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^0 and 
not MOTION_ARTIFACT^0)) and lb < (1 + lb) >>
S [159] ->
Q [188] << goodCount = (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in 1 + lb..ub 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in 1 + lb..ub 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in 1 + lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
and theorem 438:
Theorem (438) [serial 1681] used for:
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j) [serial 1625]
 


Theorem (440)                               [serial 1605] 
P [154] << goodCount = (((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + 
(numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) - (if 
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0)) and 
spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(0) and 
not MOTION_ARTIFACT^(0) then SPO2^(0) else 0)) and totalSpO2 = (((if SENSOR_CONNECTED^(0) and 
not MOTION_ARTIFACT^(0) then SPO2^(0) else 0)) + (sum k~quantity whole
  in 1 + lb..ub - 1 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) )) and 
window_size = (ub - lb) and ((lb < (lb + 1))) and (all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (all k~quantity whole
  in 1 + lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and (goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0)) >>
S [159] ->
Q [188] << goodCount = (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in 1 + lb..ub 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in 1 + lb..ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and (all k~quantity whole
  in 1 + lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 439:
Theorem (439) [serial 1625] used for:
    normalization of [serial 1605]
 


Theorem (441)                               [serial 1528] 
P [154] << goodCount = (((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + 
(numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) - (if 
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0)) and 
spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x:0) and 
totalSpO2 = (SSQ(x:0) + (sum k~quantity whole
  in 1 + lb..ub - 1 
  of SSQ(k - ub) )) and window_size = (ub - lb) and AXIOM_LB() and GS() and 
(all k~quantity whole
  in 1 + lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^0 and 
not MOTION_ARTIFACT^0)) >>
S [159] ->
Q [188] << goodCount = (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in 1 + lb..ub 
  of SSQ(k - ub) ) and window_size = (ub - lb) and (all k~quantity whole
  in 1 + lb..ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in 1 + lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Substitution of Assertion Labels
and theorem 440:
Theorem (440) [serial 1605] used for:
  substituted Assertions' predicates for  labels  [serial 1528]
 


Theorem (442)                               [serial 1499] 
P [154] << ((all k~quantity whole
  in (lb + 1)..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)) )) and 
(((spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x:0)))) and 
(((totalSpO2 = (SSQ(x:0) + (sum k~quantity whole
  in (lb + 1)..(ub - 1) 
  of SSQ(k - ub) ))))) and ((((ub - lb) = window_size))) and ((goodCount = ((
(if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) - (if 
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0)))) and 
((goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^0 and 
not MOTION_ARTIFACT^0))) and (GS()) and (AXIOM_LB()) >>
S [159] ->
Q [188] << (all k~quantity whole
  in (lb + 1)..ub 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)) ) and 
((totalSpO2 = (sum k~quantity whole
  in (lb + 1)..ub 
  of SSQ(k - ub) ))) and (((ub - lb) = window_size)) and ((goodCount = (numberof k~quantity whole
  in (lb + 1)..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in (lb + 1)..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 441:
Theorem (441) [serial 1528] used for:
    normalization of [serial 1499]
 


Theorem (443)                               [serial 1689] 
P [154] << all k~quantity whole
  in 1 + lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [157] ->
Q [159] << all k~quantity whole
  in 1 + lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
by Identity (id):  P->P is tautology


Theorem (444)                               [serial 1687] 
P [154] << all k~quantity whole
  in 1 + lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [157] ->
Q [159] << ((all k~quantity whole
  in 1 + lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] )) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 443:
Theorem (443) [serial 1689] used for:
    normalization of [serial 1687]
 


Theorem (445)                               [serial 1686] 
P [154] << all k~quantity whole
  in 1 + lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [157] ->
Q [159] << true and (all k~quantity whole
  in 1 + lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
by Law of And-Simplification:  P and true is P
and theorem 444:
Theorem (444) [serial 1687] used for:
  Law of And-Simplification:  P and true is P [serial 1686]
 


Theorem (446)                               [serial 1684] 
P [154] << all k~quantity whole
  in 1 + lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [157] ->
Q [159] << (if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) = (if 
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) and (all k~quantity whole
  in 1 + lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
by Equality Law (idistr):  a=a <-> true
and theorem 445:
Theorem (445) [serial 1686] used for:
  Equality Law (idistr):  a=a <-> true [serial 1684]
 


Theorem (447)                               [serial 1682] 
P [154] << all k~quantity whole
  in 1 + lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [157] ->
Q [159] << (if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) = ((if 
not (MOTION_ARTIFACT)^0 and (SENSOR_CONNECTED)^0 then (SPO2)^0 else 0)) and 
(all k~quantity whole
  in 1 + lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 446:
Theorem (446) [serial 1684] used for:
    normalization of [serial 1682]
 


Theorem (448)                               [serial 1627] 
P [154] << all k~quantity whole
  in 1 + lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]  >>
S [157] spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] := (if not MotionArtifact? and 
SensorConnected? then SpO2? else 0)
Q [159] << (if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) = spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] and 
(all k~quantity whole
  in 1 + lb..ub - 1 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 447:
Theorem (447) [serial 1682] used for:
  applied wp for assignment [serial 1627]
 


Theorem (449)                               [serial 1606] 
P [154] << all k~quantity whole
  in 1 + lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0))  >>
S [157] spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] := (if not MotionArtifact? and 
SensorConnected? then SpO2? else 0)
Q [159] << spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(0) and 
not MOTION_ARTIFACT^(0) then SPO2^(0) else 0)) and (all k~quantity whole
  in 1 + lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 448:
Theorem (448) [serial 1627] used for:
    normalization of [serial 1606]
 


Theorem (450)                               [serial 1530] 
P [154] << all k~quantity whole
  in 1 + lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)  >>
S [157] spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] := (if not MotionArtifact? and 
SensorConnected? then SpO2? else 0)
Q [159] << spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x:0) and 
(all k~quantity whole
  in 1 + lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) >>
by Substitution of Assertion Labels
and theorem 449:
Theorem (449) [serial 1606] used for:
  substituted Assertions' predicates for  labels  [serial 1530]
 


Theorem (451)                               [serial 1500] 
P [154] << all k~quantity whole
  in (lb + 1)..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub))  >>
S [157] spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] := (if SensorConnected? and 
not MotionArtifact? then SpO2? else 0)
Q [159] << (all k~quantity whole
  in (lb + 1)..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)) ) and 
((spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x:0))) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 450:
Theorem (450) [serial 1530] used for:
    normalization of [serial 1500]
 


Theorem (452)                               [serial 1703] 
P [168] << window_size = (ub - lb) and (sum k~quantity whole
  in 1 + lb..ub 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) = ((
(if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + (if 
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]) >>
S [166] ->
Q [168] << window_size = (ub - lb) and (sum k~quantity whole
  in 1 + lb..ub 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) = ((
(if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + (if 
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]) >>
by Identity (id):  P->P is tautology


Theorem (453)                               [serial 1701] 
REMAINS UNSOLVED!
P [163] << (if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] and 
totalSpO2 = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) and 
window_size = (ub - lb) >>
S [166] ->
Q [168] << window_size = (ub - lb) and (((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + 
(if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]) = (
(if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + (sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) >>
by  ingenuity of whomever proves this unsolved obligation.
and theorem 452:
Theorem (452) [serial 1703] used for:
  No reason [serial 1701]
 


Theorem (454)                               [serial 1699] 
P [163] << (if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] and 
totalSpO2 = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) and 
window_size = (ub - lb) >>
S [166] ->
Q [168] << window_size = (ub - lb) and (((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) + 
(if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0)) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]) = (
(if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + (sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 453:
Theorem (453) [serial 1701] used for:
    normalization of [serial 1699]
 


Theorem (455)                               [serial 1697] 
P [163] << (if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] and 
totalSpO2 = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) and 
window_size = (ub - lb) >>
S [166] ->
Q [168] << window_size = (ub - lb) and (((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + 
((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ))) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]) = (
(if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + (sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) >>
by Associativity: (b.c).a = a.b.c
and theorem 454:
Theorem (454) [serial 1699] used for:
  Associativity: (b.c).a = a.b.c [serial 1697]
 


Theorem (456)                               [serial 1695] 
P [163] << (if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] and 
totalSpO2 = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) and 
window_size = (ub - lb) >>
S [166] ->
Q [168] << window_size = (ub - lb) and (((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + 
(((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )))) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]) = (
(if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + (sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 455:
Theorem (455) [serial 1697] used for:
    normalization of [serial 1695]
 


Theorem (457)                               [serial 1693] 
P [163] << (if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] and 
totalSpO2 = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) and 
window_size = (ub - lb) >>
S [166] ->
Q [168] << window_size = (ub - lb) and (((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + 
totalSpO2) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]) = (
(if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + (sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) >>
by Guided Substitution of Equals
and theorem 456:
Theorem (456) [serial 1695] used for:
  Guided Substitution of Equals
 replacing "totalSpO2" with its = "(((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )))" in its postcondition [serial 1693]
 


Theorem (458)                               [serial 1691] 
P [163] << (if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] and 
totalSpO2 = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) and 
window_size = (ub - lb) >>
S [166] ->
Q [168] << (((if not (MOTION_ARTIFACT)^0 and (SENSOR_CONNECTED)^0 then (SPO2)^0 else 0) + 
totalSpO2) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]) = (
(if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + (sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) and 
window_size = (ub - lb) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 457:
Theorem (457) [serial 1693] used for:
    normalization of [serial 1691]
 


Theorem (459)                               [serial 1629] 
P [163] << (if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) = spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] and 
totalSpO2 = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) and 
window_size = (ub - lb) >>
S [166] totalSpO2 := ((if not MotionArtifact? and SensorConnected? then SpO2? else 0) + 
totalSpO2) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
Q [168] << totalSpO2 = ((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then SPO2^0 else 0) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) )) and 
window_size = (ub - lb) >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 458:
Theorem (458) [serial 1691] used for:
  applied wp for assignment [serial 1629]
 


Theorem (460)                               [serial 1607] 
P [163] << spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(lb-ub) and 
not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0)) and totalSpO2 = (
((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then SPO2^(lb-ub) else 0)) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) )) and 
window_size = (ub - lb) >>
S [166] totalSpO2 := ((if not MotionArtifact? and SensorConnected? then SpO2? else 0) + 
totalSpO2) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
Q [168] << totalSpO2 = (((if SENSOR_CONNECTED^(0) and not MOTION_ARTIFACT^(0) then SPO2^(0) else 0)) + 
(sum k~quantity whole
  in 1 + lb..ub - 1 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) )) and 
window_size = (ub - lb) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 459:
Theorem (459) [serial 1629] used for:
    normalization of [serial 1607]
 


Theorem (461)                               [serial 1532] 
P [163] << spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] = SSQ(lb - ub) and 
totalSpO2 = (SSQ(lb - ub) + (sum k~quantity whole
  in 1 + lb..ub - 1 
  of SSQ(k - ub) )) and window_size = (ub - lb) >>
S [166] totalSpO2 := ((if not MotionArtifact? and SensorConnected? then SpO2? else 0) + 
totalSpO2) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
Q [168] << totalSpO2 = (SSQ(x:0) + (sum k~quantity whole
  in 1 + lb..ub - 1 
  of SSQ(k - ub) )) and window_size = (ub - lb) >>
by Substitution of Assertion Labels
and theorem 460:
Theorem (460) [serial 1607] used for:
  substituted Assertions' predicates for  labels  [serial 1532]
 


Theorem (462)                               [serial 1501] 
P [163] << ((totalSpO2 = (SSQ(lb - ub) + (sum k~quantity whole
  in (lb + 1)..(ub - 1) 
  of SSQ(k - ub) )))) and ((spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] = SSQ(lb - ub))) and 
(((ub - lb) = window_size)) >>
S [166] totalSpO2 := (totalSpO2 + (if SensorConnected? and not MotionArtifact? then SpO2? else 0)) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
Q [168] << ((totalSpO2 = (SSQ(x:0) + (sum k~quantity whole
  in (lb + 1)..(ub - 1) 
  of SSQ(k - ub) )))) and (((ub - lb) = window_size)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 461:
Theorem (461) [serial 1532] used for:
    normalization of [serial 1501]
 


Theorem (463)                               [serial 1674] 
P [170] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and (goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub))) >>
S [175] ->
Q [177] << true >>
by True Conclusion Schema (tc): P->true


Theorem (464)                               [serial 1673] 
P [170] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and (goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub))) >>
S [175] ->
Q [177] << (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) = (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) >>
by Equality Law (idistr):  a=a <-> true
and theorem 463:
Theorem (463) [serial 1674] used for:
  Equality Law (idistr):  a=a <-> true [serial 1673]
 


Theorem (465)                               [serial 1672] 
P [170] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and (goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub))) >>
S [175] ->
Q [177] << (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) = ((numberof k~quantity whole
  in lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) - (if 
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0)) >>
by Contract Summation
and theorem 464:
Theorem (464) [serial 1673] used for:
  Contract Summation [serial 1672]
 


Theorem (466)                               [serial 1671] 
P [170] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and (goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub))) >>
S [175] ->
Q [177] << (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) = ((numberof k~quantity whole
  in lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] then 1 else 0)) >>
by Substitution of Equivalents:
  <<...P[a|b] and (a iff b)>> S <<Q>>
  ----------------------
   <<...P and (a iff b)>> S <<Q>>
and theorem 465:
Theorem (465) [serial 1672] used for:
  Substitution of Equivalents:
  <<...P[a|b] and (a iff b)>> S <<Q>>
  ----------------------
   <<...P and (a iff b)>> S <<Q>>
 replacing "
^{goodSamp 
 ^{/ lb 
  ^{# 
   ^{:: PulseOx_Properties Max_Window_Samples}}}}"
 with its iff"
 ((SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub)))" [serial 1671]
 


Theorem (467)                               [serial 1670] 
P [170] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and (goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub))) >>
S [175] ->
Q [177] << ((numberof k~quantity whole
  in lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) - (if 
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0)) = ((
(if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] then 1 else 0)) >>
by Extend Summation: 
if P(ub)=term -> (sum j:integer in lb..ub of P(j))-term = (sum j:integer in lb..ub-1 of P(j))
if P(lb)=term -> (sum j:integer in lb..ub of P(j))-term = (sum j:integer in lb+1..ub of P(j))
and theorem 466:
Theorem (466) [serial 1671] used for:
  Extend Summation: 
if P(ub)=term -> (sum j:integer in lb..ub of P(j))-term = (sum j:integer in lb..ub-1 of P(j))
if P(lb)=term -> (sum j:integer in lb..ub of P(j))-term = (sum j:integer in lb+1..ub of P(j)) [serial 1670]
 


Theorem (468)                               [serial 1669] 
P [170] << goodCount = (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and (goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub))) >>
S [175] ->
Q [177] << ((numberof k~quantity whole
  in lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) - (if 
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0)) = ((
(if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + goodCount) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] then 1 else 0)) >>
by Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
and theorem 467:
Theorem (467) [serial 1670] used for:
  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
 replacing "goodCount"
 with its ="
 ((numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))" [serial 1669]
 


Theorem (469)                               [serial 1667] 
P [170] << goodCount = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0) + 
(numberof k~quantity whole
  in 1 + lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and (goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub))) >>
S [175] ->
Q [177] << (((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + goodCount) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] then 1 else 0)) = ((
(if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) - (if 
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0)) >>
by Extend Summation: 
if P(ub)=term -> (sum j:integer in lb..ub of P(j))-term = (sum j:integer in lb..ub-1 of P(j))
if P(lb)=term -> (sum j:integer in lb..ub of P(j))-term = (sum j:integer in lb+1..ub of P(j))
and theorem 468:
Theorem (468) [serial 1669] used for:
  Extend Summation: 
if P(ub)=term -> (sum j:integer in lb..ub of P(j))-term = (sum j:integer in lb..ub-1 of P(j))
if P(lb)=term -> (sum j:integer in lb..ub of P(j))-term = (sum j:integer in lb+1..ub of P(j)) [serial 1667]
 


Theorem (470)                               [serial 1665] 
P [170] << goodCount = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0) + 
(numberof k~quantity whole
  in 1 + lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and (goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub))) >>
S [175] ->
Q [177] << (((if not (MOTION_ARTIFACT)^0 and (SENSOR_CONNECTED)^0 then 1 else 0) + 
goodCount) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] then 1 else 0)) = ((
(if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) - (if 
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 469:
Theorem (469) [serial 1667] used for:
    normalization of [serial 1665]
 


Theorem (471)                               [serial 1534] 
P [170] << goodCount = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0) + 
(numberof k~quantity whole
  in 1 + lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) and (goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub))) >>
S [175] goodCount := ((if not MotionArtifact? and SensorConnected? then 1 else 0) + 
goodCount) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] then 1 else 0)
Q [177] << goodCount = (((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + 
(numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) - (if 
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0)) >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 470:
Theorem (470) [serial 1665] used for:
  applied wp for assignment [serial 1534]
 


Theorem (472)                               [serial 1502] 
P [170] << ((goodCount = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0) + 
(numberof k~quantity whole
  in (lb + 1)..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )))) and 
((SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub)) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples]) >>
S [175] goodCount := (goodCount + (if (SensorConnected? and not MotionArtifact?) then 1 else 0)) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] then 1 else 0)
Q [177] << (goodCount = (((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + 
(numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) - (if 
SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0))) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 471:
Theorem (471) [serial 1534] used for:
    normalization of [serial 1502]
 


Theorem (473)                               [serial 1714] 
P [182] << all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))  >>
S [183] ->
Q [185] << all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))  >>
by Identity (id):  P->P is tautology


Theorem (474)                               [serial 1712] 
P [182] << all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))  >>
S [183] ->
Q [185] << ((all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 473:
Theorem (473) [serial 1714] used for:
    normalization of [serial 1712]
 


Theorem (475)                               [serial 1710] 
P [182] << all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))  >>
S [183] ->
Q [185] << true and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Law of And-Simplification:  P and true is P
and theorem 474:
Theorem (474) [serial 1712] used for:
  Law of And-Simplification:  P and true is P [serial 1710]
 


Theorem (476)                               [serial 1708] 
P [182] << all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))  >>
S [183] ->
Q [185] << (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (true) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 475:
Theorem (475) [serial 1710] used for:
    normalization of [serial 1708]
 


Theorem (477)                               [serial 1706] 
P [182] << all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))  >>
S [183] ->
Q [185] << (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and ((SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0) iff (
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0)) >>
by Equality Law (idistr):  a=a <-> true
and theorem 476:
Theorem (476) [serial 1708] used for:
  Equality Law (idistr):  a=a <-> true [serial 1706]
 


Theorem (478)                               [serial 1704] 
P [182] << all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))  >>
S [183] ->
Q [185] << (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (((not (MOTION_ARTIFACT)^0 and (SENSOR_CONNECTED)^0)) iff (
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0)) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 477:
Theorem (477) [serial 1706] used for:
    normalization of [serial 1704]
 


Theorem (479)                               [serial 1631] 
P [182] << all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))  >>
S [183] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := (not MotionArtifact? and 
SensorConnected?)
Q [185] << (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0)) >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 478:
Theorem (478) [serial 1704] used for:
  applied wp for assignment [serial 1631]
 


Theorem (480)                               [serial 1609] 
P [182] << (all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
S [183] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := (not MotionArtifact? and 
SensorConnected?)
Q [185] << (all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0)) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 479:
Theorem (479) [serial 1631] used for:
    normalization of [serial 1609]
 


Theorem (481)                               [serial 1568] 
P [182] << GS() >>
S [183] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := (not MotionArtifact? and 
SensorConnected?)
Q [185] << GS() and (goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0)) >>
by Substitution of Assertion Labels
and theorem 480:
Theorem (480) [serial 1609] used for:
  substituted Assertions' predicates for  labels  [serial 1568]
 


Theorem (482)                               [serial 1544] 
P [182] << GS() >>
S [183] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := (not MotionArtifact? and 
SensorConnected?)
Q [185] << GS() and true and (goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0)) >>
by Law of And-Simplification:  P and true is P
and theorem 481:
Theorem (481) [serial 1568] used for:
  Law of And-Simplification:  P and true is P [serial 1544]
 


Theorem (483)                               [serial 1507] 
P [182] << GS() >>
S [183] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := (SensorConnected? and 
not MotionArtifact?)
Q [185] << (goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^0 and 
not MOTION_ARTIFACT^0)) and GS() and true >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 482:
Theorem (482) [serial 1544] used for:
    normalization of [serial 1507]
 


Theorem (484)                               [serial 1714] 
P [182] << all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))  >>
S [183] ->
Q [185] << all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))  >>
by Identity (id):  P->P is tautology


Theorem (485)                               [serial 1712] 
P [182] << all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))  >>
S [183] ->
Q [185] << ((all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) )) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 484:
Theorem (484) [serial 1714] used for:
    normalization of [serial 1712]
 


Theorem (486)                               [serial 1710] 
P [182] << all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))  >>
S [183] ->
Q [185] << true and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Law of And-Simplification:  P and true is P
and theorem 485:
Theorem (485) [serial 1712] used for:
  Law of And-Simplification:  P and true is P [serial 1710]
 


Theorem (487)                               [serial 1708] 
P [182] << all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))  >>
S [183] ->
Q [185] << (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (true) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 486:
Theorem (486) [serial 1710] used for:
    normalization of [serial 1708]
 


Theorem (488)                               [serial 1706] 
P [182] << all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))  >>
S [183] ->
Q [185] << (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and ((SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0) iff (
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0)) >>
by Equality Law (idistr):  a=a <-> true
and theorem 487:
Theorem (487) [serial 1708] used for:
  Equality Law (idistr):  a=a <-> true [serial 1706]
 


Theorem (489)                               [serial 1704] 
P [182] << all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))  >>
S [183] ->
Q [185] << (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (((not (MOTION_ARTIFACT)^0 and (SENSOR_CONNECTED)^0)) iff (
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0)) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 488:
Theorem (488) [serial 1706] used for:
    normalization of [serial 1704]
 


Theorem (490)                               [serial 1631] 
P [182] << all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub))  >>
S [183] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := (not MotionArtifact? and 
SensorConnected?)
Q [185] << (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0)) >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 489:
Theorem (489) [serial 1704] used for:
  applied wp for assignment [serial 1631]
 


Theorem (491)                               [serial 1609] 
P [182] << (all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
S [183] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := (not MotionArtifact? and 
SensorConnected?)
Q [185] << (all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) and (goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0)) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 490:
Theorem (490) [serial 1631] used for:
    normalization of [serial 1609]
 


Theorem (492)                               [serial 1568] 
P [182] << GS() >>
S [183] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := (not MotionArtifact? and 
SensorConnected?)
Q [185] << GS() and (goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0)) >>
by Substitution of Assertion Labels
and theorem 491:
Theorem (491) [serial 1609] used for:
  substituted Assertions' predicates for  labels  [serial 1568]
 


Theorem (493)                               [serial 1544] 
P [182] << GS() >>
S [183] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := (not MotionArtifact? and 
SensorConnected?)
Q [185] << GS() and true and (goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (
SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0)) >>
by Law of And-Simplification:  P and true is P
and theorem 492:
Theorem (492) [serial 1568] used for:
  Law of And-Simplification:  P and true is P [serial 1544]
 


Theorem (494)                               [serial 1507] 
P [182] << GS() >>
S [183] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := (SensorConnected? and 
not MotionArtifact?)
Q [185] << (goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^0 and 
not MOTION_ARTIFACT^0)) and GS() and true >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 493:
Theorem (493) [serial 1544] used for:
    normalization of [serial 1507]
 


Theorem (495)                               [serial 1503] 
P [182] << GS() >>
S [183] goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := (SensorConnected? and 
not MotionArtifact?)
Q [185] << (goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^0 and 
not MOTION_ARTIFACT^0)) and GS() and AXIOM_LB() >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 494 494:
Theorem (494) [serial 1507] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (494) [serial 1507] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (496)                               [serial 1494] 
P [152] << RUN_AV() and AXIOM_LB() >>
S [154] << all k~quantity whole
  in (lb + 1)..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub))  >>
spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] := (if SensorConnected? and not MotionArtifact? then SpO2? else 0)
<< (all k~quantity whole
  in (lb + 1)..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)) ) and ((spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x:0))) >>
&
<< ((totalSpO2 = (SSQ(lb - ub) + (sum k~quantity whole
  in (lb + 1)..(ub - 1) 
  of SSQ(k - ub) )))) and ((spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] = SSQ(lb - ub))) and (((ub - lb) = window_size)) >>
totalSpO2 := (totalSpO2 + (if SensorConnected? and not MotionArtifact? then SpO2? else 0)) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
<< ((totalSpO2 = (SSQ(x:0) + (sum k~quantity whole
  in (lb + 1)..(ub - 1) 
  of SSQ(k - ub) )))) and (((ub - lb) = window_size)) >>
&
<< ((goodCount = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0) + (numberof k~quantity whole
  in (lb + 1)..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )))) and ((SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub)) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples]) >>
goodCount := (goodCount + (if (SensorConnected? and not MotionArtifact?) then 1 else 0)) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] then 1 else 0)
<< (goodCount = (((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) - (if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0))) >>
&
<< GS() >>
goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := (SensorConnected? and not MotionArtifact?)
<< (goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0)) and GS() and AXIOM_LB() >>
Q [188] << (all k~quantity whole
  in (lb + 1)..ub 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)) ) and 
((totalSpO2 = (sum k~quantity whole
  in (lb + 1)..ub 
  of SSQ(k - ub) ))) and (((ub - lb) = window_size)) and ((goodCount = (numberof k~quantity whole
  in (lb + 1)..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in (lb + 1)..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>> (bl.cck)
and theorems 401 412 427 437 442 451 462 472 495:
Theorem (401) [serial 1495] used for:
  P -> P1 in concurrent composition for [serial 1494]
 
Theorem (412) [serial 1496] used for:
  P -> P2 in concurrent composition for [serial 1494]
 
Theorem (427) [serial 1497] used for:
  P -> P3 in concurrent composition for [serial 1494]
 
Theorem (437) [serial 1498] used for:
  P -> P4 in concurrent composition for [serial 1494]
 
Theorem (442) [serial 1499] used for:
  Q1 and Q2 and  . . . and Qn -> Q in concurrent composition for [serial 1494]
 
Theorem (451) [serial 1500] used for:
  <<P1>> S1 <<Q1>> in concurrent composition for [serial 1494]
 
Theorem (462) [serial 1501] used for:
  <<P2>> S2 <<Q2>> in concurrent composition for [serial 1494]
 
Theorem (472) [serial 1502] used for:
  <<P3>> S3 <<Q3>> in concurrent composition for [serial 1494]
 
Theorem (495) [serial 1503] used for:
  <<P4>> S4 <<Q4>> in concurrent composition for [serial 1494]
 


Theorem (497)                               [serial 1484] 
P [152] << RUN_AV() and AXIOM_LB() >>
S [153] {
<< all k~quantity whole
  in (lb + 1)..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub))  >>
spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] := (if SensorConnected? and not MotionArtifact? then SpO2? else 0)
<< (all k~quantity whole
  in (lb + 1)..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)) ) and ((spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x:0))) >>
&
<< ((totalSpO2 = (SSQ(lb - ub) + (sum k~quantity whole
  in (lb + 1)..(ub - 1) 
  of SSQ(k - ub) )))) and ((spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] = SSQ(lb - ub))) and (((ub - lb) = window_size)) >>
totalSpO2 := (totalSpO2 + (if SensorConnected? and not MotionArtifact? then SpO2? else 0)) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
<< ((totalSpO2 = (SSQ(x:0) + (sum k~quantity whole
  in (lb + 1)..(ub - 1) 
  of SSQ(k - ub) )))) and (((ub - lb) = window_size)) >>
&
<< ((goodCount = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0) + (numberof k~quantity whole
  in (lb + 1)..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )))) and ((SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub)) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples]) >>
goodCount := (goodCount + (if (SensorConnected? and not MotionArtifact?) then 1 else 0)) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] then 1 else 0)
<< (goodCount = (((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) - (if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0))) >>
&
<< GS() >>
goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := (SensorConnected? and not MotionArtifact?)
<< (goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0)) and GS() and AXIOM_LB() >>
} 
Q [188] << (all k~quantity whole
  in (lb + 1)..ub 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)) ) and 
((totalSpO2 = (sum k~quantity whole
  in (lb + 1)..ub 
  of SSQ(k - ub) ))) and (((ub - lb) = window_size)) and ((goodCount = (numberof k~quantity whole
  in (lb + 1)..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in (lb + 1)..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Introduction of Existential Quantification (bl.elq)
and theorem 496:
Theorem (496) [serial 1494] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1484]
 


Theorem (498)                               [serial 1726] 
P [188] << goodCount = (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in 1 + lb..ub 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in 1 + lb..ub 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in 1 + lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
S [197] ->
Q [198] << goodCount = (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in 1 + lb..ub 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in 1 + lb..ub 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in 1 + lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Identity (id):  P->P is tautology


Theorem (499)                               [serial 1723] 
P [188] << goodCount = (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in 1 + lb..ub 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in 1 + lb..ub 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in 1 + lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
S [197] ->
Q [198] << goodCount = (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^((k)-(ub)) and not MOTION_ARTIFACT^((k)-(ub))) ) and 
totalSpO2 = (sum k~quantity whole
  in 1 + lb..ub 
  of (if SENSOR_CONNECTED^((k)-(ub)) and not MOTION_ARTIFACT^((k)-(ub)) then SPO2^((k)-(ub)) else 0) ) and 
window_size = ((ub) - (lb)) and (all k~quantity whole
  in 1 + lb..ub 
  are (if SENSOR_CONNECTED^((k)-(ub)) and not MOTION_ARTIFACT^((k)-(ub)) then SPO2^((k)-(ub)) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in 1 + lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((k)-(ub)) and 
      not MOTION_ARTIFACT^((k)-(ub))) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 498:
Theorem (498) [serial 1726] used for:
    normalization of [serial 1723]
 


Theorem (500)                               [serial 1718] 
P [188] << goodCount = (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in 1 + lb..ub 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in 1 + lb..ub 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in 1 + lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
S [197] ->
Q [198] << goodCount = (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^((1+k)-(1+ub)) and not MOTION_ARTIFACT^((1+k)-(1+ub))) ) and 
totalSpO2 = (sum k~quantity whole
  in 1 + lb..ub 
  of (if SENSOR_CONNECTED^((1+k)-(1+ub)) and not MOTION_ARTIFACT^((1+k)-(1+ub)) then SPO2^((1+k)-(1+ub)) else 0) ) and 
window_size = ((1 + ub) - (1 + lb)) and (all k~quantity whole
  in 1 + lb..ub 
  are (if SENSOR_CONNECTED^((1+k)-(1+ub)) and not MOTION_ARTIFACT^((1+k)-(1+ub)) then SPO2^((1+k)-(1+ub)) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in 1 + lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-(1+ub)) and 
      not MOTION_ARTIFACT^((1+k)-(1+ub))) ) >>
by Add both sides of subtraction:  a-b is (x+a)-(x+b)
and theorem 499:
Theorem (499) [serial 1723] used for:
  Add both sides of subtraction:  a-b is (x+a)-(x+b) [serial 1718]
 


Theorem (501)                               [serial 1728] 
P [188] << goodCount = (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in 1 + lb..ub 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in 1 + lb..ub 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in 1 + lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
S [197] ->
Q [198] << goodCount = (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in 1 + lb..ub 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in 1 + lb..ub 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in 1 + lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
by Identity (id):  P->P is tautology


Theorem (502)                               [serial 1724] 
P [188] << goodCount = (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in 1 + lb..ub 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in 1 + lb..ub 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in 1 + lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
S [197] ->
Q [198] << goodCount = (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^((k)-(ub)) and not MOTION_ARTIFACT^((k)-(ub))) ) and 
totalSpO2 = (sum k~quantity whole
  in 1 + lb..ub 
  of (if SENSOR_CONNECTED^((k)-(ub)) and not MOTION_ARTIFACT^((k)-(ub)) then SPO2^((k)-(ub)) else 0) ) and 
window_size = ((ub) - (lb)) and (all k~quantity whole
  in 1 + lb..ub 
  are (if SENSOR_CONNECTED^((k)-(ub)) and not MOTION_ARTIFACT^((k)-(ub)) then SPO2^((k)-(ub)) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in 1 + lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((k)-(ub)) and 
      not MOTION_ARTIFACT^((k)-(ub))) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 501:
Theorem (501) [serial 1728] used for:
    normalization of [serial 1724]
 


Theorem (503)                               [serial 1720] 
P [188] << goodCount = (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in 1 + lb..ub 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in 1 + lb..ub 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in 1 + lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
S [197] ->
Q [198] << goodCount = (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^((1+k)-(1+ub)) and not MOTION_ARTIFACT^((1+k)-(1+ub))) ) and 
totalSpO2 = (sum k~quantity whole
  in 1 + lb..ub 
  of (if SENSOR_CONNECTED^((1+k)-(1+ub)) and not MOTION_ARTIFACT^((1+k)-(1+ub)) then SPO2^((1+k)-(1+ub)) else 0) ) and 
window_size = ((1 + ub) - (1 + lb)) and (all k~quantity whole
  in 1 + lb..ub 
  are (if SENSOR_CONNECTED^((1+k)-(1+ub)) and not MOTION_ARTIFACT^((1+k)-(1+ub)) then SPO2^((1+k)-(1+ub)) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in 1 + lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-(1+ub)) and 
      not MOTION_ARTIFACT^((1+k)-(1+ub))) ) >>
by Add both sides of subtraction:  a-b is (x+a)-(x+b)
and theorem 502:
Theorem (502) [serial 1724] used for:
  Add both sides of subtraction:  a-b is (x+a)-(x+b) [serial 1720]
 


Theorem (504)                               [serial 1716] 
P [188] << goodCount = (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in 1 + lb..ub 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in 1 + lb..ub 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in 1 + lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
S [197] ->
Q [198] << (numberof k~quantity whole
  in ((1 + lb))..((1 + ub)) - 1 
  that (SENSOR_CONNECTED^((1+k)-((1+ub))) and not MOTION_ARTIFACT^((1+k)-((1+ub)))) ) = goodCount and 
(sum k~quantity whole
  in ((1 + lb))..((1 + ub)) - 1 
  of (if SENSOR_CONNECTED^((1+k)-((1+ub))) and not MOTION_ARTIFACT^((1+k)-((1+ub))) then SPO2^((1+k)-((1+ub))) else 0) ) = totalSpO2 and 
(((1 + ub)) - ((1 + lb))) = window_size and (all k~quantity whole
  in ((1 + lb))..((1 + ub)) - 1 
  are (if SENSOR_CONNECTED^((1+k)-((1+ub))) and not MOTION_ARTIFACT^((1+k)-((1+ub))) then SPO2^((1+k)-((1+ub))) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in ((1 + lb))..((1 + ub)) - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-((1+ub))) and 
      not MOTION_ARTIFACT^((1+k)-((1+ub)))) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Subtaction of Added Value:  (a+b)-a is b
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorems 500 503:
Theorem (500) [serial 1718] used for:
    normalization of [serial 1716]
 
Theorem (503) [serial 1720] used for:
    normalization of [serial 1716]
 


Theorem (505)                               [serial 1633] 
P [188] << goodCount = (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in 1 + lb..ub 
  of (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in 1 + lb..ub 
  are (if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in 1 + lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
S [197] |ub,lb,window_size',totalSpO2',goodCount' := 1 + ub,1 + lb,window_size,totalSpO2,goodCount|  
Q [198] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) = totalSpO2' and 
(ub - lb) = window_size' and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
by Simultaneous Assignment
and theorem 504:
Theorem (504) [serial 1716] used for:
  applied wp for simultaneous assignment [serial 1633]
 


Theorem (506)                               [serial 1610] 
P [188] << goodCount = (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in 1 + lb..ub 
  of ((if SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and 
window_size = (ub - lb) and (all k~quantity whole
  in 1 + lb..ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub) then SPO2^(k-ub) else 0)) ) and (all k~quantity whole
  in 1 + lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
S [197] |ub,lb,window_size',totalSpO2',goodCount' := 1 + ub,1 + lb,window_size,totalSpO2,goodCount|  
Q [198] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of ((if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0)) ) = totalSpO2' and 
(ub - lb) = window_size' and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0)) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 505:
Theorem (505) [serial 1633] used for:
    normalization of [serial 1610]
 


Theorem (507)                               [serial 1588] 
P [188] << goodCount = (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in 1 + lb..ub 
  of SSQ(k - ub) ) and window_size = (ub - lb) and (all k~quantity whole
  in 1 + lb..ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in 1 + lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
S [197] |ub,lb,window_size',totalSpO2',goodCount' := 1 + ub,1 + lb,window_size,totalSpO2,goodCount|  
Q [198] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of SSQ((1 + k) - ub) ) = totalSpO2' and (ub - lb) = window_size' and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ((1 + 
      k) - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
by Substitution of Assertion Labels
and theorem 506:
Theorem (506) [serial 1610] used for:
  substituted Assertions' predicates for  labels  [serial 1588]
 


Theorem (508)                               [serial 1565] 
P [188] << goodCount = (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in 1 + lb..ub 
  of SSQ(k - ub) ) and window_size = (ub - lb) and (all k~quantity whole
  in 1 + lb..ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in 1 + lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
S [197] |ub,lb,window_size',totalSpO2',goodCount' := 1 + ub,1 + lb,window_size,totalSpO2,goodCount|  
Q [198] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of SSQ((1 + k) - ub) ) = totalSpO2' and ((ub) - (lb)) = window_size' and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ((1 + 
      k) - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 507:
Theorem (507) [serial 1588] used for:
    normalization of [serial 1565]
 


Theorem (509)                               [serial 1536] 
P [188] << goodCount = (numberof k~quantity whole
  in 1 + lb..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) and totalSpO2 = (sum k~quantity whole
  in 1 + lb..ub 
  of SSQ(k - ub) ) and window_size = (ub - lb) and (all k~quantity whole
  in 1 + lb..ub 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub) ) and 
(all k~quantity whole
  in 1 + lb..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
S [197] |ub,lb,window_size',totalSpO2',goodCount' := 1 + ub,1 + lb,window_size,totalSpO2,goodCount|  
Q [198] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of SSQ((1 + k) - ub) ) = totalSpO2' and ((1 + ub) - (1 + lb)) = window_size' and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ((1 + 
      k) - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
by Add both sides of subtraction:  a-b is (x+a)-(x+b)
and theorem 508:
Theorem (508) [serial 1565] used for:
  Add both sides of subtraction:  a-b is (x+a)-(x+b) [serial 1536]
 


Theorem (510)                               [serial 1485] 
P [188] << (all k~quantity whole
  in (lb + 1)..ub 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)) ) and 
((totalSpO2 = (sum k~quantity whole
  in (lb + 1)..ub 
  of SSQ(k - ub) ))) and (((ub - lb) = window_size)) and ((goodCount = (numberof k~quantity whole
  in (lb + 1)..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and 
(all k~quantity whole
  in (lb + 1)..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and 
      not MOTION_ARTIFACT^(k-ub)) ) >>
S [197] |ub,lb,window_size',totalSpO2',goodCount' := ub + 1,lb + 1,window_size,totalSpO2,goodCount|  
Q [198] << (all k~quantity whole
  in lb..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - (ub - 1))) ) and 
((totalSpO2' = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - (ub - 1)) ))) and ((((ub - 1) - (lb - 1)) = window_size')) and 
((goodCount' = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-(ub-1)) and not MOTION_ARTIFACT^(k-(ub-1))) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-(ub-1)) and 
      not MOTION_ARTIFACT^(k-(ub-1))) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Associativity: (b.c).a = a.b.c
and theorem 509:
Theorem (509) [serial 1536] used for:
    normalization of [serial 1485]
 


Theorem (511)                               [serial 1733] 
P [198] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) = totalSpO2' and 
(ub - lb) = window_size' and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [208] ->
Q [209] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) = totalSpO2' and 
(ub - lb) = window_size' and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
by Identity (id):  P->P is tautology


Theorem (512)                               [serial 1735] 
P [198] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) = totalSpO2' and 
(ub - lb) = window_size' and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [208] ->
Q [209] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) = totalSpO2' and 
(ub - lb) = window_size' and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
by Identity (id):  P->P is tautology


Theorem (513)                               [serial 1731] 
P [198] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) = totalSpO2' and 
(ub - lb) = window_size' and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [208] ->
Q [209] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) = totalSpO2' and 
((ub) - (lb)) = window_size' and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) iff goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorems 511 512:
Theorem (511) [serial 1733] used for:
    normalization of [serial 1731]
 
Theorem (512) [serial 1735] used for:
    normalization of [serial 1731]
 


Theorem (514)                               [serial 1635] 
P [198] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) = totalSpO2' and 
(ub - lb) = window_size' and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [208] |spo2_hist',goodSamp',ub',lb' := spo2_hist,goodSamp,ub,lb|  
Q [209] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) ) = totalSpO2' and 
((ub') - (lb')) = window_size' and (all k~quantity whole
  in lb..ub - 1 
  are (if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) iff \'goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
by Simultaneous Assignment
and theorem 513:
Theorem (513) [serial 1731] used for:
  applied wp for simultaneous assignment [serial 1635]
 


Theorem (515)                               [serial 1611] 
P [198] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of ((if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0)) ) = totalSpO2' and 
(ub - lb) = window_size' and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = ((if SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0)) ) and 
(all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [208] |spo2_hist',goodSamp',ub',lb' := spo2_hist,goodSamp,ub,lb|  
Q [209] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of ((if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0)) ) = totalSpO2' and 
((ub') - (lb')) = window_size' and (all k~quantity whole
  in lb..ub - 1 
  are ((if SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub) then SPO2^((1+k)-ub) else 0)) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) iff \'goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 514:
Theorem (514) [serial 1635] used for:
    normalization of [serial 1611]
 


Theorem (516)                               [serial 1590] 
P [198] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of SSQ((1 + k) - ub) ) = totalSpO2' and (ub - lb) = window_size' and (all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ((1 + 
      k) - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [208] |spo2_hist',goodSamp',ub',lb' := spo2_hist,goodSamp,ub,lb|  
Q [209] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of SSQ((1 + k) - ub) ) = totalSpO2' and ((ub') - (lb')) = window_size' and 
(all k~quantity whole
  in lb..ub - 1 
  are SSQ((1 + k) - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) iff \'goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
by Substitution of Assertion Labels
and theorem 515:
Theorem (515) [serial 1611] used for:
  substituted Assertions' predicates for  labels  [serial 1590]
 


Theorem (517)                               [serial 1566] 
P [198] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of SSQ((1 + k) - ub) ) = totalSpO2' and ((ub) - (lb)) = window_size' and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ((1 + 
      k) - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [208] |spo2_hist',goodSamp',ub',lb' := spo2_hist,goodSamp,ub,lb|  
Q [209] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of SSQ((1 + k) - ub) ) = totalSpO2' and ((ub') - (lb')) = window_size' and 
(all k~quantity whole
  in lb..ub - 1 
  are SSQ((1 + k) - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) iff \'goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 516:
Theorem (516) [serial 1590] used for:
    normalization of [serial 1566]
 


Theorem (518)                               [serial 1538] 
P [198] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of SSQ((1 + k) - ub) ) = totalSpO2' and ((1 + ub) - (1 + lb)) = window_size' and 
(all k~quantity whole
  in lb..ub - 1 
  are spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ((1 + 
      k) - ub) ) and (all k~quantity whole
  in lb..ub - 1 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^((1+k)-ub) and 
      not MOTION_ARTIFACT^((1+k)-ub)) ) >>
S [208] |spo2_hist',goodSamp',ub',lb' := spo2_hist,goodSamp,ub,lb|  
Q [209] << (numberof k~quantity whole
  in lb..ub - 1 
  that (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) ) = goodCount' and 
(sum k~quantity whole
  in lb..ub - 1 
  of SSQ((1 + k) - ub) ) = totalSpO2' and ((1 + ub') - (1 + lb')) = window_size' and 
(all k~quantity whole
  in lb..ub - 1 
  are SSQ((1 + k) - ub) = spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' ) and 
(all k~quantity whole
  in lb..ub - 1 
  are (SENSOR_CONNECTED^((1+k)-ub) and not MOTION_ARTIFACT^((1+k)-ub)) iff \'goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] ) >>
by Add both sides of subtraction:  a-b is (x+a)-(x+b)
and theorem 517:
Theorem (517) [serial 1566] used for:
  Add both sides of subtraction:  a-b is (x+a)-(x+b) [serial 1538]
 


Theorem (519)                               [serial 1486] 
P [198] << (all k~quantity whole
  in lb..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - (ub - 1))) ) and 
((totalSpO2' = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - (ub - 1)) ))) and ((((ub - 1) - (lb - 1)) = window_size')) and 
((goodCount' = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-(ub-1)) and not MOTION_ARTIFACT^(k-(ub-1))) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-(ub-1)) and 
      not MOTION_ARTIFACT^(k-(ub-1))) ) >>
S [208] |spo2_hist',goodSamp',ub',lb' := spo2_hist,goodSamp,ub,lb|  
Q [209] << (all k~quantity whole
  in lb..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' = SSQ(k - (ub - 1))) ) and 
((totalSpO2' = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - (ub - 1)) ))) and ((((ub' - 1) - (lb' - 1)) = window_size')) and 
((goodCount' = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-(ub-1)) and not MOTION_ARTIFACT^(k-(ub-1))) ))) and 
(all k~quantity whole
  in lb..(ub - 1) 
  are \'goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-(ub-1)) and 
      not MOTION_ARTIFACT^(k-(ub-1))) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Associativity: (b.c).a = a.b.c
and theorem 518:
Theorem (518) [serial 1538] used for:
    normalization of [serial 1486]
 


Theorem (520)                               [serial 1019] 
P [82] << INV_AV() and (((ub - lb) = window_size)) >>
S [142] << RUN_AV() >>
if 
((goodCount > 0))~> 
  << RUN_AV() and ((goodCount > 0)) and AXIOM_K2I() >>
  SpO2Avg!(totalSpO2 / goodCount)
  << RUN_AV() >> 
[]
((goodCount <= 0))~> 
  << RUN_AV() >>
  skip
  << RUN_AV() >> 
fi
;
<< RUN_AV() and AXIOM_LB() >>
{
<< all k~quantity whole
  in (lb + 1)..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub))  >>
spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] := (if SensorConnected? and not MotionArtifact? then SpO2? else 0)
<< (all k~quantity whole
  in (lb + 1)..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)) ) and ((spo2_hist[ub mod #PulseOx_Properties::Max_Window_Samples] = SSQ(x:0))) >>
&
<< ((totalSpO2 = (SSQ(lb - ub) + (sum k~quantity whole
  in (lb + 1)..(ub - 1) 
  of SSQ(k - ub) )))) and ((spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples] = SSQ(lb - ub))) and (((ub - lb) = window_size)) >>
totalSpO2 := (totalSpO2 + (if SensorConnected? and not MotionArtifact? then SpO2? else 0)) - spo2_hist[lb mod #PulseOx_Properties::Max_Window_Samples]
<< ((totalSpO2 = (SSQ(x:0) + (sum k~quantity whole
  in (lb + 1)..(ub - 1) 
  of SSQ(k - ub) )))) and (((ub - lb) = window_size)) >>
&
<< ((goodCount = ((if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0) + (numberof k~quantity whole
  in (lb + 1)..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )))) and ((SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub)) iff goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples]) >>
goodCount := (goodCount + (if (SensorConnected? and not MotionArtifact?) then 1 else 0)) - (if goodSamp[lb mod #PulseOx_Properties::Max_Window_Samples] then 1 else 0)
<< (goodCount = (((if SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0 then 1 else 0) + (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) )) - (if SENSOR_CONNECTED^(lb-ub) and not MOTION_ARTIFACT^(lb-ub) then 1 else 0))) >>
&
<< GS() >>
goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] := (SensorConnected? and not MotionArtifact?)
<< (goodSamp[ub mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^0 and not MOTION_ARTIFACT^0)) and GS() and AXIOM_LB() >>
} 
<< (all k~quantity whole
  in (lb + 1)..ub 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - ub)) ) and ((totalSpO2 = (sum k~quantity whole
  in (lb + 1)..ub 
  of SSQ(k - ub) ))) and (((ub - lb) = window_size)) and ((goodCount = (numberof k~quantity whole
  in (lb + 1)..ub 
  that (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ))) and (all k~quantity whole
  in (lb + 1)..ub 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-ub) and not MOTION_ARTIFACT^(k-ub)) ) >>
;
|ub,lb,window_size',totalSpO2',goodCount' := ub + 1,lb + 1,window_size,totalSpO2,goodCount|  
<< (all k~quantity whole
  in lb..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples] = SSQ(k - (ub - 1))) ) and ((totalSpO2' = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - (ub - 1)) ))) and ((((ub - 1) - (lb - 1)) = window_size')) and ((goodCount' = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-(ub-1)) and not MOTION_ARTIFACT^(k-(ub-1))) ))) and (all k~quantity whole
  in lb..(ub - 1) 
  are goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-(ub-1)) and not MOTION_ARTIFACT^(k-(ub-1))) ) >>
;
|spo2_hist',goodSamp',ub',lb' := spo2_hist,goodSamp,ub,lb|  
<< (all k~quantity whole
  in lb..(ub - 1) 
  are (spo2_hist[k mod #PulseOx_Properties::Max_Window_Samples]' = SSQ(k - (ub - 1))) ) and ((totalSpO2' = (sum k~quantity whole
  in lb..(ub - 1) 
  of SSQ(k - (ub - 1)) ))) and ((((ub' - 1) - (lb' - 1)) = window_size')) and ((goodCount' = (numberof k~quantity whole
  in lb..(ub - 1) 
  that (SENSOR_CONNECTED^(k-(ub-1)) and not MOTION_ARTIFACT^(k-(ub-1))) ))) and (all k~quantity whole
  in lb..(ub - 1) 
  are \'goodSamp[k mod #PulseOx_Properties::Max_Window_Samples] iff (SENSOR_CONNECTED^(k-(ub-1)) and not MOTION_ARTIFACT^(k-(ub-1))) ) >>
Q [82] << (INV_AV() and (((ub - lb) = window_size)))^1 >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 305 327 388 497 510 519:
Theorem (305) [serial 1481] used for:
  P -> P1 in sequential composition for [serial 1019]
 
Theorem (327) [serial 1482] used for:
  Q3 -> Q in sequential composition for [serial 1019]
 
Theorem (388) [serial 1483] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1019]
 
Theorem (497) [serial 1484] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1019]
 
Theorem (510) [serial 1485] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1019]
 
Theorem (519) [serial 1486] used for:
  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1019]
 


Theorem (521)                               [serial 1020] 
P [217] << ((((ub - lb) < window_size)) and INV_AV()) and stop@now and not (exists u~time
  in tops,,now 
  that true ) and not (exists u~time
  in tops,,now 
  that stop@u ) >>
S [217] ->
Q [83] << true >>
by True Conclusion Schema (tc): P->true


Theorem (522)                               [serial 1021] 
P [217] << (INV_AV() and (((ub - lb) = window_size))) and stop@now and not (exists u~time
  in tops,,now 
  that true ) and not (exists u~time
  in tops,,now 
  that stop@u ) >>
S [217] ->
Q [83] << true >>
by True Conclusion Schema (tc): P->true


Theorem (523)                               [serial 1008] 
P [34] <<   >>
S [45] ->
Q [34] << SpO2AverageThread.imp proof obligations >>
by Initial Thread Obligations
and theorems 99 102 105 109 154 156 244 269 295 297 520 521 522:
Theorem (99) [serial 1009] used for:
  <<M(fillingWindow)>> -> <<I>> from invariant I when complete state fillingWindow has Assertion <<M(fillingWindow)>> in its definition.
 
Theorem (102) [serial 1010] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
 
Theorem (105) [serial 1011] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state chooseToRun, <<M(chooseToRun)>> -> <<e1 or e2 or . . . en>>
 
Theorem (109) [serial 1012] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
 
Theorem (154) [serial 1013] used for:
   <<M(start) and x>> A <<M(fillingWindow)>> for SpAT0:start-[x]->fillingWindow{A};
 
Theorem (156) [serial 1014] used for:
   <<M(start) and x>> A <<M(fail)>> for SpAT0a:start-[x]->fail{A};
 
Theorem (244) [serial 1015] used for:
   <<M(fillingWindow) and x>> A <<M(chooseToRun)>> for SpAT1:fillingWindow-[x]->chooseToRun{A};
 
Theorem (269) [serial 1016] used for:
   <<M(chooseToRun) and x>> A <<M(fillingWindow)>> for SpAT2:chooseToRun-[x]->fillingWindow{A};
 
Theorem (295) [serial 1017] used for:
   <<M(chooseToRun) and x>> A <<M(run)>> for SpAT3:chooseToRun-[x]->run{A};
 
Theorem (297) [serial 1018] used for:
   <<M(chooseToRun) and x>> A <<M(fail)>> for SpAT3a:chooseToRun-[x]->fail{A};
 
Theorem (520) [serial 1019] used for:
   <<M(run) and x>> A <<M(run)>> for SpAt4:run-[x]->run{A};
 
Theorem (521) [serial 1020] used for:
   <<M(fillingWindow) and x>> -> <<M(halt)>> for SpATstop:fillingWindow-[x]->halt{};
 
Theorem (522) [serial 1021] used for:
   <<M(run) and x>> -> <<M(halt)>> for SpATstop:run-[x]->halt{};
 


Theorem (524)                               [serial 1866] 
P [51] << (all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
S [33] ->
Q [33] << all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)))  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (525)                               [serial 1023] 
P [51] << SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
S [33] ->
Q [33] << all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)))  >>
by Substitution of Assertion Labels
and theorem 524:
Theorem (524) [serial 1866] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1023]
 


Theorem (526)                               [serial 1867] 
P [47] << (all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ) and 
((num_samples < #PulseOx_Properties::Num_Trending_Samples)) >>
S [33] ->
Q [33] << all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)))  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (527)                               [serial 1024] 
P [47] << SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) >>
S [33] ->
Q [33] << all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)))  >>
by Substitution of Assertion Labels
and theorem 526:
Theorem (526) [serial 1867] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1024]
 


Theorem (528)                               [serial 1025] 
P [43] << ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and ((num_samples = 0)) and 
(all s~quantity whole
  in (num_samples + 1)..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) >>
S [43] ->
Q [43] << true >>
by True Conclusion Schema (tc): P->true


Theorem (529)                               [serial 1871] 
P [49] << HOLD(num_samples) >>
S [49] ->
Q [49] << true >>
by True Conclusion Schema (tc): P->true


Theorem (530)                               [serial 1869] 
P [49] << HOLD(num_samples) >>
S [49] ->
Q [49] << num_samples = #PulseOx_Properties::Num_Trending_Samples or num_samples < #PulseOx_Properties::Num_Trending_Samples or 
#PulseOx_Properties::Num_Trending_Samples < num_samples >>
by Less than, greater than, or equal:  |-a<b or b<a or a=b
and theorem 529:
Theorem (529) [serial 1871] used for:
  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1869]
 


Theorem (531)                               [serial 1026] 
P [49] << HOLD(num_samples) >>
S [49] ->
Q [49] << ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) or ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) or 
((num_samples > #PulseOx_Properties::Num_Trending_Samples)) >>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 530:
Theorem (530) [serial 1869] used for:
    normalization of [serial 1026]
 


Theorem (532)                               [serial 1909] 
P [43] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [55] ->
Q [33] << true >>
by True Conclusion Schema (tc): P->true


Theorem (533)                               [serial 1908] 
P [43] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [55] ->
Q [33] << all s~quantity whole
  in false 
  are spo2_a[s]^1 = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s))  >>
by Empty Range Law All: all a:t in false are V is tautology
and theorem 532:
Theorem (532) [serial 1909] used for:
  Empty Range Law All: all a:t in false are V is tautology [serial 1908]
 


Theorem (534)                               [serial 1907] 
P [43] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [55] ->
Q [33] << all s~quantity whole
  in 1..0 
  are spo2_a[s]^1 = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s))  >>
by Empty Range
and theorem 533:
Theorem (533) [serial 1908] used for:
  Empty Range [serial 1907]
 


Theorem (535)                               [serial 1905] 
P [43] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [55] ->
Q [33] << all s~quantity whole
  in 1..num_samples 
  are spo2_a[s]^1 = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s))  >>
by Guided Substitution of Equals
and theorem 534:
Theorem (534) [serial 1907] used for:
  Guided Substitution of Equals
 replacing "num_samples" with its = "0" in its postcondition [serial 1905]
 


Theorem (536)                               [serial 1902] 
P [43] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [55] ->
Q [33] << (all s~quantity whole
  in 1..num_samples 
  are spo2_a[s]^1 = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 535:
Theorem (535) [serial 1905] used for:
    normalization of [serial 1902]
 


Theorem (537)                               [serial 1903] 
P [43] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [55] ->
Q [47] << num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (538)                               [serial 1901] 
P [43] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [55] ->
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are spo2_a[s]^1 = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 536 537:
Theorem (536) [serial 1902] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1901]
 
Theorem (537) [serial 1903] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1901]
 


Theorem (539)                               [serial 1898] 
P [43] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [55] num_samples' := num_samples
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are spo2_a[s]^1 = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 538:
Theorem (538) [serial 1901] used for:
  applied wp for assignment [serial 1898]
 


Theorem (540)                               [serial 1896] 
P [43] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [55] num_samples' := num_samples
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are spo2_a[s]^1 = (if MOTION_ARTIFACT^(1-s) or not (SENSOR_CONNECTED^(- s))^1 then 0 else SPO2^(1-s)) ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Caret Compostition:  (x^a)^b is x^(a+b)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Associativity: (b.c).a = a.b.c
and theorem 539:
Theorem (539) [serial 1898] used for:
    normalization of [serial 1896]
 


Theorem (541)                               [serial 1894] 
P [43] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [55] num_samples' := num_samples
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are spo2_a[s]^1 = (if MOTION_ARTIFACT^(1-s) or (not SENSOR_CONNECTED^(- s))^1 then 0 else SPO2^(1-s)) ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 540:
Theorem (540) [serial 1896] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1894]
 


Theorem (542)                               [serial 1892] 
P [43] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [55] num_samples' := num_samples
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are spo2_a[s]^1 = (if (MOTION_ARTIFACT^((- s)+1) or (not SENSOR_CONNECTED^(- s))^1) then 0 else SPO2^(1-s)) ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Associativity: (b.c).a = a.b.c
and theorem 541:
Theorem (541) [serial 1894] used for:
    normalization of [serial 1892]
 


Theorem (543)                               [serial 1890] 
P [43] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [55] num_samples' := num_samples
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are spo2_a[s]^1 = (if (MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s))^1 then 0 else SPO2^(1-s)) ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 542:
Theorem (542) [serial 1892] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1890]
 


Theorem (544)                               [serial 1888] 
P [43] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [55] num_samples' := num_samples
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are (if (MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s))^1 then (0)^1 else SPO2^((- s)+1)) = spo2_a[s]^1 ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
    Associativity: (b.c).a = a.b.c
and theorem 543:
Theorem (543) [serial 1890] used for:
    normalization of [serial 1888]
 


Theorem (545)                               [serial 1886] 
P [43] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [55] num_samples' := num_samples
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))^1 = spo2_a[s]^1 ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 544:
Theorem (544) [serial 1888] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1886]
 


Theorem (546)                               [serial 1884] 
P [43] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [55] num_samples' := num_samples
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are (((if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)))^1 = (spo2_a[s])^1) ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 545:
Theorem (545) [serial 1886] used for:
    normalization of [serial 1884]
 


Theorem (547)                               [serial 1882] 
P [43] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [55] num_samples' := num_samples
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are ((if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s])^1 ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 546:
Theorem (546) [serial 1884] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1882]
 


Theorem (548)                               [serial 1880] 
P [43] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [55] num_samples' := num_samples
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are ((if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s])^1 ) and 
((num_samples)^1 < (#PulseOx_Properties::Num_Trending_Samples)^1) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
and theorem 547:
Theorem (547) [serial 1882] used for:
    normalization of [serial 1880]
 


Theorem (549)                               [serial 1878] 
P [43] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [55] num_samples' := num_samples
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] )^1 and 
(num_samples < #PulseOx_Properties::Num_Trending_Samples)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 548:
Theorem (548) [serial 1880] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1878]
 


Theorem (550)                               [serial 1876] 
P [43] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [55] num_samples' := num_samples
Q [47] << ((all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] )^1 and 
(num_samples < #PulseOx_Properties::Num_Trending_Samples)^1) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 549:
Theorem (549) [serial 1878] used for:
    normalization of [serial 1876]
 


Theorem (551)                               [serial 1874] 
P [43] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [55] num_samples' := num_samples
Q [47] << ((all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 550:
Theorem (550) [serial 1876] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1874]
 


Theorem (552)                               [serial 1872] 
P [43] << ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and ((num_samples = 0)) and 
(all s~quantity whole
  in (num_samples + 1)..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) >>
S [55] num_samples' := num_samples
Q [47] << ((all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ) and 
((num_samples < #PulseOx_Properties::Num_Trending_Samples)))^1 >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 551:
Theorem (551) [serial 1874] used for:
    normalization of [serial 1872]
 


Theorem (553)                               [serial 1027] 
P [43] << ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and ((num_samples = 0)) and 
(all s~quantity whole
  in (num_samples + 1)..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) >>
S [55] num_samples' := num_samples
Q [47] << (SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)))^1 >>
by Substitution of Assertion Labels
and theorem 552:
Theorem (552) [serial 1872] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 1027]
 


Theorem (554)                               [serial 1997] 
P [47] << SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [47] ->
Q [58] << SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Identity (id):  P->P is tautology


Theorem (555)                               [serial 1971] 
P [47] << SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [47] ->
Q [58] << SpO2_INV() and true and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Law of And-Simplification:  P and true is P
and theorem 554:
Theorem (554) [serial 1997] used for:
  Law of And-Simplification:  P and true is P [serial 1971]
 


Theorem (556)                               [serial 1929] 
P [47] << SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) >>
S [47] ->
Q [58] << SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and 
true >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 555:
Theorem (555) [serial 1971] used for:
    normalization of [serial 1929]
 


Theorem (557)                               [serial 1997] 
P [47] << SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [47] ->
Q [58] << SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Identity (id):  P->P is tautology


Theorem (558)                               [serial 1971] 
P [47] << SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [47] ->
Q [58] << SpO2_INV() and true and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Law of And-Simplification:  P and true is P
and theorem 557:
Theorem (557) [serial 1997] used for:
  Law of And-Simplification:  P and true is P [serial 1971]
 


Theorem (559)                               [serial 1929] 
P [47] << SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) >>
S [47] ->
Q [58] << SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and 
true >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 558:
Theorem (558) [serial 1971] used for:
    normalization of [serial 1929]
 


Theorem (560)                               [serial 1910] 
P [47] << SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) >>
S [47] ->
Q [58] << SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_NS() >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 559 559:
Theorem (559) [serial 1929] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (559) [serial 1929] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (561)                               [serial 2028] 
P [102] << all #0#~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-#0#) or not SENSOR_CONNECTED^(1-#0#) then 0 else SPO2^(1-#0#)) = spo2_a[#0#]  >>
S [49] ->
Q [49] << all #1#~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-#1#) or not SENSOR_CONNECTED^(1-#1#) then 0 else SPO2^(1-#1#)) = spo2_a[#1#]  >>
by Identity (id):  P->P is tautology


Theorem (562)                               [serial 2026] 
P [102] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_a[i]  >>
S [49] ->
Q [49] << all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s]  >>
by Replacement of Quantified Variables with #1, #2, etc.
and theorem 561:
Theorem (561) [serial 2028] used for:
  Replacement of Quantified Variables with #1, #2, etc. [serial 2026]
 


Theorem (563)                               [serial 2024] 
P [102] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_a[i]  >>
S [49] ->
Q [49] << (all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s))) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 562:
Theorem (562) [serial 2026] used for:
    normalization of [serial 2024]
 


Theorem (564)                               [serial 1941] 
P [102] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_a[i]  >>
S [49] ->
Q [49] << HOLD(num_samples) >>
by Substitution of Assertion Labels
and theorem 563:
Theorem (563) [serial 2024] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 1941]
 


Theorem (565)                               [serial 1911] 
P [102] << all i~quantity whole
  in 1..num_samples 
  are (spo2_a[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)))  >>
S [49] ->
Q [49] << HOLD(num_samples) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 564:
Theorem (564) [serial 1941] used for:
    normalization of [serial 1911]
 


Theorem (566)                               [serial 2085] 
P [58] << NUM_SAMPLES = num_samples and SPO2_HISTORY = spo2_a and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [60] ->
Q [15] << all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (567)                               [serial 2084] 
P [58] << NUM_SAMPLES = num_samples and SPO2_HISTORY = spo2_a and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [60] ->
Q [15] << all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = SPO2_HISTORY[s]  >>
by Guided Substitution of Equals
and theorem 566:
Theorem (566) [serial 2085] used for:
  Guided Substitution of Equals
 replacing "SPO2_HISTORY" with its = "spo2_a" in its postcondition [serial 2084]
 


Theorem (568)                               [serial 2083] 
P [58] << NUM_SAMPLES = num_samples and SPO2_HISTORY = spo2_a and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [60] ->
Q [15] << all s~quantity whole
  in 1..NUM_SAMPLES 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = SPO2_HISTORY[s]  >>
by Guided Substitution of Equals
and theorem 567:
Theorem (567) [serial 2084] used for:
  Guided Substitution of Equals
 replacing "NUM_SAMPLES" with its = "num_samples" in its postcondition [serial 2083]
 


Theorem (569)                               [serial 2081] 
P [58] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) and 
(NUM_SAMPLES = num_samples and SPO2_HISTORY = spo2_a) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [60] ->
Q [15] << all s~quantity whole
  in 1..NUM_SAMPLES 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = SPO2_HISTORY[s]  >>
by Associativity: (b.c).a = a.b.c
and theorem 568:
Theorem (568) [serial 2083] used for:
  Associativity: (b.c).a = a.b.c [serial 2081]
 


Theorem (570)                               [serial 2079] 
P [58] << ((num_samples = NUM_SAMPLES) and (spo2_a = SPO2_HISTORY)) and (all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [60] ->
Q [15] << (all s~quantity whole
  in 1..NUM_SAMPLES 
  are (SPO2_HISTORY[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 569:
Theorem (569) [serial 2081] used for:
    normalization of [serial 2079]
 


Theorem (571)                               [serial 1973] 
P [58] << AXIOM_NS() and SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [60] ->
Q [15] << SPO2_TREND() >>
by Substitution of Assertion Labels
and theorem 570:
Theorem (570) [serial 2079] used for:
  substituted Assertions' predicates for  labels  [serial 1973]
 


Theorem (572)                               [serial 1938] 
P [58] << SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_NS() >>
S [60] ->
Q [15] << SPO2_TREND() >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 571:
Theorem (571) [serial 1973] used for:
    normalization of [serial 1938]
 


Theorem (573)                               [serial 2020] 
P [60] << (SPO2_TREND())^0 and AXIOM_NS() and SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [60] ->
Q [62] << SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (574)                               [serial 1999] 
P [60] << AXIOM_NS() and SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples and 
(SPO2_TREND())^0 >>
S [60] ->
Q [62] << SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 573:
Theorem (573) [serial 2020] used for:
    normalization of [serial 1999]
 


Theorem (575)                               [serial 1998] 
P [60] << (SPO2_TREND())^0 and (AXIOM_NS() and SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples) >>
S [60] ->
Q [62] << SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Associativity: (b.c).a = a.b.c
and theorem 574:
Theorem (574) [serial 1999] used for:
  Associativity: (b.c).a = a.b.c [serial 1998]
 


Theorem (576)                               [serial 1975] 
P [60] << (SPO2_TREND())^0 and (AXIOM_NS() and SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples) >>
S [60] ->
Q [62] << SpO2_INV() and true and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Law of And-Simplification:  P and true is P
and theorem 575:
Theorem (575) [serial 1998] used for:
  Law of And-Simplification:  P and true is P [serial 1975]
 


Theorem (577)                               [serial 1939] 
P [60] << (SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_NS()) and (SPO2_TREND())^0 >>
S [60] ->
Q [62] << SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and 
true >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 576:
Theorem (576) [serial 1975] used for:
    normalization of [serial 1939]
 


Theorem (578)                               [serial 1930] 
P [58] << SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_NS() >>
S [60] SpO2Trend!(spo2_a)
Q [62] << SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and 
true >>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 572 577:
Theorem (572) [serial 1938] used for:
  applied port output of value <<pre>> -> <<M(SpO2Trend)[SpO2Trend|spo2_a]>> [serial 1930]
 
Theorem (577) [serial 1939] used for:
  applied port output <<pre and (SPO2_TREND())^0>> -> <<post>> [serial 1930]
 


Theorem (579)                               [serial 2085] 
P [58] << NUM_SAMPLES = num_samples and SPO2_HISTORY = spo2_a and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [60] ->
Q [15] << all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (580)                               [serial 2084] 
P [58] << NUM_SAMPLES = num_samples and SPO2_HISTORY = spo2_a and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [60] ->
Q [15] << all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = SPO2_HISTORY[s]  >>
by Guided Substitution of Equals
and theorem 579:
Theorem (579) [serial 2085] used for:
  Guided Substitution of Equals
 replacing "SPO2_HISTORY" with its = "spo2_a" in its postcondition [serial 2084]
 


Theorem (581)                               [serial 2083] 
P [58] << NUM_SAMPLES = num_samples and SPO2_HISTORY = spo2_a and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [60] ->
Q [15] << all s~quantity whole
  in 1..NUM_SAMPLES 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = SPO2_HISTORY[s]  >>
by Guided Substitution of Equals
and theorem 580:
Theorem (580) [serial 2084] used for:
  Guided Substitution of Equals
 replacing "NUM_SAMPLES" with its = "num_samples" in its postcondition [serial 2083]
 


Theorem (582)                               [serial 2081] 
P [58] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) and 
(NUM_SAMPLES = num_samples and SPO2_HISTORY = spo2_a) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [60] ->
Q [15] << all s~quantity whole
  in 1..NUM_SAMPLES 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = SPO2_HISTORY[s]  >>
by Associativity: (b.c).a = a.b.c
and theorem 581:
Theorem (581) [serial 2083] used for:
  Associativity: (b.c).a = a.b.c [serial 2081]
 


Theorem (583)                               [serial 2079] 
P [58] << ((num_samples = NUM_SAMPLES) and (spo2_a = SPO2_HISTORY)) and (all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [60] ->
Q [15] << (all s~quantity whole
  in 1..NUM_SAMPLES 
  are (SPO2_HISTORY[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 582:
Theorem (582) [serial 2081] used for:
    normalization of [serial 2079]
 


Theorem (584)                               [serial 1973] 
P [58] << AXIOM_NS() and SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [60] ->
Q [15] << SPO2_TREND() >>
by Substitution of Assertion Labels
and theorem 583:
Theorem (583) [serial 2079] used for:
  substituted Assertions' predicates for  labels  [serial 1973]
 


Theorem (585)                               [serial 1938] 
P [58] << SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_NS() >>
S [60] ->
Q [15] << SPO2_TREND() >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 584:
Theorem (584) [serial 1973] used for:
    normalization of [serial 1938]
 


Theorem (586)                               [serial 2020] 
P [60] << (SPO2_TREND())^0 and AXIOM_NS() and SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [60] ->
Q [62] << SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (587)                               [serial 1999] 
P [60] << AXIOM_NS() and SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples and 
(SPO2_TREND())^0 >>
S [60] ->
Q [62] << SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 586:
Theorem (586) [serial 2020] used for:
    normalization of [serial 1999]
 


Theorem (588)                               [serial 1998] 
P [60] << (SPO2_TREND())^0 and (AXIOM_NS() and SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples) >>
S [60] ->
Q [62] << SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Associativity: (b.c).a = a.b.c
and theorem 587:
Theorem (587) [serial 1999] used for:
  Associativity: (b.c).a = a.b.c [serial 1998]
 


Theorem (589)                               [serial 1975] 
P [60] << (SPO2_TREND())^0 and (AXIOM_NS() and SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples) >>
S [60] ->
Q [62] << SpO2_INV() and true and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Law of And-Simplification:  P and true is P
and theorem 588:
Theorem (588) [serial 1998] used for:
  Law of And-Simplification:  P and true is P [serial 1975]
 


Theorem (590)                               [serial 1939] 
P [60] << (SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_NS()) and (SPO2_TREND())^0 >>
S [60] ->
Q [62] << SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and 
true >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 589:
Theorem (589) [serial 1975] used for:
    normalization of [serial 1939]
 


Theorem (591)                               [serial 1930] 
P [58] << SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_NS() >>
S [60] SpO2Trend!(spo2_a)
Q [62] << SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and 
true >>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 585 590:
Theorem (585) [serial 1938] used for:
  applied port output of value <<pre>> -> <<M(SpO2Trend)[SpO2Trend|spo2_a]>> [serial 1930]
 
Theorem (590) [serial 1939] used for:
  applied port output <<pre and (SPO2_TREND())^0>> -> <<post>> [serial 1930]
 


Theorem (592)                               [serial 1912] 
P [58] << SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_NS() >>
S [60] SpO2Trend!(spo2_a)
Q [62] << SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_NS() >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 591 591:
Theorem (591) [serial 1930] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (591) [serial 1930] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (593)                               [serial 2014] 
P [64] << (NumSamples = num_samples)^0 and AXIOM_NS() and SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [64] ->
Q [66] << SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (594)                               [serial 1994] 
P [64] << AXIOM_NS() and SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples and 
(NumSamples = num_samples)^0 >>
S [64] ->
Q [66] << SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 593:
Theorem (593) [serial 2014] used for:
    normalization of [serial 1994]
 


Theorem (595)                               [serial 1943] 
P [64] << (NumSamples = num_samples)^0 and (AXIOM_NS() and SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples) >>
S [64] ->
Q [66] << SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Associativity: (b.c).a = a.b.c
and theorem 594:
Theorem (594) [serial 1994] used for:
  Associativity: (b.c).a = a.b.c [serial 1943]
 


Theorem (596)                               [serial 1931] 
P [64] << (SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_NS()) and (NumSamples = num_samples)^0 >>
S [64] ->
Q [66] << SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 595:
Theorem (595) [serial 1943] used for:
    normalization of [serial 1931]
 


Theorem (597)                               [serial 2092] 
P [64] << NUM_SAMPLES = num_samples and NumSamples = num_samples and SPO2_HISTORY = spo2_a and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [64] ->
Q [64] << NUM_SAMPLES = num_samples >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (598)                               [serial 2091] 
P [64] << NUM_SAMPLES = num_samples and NumSamples = num_samples and SPO2_HISTORY = spo2_a and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [64] ->
Q [64] << NUM_SAMPLES = NumSamples >>
by Guided Substitution of Equals
and theorem 597:
Theorem (597) [serial 2092] used for:
  Guided Substitution of Equals
 replacing "NumSamples" with its = "num_samples" in its postcondition [serial 2091]
 


Theorem (599)                               [serial 2090] 
P [64] << NUM_SAMPLES = num_samples and SPO2_HISTORY = spo2_a and (NumSamples = num_samples)^0 and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [64] ->
Q [64] << NUM_SAMPLES = NumSamples >>
by Assume Present:  P = P@now = P^0 
and theorem 598:
Theorem (598) [serial 2091] used for:
  Assume Present:  P = P@now = P^0  [serial 2090]
 


Theorem (600)                               [serial 2088] 
P [64] << (NumSamples = num_samples)^0 and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) and 
(NUM_SAMPLES = num_samples and SPO2_HISTORY = spo2_a) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [64] ->
Q [64] << NUM_SAMPLES = NumSamples >>
by Associativity: (b.c).a = a.b.c
and theorem 599:
Theorem (599) [serial 2090] used for:
  Associativity: (b.c).a = a.b.c [serial 2088]
 


Theorem (601)                               [serial 2086] 
P [64] << (NumSamples = num_samples)^0 and ((num_samples = NUM_SAMPLES) and (spo2_a = SPO2_HISTORY)) and 
(all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [64] ->
Q [64] << NUM_SAMPLES = NumSamples >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 600:
Theorem (600) [serial 2088] used for:
    normalization of [serial 2086]
 


Theorem (602)                               [serial 2016] 
P [64] << (NumSamples = num_samples)^0 and AXIOM_NS() and SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [64] ->
Q [64] << NUM_SAMPLES = NumSamples >>
by Substitution of Assertion Labels
and theorem 601:
Theorem (601) [serial 2086] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2016]
 


Theorem (603)                               [serial 1995] 
P [64] << AXIOM_NS() and SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples and 
(NumSamples = num_samples)^0 >>
S [64] ->
Q [64] << NUM_SAMPLES = NumSamples >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 602:
Theorem (602) [serial 2016] used for:
    normalization of [serial 1995]
 


Theorem (604)                               [serial 1945] 
P [64] << (NumSamples = num_samples)^0 and (AXIOM_NS() and SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples) >>
S [64] ->
Q [64] << NUM_SAMPLES = NumSamples >>
by Associativity: (b.c).a = a.b.c
and theorem 603:
Theorem (603) [serial 1995] used for:
  Associativity: (b.c).a = a.b.c [serial 1945]
 


Theorem (605)                               [serial 1932] 
P [64] << (SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_NS()) and (NumSamples = num_samples)^0 >>
S [64] ->
Q [64] << NumSamples = NUM_SAMPLES >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 604:
Theorem (604) [serial 1945] used for:
    normalization of [serial 1932]
 


Theorem (606)                               [serial 1913] 
P [62] << SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_NS() >>
S [64] NumSamples!(num_samples)
Q [66] << SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) >>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 596 605:
Theorem (596) [serial 1931] used for:
  applied port output <<pre and (NumSamples=num_samples)^0>> -> <<post>> [serial 1913]
 
Theorem (605) [serial 1932] used for:
  applied port output <<pre and (NumSamples=num_samples)^0>> -> <<(NumSamples=NUM_SAMPLES)^0>> [serial 1913]
 


Theorem (607)                               [serial 1949] 
P [69] << (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_a[i] >>
S [70] ->
Q [71] << (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_a[i] >>
by Identity (id):  P->P is tautology


Theorem (608)                               [serial 1933] 
P [69] << (spo2_a[i] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) >>
S [70] ->
Q [71] << ((spo2_a[i]) = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 607:
Theorem (607) [serial 1949] used for:
    normalization of [serial 1933]
 


Theorem (609)                               [serial 1918] 
P [69] << (spo2_a[i] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) >>
S [70] spo2_nxt[i + 1] := spo2_a[i]
Q [71] << (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 608:
Theorem (608) [serial 1933] used for:
  applied wp for assignment [serial 1918]
 


Theorem (610)                               [serial 2033] 
P [66] << (all #2#~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- #2#) or not SENSOR_CONNECTED^(- #2#) then 0 else SPO2^(- #2#)) = spo2_a[#2#] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [67] ->
Q [73] << all #3#~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- #3#) or not SENSOR_CONNECTED^(- #3#) then 0 else SPO2^(- #3#)) = spo2_a[#3#]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (611)                               [serial 2031] 
P [66] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [67] ->
Q [73] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_a[i]  >>
by Replacement of Quantified Variables with #1, #2, etc.
and theorem 610:
Theorem (610) [serial 2033] used for:
  Replacement of Quantified Variables with #1, #2, etc. [serial 2031]
 


Theorem (612)                               [serial 2029] 
P [66] << (all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [67] ->
Q [73] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_a[i]  >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 611:
Theorem (611) [serial 2031] used for:
    normalization of [serial 2029]
 


Theorem (613)                               [serial 1947] 
P [66] << SpO2_INV() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [67] ->
Q [73] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_a[i]  >>
by Substitution of Assertion Labels
and theorem 612:
Theorem (612) [serial 2029] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1947]
 


Theorem (614)                               [serial 1919] 
P [66] << (SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples))) >>
S [67] ->
Q [73] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_a[i]  >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 613:
Theorem (613) [serial 1947] used for:
    normalization of [serial 1919]
 


Theorem (615)                               [serial 1914] 
P [66] << SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) >>
S [67] forall i in 1..num_samples
  {
  << (spo2_a[i] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) >>
  spo2_nxt[i + 1] := spo2_a[i]
  << (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) >>
  }  
Q [73] << all i~quantity whole
  in 1..num_samples 
  are (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)))  >>
by Universal Quantification Rule:
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any (bl.ulq)
and theorems 609 614:
Theorem (609) [serial 1918] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1914]
 
Theorem (614) [serial 1919] used for:
    <<P and (x=e) and FAT>> -> <<wp(forall,Q)>>
 where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
   (in postcondition Q, replace all occurances of
    <<all z:i in r are B>> with <<all z:i in r are A>>)
  for [serial 1914]
 


Theorem (616)                               [serial 1996] 
P [73] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i]  >>
S [76] ->
Q [76] << true >>
by True Conclusion Schema (tc): P->true


Theorem (617)                               [serial 1951] 
P [73] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i]  >>
S [76] ->
Q [76] << not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) or (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) >>
by Law of Excluded Middle: P or not P is tautology
and theorem 616:
Theorem (616) [serial 1996] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1951]
 


Theorem (618)                               [serial 1920] 
P [73] << all i~quantity whole
  in 1..num_samples 
  are (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)))  >>
S [76] ->
Q [76] << ((MOTION_ARTIFACT)^0 or not (SENSOR_CONNECTED)^0) or (not ((MOTION_ARTIFACT)^0 or 
not (SENSOR_CONNECTED)^0)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 617:
Theorem (617) [serial 1951] used for:
    normalization of [serial 1920]
 


Theorem (619)                               [serial 2036] 
P [76] << (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [76] ->
Q [78] << (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Identity (id):  P->P is tautology


Theorem (620)                               [serial 2034] 
P [76] << (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [76] ->
Q [78] << (all i~quantity whole
  in 1..num_samples 
  are (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) ) and 
(MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 619:
Theorem (619) [serial 2036] used for:
    normalization of [serial 2034]
 


Theorem (621)                               [serial 1953] 
P [76] << (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [76] ->
Q [78] << SHFT() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Substitution of Assertion Labels
and theorem 620:
Theorem (620) [serial 2034] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 1953]
 


Theorem (622)                               [serial 1921] 
P [76] << (all i~quantity whole
  in 1..num_samples 
  are (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) ) and 
((MOTION_ARTIFACT)^0 or not (SENSOR_CONNECTED)^0) >>
S [76] ->
Q [78] << SHFT() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 621:
Theorem (621) [serial 1953] used for:
    normalization of [serial 1921]
 


Theorem (623)                               [serial 2042] 
P [78] << SHFT() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [79] ->
Q [81] << true >>
by True Conclusion Schema (tc): P->true


Theorem (624)                               [serial 2041] 
P [78] << SHFT() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [79] ->
Q [81] << 0 = 0 >>
by Equality Law (idistr):  a=a <-> true
and theorem 623:
Theorem (623) [serial 2042] used for:
  Equality Law (idistr):  a=a <-> true [serial 2041]
 


Theorem (625)                               [serial 2038] 
P [78] << SHFT() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [79] ->
Q [81] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = 0 >>
by Conditional True Expression:  b and x=e  iff  b and x=(b??e:g) 
and theorem 624:
Theorem (624) [serial 2041] used for:
   Conditional True Expression:  b and x=e  iff  b and x=(b??e:g)  [serial 2038]
 


Theorem (626)                               [serial 2039] 
P [78] << SHFT() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [79] ->
Q [80] << SHFT() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (627)                               [serial 2040] 
P [78] << SHFT() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [79] ->
Q [80] << (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (628)                               [serial 1955] 
P [78] << SHFT() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [79] ->
Q [80] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = 0 and 
SHFT() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 625 626 627:
Theorem (625) [serial 2038] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1955]
 
Theorem (626) [serial 2039] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1955]
 
Theorem (627) [serial 2040] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1955]
 


Theorem (629)                               [serial 1934] 
P [78] << SHFT() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [79] ->
Q [80] << SHFT() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and ((0 = (if 
MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 628:
Theorem (628) [serial 1955] used for:
    normalization of [serial 1934]
 


Theorem (630)                               [serial 1922] 
P [78] << SHFT() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [79] spo2_nxt[1] := 0
Q [80] << SHFT() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and ((spo2_nxt[1] = (if 
MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 629:
Theorem (629) [serial 1934] used for:
  applied wp for assignment [serial 1922]
 


Theorem (631)                               [serial 2043] 
P [80] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
SHFT() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [76] ->
Q [89] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (632)                               [serial 2053] 
P [80] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
(all i~quantity whole
  in 0..-1 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      2 + i] ) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [76] ->
Q [90] << all i~quantity whole
  in 0..-1 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      2 + i]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (633)                               [serial 2051] 
P [80] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
(all i~quantity whole
  in 0..-1 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      1 + i + 1] ) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [76] ->
Q [90] << all i~quantity whole
  in 0..-1 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      2 + i]  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 632:
Theorem (632) [serial 2053] used for:
    normalization of [serial 2051]
 


Theorem (634)                               [serial 2049] 
P [80] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
(all i~quantity whole
  in 0..-1 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      1 + (1 + i)] ) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [76] ->
Q [90] << all i~quantity whole
  in 0..-1 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      2 + i]  >>
by Associativity: (b.c).a = a.b.c
and theorem 633:
Theorem (633) [serial 2051] used for:
  Associativity: (b.c).a = a.b.c [serial 2049]
 


Theorem (635)                               [serial 2047] 
P [80] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
(all i~quantity whole
  in 0..(num_samples +  -1) 
  are (spo2_nxt[(i + 1) + 1] = (if MOTION_ARTIFACT^((- i+- 1)) or not SENSOR_CONNECTED^((- i+- 1)) then 0 else SPO2^((- i+- 1)))) ) and 
(MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [76] ->
Q [90] << (all i~quantity whole
  in 0..(1 + num_samples +  -2) 
  are (if MOTION_ARTIFACT^(1+- i+- 2) or not SENSOR_CONNECTED^(1+- i+- 2) then 0 else SPO2^(1+- i+- 2)) = spo2_nxt[(
      i + 2)] ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 634:
Theorem (634) [serial 2049] used for:
    normalization of [serial 2047]
 


Theorem (636)                               [serial 2046] 
P [80] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
(all i~quantity whole
  in 0..(num_samples - 1) 
  are (spo2_nxt[(i + 1) + 1] = (if MOTION_ARTIFACT^(- (i+1)) or not SENSOR_CONNECTED^(- (i+1)) then 0 else SPO2^(- (i+1)))) ) and 
(MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [76] ->
Q [90] << (all i~quantity whole
  in 0..((1 + num_samples) - 2) 
  are (if MOTION_ARTIFACT^(1-(i+2)) or not SENSOR_CONNECTED^(1-(i+2)) then 0 else SPO2^(1-(i+2))) = spo2_nxt[(
      i + 2)] ) >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 635:
Theorem (635) [serial 2047] used for:
   changing adding negation to subtraction  [serial 2046]
 


Theorem (637)                               [serial 2045] 
P [80] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
(all i~quantity whole
  in 1..num_samples 
  are (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) ) and 
(MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [76] ->
Q [90] << (all i~quantity whole
  in 2..1 + num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] ) >>
by Shift Quantification Range so Lower Bound is Zero
and theorem 636:
Theorem (636) [serial 2046] used for:
  Shift Quantification Range so Lower Bound is Zero [serial 2045]
 


Theorem (638)                               [serial 2044] 
P [80] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
SHFT() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [76] ->
Q [90] << (all i~quantity whole
  in 2..1 + num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] ) >>
by Substitution of Assertion Labels
and theorem 637:
Theorem (637) [serial 2045] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2044]
 


Theorem (639)                               [serial 1957] 
P [80] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
SHFT() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [76] ->
Q [89] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
(all i~quantity whole
  in 2..1 + num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] ) >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 631 638:
Theorem (631) [serial 2043] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1957]
 
Theorem (638) [serial 2044] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1957]
 


Theorem (640)                               [serial 1923] 
P [80] << SHFT() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and ((spo2_nxt[1] = (if 
MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) >>
S [76] ->
Q [89] << ((spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) and 
(all i~quantity whole
  in 2..(num_samples + 1) 
  are (spo2_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 639:
Theorem (639) [serial 1957] used for:
    normalization of [serial 1923]
 


Theorem (641)                               [serial 2059] 
P [76] << not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) >>
S [76] ->
Q [84] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (642)                               [serial 2057] 
P [76] << not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) >>
S [76] ->
Q [84] << (all i~quantity whole
  in 1..num_samples 
  are (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 641:
Theorem (641) [serial 2059] used for:
    normalization of [serial 2057]
 


Theorem (643)                               [serial 2055] 
P [76] << not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) >>
S [76] ->
Q [84] << SHFT() >>
by Substitution of Assertion Labels
and theorem 642:
Theorem (642) [serial 2057] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 2055]
 


Theorem (644)                               [serial 2056] 
P [76] << not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) >>
S [76] ->
Q [84] << not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (645)                               [serial 1959] 
P [76] << not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) >>
S [76] ->
Q [84] << SHFT() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 643 644:
Theorem (643) [serial 2055] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1959]
 
Theorem (644) [serial 2056] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1959]
 


Theorem (646)                               [serial 1924] 
P [76] << (all i~quantity whole
  in 1..num_samples 
  are (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) ) and 
(not ((MOTION_ARTIFACT)^0 or not (SENSOR_CONNECTED)^0)) >>
S [76] ->
Q [84] << SHFT() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 645:
Theorem (645) [serial 1959] used for:
    normalization of [serial 1924]
 


Theorem (647)                               [serial 2065] 
P [84] << SHFT() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [85] ->
Q [87] << true >>
by True Conclusion Schema (tc): P->true


Theorem (648)                               [serial 2064] 
P [84] << SHFT() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [85] ->
Q [87] << SPO2^0 = SPO2^0 >>
by Equality Law (idistr):  a=a <-> true
and theorem 647:
Theorem (647) [serial 2065] used for:
  Equality Law (idistr):  a=a <-> true [serial 2064]
 


Theorem (649)                               [serial 2061] 
P [84] << SHFT() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [85] ->
Q [87] << SPO2^0 = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) >>
by Conditional False Expression:  not b and x=g  iff  not b and x=(b??e:g) 
and theorem 648:
Theorem (648) [serial 2064] used for:
   Conditional False Expression:  not b and x=g  iff  not b and x=(b??e:g)  [serial 2061]
 


Theorem (650)                               [serial 2062] 
P [84] << SHFT() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [85] ->
Q [86] << SHFT() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (651)                               [serial 2063] 
P [84] << SHFT() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [85] ->
Q [86] << not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (652)                               [serial 1961] 
P [84] << SHFT() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [85] ->
Q [86] << SPO2^0 = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) and 
SHFT() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 649 650 651:
Theorem (649) [serial 2061] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1961]
 
Theorem (650) [serial 2062] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1961]
 
Theorem (651) [serial 2063] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1961]
 


Theorem (653)                               [serial 1935] 
P [84] << SHFT() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [85] ->
Q [86] << SHFT() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and ((((SPO2)^0) = (if 
MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 652:
Theorem (652) [serial 1961] used for:
    normalization of [serial 1935]
 


Theorem (654)                               [serial 1925] 
P [84] << SHFT() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [85] spo2_nxt[1] := SpO2?
Q [86] << SHFT() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and ((spo2_nxt[1] = (if 
MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 653:
Theorem (653) [serial 1935] used for:
  applied wp for assignment [serial 1925]
 


Theorem (655)                               [serial 2066] 
P [86] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
SHFT() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [76] ->
Q [89] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (656)                               [serial 2076] 
P [86] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 0..-1 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      2 + i] ) >>
S [76] ->
Q [90] << all i~quantity whole
  in 0..-1 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      2 + i]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (657)                               [serial 2074] 
P [86] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 0..-1 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      1 + i + 1] ) >>
S [76] ->
Q [90] << all i~quantity whole
  in 0..-1 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      2 + i]  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 656:
Theorem (656) [serial 2076] used for:
    normalization of [serial 2074]
 


Theorem (658)                               [serial 2072] 
P [86] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 0..-1 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      1 + (1 + i)] ) >>
S [76] ->
Q [90] << all i~quantity whole
  in 0..-1 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      2 + i]  >>
by Associativity: (b.c).a = a.b.c
and theorem 657:
Theorem (657) [serial 2074] used for:
  Associativity: (b.c).a = a.b.c [serial 2072]
 


Theorem (659)                               [serial 2070] 
P [86] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
(all i~quantity whole
  in 0..(num_samples +  -1) 
  are (spo2_nxt[(i + 1) + 1] = (if MOTION_ARTIFACT^((- i+- 1)) or not SENSOR_CONNECTED^((- i+- 1)) then 0 else SPO2^((- i+- 1)))) ) and 
not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [76] ->
Q [90] << (all i~quantity whole
  in 0..(1 + num_samples +  -2) 
  are (if MOTION_ARTIFACT^(1+- i+- 2) or not SENSOR_CONNECTED^(1+- i+- 2) then 0 else SPO2^(1+- i+- 2)) = spo2_nxt[(
      i + 2)] ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 658:
Theorem (658) [serial 2072] used for:
    normalization of [serial 2070]
 


Theorem (660)                               [serial 2069] 
P [86] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
(all i~quantity whole
  in 0..(num_samples - 1) 
  are (spo2_nxt[(i + 1) + 1] = (if MOTION_ARTIFACT^(- (i+1)) or not SENSOR_CONNECTED^(- (i+1)) then 0 else SPO2^(- (i+1)))) ) and 
not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [76] ->
Q [90] << (all i~quantity whole
  in 0..((1 + num_samples) - 2) 
  are (if MOTION_ARTIFACT^(1-(i+2)) or not SENSOR_CONNECTED^(1-(i+2)) then 0 else SPO2^(1-(i+2))) = spo2_nxt[(
      i + 2)] ) >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 659:
Theorem (659) [serial 2070] used for:
   changing adding negation to subtraction  [serial 2069]
 


Theorem (661)                               [serial 2068] 
P [86] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
(all i~quantity whole
  in 1..num_samples 
  are (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) ) and 
not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [76] ->
Q [90] << (all i~quantity whole
  in 2..1 + num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] ) >>
by Shift Quantification Range so Lower Bound is Zero
and theorem 660:
Theorem (660) [serial 2069] used for:
  Shift Quantification Range so Lower Bound is Zero [serial 2068]
 


Theorem (662)                               [serial 2067] 
P [86] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
SHFT() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [76] ->
Q [90] << (all i~quantity whole
  in 2..1 + num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] ) >>
by Substitution of Assertion Labels
and theorem 661:
Theorem (661) [serial 2068] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2067]
 


Theorem (663)                               [serial 1963] 
P [86] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
SHFT() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [76] ->
Q [89] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
(all i~quantity whole
  in 2..1 + num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] ) >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 655 662:
Theorem (655) [serial 2066] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1963]
 
Theorem (662) [serial 2067] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1963]
 


Theorem (664)                               [serial 1926] 
P [86] << SHFT() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and ((spo2_nxt[1] = (if 
MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) >>
S [76] ->
Q [89] << ((spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) and 
(all i~quantity whole
  in 2..(num_samples + 1) 
  are (spo2_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 663:
Theorem (663) [serial 1963] used for:
    normalization of [serial 1926]
 


Theorem (665)                               [serial 1915] 
P [73] << all i~quantity whole
  in 1..num_samples 
  are (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)))  >>
S [76] if 
(MotionArtifact? or not SensorConnected?)~> 
  << SHFT() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
  spo2_nxt[1] := 0
  << SHFT() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and ((spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) >> 
[]
(not (MotionArtifact? or not SensorConnected?))~> 
  << SHFT() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
  spo2_nxt[1] := SpO2?
  << SHFT() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and ((spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) >> 
fi
Q [89] << ((spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) and 
(all i~quantity whole
  in 2..(num_samples + 1) 
  are (spo2_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) ) >>
by Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>> (bl.iffi)
and theorems 618 622 630 640 646 654 664:
Theorem (618) [serial 1920] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>>  in if-[]-fi  for [serial 1915]
 
Theorem (622) [serial 1921] used for:
    <<P and B0>> -> <<P0>>  for [serial 1915]
 
Theorem (630) [serial 1922] used for:
    <<P0>> S0 <<Q0>>  for [serial 1915]
 
Theorem (640) [serial 1923] used for:
    <<Q0>> -> <<Q>>  for [serial 1915]
 
Theorem (646) [serial 1924] used for:
    <<P and B1>> -> <<P1>>  for [serial 1915]
 
Theorem (654) [serial 1925] used for:
    <<P1>> S1 <<Q1>>  for [serial 1915]
 
Theorem (664) [serial 1926] used for:
    <<Q1>> -> <<Q>>  for [serial 1915]
 


Theorem (666)                               [serial 2078] 
P [94] << all i~quantity whole
  in 1..1 + num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i]  >>
S [93] ->
Q [94] << all i~quantity whole
  in 1..1 + num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i]  >>
by Identity (id):  P->P is tautology


Theorem (667)                               [serial 1965] 
P [89] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
(all i~quantity whole
  in 2..1 + num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] ) >>
S [93] ->
Q [94] << all i~quantity whole
  in 1..1 + num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i]  >>
by Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
and theorem 666:
Theorem (666) [serial 2078] used for:
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j) [serial 1965]
 


Theorem (668)                               [serial 1936] 
P [89] << ((spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) and 
(all i~quantity whole
  in 2..(num_samples + 1) 
  are (spo2_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) ) >>
S [93] ->
Q [94] << all i~quantity whole
  in 1..(num_samples + 1) 
  are (spo2_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)))  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 667:
Theorem (667) [serial 1965] used for:
    normalization of [serial 1936]
 


Theorem (669)                               [serial 1916] 
P [89] << ((spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) and 
(all i~quantity whole
  in 2..(num_samples + 1) 
  are (spo2_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) ) >>
S [93] num_samples := num_samples + 1
Q [94] << all i~quantity whole
  in 1..num_samples 
  are (spo2_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)))  >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 668:
Theorem (668) [serial 1936] used for:
  applied wp for assignment [serial 1916]
 


Theorem (670)                               [serial 1969] 
P [98] << (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] >>
S [99] ->
Q [100] << (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] >>
by Identity (id):  P->P is tautology


Theorem (671)                               [serial 1937] 
P [98] << (spo2_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) >>
S [99] ->
Q [100] << ((spo2_nxt[i]) = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 670:
Theorem (670) [serial 1969] used for:
    normalization of [serial 1937]
 


Theorem (672)                               [serial 1927] 
P [98] << (spo2_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) >>
S [99] spo2_a[i] := spo2_nxt[i]
Q [100] << (spo2_a[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 671:
Theorem (671) [serial 1937] used for:
  applied wp for assignment [serial 1927]
 


Theorem (673)                               [serial 1967] 
P [94] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i]  >>
S [96] ->
Q [102] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i]  >>
by Identity (id):  P->P is tautology


Theorem (674)                               [serial 1928] 
P [94] << (all i~quantity whole
  in 1..num_samples 
  are (spo2_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) ) >>
S [96] ->
Q [102] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i]  >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 673:
Theorem (673) [serial 1967] used for:
    normalization of [serial 1928]
 


Theorem (675)                               [serial 1917] 
P [94] << all i~quantity whole
  in 1..num_samples 
  are (spo2_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)))  >>
S [96] forall i in 1..num_samples
  {
  << (spo2_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) >>
  spo2_a[i] := spo2_nxt[i]
  << (spo2_a[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) >>
  }  
Q [102] << all i~quantity whole
  in 1..num_samples 
  are (spo2_a[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)))  >>
by Universal Quantification Rule:
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any (bl.ulq)
and theorems 672 674:
Theorem (672) [serial 1927] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 1917]
 
Theorem (674) [serial 1928] used for:
    <<P and (x=e) and FAT>> -> <<wp(forall,Q)>>
 where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
   (in postcondition Q, replace all occurances of
    <<all z:i in r are B>> with <<all z:i in r are A>>)
  for [serial 1917]
 


Theorem (676)                               [serial 1028] 
P [47] << SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) >>
S [58] << SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and AXIOM_NS() >>
SpO2Trend!(spo2_a)
;
<< SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and AXIOM_NS() >>
NumSamples!(num_samples)
;
<< SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) >>
forall i in 1..num_samples
  {
  << (spo2_a[i] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) >>
  spo2_nxt[i + 1] := spo2_a[i]
  << (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) >>
  }  
<< SHFT: :all i~quantity whole
  in 1..num_samples 
  are (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)))  >>
;
if 
(MotionArtifact? or not SensorConnected?)~> 
  << SHFT() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
  spo2_nxt[1] := 0
  << SHFT() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and ((spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) >> 
[]
(not (MotionArtifact? or not SensorConnected?))~> 
  << SHFT() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
  spo2_nxt[1] := SpO2?
  << SHFT() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and ((spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) >> 
fi
<< ((spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) and (all i~quantity whole
  in 2..(num_samples + 1) 
  are (spo2_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) ) >>
;
num_samples := num_samples + 1
<< all i~quantity whole
  in 1..num_samples 
  are (spo2_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)))  >>
;
forall i in 1..num_samples
  {
  << (spo2_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) >>
  spo2_a[i] := spo2_nxt[i]
  << (spo2_a[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) >>
  }  
<< all i~quantity whole
  in 1..num_samples 
  are (spo2_a[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)))  >>
Q [49] << HOLD(num_samples) >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 560 565 592 606 615 665 669 675:
Theorem (560) [serial 1910] used for:
  P -> P1 in sequential composition for [serial 1028]
 
Theorem (565) [serial 1911] used for:
  Q5 -> Q in sequential composition for [serial 1028]
 
Theorem (592) [serial 1912] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1028]
 
Theorem (606) [serial 1913] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]
 
Theorem (615) [serial 1914] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028]
 
Theorem (665) [serial 1915] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1028]
 
Theorem (669) [serial 1916] used for:
  <<Q3 and P4>> S4 <<Q4 and P5>> in sequential composition for [serial 1028]
 
Theorem (675) [serial 1917] used for:
  <<Q4 and P5>> S5 <<Q5>> in sequential composition for [serial 1028]
 


Theorem (677)                               [serial 2121] 
P [49] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] ->
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Identity (id):  P->P is tautology


Theorem (678)                               [serial 2123] 
P [49] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] ->
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Identity (id):  P->P is tautology


Theorem (679)                               [serial 2119] 
P [49] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] ->
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorems 677 678:
Theorem (677) [serial 2121] used for:
    normalization of [serial 2119]
 
Theorem (678) [serial 2123] used for:
    normalization of [serial 2119]
 


Theorem (680)                               [serial 2116] 
P [49] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are spo2_a[s]^1 = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Simultaneous Assignment
and theorem 679:
Theorem (679) [serial 2119] used for:
  applied wp for simultaneous assignment [serial 2116]
 


Theorem (681)                               [serial 2114] 
P [49] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are spo2_a[s]^1 = (if MOTION_ARTIFACT^(1-s) or not (SENSOR_CONNECTED^(- s))^1 then 0 else SPO2^(1-s)) ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Caret Compostition:  (x^a)^b is x^(a+b)
    Associativity: (b.c).a = a.b.c
and theorem 680:
Theorem (680) [serial 2116] used for:
    normalization of [serial 2114]
 


Theorem (682)                               [serial 2112] 
P [49] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are spo2_a[s]^1 = (if MOTION_ARTIFACT^(1-s) or (not SENSOR_CONNECTED^(- s))^1 then 0 else SPO2^(1-s)) ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 681:
Theorem (681) [serial 2114] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2112]
 


Theorem (683)                               [serial 2110] 
P [49] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are spo2_a[s]^1 = (if (MOTION_ARTIFACT^((- s)+1) or (not SENSOR_CONNECTED^(- s))^1) then 0 else SPO2^(1-s)) ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Associativity: (b.c).a = a.b.c
and theorem 682:
Theorem (682) [serial 2112] used for:
    normalization of [serial 2110]
 


Theorem (684)                               [serial 2108] 
P [49] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are spo2_a[s]^1 = (if (MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s))^1 then 0 else SPO2^(1-s)) ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 683:
Theorem (683) [serial 2110] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2108]
 


Theorem (685)                               [serial 2106] 
P [49] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are (if (MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s))^1 then (0)^1 else SPO2^((- s)+1)) = spo2_a[s]^1 ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
    Associativity: (b.c).a = a.b.c
and theorem 684:
Theorem (684) [serial 2108] used for:
    normalization of [serial 2106]
 


Theorem (686)                               [serial 2104] 
P [49] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))^1 = spo2_a[s]^1 ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 685:
Theorem (685) [serial 2106] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2104]
 


Theorem (687)                               [serial 2102] 
P [49] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are (((if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)))^1 = (spo2_a[s])^1) ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 686:
Theorem (686) [serial 2104] used for:
    normalization of [serial 2102]
 


Theorem (688)                               [serial 2100] 
P [49] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are ((if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s])^1 ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 687:
Theorem (687) [serial 2102] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2100]
 


Theorem (689)                               [serial 2098] 
P [49] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are ((if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s])^1 ) and 
((num_samples)^1 < (#PulseOx_Properties::Num_Trending_Samples)^1) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
and theorem 688:
Theorem (688) [serial 2100] used for:
    normalization of [serial 2098]
 


Theorem (690)                               [serial 2096] 
P [49] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] )^1 and 
(num_samples < #PulseOx_Properties::Num_Trending_Samples)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 689:
Theorem (689) [serial 2098] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2096]
 


Theorem (691)                               [serial 2094] 
P [49] << ((all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s))) )) and 
((num_samples < #PulseOx_Properties::Num_Trending_Samples)) >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ((all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) )^1 and 
((num_samples < #PulseOx_Properties::Num_Trending_Samples))^1) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 690:
Theorem (690) [serial 2096] used for:
    normalization of [serial 2094]
 


Theorem (692)                               [serial 2093] 
P [49] << ((all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s))) )) and 
((num_samples < #PulseOx_Properties::Num_Trending_Samples)) >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << ((all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ) and 
((num_samples < #PulseOx_Properties::Num_Trending_Samples)))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 691:
Theorem (691) [serial 2094] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2093]
 


Theorem (693)                               [serial 1029] 
P [49] << (HOLD(num_samples)) and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) >>
S [105] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [47] << (SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)))^1 >>
by Substitution of Assertion Labels
and theorem 692:
Theorem (692) [serial 2093] used for:
  substituted Assertions' predicates for  labels  [serial 1029]
 


Theorem (694)                               [serial 2154] 
P [49] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) >>
S [107] ->
Q [51] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) >>
by Identity (id):  P->P is tautology


Theorem (695)                               [serial 2156] 
P [49] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) >>
S [107] ->
Q [51] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) >>
by Identity (id):  P->P is tautology


Theorem (696)                               [serial 2152] 
P [49] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) >>
S [107] ->
Q [51] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are spo2_a[s] = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorems 694 695:
Theorem (694) [serial 2154] used for:
    normalization of [serial 2152]
 
Theorem (695) [serial 2156] used for:
    normalization of [serial 2152]
 


Theorem (697)                               [serial 2149] 
P [49] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are spo2_a[s]^1 = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) ) >>
by Simultaneous Assignment
and theorem 696:
Theorem (696) [serial 2152] used for:
  applied wp for simultaneous assignment [serial 2149]
 


Theorem (698)                               [serial 2147] 
P [49] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are spo2_a[s]^1 = (if MOTION_ARTIFACT^(1-s) or not (SENSOR_CONNECTED^(- s))^1 then 0 else SPO2^(1-s)) ) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Caret Compostition:  (x^a)^b is x^(a+b)
    Associativity: (b.c).a = a.b.c
and theorem 697:
Theorem (697) [serial 2149] used for:
    normalization of [serial 2147]
 


Theorem (699)                               [serial 2145] 
P [49] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are spo2_a[s]^1 = (if MOTION_ARTIFACT^(1-s) or (not SENSOR_CONNECTED^(- s))^1 then 0 else SPO2^(1-s)) ) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 698:
Theorem (698) [serial 2147] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2145]
 


Theorem (700)                               [serial 2143] 
P [49] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are spo2_a[s]^1 = (if (MOTION_ARTIFACT^((- s)+1) or (not SENSOR_CONNECTED^(- s))^1) then 0 else SPO2^(1-s)) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Associativity: (b.c).a = a.b.c
and theorem 699:
Theorem (699) [serial 2145] used for:
    normalization of [serial 2143]
 


Theorem (701)                               [serial 2141] 
P [49] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are spo2_a[s]^1 = (if (MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s))^1 then 0 else SPO2^(1-s)) ) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 700:
Theorem (700) [serial 2143] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2141]
 


Theorem (702)                               [serial 2139] 
P [49] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if (MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s))^1 then (0)^1 else SPO2^((- s)+1)) = spo2_a[s]^1 ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
    Associativity: (b.c).a = a.b.c
and theorem 701:
Theorem (701) [serial 2141] used for:
    normalization of [serial 2139]
 


Theorem (703)                               [serial 2137] 
P [49] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))^1 = spo2_a[s]^1 ) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 702:
Theorem (702) [serial 2139] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2137]
 


Theorem (704)                               [serial 2135] 
P [49] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (((if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)))^1 = (spo2_a[s])^1) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 703:
Theorem (703) [serial 2137] used for:
    normalization of [serial 2135]
 


Theorem (705)                               [serial 2133] 
P [49] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are ((if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s])^1 ) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 704:
Theorem (704) [serial 2135] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2133]
 


Theorem (706)                               [serial 2131] 
P [49] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ((num_samples)^1 = (#PulseOx_Properties::Num_Trending_Samples)^1) and 
(all s~quantity whole
  in 1..num_samples 
  are ((if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s])^1 ) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
and theorem 705:
Theorem (705) [serial 2133] used for:
    normalization of [serial 2131]
 


Theorem (707)                               [serial 2129] 
P [49] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) = spo2_a[s] ) >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << (num_samples = #PulseOx_Properties::Num_Trending_Samples)^1 and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] )^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 706:
Theorem (706) [serial 2131] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2129]
 


Theorem (708)                               [serial 2127] 
P [49] << ((all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s))) )) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ((all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) )^1 and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples))^1) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 707:
Theorem (707) [serial 2129] used for:
    normalization of [serial 2127]
 


Theorem (709)                               [serial 2126] 
P [49] << ((all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s))) )) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << ((all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 708:
Theorem (708) [serial 2127] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2126]
 


Theorem (710)                               [serial 1030] 
P [49] << (HOLD(num_samples)) and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
S [107] |spo2_a',num_samples' := spo2_a,num_samples|  
Q [51] << (SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)))^1 >>
by Substitution of Assertion Labels
and theorem 709:
Theorem (709) [serial 2126] used for:
  substituted Assertions' predicates for  labels  [serial 1030]
 


Theorem (711)                               [serial 1031] 
P [49] << (HOLD(num_samples)) and ((num_samples > #PulseOx_Properties::Num_Trending_Samples)) >>
S [108] ->
Q [53] << true >>
by True Conclusion Schema (tc): P->true


Theorem (712)                               [serial 2232] 
P [51] << num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV() >>
S [51] ->
Q [111] << num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV() >>
by Identity (id):  P->P is tautology


Theorem (713)                               [serial 2208] 
P [51] << num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV() >>
S [51] ->
Q [111] << num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV() and 
true >>
by Law of And-Simplification:  P and true is P
and theorem 712:
Theorem (712) [serial 2232] used for:
  Law of And-Simplification:  P and true is P [serial 2208]
 


Theorem (714)                               [serial 2178] 
P [51] << SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
S [51] ->
Q [111] << SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and 
true >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 713:
Theorem (713) [serial 2208] used for:
    normalization of [serial 2178]
 


Theorem (715)                               [serial 2232] 
P [51] << num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV() >>
S [51] ->
Q [111] << num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV() >>
by Identity (id):  P->P is tautology


Theorem (716)                               [serial 2208] 
P [51] << num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV() >>
S [51] ->
Q [111] << num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV() and 
true >>
by Law of And-Simplification:  P and true is P
and theorem 715:
Theorem (715) [serial 2232] used for:
  Law of And-Simplification:  P and true is P [serial 2208]
 


Theorem (717)                               [serial 2178] 
P [51] << SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
S [51] ->
Q [111] << SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and 
true >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 716:
Theorem (716) [serial 2208] used for:
    normalization of [serial 2178]
 


Theorem (718)                               [serial 2159] 
P [51] << SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
S [51] ->
Q [111] << SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_NS() >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 717 717:
Theorem (717) [serial 2178] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (717) [serial 2178] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (719)                               [serial 2279] 
P [160] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all #4#~quantity whole
  in 1..num_samples 
  are spo2_a[#4#]^1 = (if MOTION_ARTIFACT^(1-#4#) or not SENSOR_CONNECTED^(1-#4#) then 0 else SPO2^(1-#4#)) ) >>
S [51] ->
Q [21] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all #5#~quantity whole
  in 1..num_samples 
  are spo2_a[#5#]^1 = (if MOTION_ARTIFACT^(1-#5#) or not SENSOR_CONNECTED^(1-#5#) then 0 else SPO2^(1-#5#)) ) >>
by Identity (id):  P->P is tautology


Theorem (720)                               [serial 2276] 
P [160] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are spo2_a[i]^1 = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) ) >>
S [51] ->
Q [21] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are spo2_a[s]^1 = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else SPO2^(1-s)) ) >>
by Replacement of Quantified Variables with #1, #2, etc.
and theorem 719:
Theorem (719) [serial 2279] used for:
  Replacement of Quantified Variables with #1, #2, etc. [serial 2276]
 


Theorem (721)                               [serial 2274] 
P [160] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are spo2_a[i]^1 = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) ) >>
S [51] ->
Q [21] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are spo2_a[s]^1 = (if MOTION_ARTIFACT^(1-s) or not (SENSOR_CONNECTED^(- s))^1 then 0 else SPO2^(1-s)) ) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Caret Compostition:  (x^a)^b is x^(a+b)
    Associativity: (b.c).a = a.b.c
and theorem 720:
Theorem (720) [serial 2276] used for:
    normalization of [serial 2274]
 


Theorem (722)                               [serial 2272] 
P [160] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are spo2_a[i]^1 = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) ) >>
S [51] ->
Q [21] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are spo2_a[s]^1 = (if MOTION_ARTIFACT^(1-s) or (not SENSOR_CONNECTED^(- s))^1 then 0 else SPO2^(1-s)) ) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 721:
Theorem (721) [serial 2274] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2272]
 


Theorem (723)                               [serial 2270] 
P [160] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are spo2_a[i]^1 = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) ) >>
S [51] ->
Q [21] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are spo2_a[s]^1 = (if (MOTION_ARTIFACT^((- s)+1) or (not SENSOR_CONNECTED^(- s))^1) then 0 else SPO2^(1-s)) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Associativity: (b.c).a = a.b.c
and theorem 722:
Theorem (722) [serial 2272] used for:
    normalization of [serial 2270]
 


Theorem (724)                               [serial 2268] 
P [160] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are spo2_a[i]^1 = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) ) >>
S [51] ->
Q [21] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are spo2_a[s]^1 = (if (MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s))^1 then 0 else SPO2^(1-s)) ) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 723:
Theorem (723) [serial 2270] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2268]
 


Theorem (725)                               [serial 2266] 
P [160] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are spo2_a[i]^1 = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) ) >>
S [51] ->
Q [21] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if (MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s))^1 then (0)^1 else SPO2^((- s)+1)) = spo2_a[s]^1 ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
    Associativity: (b.c).a = a.b.c
and theorem 724:
Theorem (724) [serial 2268] used for:
    normalization of [serial 2266]
 


Theorem (726)                               [serial 2264] 
P [160] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are spo2_a[i]^1 = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) ) >>
S [51] ->
Q [21] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))^1 = spo2_a[s]^1 ) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 725:
Theorem (725) [serial 2266] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2264]
 


Theorem (727)                               [serial 2262] 
P [160] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are spo2_a[i]^1 = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) ) >>
S [51] ->
Q [21] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (((if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)))^1 = (spo2_a[s])^1) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 726:
Theorem (726) [serial 2264] used for:
    normalization of [serial 2262]
 


Theorem (728)                               [serial 2260] 
P [160] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are spo2_a[i]^1 = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) ) >>
S [51] ->
Q [21] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are ((if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s])^1 ) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 727:
Theorem (727) [serial 2262] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2260]
 


Theorem (729)                               [serial 2258] 
P [160] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are spo2_a[i]^1 = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) ) >>
S [51] ->
Q [21] << ((num_samples)^1 = (#PulseOx_Properties::Num_Trending_Samples)^1) and 
(all s~quantity whole
  in 1..num_samples 
  are ((if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s])^1 ) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
and theorem 728:
Theorem (728) [serial 2260] used for:
    normalization of [serial 2258]
 


Theorem (730)                               [serial 2256] 
P [160] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are spo2_a[i]^1 = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) ) >>
S [51] ->
Q [21] << (num_samples = #PulseOx_Properties::Num_Trending_Samples)^1 and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] )^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 729:
Theorem (729) [serial 2258] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2256]
 


Theorem (731)                               [serial 2254] 
P [160] << #PulseOx_Properties::Num_Trending_Samples = (num_samples)^1 and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = (spo2_a[i])^1 ) >>
S [51] ->
Q [21] << ((num_samples = #PulseOx_Properties::Num_Trending_Samples)^1 and (all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) )^1) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 730:
Theorem (730) [serial 2256] used for:
    normalization of [serial 2254]
 


Theorem (732)                               [serial 2253] 
P [160] << #PulseOx_Properties::Num_Trending_Samples = num_samples' and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_a[i]' ) >>
S [51] ->
Q [21] << (num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 731:
Theorem (731) [serial 2254] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2253]
 


Theorem (733)                               [serial 2182] 
P [160] << #PulseOx_Properties::Num_Trending_Samples = num_samples' and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_a[i]' ) >>
S [51] ->
Q [21] << (num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV())^1 >>
by Substitution of Assertion Labels
and theorem 732:
Theorem (732) [serial 2253] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 2182]
 


Theorem (734)                               [serial 2160] 
P [160] << (all i~quantity whole
  in 1..num_samples 
  are (spo2_a[i]' = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) ) and 
((num_samples' = #PulseOx_Properties::Num_Trending_Samples)) >>
S [51] ->
Q [21] << (SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)))^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 733:
Theorem (733) [serial 2182] used for:
    normalization of [serial 2160]
 


Theorem (735)                               [serial 2385] 
P [111] << NUM_SAMPLES = num_samples and SPO2_HISTORY = spo2_a and num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) >>
S [113] ->
Q [15] << all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (736)                               [serial 2384] 
P [111] << NUM_SAMPLES = num_samples and SPO2_HISTORY = spo2_a and num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) >>
S [113] ->
Q [15] << all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = SPO2_HISTORY[s]  >>
by Guided Substitution of Equals
and theorem 735:
Theorem (735) [serial 2385] used for:
  Guided Substitution of Equals
 replacing "SPO2_HISTORY" with its = "spo2_a" in its postcondition [serial 2384]
 


Theorem (737)                               [serial 2382] 
P [111] << NUM_SAMPLES = num_samples and SPO2_HISTORY = spo2_a and num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) >>
S [113] ->
Q [15] << all s~quantity whole
  in 1..NUM_SAMPLES 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = SPO2_HISTORY[s]  >>
by Guided Substitution of Equals
and theorem 736:
Theorem (736) [serial 2384] used for:
  Guided Substitution of Equals
 replacing "NUM_SAMPLES" with its = "num_samples" in its postcondition [serial 2382]
 


Theorem (738)                               [serial 2380] 
P [111] << (num_samples = NUM_SAMPLES) and (spo2_a = SPO2_HISTORY) and num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ) >>
S [113] ->
Q [15] << (all s~quantity whole
  in 1..NUM_SAMPLES 
  are (SPO2_HISTORY[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 737:
Theorem (737) [serial 2382] used for:
    normalization of [serial 2380]
 


Theorem (739)                               [serial 2379] 
P [111] << num_samples = #PulseOx_Properties::Num_Trending_Samples and ((num_samples = NUM_SAMPLES) and 
(spo2_a = SPO2_HISTORY)) and (all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ) >>
S [113] ->
Q [15] << (all s~quantity whole
  in 1..NUM_SAMPLES 
  are (SPO2_HISTORY[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ) >>
by Associativity: (b.c).a = a.b.c
and theorem 738:
Theorem (738) [serial 2380] used for:
  Associativity: (b.c).a = a.b.c [serial 2379]
 


Theorem (740)                               [serial 2376] 
P [111] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_NS() and 
SpO2_INV() >>
S [113] ->
Q [15] << SPO2_TREND() >>
by Substitution of Assertion Labels
and theorem 739:
Theorem (739) [serial 2379] used for:
  substituted Assertions' predicates for  labels  [serial 2376]
 


Theorem (741)                               [serial 2378] 
P [113] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_NS() and 
SpO2_INV() and (SPO2_TREND())^0 >>
S [113] ->
Q [115] << num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV() >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (742)                               [serial 2377] 
P [113] << (num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_NS() and 
SpO2_INV()) and (SPO2_TREND())^0 >>
S [113] ->
Q [115] << num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV() >>
by Associativity: (b.c).a = a.b.c
and theorem 741:
Theorem (741) [serial 2378] used for:
  Associativity: (b.c).a = a.b.c [serial 2377]
 


Theorem (743)                               [serial 2233] 
P [111] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_NS() and 
SpO2_INV() >>
S [113] SpO2Trend!(spo2_a)
Q [115] << num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV() >>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 740 742:
Theorem (740) [serial 2376] used for:
  applied port output of value <<pre>> -> <<M(SpO2Trend)[SpO2Trend|spo2_a]>> [serial 2233]
 
Theorem (742) [serial 2377] used for:
  applied port output <<pre and (SPO2_TREND())^0>> -> <<post>> [serial 2233]
 


Theorem (744)                               [serial 2210] 
P [111] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_NS() and 
SpO2_INV() >>
S [113] SpO2Trend!(spo2_a)
Q [115] << num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV() and 
true >>
by Law of And-Simplification:  P and true is P
and theorem 743:
Theorem (743) [serial 2233] used for:
  Law of And-Simplification:  P and true is P [serial 2210]
 


Theorem (745)                               [serial 2179] 
P [111] << SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_NS() >>
S [113] SpO2Trend!(spo2_a)
Q [115] << SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and 
true >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 744:
Theorem (744) [serial 2210] used for:
    normalization of [serial 2179]
 


Theorem (746)                               [serial 2385] 
P [111] << NUM_SAMPLES = num_samples and SPO2_HISTORY = spo2_a and num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) >>
S [113] ->
Q [15] << all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (747)                               [serial 2384] 
P [111] << NUM_SAMPLES = num_samples and SPO2_HISTORY = spo2_a and num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) >>
S [113] ->
Q [15] << all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = SPO2_HISTORY[s]  >>
by Guided Substitution of Equals
and theorem 746:
Theorem (746) [serial 2385] used for:
  Guided Substitution of Equals
 replacing "SPO2_HISTORY" with its = "spo2_a" in its postcondition [serial 2384]
 


Theorem (748)                               [serial 2382] 
P [111] << NUM_SAMPLES = num_samples and SPO2_HISTORY = spo2_a and num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) >>
S [113] ->
Q [15] << all s~quantity whole
  in 1..NUM_SAMPLES 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = SPO2_HISTORY[s]  >>
by Guided Substitution of Equals
and theorem 747:
Theorem (747) [serial 2384] used for:
  Guided Substitution of Equals
 replacing "NUM_SAMPLES" with its = "num_samples" in its postcondition [serial 2382]
 


Theorem (749)                               [serial 2380] 
P [111] << (num_samples = NUM_SAMPLES) and (spo2_a = SPO2_HISTORY) and num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ) >>
S [113] ->
Q [15] << (all s~quantity whole
  in 1..NUM_SAMPLES 
  are (SPO2_HISTORY[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 748:
Theorem (748) [serial 2382] used for:
    normalization of [serial 2380]
 


Theorem (750)                               [serial 2379] 
P [111] << num_samples = #PulseOx_Properties::Num_Trending_Samples and ((num_samples = NUM_SAMPLES) and 
(spo2_a = SPO2_HISTORY)) and (all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ) >>
S [113] ->
Q [15] << (all s~quantity whole
  in 1..NUM_SAMPLES 
  are (SPO2_HISTORY[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ) >>
by Associativity: (b.c).a = a.b.c
and theorem 749:
Theorem (749) [serial 2380] used for:
  Associativity: (b.c).a = a.b.c [serial 2379]
 


Theorem (751)                               [serial 2376] 
P [111] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_NS() and 
SpO2_INV() >>
S [113] ->
Q [15] << SPO2_TREND() >>
by Substitution of Assertion Labels
and theorem 750:
Theorem (750) [serial 2379] used for:
  substituted Assertions' predicates for  labels  [serial 2376]
 


Theorem (752)                               [serial 2378] 
P [113] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_NS() and 
SpO2_INV() and (SPO2_TREND())^0 >>
S [113] ->
Q [115] << num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV() >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (753)                               [serial 2377] 
P [113] << (num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_NS() and 
SpO2_INV()) and (SPO2_TREND())^0 >>
S [113] ->
Q [115] << num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV() >>
by Associativity: (b.c).a = a.b.c
and theorem 752:
Theorem (752) [serial 2378] used for:
  Associativity: (b.c).a = a.b.c [serial 2377]
 


Theorem (754)                               [serial 2233] 
P [111] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_NS() and 
SpO2_INV() >>
S [113] SpO2Trend!(spo2_a)
Q [115] << num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV() >>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 751 753:
Theorem (751) [serial 2376] used for:
  applied port output of value <<pre>> -> <<M(SpO2Trend)[SpO2Trend|spo2_a]>> [serial 2233]
 
Theorem (753) [serial 2377] used for:
  applied port output <<pre and (SPO2_TREND())^0>> -> <<post>> [serial 2233]
 


Theorem (755)                               [serial 2210] 
P [111] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_NS() and 
SpO2_INV() >>
S [113] SpO2Trend!(spo2_a)
Q [115] << num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV() and 
true >>
by Law of And-Simplification:  P and true is P
and theorem 754:
Theorem (754) [serial 2233] used for:
  Law of And-Simplification:  P and true is P [serial 2210]
 


Theorem (756)                               [serial 2179] 
P [111] << SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_NS() >>
S [113] SpO2Trend!(spo2_a)
Q [115] << SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and 
true >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 755:
Theorem (755) [serial 2210] used for:
    normalization of [serial 2179]
 


Theorem (757)                               [serial 2161] 
P [111] << SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_NS() >>
S [113] SpO2Trend!(spo2_a)
Q [115] << SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_NS() >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 756 756:
Theorem (756) [serial 2179] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (756) [serial 2179] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (758)                               [serial 2388] 
P [117] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_NS() and 
SpO2_INV() and (NumSamples = num_samples)^0 >>
S [117] ->
Q [119] << num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV() >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (759)                               [serial 2386] 
P [117] << (num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_NS() and 
SpO2_INV()) and (NumSamples = num_samples)^0 >>
S [117] ->
Q [119] << num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV() >>
by Associativity: (b.c).a = a.b.c
and theorem 758:
Theorem (758) [serial 2388] used for:
  Associativity: (b.c).a = a.b.c [serial 2386]
 


Theorem (760)                               [serial 2396] 
P [117] << NUM_SAMPLES = num_samples and NumSamples = num_samples and SPO2_HISTORY = spo2_a and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) >>
S [117] ->
Q [117] << NUM_SAMPLES = num_samples >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (761)                               [serial 2395] 
P [117] << NUM_SAMPLES = num_samples and NumSamples = num_samples and SPO2_HISTORY = spo2_a and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) >>
S [117] ->
Q [117] << NUM_SAMPLES = NumSamples >>
by Guided Substitution of Equals
and theorem 760:
Theorem (760) [serial 2396] used for:
  Guided Substitution of Equals
 replacing "NumSamples" with its = "num_samples" in its postcondition [serial 2395]
 


Theorem (762)                               [serial 2393] 
P [117] << (NumSamples = num_samples)^0 and NUM_SAMPLES = num_samples and SPO2_HISTORY = spo2_a and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) >>
S [117] ->
Q [117] << NUM_SAMPLES = NumSamples >>
by Assume Present:  P = P@now = P^0 
and theorem 761:
Theorem (761) [serial 2395] used for:
  Assume Present:  P = P@now = P^0  [serial 2393]
 


Theorem (763)                               [serial 2391] 
P [117] << (num_samples = NUM_SAMPLES) and (spo2_a = SPO2_HISTORY) and num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ) and 
(NumSamples = num_samples)^0 >>
S [117] ->
Q [117] << NumSamples = NUM_SAMPLES >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 762:
Theorem (762) [serial 2393] used for:
    normalization of [serial 2391]
 


Theorem (764)                               [serial 2390] 
P [117] << num_samples = #PulseOx_Properties::Num_Trending_Samples and ((num_samples = NUM_SAMPLES) and 
(spo2_a = SPO2_HISTORY)) and (all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ) and 
(NumSamples = num_samples)^0 >>
S [117] ->
Q [117] << NumSamples = NUM_SAMPLES >>
by Associativity: (b.c).a = a.b.c
and theorem 763:
Theorem (763) [serial 2391] used for:
  Associativity: (b.c).a = a.b.c [serial 2390]
 


Theorem (765)                               [serial 2389] 
P [117] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_NS() and 
SpO2_INV() and (NumSamples = num_samples)^0 >>
S [117] ->
Q [117] << NumSamples = NUM_SAMPLES >>
by Substitution of Assertion Labels
and theorem 764:
Theorem (764) [serial 2390] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2389]
 


Theorem (766)                               [serial 2387] 
P [117] << (num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_NS() and 
SpO2_INV()) and (NumSamples = num_samples)^0 >>
S [117] ->
Q [117] << NumSamples = NUM_SAMPLES >>
by Associativity: (b.c).a = a.b.c
and theorem 765:
Theorem (765) [serial 2389] used for:
  Associativity: (b.c).a = a.b.c [serial 2387]
 


Theorem (767)                               [serial 2234] 
P [115] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_NS() and 
SpO2_INV() >>
S [117] NumSamples!(num_samples)
Q [119] << num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV() >>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 759 766:
Theorem (759) [serial 2386] used for:
  applied port output <<pre and (NumSamples=num_samples)^0>> -> <<post>> [serial 2234]
 
Theorem (766) [serial 2387] used for:
  applied port output <<pre and (NumSamples=num_samples)^0>> -> <<(NumSamples=NUM_SAMPLES)^0>> [serial 2234]
 


Theorem (768)                               [serial 2212] 
P [115] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_NS() and 
SpO2_INV() >>
S [117] NumSamples!(num_samples)
Q [119] << num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV() and 
true >>
by Law of And-Simplification:  P and true is P
and theorem 767:
Theorem (767) [serial 2234] used for:
  Law of And-Simplification:  P and true is P [serial 2212]
 


Theorem (769)                               [serial 2180] 
P [115] << SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_NS() >>
S [117] NumSamples!(num_samples)
Q [119] << SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and 
true >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 768:
Theorem (768) [serial 2212] used for:
    normalization of [serial 2180]
 


Theorem (770)                               [serial 2388] 
P [117] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_NS() and 
SpO2_INV() and (NumSamples = num_samples)^0 >>
S [117] ->
Q [119] << num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV() >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (771)                               [serial 2386] 
P [117] << (num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_NS() and 
SpO2_INV()) and (NumSamples = num_samples)^0 >>
S [117] ->
Q [119] << num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV() >>
by Associativity: (b.c).a = a.b.c
and theorem 770:
Theorem (770) [serial 2388] used for:
  Associativity: (b.c).a = a.b.c [serial 2386]
 


Theorem (772)                               [serial 2396] 
P [117] << NUM_SAMPLES = num_samples and NumSamples = num_samples and SPO2_HISTORY = spo2_a and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) >>
S [117] ->
Q [117] << NUM_SAMPLES = num_samples >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (773)                               [serial 2395] 
P [117] << NUM_SAMPLES = num_samples and NumSamples = num_samples and SPO2_HISTORY = spo2_a and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) >>
S [117] ->
Q [117] << NUM_SAMPLES = NumSamples >>
by Guided Substitution of Equals
and theorem 772:
Theorem (772) [serial 2396] used for:
  Guided Substitution of Equals
 replacing "NumSamples" with its = "num_samples" in its postcondition [serial 2395]
 


Theorem (774)                               [serial 2393] 
P [117] << (NumSamples = num_samples)^0 and NUM_SAMPLES = num_samples and SPO2_HISTORY = spo2_a and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) >>
S [117] ->
Q [117] << NUM_SAMPLES = NumSamples >>
by Assume Present:  P = P@now = P^0 
and theorem 773:
Theorem (773) [serial 2395] used for:
  Assume Present:  P = P@now = P^0  [serial 2393]
 


Theorem (775)                               [serial 2391] 
P [117] << (num_samples = NUM_SAMPLES) and (spo2_a = SPO2_HISTORY) and num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ) and 
(NumSamples = num_samples)^0 >>
S [117] ->
Q [117] << NumSamples = NUM_SAMPLES >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 774:
Theorem (774) [serial 2393] used for:
    normalization of [serial 2391]
 


Theorem (776)                               [serial 2390] 
P [117] << num_samples = #PulseOx_Properties::Num_Trending_Samples and ((num_samples = NUM_SAMPLES) and 
(spo2_a = SPO2_HISTORY)) and (all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ) and 
(NumSamples = num_samples)^0 >>
S [117] ->
Q [117] << NumSamples = NUM_SAMPLES >>
by Associativity: (b.c).a = a.b.c
and theorem 775:
Theorem (775) [serial 2391] used for:
  Associativity: (b.c).a = a.b.c [serial 2390]
 


Theorem (777)                               [serial 2389] 
P [117] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_NS() and 
SpO2_INV() and (NumSamples = num_samples)^0 >>
S [117] ->
Q [117] << NumSamples = NUM_SAMPLES >>
by Substitution of Assertion Labels
and theorem 776:
Theorem (776) [serial 2390] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2389]
 


Theorem (778)                               [serial 2387] 
P [117] << (num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_NS() and 
SpO2_INV()) and (NumSamples = num_samples)^0 >>
S [117] ->
Q [117] << NumSamples = NUM_SAMPLES >>
by Associativity: (b.c).a = a.b.c
and theorem 777:
Theorem (777) [serial 2389] used for:
  Associativity: (b.c).a = a.b.c [serial 2387]
 


Theorem (779)                               [serial 2234] 
P [115] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_NS() and 
SpO2_INV() >>
S [117] NumSamples!(num_samples)
Q [119] << num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV() >>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 771 778:
Theorem (771) [serial 2386] used for:
  applied port output <<pre and (NumSamples=num_samples)^0>> -> <<post>> [serial 2234]
 
Theorem (778) [serial 2387] used for:
  applied port output <<pre and (NumSamples=num_samples)^0>> -> <<(NumSamples=NUM_SAMPLES)^0>> [serial 2234]
 


Theorem (780)                               [serial 2212] 
P [115] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_NS() and 
SpO2_INV() >>
S [117] NumSamples!(num_samples)
Q [119] << num_samples = #PulseOx_Properties::Num_Trending_Samples and SpO2_INV() and 
true >>
by Law of And-Simplification:  P and true is P
and theorem 779:
Theorem (779) [serial 2234] used for:
  Law of And-Simplification:  P and true is P [serial 2212]
 


Theorem (781)                               [serial 2180] 
P [115] << SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_NS() >>
S [117] NumSamples!(num_samples)
Q [119] << SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and 
true >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 780:
Theorem (780) [serial 2212] used for:
    normalization of [serial 2180]
 


Theorem (782)                               [serial 2162] 
P [115] << SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_NS() >>
S [117] NumSamples!(num_samples)
Q [119] << SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_CR() >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 781 781:
Theorem (781) [serial 2180] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (781) [serial 2180] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (783)                               [serial 2293] 
P [123] << (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_a[i] >>
S [124] ->
Q [125] << (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_a[i] >>
by Identity (id):  P->P is tautology


Theorem (784)                               [serial 2291] 
P [123] << (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_a[i] >>
S [124] ->
Q [125] << (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = (spo2_a[i]) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 783:
Theorem (783) [serial 2293] used for:
    normalization of [serial 2291]
 


Theorem (785)                               [serial 2186] 
P [123] << (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_a[i] >>
S [124] spo2_nxt[1 + i] := spo2_a[i]
Q [125] << (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
1 + i] >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 784:
Theorem (784) [serial 2291] used for:
  applied wp for assignment [serial 2186]
 


Theorem (786)                               [serial 2167] 
P [123] << (spo2_a[i] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) >>
S [124] spo2_nxt[i + 1] := spo2_a[i]
Q [125] << (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 785:
Theorem (785) [serial 2186] used for:
    normalization of [serial 2167]
 


Theorem (787)                               [serial 2290] 
P [119] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all #6#~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- #6#) or not SENSOR_CONNECTED^(-1+- #6#) then 0 else SPO2^(-1+- #6#)) = spo2_a[
      1 + #6#] ) and (-2 + num_samples) < (-1 + num_samples) >>
S [121] ->
Q [127] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all #7#~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- #7#) or not SENSOR_CONNECTED^(-1+- #7#) then 0 else SPO2^(-1+- #7#)) = spo2_a[
      1 + #7#] ) >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (788)                               [serial 2289] 
P [119] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- s) or not SENSOR_CONNECTED^(-1+- s) then 0 else SPO2^(-1+- s)) = spo2_a[
      1 + s] ) and (-2 + num_samples) < (-1 + num_samples) >>
S [121] ->
Q [127] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_a[
      1 + i] ) >>
by Replacement of Quantified Variables with #1, #2, etc.
and theorem 787:
Theorem (787) [serial 2290] used for:
  Replacement of Quantified Variables with #1, #2, etc. [serial 2289]
 


Theorem (789)                               [serial 2287] 
P [119] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 0..-1 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- s) or not SENSOR_CONNECTED^(-1+- s) then 0 else SPO2^(-1+- s)) = spo2_a[
      1 + s] ) and (-2 + num_samples) < (-1 + num_samples) >>
S [121] ->
Q [127] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_a[
      1 + i] ) >>
by Contract Universal Quantification Range
and theorem 788:
Theorem (788) [serial 2289] used for:
  Contract Universal Quantification Range [serial 2287]
 


Theorem (790)                               [serial 2285] 
P [119] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 0..(num_samples +  -1) 
  are (if MOTION_ARTIFACT^((- s+- 1)) or not SENSOR_CONNECTED^((- s+- 1)) then 0 else SPO2^((- s+- 1))) = spo2_a[(
      s + 1)] ) and (num_samples +  -2) < (num_samples +  -1) >>
S [121] ->
Q [127] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..(num_samples +  -1 +  -1) 
  are (if MOTION_ARTIFACT^((- i+- 1)) or not SENSOR_CONNECTED^((- i+- 1)) then 0 else SPO2^((- i+- 1))) = spo2_a[(
      i + 1)] ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 789:
Theorem (789) [serial 2287] used for:
    normalization of [serial 2285]
 


Theorem (791)                               [serial 2284] 
P [119] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 0..(num_samples - 1) 
  are (if MOTION_ARTIFACT^(- (s+1)) or not SENSOR_CONNECTED^(- (s+1)) then 0 else SPO2^(- (s+1))) = spo2_a[(
      s + 1)] ) and (num_samples - 2) < (num_samples - 1) >>
S [121] ->
Q [127] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..((num_samples - 1) - 1) 
  are (if MOTION_ARTIFACT^(- (i+1)) or not SENSOR_CONNECTED^(- (i+1)) then 0 else SPO2^(- (i+1))) = spo2_a[(
      i + 1)] ) >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 790:
Theorem (790) [serial 2285] used for:
   changing adding negation to subtraction  [serial 2284]
 


Theorem (792)                               [serial 2282] 
P [119] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s)) = spo2_a[s] ) and 
(num_samples - 2) < (num_samples - 1) >>
S [121] ->
Q [127] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_a[i] ) >>
by Shift Quantification Range so Lower Bound is Zero
and theorem 791:
Theorem (791) [serial 2284] used for:
  Shift Quantification Range so Lower Bound is Zero [serial 2282]
 


Theorem (793)                               [serial 2280] 
P [119] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (((num_samples - 2) < (num_samples - 1))) and 
(all s~quantity whole
  in 1..num_samples 
  are (spo2_a[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else SPO2^(- s))) ) >>
S [121] ->
Q [127] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_a[i] ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 792:
Theorem (792) [serial 2282] used for:
    normalization of [serial 2280]
 


Theorem (794)                               [serial 2184] 
P [119] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_CR() and 
SpO2_INV() >>
S [121] ->
Q [127] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_a[i] ) >>
by Substitution of Assertion Labels
and theorem 793:
Theorem (793) [serial 2280] used for:
  substituted Assertions' predicates for  labels  [serial 2184]
 


Theorem (795)                               [serial 2168] 
P [119] << (SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_CR()) >>
S [121] ->
Q [127] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_a[i] ) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 794:
Theorem (794) [serial 2184] used for:
    normalization of [serial 2168]
 


Theorem (796)                               [serial 2163] 
P [119] << SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_CR() >>
S [121] forall i in 1..(num_samples - 1)
  {
  << (spo2_a[i] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) >>
  spo2_nxt[i + 1] := spo2_a[i]
  << (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) >>
  }  
Q [127] << (all i~quantity whole
  in 1..(num_samples - 1) 
  are (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
by Universal Quantification Rule:
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any (bl.ulq)
and theorems 786 795:
Theorem (786) [serial 2167] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 2163]
 
Theorem (795) [serial 2168] used for:
    <<P and (x=e) and FAT>> -> <<wp(forall,Q)>>
 where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
   (in postcondition Q, replace all occurances of
    <<all z:i in r are B>> with <<all z:i in r are A>>)
  for [serial 2163]
 


Theorem (797)                               [serial 2229] 
P [127] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) >>
S [131] ->
Q [131] << true >>
by True Conclusion Schema (tc): P->true


Theorem (798)                               [serial 2188] 
P [127] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) >>
S [131] ->
Q [131] << not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) or (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) >>
by Law of Excluded Middle: P or not P is tautology
and theorem 797:
Theorem (797) [serial 2229] used for:
  Law of Excluded Middle: P or not P is tautology [serial 2188]
 


Theorem (799)                               [serial 2169] 
P [127] << (all i~quantity whole
  in 1..(num_samples - 1) 
  are (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
S [131] ->
Q [131] << ((MOTION_ARTIFACT)^0 or not (SENSOR_CONNECTED)^0) or (not ((MOTION_ARTIFACT)^0 or 
not (SENSOR_CONNECTED)^0)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 798:
Theorem (798) [serial 2188] used for:
    normalization of [serial 2169]
 


Theorem (800)                               [serial 2374] 
P [131] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [131] ->
Q [133] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (801)                               [serial 2372] 
P [131] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [131] ->
Q [133] << ((all i~quantity whole
  in 1..(num_samples - 1) 
  are (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples))) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 800:
Theorem (800) [serial 2374] used for:
    normalization of [serial 2372]
 


Theorem (802)                               [serial 2370] 
P [131] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [131] ->
Q [133] << SHFTR() >>
by Substitution of Assertion Labels
and theorem 801:
Theorem (801) [serial 2372] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 2370]
 


Theorem (803)                               [serial 2371] 
P [131] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [131] ->
Q [133] << (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (804)                               [serial 2230] 
P [131] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [131] ->
Q [133] << SHFTR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 802 803:
Theorem (802) [serial 2370] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2230]
 
Theorem (803) [serial 2371] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2230]
 


Theorem (805)                               [serial 2190] 
P [131] << (num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] )) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [131] ->
Q [133] << SHFTR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Associativity: (b.c).a = a.b.c
and theorem 804:
Theorem (804) [serial 2230] used for:
  Associativity: (b.c).a = a.b.c [serial 2190]
 


Theorem (806)                               [serial 2170] 
P [131] << ((all i~quantity whole
  in 1..(num_samples - 1) 
  are (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples))) and ((MOTION_ARTIFACT)^0 or 
not (SENSOR_CONNECTED)^0) >>
S [131] ->
Q [133] << SHFTR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 805:
Theorem (805) [serial 2190] used for:
    normalization of [serial 2170]
 


Theorem (807)                               [serial 2300] 
P [133] << SHFTR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [134] ->
Q [136] << true >>
by True Conclusion Schema (tc): P->true


Theorem (808)                               [serial 2299] 
P [133] << SHFTR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [134] ->
Q [136] << 0 = 0 >>
by Equality Law (idistr):  a=a <-> true
and theorem 807:
Theorem (807) [serial 2300] used for:
  Equality Law (idistr):  a=a <-> true [serial 2299]
 


Theorem (809)                               [serial 2296] 
P [133] << SHFTR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [134] ->
Q [136] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = 0 >>
by Conditional True Expression:  b and x=e  iff  b and x=(b??e:g) 
and theorem 808:
Theorem (808) [serial 2299] used for:
   Conditional True Expression:  b and x=e  iff  b and x=(b??e:g)  [serial 2296]
 


Theorem (810)                               [serial 2297] 
P [133] << SHFTR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [134] ->
Q [135] << SHFTR() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (811)                               [serial 2298] 
P [133] << SHFTR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [134] ->
Q [135] << (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (812)                               [serial 2295] 
P [133] << SHFTR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [134] ->
Q [135] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = 0 and 
SHFTR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 809 810 811:
Theorem (809) [serial 2296] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2295]
 
Theorem (810) [serial 2297] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2295]
 
Theorem (811) [serial 2298] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2295]
 


Theorem (813)                               [serial 2192] 
P [133] << SHFTR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [134] spo2_nxt[1] := 0
Q [135] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
SHFTR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 812:
Theorem (812) [serial 2295] used for:
  applied wp for assignment [serial 2192]
 


Theorem (814)                               [serial 2171] 
P [133] << SHFTR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [134] spo2_nxt[1] := 0
Q [135] << SHFTR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and ((spo2_nxt[1] = (if 
MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 813:
Theorem (813) [serial 2192] used for:
    normalization of [serial 2171]
 


Theorem (815)                               [serial 2305] 
P [135] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
(num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] )) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [131] ->
Q [144] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (816)                               [serial 2321] 
P [135] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      2 + i] ) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [131] ->
Q [145] << num_samples = #PulseOx_Properties::Num_Trending_Samples >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (817)                               [serial 2318] 
P [135] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      1 + i + 1] ) and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
(MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [131] ->
Q [145] << num_samples = #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 816:
Theorem (816) [serial 2321] used for:
    normalization of [serial 2318]
 


Theorem (818)                               [serial 2313] 
P [135] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
(num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      1 + (1 + i)] )) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [131] ->
Q [145] << num_samples = #PulseOx_Properties::Num_Trending_Samples >>
by Associativity: (b.c).a = a.b.c
and theorem 817:
Theorem (817) [serial 2318] used for:
  Associativity: (b.c).a = a.b.c [serial 2313]
 


Theorem (819)                               [serial 2310] 
P [135] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
(num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..(num_samples +  -1 +  -1) 
  are (if MOTION_ARTIFACT^((- i+- 1)) or not SENSOR_CONNECTED^((- i+- 1)) then 0 else SPO2^((- i+- 1))) = spo2_nxt[
      1 + (i + 1)] )) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [131] ->
Q [145] << num_samples = #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 818:
Theorem (818) [serial 2313] used for:
    normalization of [serial 2310]
 


Theorem (820)                               [serial 2308] 
P [135] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
(num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..((num_samples - 1) - 1) 
  are (if MOTION_ARTIFACT^(- (i+1)) or not SENSOR_CONNECTED^(- (i+1)) then 0 else SPO2^(- (i+1))) = spo2_nxt[
      1 + (i + 1)] )) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [131] ->
Q [145] << num_samples = #PulseOx_Properties::Num_Trending_Samples >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 819:
Theorem (819) [serial 2310] used for:
   changing adding negation to subtraction  [serial 2308]
 


Theorem (821)                               [serial 2306] 
P [135] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
(num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] )) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [131] ->
Q [145] << num_samples = #PulseOx_Properties::Num_Trending_Samples >>
by Shift Quantification Range so Lower Bound is Zero
and theorem 820:
Theorem (820) [serial 2308] used for:
  Shift Quantification Range so Lower Bound is Zero [serial 2306]
 


Theorem (822)                               [serial 2323] 
P [135] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      2 + i] ) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [131] ->
Q [146] << all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      2 + i]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (823)                               [serial 2319] 
P [135] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      1 + i + 1] ) and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
(MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [131] ->
Q [146] << all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      2 + i]  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 822:
Theorem (822) [serial 2323] used for:
    normalization of [serial 2319]
 


Theorem (824)                               [serial 2315] 
P [135] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
(num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      1 + (1 + i)] )) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [131] ->
Q [146] << all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      2 + i]  >>
by Associativity: (b.c).a = a.b.c
and theorem 823:
Theorem (823) [serial 2319] used for:
  Associativity: (b.c).a = a.b.c [serial 2315]
 


Theorem (825)                               [serial 2311] 
P [135] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
(num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..(num_samples +  -1 +  -1) 
  are (if MOTION_ARTIFACT^((- i+- 1)) or not SENSOR_CONNECTED^((- i+- 1)) then 0 else SPO2^((- i+- 1))) = spo2_nxt[
      1 + (i + 1)] )) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [131] ->
Q [146] << (all i~quantity whole
  in 0..(num_samples +  -2) 
  are (if MOTION_ARTIFACT^(1+- i+- 2) or not SENSOR_CONNECTED^(1+- i+- 2) then 0 else SPO2^(1+- i+- 2)) = spo2_nxt[(
      i + 2)] ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 824:
Theorem (824) [serial 2315] used for:
    normalization of [serial 2311]
 


Theorem (826)                               [serial 2309] 
P [135] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
(num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..((num_samples - 1) - 1) 
  are (if MOTION_ARTIFACT^(- (i+1)) or not SENSOR_CONNECTED^(- (i+1)) then 0 else SPO2^(- (i+1))) = spo2_nxt[
      1 + (i + 1)] )) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [131] ->
Q [146] << (all i~quantity whole
  in 0..(num_samples - 2) 
  are (if MOTION_ARTIFACT^(1-(i+2)) or not SENSOR_CONNECTED^(1-(i+2)) then 0 else SPO2^(1-(i+2))) = spo2_nxt[(
      i + 2)] ) >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 825:
Theorem (825) [serial 2311] used for:
   changing adding negation to subtraction  [serial 2309]
 


Theorem (827)                               [serial 2307] 
P [135] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
(num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] )) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [131] ->
Q [146] << (all i~quantity whole
  in 2..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] ) >>
by Shift Quantification Range so Lower Bound is Zero
and theorem 826:
Theorem (826) [serial 2309] used for:
  Shift Quantification Range so Lower Bound is Zero [serial 2307]
 


Theorem (828)                               [serial 2303] 
P [135] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
(num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] )) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [131] ->
Q [144] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 2..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] ) >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 815 821 827:
Theorem (815) [serial 2305] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2303]
 
Theorem (821) [serial 2306] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2303]
 
Theorem (827) [serial 2307] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2303]
 


Theorem (829)                               [serial 2301] 
P [135] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
((all i~quantity whole
  in 1..(num_samples - 1) 
  are (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples))) and (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) >>
S [131] ->
Q [144] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 2..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 828:
Theorem (828) [serial 2303] used for:
    normalization of [serial 2301]
 


Theorem (830)                               [serial 2194] 
P [135] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
SHFTR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [131] ->
Q [144] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 2..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] ) >>
by Substitution of Assertion Labels
and theorem 829:
Theorem (829) [serial 2301] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2194]
 


Theorem (831)                               [serial 2172] 
P [135] << SHFTR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and ((spo2_nxt[1] = (if 
MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) >>
S [131] ->
Q [144] << ((spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and (all i~quantity whole
  in 2..num_samples 
  are (spo2_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 830:
Theorem (830) [serial 2194] used for:
    normalization of [serial 2172]
 


Theorem (832)                               [serial 2403] 
P [131] << num_samples = #PulseOx_Properties::Num_Trending_Samples and not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) >>
S [131] ->
Q [139] << num_samples = #PulseOx_Properties::Num_Trending_Samples and not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) >>
by Identity (id):  P->P is tautology


Theorem (833)                               [serial 2401] 
P [131] << num_samples = #PulseOx_Properties::Num_Trending_Samples and not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) >>
S [131] ->
Q [139] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 832:
Theorem (832) [serial 2403] used for:
    normalization of [serial 2401]
 


Theorem (834)                               [serial 2399] 
P [131] << num_samples = #PulseOx_Properties::Num_Trending_Samples and not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) >>
S [131] ->
Q [139] << not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and (num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] )) >>
by Associativity: (b.c).a = a.b.c
and theorem 833:
Theorem (833) [serial 2401] used for:
  Associativity: (b.c).a = a.b.c [serial 2399]
 


Theorem (835)                               [serial 2397] 
P [131] << num_samples = #PulseOx_Properties::Num_Trending_Samples and not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) >>
S [131] ->
Q [139] << ((all i~quantity whole
  in 1..(num_samples - 1) 
  are (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples))) and not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 834:
Theorem (834) [serial 2399] used for:
    normalization of [serial 2397]
 


Theorem (836)                               [serial 2248] 
P [131] << num_samples = #PulseOx_Properties::Num_Trending_Samples and not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) >>
S [131] ->
Q [139] << SHFTR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Substitution of Assertion Labels
and theorem 835:
Theorem (835) [serial 2397] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 2248]
 


Theorem (837)                               [serial 2231] 
P [131] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [131] ->
Q [139] << SHFTR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 836:
Theorem (836) [serial 2248] used for:
    normalization of [serial 2231]
 


Theorem (838)                               [serial 2196] 
P [131] << not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and (num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] )) >>
S [131] ->
Q [139] << SHFTR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Associativity: (b.c).a = a.b.c
and theorem 837:
Theorem (837) [serial 2231] used for:
  Associativity: (b.c).a = a.b.c [serial 2196]
 


Theorem (839)                               [serial 2173] 
P [131] << ((all i~quantity whole
  in 1..(num_samples - 1) 
  are (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples))) and (not ((MOTION_ARTIFACT)^0 or 
not (SENSOR_CONNECTED)^0)) >>
S [131] ->
Q [139] << SHFTR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 838:
Theorem (838) [serial 2196] used for:
    normalization of [serial 2173]
 


Theorem (840)                               [serial 2334] 
P [139] << SHFTR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [140] ->
Q [142] << true >>
by True Conclusion Schema (tc): P->true


Theorem (841)                               [serial 2333] 
P [139] << SHFTR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [140] ->
Q [142] << SPO2^0 = SPO2^0 >>
by Equality Law (idistr):  a=a <-> true
and theorem 840:
Theorem (840) [serial 2334] used for:
  Equality Law (idistr):  a=a <-> true [serial 2333]
 


Theorem (842)                               [serial 2331] 
P [139] << SHFTR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [140] ->
Q [142] << SPO2^0 = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) >>
by Conditional False Expression:  not b and x=g  iff  not b and x=(b??e:g) 
and theorem 841:
Theorem (841) [serial 2333] used for:
   Conditional False Expression:  not b and x=g  iff  not b and x=(b??e:g)  [serial 2331]
 


Theorem (843)                               [serial 2327] 
P [139] << SHFTR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [140] ->
Q [142] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = ((SPO2)^0) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 842:
Theorem (842) [serial 2331] used for:
    normalization of [serial 2327]
 


Theorem (844)                               [serial 2328] 
P [139] << SHFTR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [140] ->
Q [141] << SHFTR() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (845)                               [serial 2329] 
P [139] << SHFTR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [140] ->
Q [141] << not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (846)                               [serial 2326] 
P [139] << SHFTR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [140] ->
Q [141] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = ((SPO2)^0) and 
SHFTR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 843 844 845:
Theorem (843) [serial 2327] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2326]
 
Theorem (844) [serial 2328] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2326]
 
Theorem (845) [serial 2329] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2326]
 


Theorem (847)                               [serial 2198] 
P [139] << SHFTR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [140] spo2_nxt[1] := SpO2?
Q [141] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
SHFTR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 846:
Theorem (846) [serial 2326] used for:
  applied wp for assignment [serial 2198]
 


Theorem (848)                               [serial 2174] 
P [139] << SHFTR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [140] spo2_nxt[1] := SpO2?
Q [141] << SHFTR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and ((spo2_nxt[1] = (if 
MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 847:
Theorem (847) [serial 2198] used for:
    normalization of [serial 2174]
 


Theorem (849)                               [serial 2343] 
P [141] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) >>
S [131] ->
Q [144] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (850)                               [serial 2344] 
P [141] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) >>
S [131] ->
Q [145] << num_samples = #PulseOx_Properties::Num_Trending_Samples >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (851)                               [serial 2359] 
P [141] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      2 + i] ) >>
S [131] ->
Q [146] << all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      2 + i]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (852)                               [serial 2357] 
P [141] << ((if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1]) and 
(num_samples = #PulseOx_Properties::Num_Trending_Samples) and (not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0)) and (all i~quantity whole
  in 0..num_samples +  -1 +  -1 
  are (if MOTION_ARTIFACT^(- 1+- i) or not SENSOR_CONNECTED^(- 1+- i) then 0 else SPO2^(- 1+- i)) = spo2_nxt[
      2 + i] ) >>
S [131] ->
Q [146] << all i~quantity whole
  in 0.. -2 + num_samples 
  are (if MOTION_ARTIFACT^(- 1+- i) or not SENSOR_CONNECTED^(- 1+- i) then 0 else SPO2^(- 1+- i)) = spo2_nxt[
      2 + i]  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 851:
Theorem (851) [serial 2359] used for:
    normalization of [serial 2357]
 


Theorem (853)                               [serial 2356] 
P [141] << ((if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1]) and 
(num_samples = #PulseOx_Properties::Num_Trending_Samples) and (not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0)) and (all i~quantity whole
  in 0..(num_samples - 1) - 1 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      2 + i] ) >>
S [131] ->
Q [146] << all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      2 + i]  >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 852:
Theorem (852) [serial 2357] used for:
   changing adding negation to subtraction  [serial 2356]
 


Theorem (854)                               [serial 2354] 
P [141] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 0..(#PulseOx_Properties::Num_Trending_Samples - 1) - 1 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      2 + i] ) >>
S [131] ->
Q [146] << all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else SPO2^(-1+- i)) = spo2_nxt[
      2 + i]  >>
by Substituting Equals Within Conjunction
and theorem 853:
Theorem (853) [serial 2356] used for:
  Substituting Equals Within Conjunction [serial 2354]
 


Theorem (855)                               [serial 2352] 
P [141] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 0..(#PulseOx_Properties::Num_Trending_Samples - 1) - 1 
  are (if MOTION_ARTIFACT^((- 1+- i)) or not SENSOR_CONNECTED^((- 1+- i)) then 0 else SPO2^((- 1+- i))) = spo2_nxt[
      2 + i] ) >>
S [131] ->
Q [146] << all i~quantity whole
  in 0..num_samples +  -2 
  are (if MOTION_ARTIFACT^(1+- 2+- i) or not SENSOR_CONNECTED^(1+- 2+- i) then 0 else SPO2^(1+- 2+- i)) = spo2_nxt[
      2 + i]  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Associativity: (b.c).a = a.b.c
and theorem 854:
Theorem (854) [serial 2354] used for:
    normalization of [serial 2352]
 


Theorem (856)                               [serial 2350] 
P [141] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 0..(#PulseOx_Properties::Num_Trending_Samples - 1) - 1 
  are (if MOTION_ARTIFACT^(- (1+i)) or not SENSOR_CONNECTED^(- (1+i)) then 0 else SPO2^(- (1+i))) = spo2_nxt[
      2 + i] ) >>
S [131] ->
Q [146] << all i~quantity whole
  in 0..num_samples - 2 
  are (if MOTION_ARTIFACT^(1-(2+i)) or not SENSOR_CONNECTED^(1-(2+i)) then 0 else SPO2^(1-(2+i))) = spo2_nxt[
      2 + i]  >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 855:
Theorem (855) [serial 2352] used for:
   changing adding negation to subtraction  [serial 2350]
 


Theorem (857)                               [serial 2348] 
P [141] << ((if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1]) and 
(num_samples = #PulseOx_Properties::Num_Trending_Samples) and (not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0)) and (all i~quantity whole
  in 0..((#PulseOx_Properties::Num_Trending_Samples - 1) - 1) 
  are (if MOTION_ARTIFACT^(- (i+1)) or not SENSOR_CONNECTED^(- (i+1)) then 0 else SPO2^(- (i+1))) = spo2_nxt[
      i + 1 + 1] ) >>
S [131] ->
Q [146] << (all i~quantity whole
  in 0..(num_samples - 2) 
  are (if MOTION_ARTIFACT^(1-(i+2)) or not SENSOR_CONNECTED^(1-(i+2)) then 0 else SPO2^(1-(i+2))) = spo2_nxt[(
      i + 2)] ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Associativity: (b.c).a = a.b.c
and theorem 856:
Theorem (856) [serial 2350] used for:
    normalization of [serial 2348]
 


Theorem (858)                               [serial 2347] 
P [141] << ((if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1]) and 
(num_samples = #PulseOx_Properties::Num_Trending_Samples) and (not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0)) and (all i~quantity whole
  in 0..((#PulseOx_Properties::Num_Trending_Samples - 1) - 1) 
  are (if MOTION_ARTIFACT^(- (i+1)) or not SENSOR_CONNECTED^(- (i+1)) then 0 else SPO2^(- (i+1))) = spo2_nxt[
      1 + (i + 1)] ) >>
S [131] ->
Q [146] << (all i~quantity whole
  in 0..(num_samples - 2) 
  are (if MOTION_ARTIFACT^(1-(i+2)) or not SENSOR_CONNECTED^(1-(i+2)) then 0 else SPO2^(1-(i+2))) = spo2_nxt[(
      i + 2)] ) >>
by Associativity: (b.c).a = a.b.c
and theorem 857:
Theorem (857) [serial 2348] used for:
  Associativity: (b.c).a = a.b.c [serial 2347]
 


Theorem (859)                               [serial 2346] 
P [141] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 0..((num_samples - 1) - 1) 
  are (if MOTION_ARTIFACT^(- (i+1)) or not SENSOR_CONNECTED^(- (i+1)) then 0 else SPO2^(- (i+1))) = spo2_nxt[
      1 + (i + 1)] ) >>
S [131] ->
Q [146] << (all i~quantity whole
  in 0..(num_samples - 2) 
  are (if MOTION_ARTIFACT^(1-(i+2)) or not SENSOR_CONNECTED^(1-(i+2)) then 0 else SPO2^(1-(i+2))) = spo2_nxt[(
      i + 2)] ) >>
by Substituting Equals Within Conjunction
and theorem 858:
Theorem (858) [serial 2347] used for:
  Substituting Equals Within Conjunction [serial 2346]
 


Theorem (860)                               [serial 2345] 
P [141] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) >>
S [131] ->
Q [146] << (all i~quantity whole
  in 2..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] ) >>
by Shift Quantification Range so Lower Bound is Zero
and theorem 859:
Theorem (859) [serial 2346] used for:
  Shift Quantification Range so Lower Bound is Zero [serial 2345]
 


Theorem (861)                               [serial 2341] 
P [141] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) >>
S [131] ->
Q [144] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 2..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] ) >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 849 850 860:
Theorem (849) [serial 2343] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2341]
 
Theorem (850) [serial 2344] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2341]
 
Theorem (860) [serial 2345] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2341]
 


Theorem (862)                               [serial 2339] 
P [141] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] ) and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [131] ->
Q [144] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 2..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 861:
Theorem (861) [serial 2341] used for:
    normalization of [serial 2339]
 


Theorem (863)                               [serial 2337] 
P [141] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and (num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i)) = spo2_nxt[
      1 + i] )) >>
S [131] ->
Q [144] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 2..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] ) >>
by Associativity: (b.c).a = a.b.c
and theorem 862:
Theorem (862) [serial 2339] used for:
  Associativity: (b.c).a = a.b.c [serial 2337]
 


Theorem (864)                               [serial 2335] 
P [141] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
((all i~quantity whole
  in 1..(num_samples - 1) 
  are (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples))) and not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) >>
S [131] ->
Q [144] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 2..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 863:
Theorem (863) [serial 2337] used for:
    normalization of [serial 2335]
 


Theorem (865)                               [serial 2200] 
P [141] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
SHFTR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [131] ->
Q [144] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 2..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] ) >>
by Substitution of Assertion Labels
and theorem 864:
Theorem (864) [serial 2335] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2200]
 


Theorem (866)                               [serial 2175] 
P [141] << SHFTR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and ((spo2_nxt[1] = (if 
MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) >>
S [131] ->
Q [144] << ((spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and (all i~quantity whole
  in 2..num_samples 
  are (spo2_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 865:
Theorem (865) [serial 2200] used for:
    normalization of [serial 2175]
 


Theorem (867)                               [serial 2164] 
P [127] << (all i~quantity whole
  in 1..(num_samples - 1) 
  are (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
S [131] if 
(MotionArtifact? or not SensorConnected?)~> 
  << SHFTR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
  spo2_nxt[1] := 0
  << SHFTR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and ((spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) >> 
[]
(not (MotionArtifact? or not SensorConnected?))~> 
  << SHFTR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
  spo2_nxt[1] := SpO2?
  << SHFTR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and ((spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) >> 
fi
Q [144] << ((spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and (all i~quantity whole
  in 2..num_samples 
  are (spo2_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) ) >>
by Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>> (bl.iffi)
and theorems 799 806 814 831 839 848 866:
Theorem (799) [serial 2169] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>>  in if-[]-fi  for [serial 2164]
 
Theorem (806) [serial 2170] used for:
    <<P and B0>> -> <<P0>>  for [serial 2164]
 
Theorem (814) [serial 2171] used for:
    <<P0>> S0 <<Q0>>  for [serial 2164]
 
Theorem (831) [serial 2172] used for:
    <<Q0>> -> <<Q>>  for [serial 2164]
 
Theorem (839) [serial 2173] used for:
    <<P and B1>> -> <<P1>>  for [serial 2164]
 
Theorem (848) [serial 2174] used for:
    <<P1>> S1 <<Q1>>  for [serial 2164]
 
Theorem (866) [serial 2175] used for:
    <<Q1>> -> <<Q>>  for [serial 2164]
 


Theorem (868)                               [serial 2364] 
P [151] << (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] >>
S [152] ->
Q [153] << (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] >>
by Identity (id):  P->P is tautology


Theorem (869)                               [serial 2362] 
P [151] << (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] >>
S [152] ->
Q [153] << (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = (spo2_nxt[i]) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 868:
Theorem (868) [serial 2364] used for:
    normalization of [serial 2362]
 


Theorem (870)                               [serial 2204] 
P [151] << (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] >>
S [152] spo2_a[i]' := spo2_nxt[i]
Q [153] << (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_a[i]' >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 869:
Theorem (869) [serial 2362] used for:
  applied wp for assignment [serial 2204]
 


Theorem (871)                               [serial 2176] 
P [151] << (spo2_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) >>
S [152] spo2_a[i]' := spo2_nxt[i]
Q [153] << (spo2_a[i]' = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 870:
Theorem (870) [serial 2204] used for:
    normalization of [serial 2176]
 


Theorem (872)                               [serial 2361] 
P [155] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] ) >>
S [149] ->
Q [155] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] ) >>
by Identity (id):  P->P is tautology


Theorem (873)                               [serial 2202] 
P [144] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0) = spo2_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 2..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] ) >>
S [149] ->
Q [155] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] ) >>
by Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
and theorem 872:
Theorem (872) [serial 2361] used for:
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j) [serial 2202]
 


Theorem (874)                               [serial 2177] 
P [144] << (((spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and (all i~quantity whole
  in 2..num_samples 
  are (spo2_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) )) >>
S [149] ->
Q [155] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_nxt[i] ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 873:
Theorem (873) [serial 2202] used for:
    normalization of [serial 2177]
 


Theorem (875)                               [serial 2165] 
P [144] << ((spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and (all i~quantity whole
  in 2..num_samples 
  are (spo2_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) ) >>
S [149] forall i in 1..num_samples
  {
  << (spo2_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) >>
  spo2_a[i]' := spo2_nxt[i]
  << (spo2_a[i]' = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) >>
  }  
Q [155] << (all i~quantity whole
  in 1..num_samples 
  are (spo2_a[i]' = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
by Universal Quantification Rule:
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any (bl.ulq)
and theorems 871 874:
Theorem (871) [serial 2176] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 2165]
 
Theorem (874) [serial 2177] used for:
    <<P and (x=e) and FAT>> -> <<wp(forall,Q)>>
 where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
   (in postcondition Q, replace all occurances of
    <<all z:i in r are B>> with <<all z:i in r are A>>)
  for [serial 2165]
 


Theorem (876)                               [serial 2368] 
P [155] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_a[i]' ) >>
S [159] ->
Q [160] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_a[i]' ) >>
by Identity (id):  P->P is tautology


Theorem (877)                               [serial 2366] 
P [155] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_a[i]' ) >>
S [159] ->
Q [160] << #PulseOx_Properties::Num_Trending_Samples = num_samples and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_a[i]' ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 876:
Theorem (876) [serial 2368] used for:
    normalization of [serial 2366]
 


Theorem (878)                               [serial 2206] 
P [155] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_a[i]' ) >>
S [159] num_samples' := num_samples
Q [160] << #PulseOx_Properties::Num_Trending_Samples = num_samples' and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i)) = spo2_a[i]' ) >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 877:
Theorem (877) [serial 2366] used for:
  applied wp for assignment [serial 2206]
 


Theorem (879)                               [serial 2166] 
P [155] << (all i~quantity whole
  in 1..num_samples 
  are (spo2_a[i]' = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
S [159] num_samples' := num_samples
Q [160] << (all i~quantity whole
  in 1..num_samples 
  are (spo2_a[i]' = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) ) and 
((num_samples' = #PulseOx_Properties::Num_Trending_Samples)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 878:
Theorem (878) [serial 2206] used for:
    normalization of [serial 2166]
 


Theorem (880)                               [serial 1032] 
P [51] << SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
S [111] << SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and AXIOM_NS() >>
SpO2Trend!(spo2_a)
;
<< SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and AXIOM_NS() >>
NumSamples!(num_samples)
;
<< SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and AXIOM_CR() >>
forall i in 1..(num_samples - 1)
  {
  << (spo2_a[i] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) >>
  spo2_nxt[i + 1] := spo2_a[i]
  << (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) >>
  }  
<< SHFTR: :(all i~quantity whole
  in 1..(num_samples - 1) 
  are (spo2_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else SPO2^(- i))) ) and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
;
if 
(MotionArtifact? or not SensorConnected?)~> 
  << SHFTR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
  spo2_nxt[1] := 0
  << SHFTR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and ((spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) >> 
[]
(not (MotionArtifact? or not SensorConnected?))~> 
  << SHFTR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
  spo2_nxt[1] := SpO2?
  << SHFTR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and ((spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) >> 
fi
<< ((spo2_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else SPO2^0))) and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and (all i~quantity whole
  in 2..num_samples 
  are (spo2_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) ) >>
;
forall i in 1..num_samples
  {
  << (spo2_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) >>
  spo2_a[i]' := spo2_nxt[i]
  << (spo2_a[i]' = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) >>
  }  
<< (all i~quantity whole
  in 1..num_samples 
  are (spo2_a[i]' = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) ) and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
;
num_samples' := num_samples
<< (all i~quantity whole
  in 1..num_samples 
  are (spo2_a[i]' = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else SPO2^(1-i))) ) and ((num_samples' = #PulseOx_Properties::Num_Trending_Samples)) >>
Q [51] << (SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)))^1 >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 718 734 757 782 796 867 875 879:
Theorem (718) [serial 2159] used for:
  P -> P1 in sequential composition for [serial 1032]
 
Theorem (734) [serial 2160] used for:
  Q5 -> Q in sequential composition for [serial 1032]
 
Theorem (757) [serial 2161] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1032]
 
Theorem (782) [serial 2162] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1032]
 
Theorem (796) [serial 2163] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1032]
 
Theorem (867) [serial 2164] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1032]
 
Theorem (875) [serial 2165] used for:
  <<Q3 and P4>> S4 <<Q4 and P5>> in sequential composition for [serial 1032]
 
Theorem (879) [serial 2166] used for:
  <<Q4 and P5>> S5 <<Q5>> in sequential composition for [serial 1032]
 


Theorem (881)                               [serial 1033] 
P [164] << (SpO2_INV() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples))) and 
stop@now and not (exists u~time
  in tops,,now 
  that true ) and not (exists u~time
  in tops,,now 
  that stop@u ) >>
S [164] ->
Q [52] << true >>
by True Conclusion Schema (tc): P->true


Theorem (882)                               [serial 1034] 
P [164] << (SpO2_INV() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples))) and 
stop@now and not (exists u~time
  in tops,,now 
  that true ) and not (exists u~time
  in tops,,now 
  that stop@u ) >>
S [164] ->
Q [52] << true >>
by True Conclusion Schema (tc): P->true


Theorem (883)                               [serial 1022] 
P [28] <<   >>
S [33] ->
Q [28] << SpO2TrendThread.imp proof obligations >>
by Initial Thread Obligations
and theorems 525 527 528 531 553 676 693 710 711 880 881 882:
Theorem (525) [serial 1023] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
 
Theorem (527) [serial 1024] used for:
  <<M(loading)>> -> <<I>> from invariant I when complete state loading has Assertion <<M(loading)>> in its definition.
 
Theorem (528) [serial 1025] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
 
Theorem (531) [serial 1026] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state check, <<M(check)>> -> <<e1 or e2 or . . . en>>
 
Theorem (553) [serial 1027] used for:
   <<M(start)>> A <<M(loading)>> for sptt0:start-[ ]->loading{A};
 
Theorem (676) [serial 1028] used for:
   <<M(loading) and x>> A <<M(check)>> for sptt1:loading-[x]->check{A};
 
Theorem (693) [serial 1029] used for:
   <<M(check) and x>> A <<M(loading)>> for sptt2a:check-[x]->loading{A};
 
Theorem (710) [serial 1030] used for:
   <<M(check) and x>> A <<M(run)>> for sptt2b:check-[x]->run{A};
 
Theorem (711) [serial 1031] used for:
   <<M(check) and x>> -> <<M(fail)>> for sptt2c:check-[x]->fail{};
 
Theorem (880) [serial 1032] used for:
   <<M(run) and x>> A <<M(run)>> for sptt3:run-[x]->run{A};
 
Theorem (881) [serial 1033] used for:
   <<M(loading) and x>> -> <<M(halt)>> for sptt4:loading-[x]->halt{};
 
Theorem (882) [serial 1034] used for:
   <<M(run) and x>> -> <<M(halt)>> for sptt4:run-[x]->halt{};
 


Theorem (884)                               [serial 2597] 
P [52] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) >>
S [35] ->
Q [35] << all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (885)                               [serial 2595] 
P [52] << (all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
S [35] ->
Q [35] << all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)))  >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 884:
Theorem (884) [serial 2597] used for:
    normalization of [serial 2595]
 


Theorem (886)                               [serial 1036] 
P [52] << INV_HR() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
S [35] ->
Q [35] << all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)))  >>
by Substitution of Assertion Labels
and theorem 885:
Theorem (885) [serial 2595] used for:
  substituted Assertions' predicates for  labels  [serial 1036]
 


Theorem (887)                               [serial 2601] 
P [48] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [35] ->
Q [35] << all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (888)                               [serial 2599] 
P [48] << (all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))) ) and 
((num_samples < #PulseOx_Properties::Num_Trending_Samples)) >>
S [35] ->
Q [35] << all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)))  >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 887:
Theorem (887) [serial 2601] used for:
    normalization of [serial 2599]
 


Theorem (889)                               [serial 1037] 
P [48] << INV_HR() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) >>
S [35] ->
Q [35] << all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)))  >>
by Substitution of Assertion Labels
and theorem 888:
Theorem (888) [serial 2599] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1037]
 


Theorem (890)                               [serial 1038] 
P [44] << ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and ((num_samples = 0)) and 
(all s~quantity whole
  in (num_samples + 1)..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) >>
S [44] ->
Q [44] << true >>
by True Conclusion Schema (tc): P->true


Theorem (891)                               [serial 2607] 
P [50] << all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s]  >>
S [50] ->
Q [50] << true >>
by True Conclusion Schema (tc): P->true


Theorem (892)                               [serial 2605] 
P [50] << all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s]  >>
S [50] ->
Q [50] << num_samples = #PulseOx_Properties::Num_Trending_Samples or num_samples < #PulseOx_Properties::Num_Trending_Samples or 
#PulseOx_Properties::Num_Trending_Samples < num_samples >>
by Less than, greater than, or equal:  |-a<b or b<a or a=b
and theorem 891:
Theorem (891) [serial 2607] used for:
  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 2605]
 


Theorem (893)                               [serial 2603] 
P [50] << (all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s))) ) >>
S [50] ->
Q [50] << ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) or ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) or 
((num_samples > #PulseOx_Properties::Num_Trending_Samples)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 892:
Theorem (892) [serial 2605] used for:
    normalization of [serial 2603]
 


Theorem (894)                               [serial 1039] 
P [50] << HOLD_HR(num_samples) >>
S [50] ->
Q [50] << ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) or ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) or 
((num_samples > #PulseOx_Properties::Num_Trending_Samples)) >>
by Substitution of Assertion Labels
and theorem 893:
Theorem (893) [serial 2603] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1039]
 


Theorem (895)                               [serial 2658] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] ->
Q [48] << num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (896)                               [serial 2653] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] ->
Q [48] << 0 < #PulseOx_Properties::Num_Trending_Samples >>
by Guided Substitution of Equals
and theorem 895:
Theorem (895) [serial 2658] used for:
  Guided Substitution of Equals
 replacing "0" with its = "num_samples" in its postcondition [serial 2653]
 


Theorem (897)                               [serial 2650] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] ->
Q [48] << (0 < #PulseOx_Properties::Num_Trending_Samples) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 896:
Theorem (896) [serial 2653] used for:
    normalization of [serial 2650]
 


Theorem (898)                               [serial 2645] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] ->
Q [48] << true and 0 < #PulseOx_Properties::Num_Trending_Samples >>
by Law of And-Simplification:  P and true is P
and theorem 897:
Theorem (897) [serial 2650] used for:
  Law of And-Simplification:  P and true is P [serial 2645]
 


Theorem (899)                               [serial 2642] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] ->
Q [48] << (true) and 0 < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 898:
Theorem (898) [serial 2645] used for:
    normalization of [serial 2642]
 


Theorem (900)                               [serial 2640] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] ->
Q [48] << (all s~quantity whole
  in false 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) ) and 
0 < #PulseOx_Properties::Num_Trending_Samples >>
by Empty Range Law All: all a:t in false are V is tautology
and theorem 899:
Theorem (899) [serial 2642] used for:
  Empty Range Law All: all a:t in false are V is tautology [serial 2640]
 


Theorem (901)                               [serial 2638] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] ->
Q [48] << (all s~quantity whole
  in 1..0 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) ) and 
0 < #PulseOx_Properties::Num_Trending_Samples >>
by Empty Range
and theorem 900:
Theorem (900) [serial 2640] used for:
  Empty Range [serial 2638]
 


Theorem (902)                               [serial 2659] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] ->
Q [48] << num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (903)                               [serial 2655] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] ->
Q [48] << 0 < #PulseOx_Properties::Num_Trending_Samples >>
by Guided Substitution of Equals
and theorem 902:
Theorem (902) [serial 2659] used for:
  Guided Substitution of Equals
 replacing "0" with its = "num_samples" in its postcondition [serial 2655]
 


Theorem (904)                               [serial 2651] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] ->
Q [48] << (0 < #PulseOx_Properties::Num_Trending_Samples) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 903:
Theorem (903) [serial 2655] used for:
    normalization of [serial 2651]
 


Theorem (905)                               [serial 2647] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] ->
Q [48] << true and 0 < #PulseOx_Properties::Num_Trending_Samples >>
by Law of And-Simplification:  P and true is P
and theorem 904:
Theorem (904) [serial 2651] used for:
  Law of And-Simplification:  P and true is P [serial 2647]
 


Theorem (906)                               [serial 2643] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] ->
Q [48] << (true) and 0 < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 905:
Theorem (905) [serial 2647] used for:
    normalization of [serial 2643]
 


Theorem (907)                               [serial 2641] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] ->
Q [48] << (all s~quantity whole
  in false 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) ) and 
0 < #PulseOx_Properties::Num_Trending_Samples >>
by Empty Range Law All: all a:t in false are V is tautology
and theorem 906:
Theorem (906) [serial 2643] used for:
  Empty Range Law All: all a:t in false are V is tautology [serial 2641]
 


Theorem (908)                               [serial 2639] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] ->
Q [48] << (all s~quantity whole
  in 1..0 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) ) and 
0 < #PulseOx_Properties::Num_Trending_Samples >>
by Empty Range
and theorem 907:
Theorem (907) [serial 2641] used for:
  Empty Range [serial 2639]
 


Theorem (909)                               [serial 2637] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] ->
Q [48] << (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Guided Substitution of Equals
and theorems 901 908:
Theorem (901) [serial 2638] used for:
  Guided Substitution of Equals
 replacing "num_samples" with its = "0" in its postcondition [serial 2637]
 
Theorem (908) [serial 2639] used for:
  Guided Substitution of Equals
 replacing "num_samples" with its = "0" in its postcondition [serial 2637]
 


Theorem (910)                               [serial 2634] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s]^1 = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Simultaneous Assignment
and theorem 909:
Theorem (909) [serial 2637] used for:
  applied wp for simultaneous assignment [serial 2634]
 


Theorem (911)                               [serial 2632] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s]^1 = (if MOTION_ARTIFACT^(1-s) or not (SENSOR_CONNECTED^(- s))^1 then 0 else HEART_RATE^(1-s)) ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Caret Compostition:  (x^a)^b is x^(a+b)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Associativity: (b.c).a = a.b.c
and theorem 910:
Theorem (910) [serial 2634] used for:
    normalization of [serial 2632]
 


Theorem (912)                               [serial 2630] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s]^1 = (if MOTION_ARTIFACT^(1-s) or (not SENSOR_CONNECTED^(- s))^1 then 0 else HEART_RATE^(1-s)) ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 911:
Theorem (911) [serial 2632] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2630]
 


Theorem (913)                               [serial 2628] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s]^1 = (if (MOTION_ARTIFACT^((- s)+1) or (not SENSOR_CONNECTED^(- s))^1) then 0 else HEART_RATE^(1-s)) ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Associativity: (b.c).a = a.b.c
and theorem 912:
Theorem (912) [serial 2630] used for:
    normalization of [serial 2628]
 


Theorem (914)                               [serial 2626] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s]^1 = (if (MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s))^1 then 0 else HEART_RATE^(1-s)) ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 913:
Theorem (913) [serial 2628] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2626]
 


Theorem (915)                               [serial 2624] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << (all s~quantity whole
  in 1..num_samples 
  are (if (MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s))^1 then (0)^1 else HEART_RATE^((- s)+1)) = heart_rate_store[s]^1 ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
    Associativity: (b.c).a = a.b.c
and theorem 914:
Theorem (914) [serial 2626] used for:
    normalization of [serial 2624]
 


Theorem (916)                               [serial 2622] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))^1 = heart_rate_store[s]^1 ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 915:
Theorem (915) [serial 2624] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2622]
 


Theorem (917)                               [serial 2620] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << (all s~quantity whole
  in 1..num_samples 
  are (((if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)))^1 = (heart_rate_store[s])^1) ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 916:
Theorem (916) [serial 2622] used for:
    normalization of [serial 2620]
 


Theorem (918)                               [serial 2618] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << (all s~quantity whole
  in 1..num_samples 
  are ((if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s])^1 ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 917:
Theorem (917) [serial 2620] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2618]
 


Theorem (919)                               [serial 2616] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << (all s~quantity whole
  in 1..num_samples 
  are ((if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s])^1 ) and 
((num_samples)^1 < (#PulseOx_Properties::Num_Trending_Samples)^1) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
and theorem 918:
Theorem (918) [serial 2618] used for:
    normalization of [serial 2616]
 


Theorem (920)                               [serial 2614] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] )^1 and 
(num_samples < #PulseOx_Properties::Num_Trending_Samples)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 919:
Theorem (919) [serial 2616] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2614]
 


Theorem (921)                               [serial 2612] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << ((all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] )^1 and 
(num_samples < #PulseOx_Properties::Num_Trending_Samples)^1) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 920:
Theorem (920) [serial 2614] used for:
    normalization of [serial 2612]
 


Theorem (922)                               [serial 2610] 
P [44] << num_samples = 0 and (all s~quantity whole
  in 1 + num_samples..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [57] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << ((all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 921:
Theorem (921) [serial 2612] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2610]
 


Theorem (923)                               [serial 2608] 
P [44] << ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and ((num_samples = 0)) and 
(all s~quantity whole
  in (num_samples + 1)..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) >>
S [57] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << ((all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))) ) and 
((num_samples < #PulseOx_Properties::Num_Trending_Samples)))^1 >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 922:
Theorem (922) [serial 2610] used for:
    normalization of [serial 2608]
 


Theorem (924)                               [serial 1040] 
P [44] << ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and ((num_samples = 0)) and 
(all s~quantity whole
  in (num_samples + 1)..#PulseOx_Properties::Num_Trending_Samples 
  are not SENSOR_CONNECTED^(- s) ) >>
S [57] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << (INV_HR() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)))^1 >>
by Substitution of Assertion Labels
and theorem 923:
Theorem (923) [serial 2608] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 1040]
 


Theorem (925)                               [serial 2729] 
P [48] << INV_HR() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [48] ->
Q [61] << INV_HR() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Identity (id):  P->P is tautology


Theorem (926)                               [serial 2728] 
P [48] << INV_HR() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [48] ->
Q [61] << true and INV_HR() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Law of And-Simplification:  P and true is P
and theorem 925:
Theorem (925) [serial 2729] used for:
  Law of And-Simplification:  P and true is P [serial 2728]
 


Theorem (927)                               [serial 2729] 
P [48] << INV_HR() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [48] ->
Q [61] << INV_HR() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Identity (id):  P->P is tautology


Theorem (928)                               [serial 2728] 
P [48] << INV_HR() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [48] ->
Q [61] << true and INV_HR() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Law of And-Simplification:  P and true is P
and theorem 927:
Theorem (927) [serial 2729] used for:
  Law of And-Simplification:  P and true is P [serial 2728]
 


Theorem (929)                               [serial 2680] 
P [48] << INV_HR() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [48] ->
Q [61] << AXIOM_HRT() and INV_HR() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 928 928:
Theorem (928) [serial 2728] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (928) [serial 2728] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (930)                               [serial 2660] 
P [48] << INV_HR() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) >>
S [48] ->
Q [61] << INV_HR() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_HRT() >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 929:
Theorem (929) [serial 2680] used for:
    normalization of [serial 2660]
 


Theorem (931)                               [serial 2734] 
P [104] << all #8#~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-#8#) or not SENSOR_CONNECTED^(1-#8#) then 0 else HEART_RATE^(1-#8#)) = heart_rate_store[#8#]  >>
S [50] ->
Q [50] << all #9#~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-#9#) or not SENSOR_CONNECTED^(1-#9#) then 0 else HEART_RATE^(1-#9#)) = heart_rate_store[#9#]  >>
by Identity (id):  P->P is tautology


Theorem (932)                               [serial 2732] 
P [104] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = heart_rate_store[i]  >>
S [50] ->
Q [50] << all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s]  >>
by Replacement of Quantified Variables with #1, #2, etc.
and theorem 931:
Theorem (931) [serial 2734] used for:
  Replacement of Quantified Variables with #1, #2, etc. [serial 2732]
 


Theorem (933)                               [serial 2730] 
P [104] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = heart_rate_store[i]  >>
S [50] ->
Q [50] << (all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s))) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 932:
Theorem (932) [serial 2732] used for:
    normalization of [serial 2730]
 


Theorem (934)                               [serial 2682] 
P [104] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = heart_rate_store[i]  >>
S [50] ->
Q [50] << HOLD_HR(num_samples) >>
by Substitution of Assertion Labels
and theorem 933:
Theorem (933) [serial 2730] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 2682]
 


Theorem (935)                               [serial 2661] 
P [104] << all i~quantity whole
  in 1..num_samples 
  are (heart_rate_store[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)))  >>
S [50] ->
Q [50] << HOLD_HR(num_samples) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 934:
Theorem (934) [serial 2682] used for:
    normalization of [serial 2661]
 


Theorem (936)                               [serial 2748] 
P [61] << HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [63] ->
Q [15] << all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (937)                               [serial 2747] 
P [61] << HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [63] ->
Q [15] << all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = HEART_RATE_HISTORY[s]  >>
by Guided Substitution of Equals
and theorem 936:
Theorem (936) [serial 2748] used for:
  Guided Substitution of Equals
 replacing "HEART_RATE_HISTORY" with its = "heart_rate_store" in its postcondition [serial 2747]
 


Theorem (938)                               [serial 2746] 
P [61] << HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [63] ->
Q [15] << all s~quantity whole
  in 1..NUM_SAMPLES 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = HEART_RATE_HISTORY[s]  >>
by Guided Substitution of Equals
and theorem 937:
Theorem (937) [serial 2747] used for:
  Guided Substitution of Equals
 replacing "NUM_SAMPLES" with its = "num_samples" in its postcondition [serial 2746]
 


Theorem (939)                               [serial 2744] 
P [61] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
(HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [63] ->
Q [15] << all s~quantity whole
  in 1..NUM_SAMPLES 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = HEART_RATE_HISTORY[s]  >>
by Associativity: (b.c).a = a.b.c
and theorem 938:
Theorem (938) [serial 2746] used for:
  Associativity: (b.c).a = a.b.c [serial 2744]
 


Theorem (940)                               [serial 2742] 
P [61] << ((num_samples = NUM_SAMPLES) and (heart_rate_store = HEART_RATE_HISTORY)) and 
(all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))) ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [63] ->
Q [15] << (all s~quantity whole
  in 1..NUM_SAMPLES 
  are (HEART_RATE_HISTORY[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 939:
Theorem (939) [serial 2744] used for:
    normalization of [serial 2742]
 


Theorem (941)                               [serial 2741] 
P [61] << ((num_samples = NUM_SAMPLES) and (heart_rate_store = HEART_RATE_HISTORY)) and 
(all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))) ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [63] ->
Q [15] << HR_TREND() >>
by Substitution of Assertion Labels
and theorem 940:
Theorem (940) [serial 2742] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 2741]
 


Theorem (942)                               [serial 2735] 
P [61] << AXIOM_HRT() and INV_HR() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [63] ->
Q [15] << HR_TREND() >>
by Substitution of Assertion Labels
and theorem 941:
Theorem (941) [serial 2741] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2735]
 


Theorem (943)                               [serial 2739] 
P [63] << (HR_TREND())^0 and (AXIOM_HRT() and INV_HR() and num_samples < #PulseOx_Properties::Num_Trending_Samples) >>
S [63] ->
Q [65] << AXIOM_HRT() and INV_HR() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (944)                               [serial 2736] 
P [63] << (AXIOM_HRT() and INV_HR() and num_samples < #PulseOx_Properties::Num_Trending_Samples) and 
(HR_TREND())^0 >>
S [63] ->
Q [65] << AXIOM_HRT() and INV_HR() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 943:
Theorem (943) [serial 2739] used for:
    normalization of [serial 2736]
 


Theorem (945)                               [serial 2684] 
P [61] << AXIOM_HRT() and INV_HR() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [63] HeartRateTrend!(heart_rate_store)
Q [65] << AXIOM_HRT() and INV_HR() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 942 944:
Theorem (942) [serial 2735] used for:
  applied port output of value <<pre>> -> <<M(HeartRateTrend)[HeartRateTrend|heart_rate_store]>> [serial 2684]
 
Theorem (944) [serial 2736] used for:
  applied port output <<pre and (HR_TREND())^0>> -> <<post>> [serial 2684]
 


Theorem (946)                               [serial 2662] 
P [61] << INV_HR() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_HRT() >>
S [63] HeartRateTrend!(heart_rate_store)
Q [65] << INV_HR() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_HRT() >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 945:
Theorem (945) [serial 2684] used for:
    normalization of [serial 2662]
 


Theorem (947)                               [serial 2762] 
P [67] << HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples and (NumSamples = num_samples)^0 >>
S [67] ->
Q [69] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (948)                               [serial 2757] 
P [67] << (NumSamples = num_samples)^0 and (HEART_RATE_HISTORY = heart_rate_store and 
NUM_SAMPLES = num_samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples) >>
S [67] ->
Q [69] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Associativity: (b.c).a = a.b.c
and theorem 947:
Theorem (947) [serial 2762] used for:
  Associativity: (b.c).a = a.b.c [serial 2757]
 


Theorem (949)                               [serial 2754] 
P [67] << (HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples) and (NumSamples = num_samples)^0 >>
S [67] ->
Q [69] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 948:
Theorem (948) [serial 2757] used for:
    normalization of [serial 2754]
 


Theorem (950)                               [serial 2765] 
P [67] << HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples and 
NumSamples = num_samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [67] ->
Q [67] << NUM_SAMPLES = num_samples >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (951)                               [serial 2764] 
P [67] << HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples and 
NumSamples = num_samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [67] ->
Q [67] << NUM_SAMPLES = NumSamples >>
by Guided Substitution of Equals
and theorem 950:
Theorem (950) [serial 2765] used for:
  Guided Substitution of Equals
 replacing "NumSamples" with its = "num_samples" in its postcondition [serial 2764]
 


Theorem (952)                               [serial 2763] 
P [67] << HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples and (NumSamples = num_samples)^0 >>
S [67] ->
Q [67] << NUM_SAMPLES = NumSamples >>
by Assume Present:  P = P@now = P^0 
and theorem 951:
Theorem (951) [serial 2764] used for:
  Assume Present:  P = P@now = P^0  [serial 2763]
 


Theorem (953)                               [serial 2759] 
P [67] << (NumSamples = num_samples)^0 and (HEART_RATE_HISTORY = heart_rate_store and 
NUM_SAMPLES = num_samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples) >>
S [67] ->
Q [67] << NUM_SAMPLES = NumSamples >>
by Associativity: (b.c).a = a.b.c
and theorem 952:
Theorem (952) [serial 2763] used for:
  Associativity: (b.c).a = a.b.c [serial 2759]
 


Theorem (954)                               [serial 2755] 
P [67] << (HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples) and (NumSamples = num_samples)^0 >>
S [67] ->
Q [67] << NumSamples = NUM_SAMPLES >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 953:
Theorem (953) [serial 2759] used for:
    normalization of [serial 2755]
 


Theorem (955)                               [serial 2753] 
P [65] << HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [67] NumSamples!(num_samples)
Q [69] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 949 954:
Theorem (949) [serial 2754] used for:
  applied port output <<pre and (NumSamples=num_samples)^0>> -> <<post>> [serial 2753]
 
Theorem (954) [serial 2755] used for:
  applied port output <<pre and (NumSamples=num_samples)^0>> -> <<(NumSamples=NUM_SAMPLES)^0>> [serial 2753]
 


Theorem (956)                               [serial 2751] 
P [65] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
(HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [67] NumSamples!(num_samples)
Q [69] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Associativity: (b.c).a = a.b.c
and theorem 955:
Theorem (955) [serial 2753] used for:
  Associativity: (b.c).a = a.b.c [serial 2751]
 


Theorem (957)                               [serial 2749] 
P [65] << ((num_samples = NUM_SAMPLES) and (heart_rate_store = HEART_RATE_HISTORY)) and 
(all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))) ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [67] NumSamples!(num_samples)
Q [69] << (all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))) ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 956:
Theorem (956) [serial 2751] used for:
    normalization of [serial 2749]
 


Theorem (958)                               [serial 2686] 
P [65] << AXIOM_HRT() and INV_HR() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [67] NumSamples!(num_samples)
Q [69] << INV_HR() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Substitution of Assertion Labels
and theorem 957:
Theorem (957) [serial 2749] used for:
  substituted Assertions' predicates for  labels  [serial 2686]
 


Theorem (959)                               [serial 2663] 
P [65] << INV_HR() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_HRT() >>
S [67] NumSamples!(num_samples)
Q [69] << INV_HR() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 958:
Theorem (958) [serial 2686] used for:
    normalization of [serial 2663]
 


Theorem (960)                               [serial 2773] 
P [72] << (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = heart_rate_store[i] >>
S [73] ->
Q [74] << (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = heart_rate_store[i] >>
by Identity (id):  P->P is tautology


Theorem (961)                               [serial 2771] 
P [72] << (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = heart_rate_store[i] >>
S [73] ->
Q [74] << (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = (heart_rate_store[i]) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 960:
Theorem (960) [serial 2773] used for:
    normalization of [serial 2771]
 


Theorem (962)                               [serial 2690] 
P [72] << (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = heart_rate_store[i] >>
S [73] hr_nxt[1 + i] := heart_rate_store[i]
Q [74] << (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
1 + i] >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 961:
Theorem (961) [serial 2771] used for:
  applied wp for assignment [serial 2690]
 


Theorem (963)                               [serial 2668] 
P [72] << (heart_rate_store[i] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) >>
S [73] hr_nxt[i + 1] := heart_rate_store[i]
Q [74] << (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 962:
Theorem (962) [serial 2690] used for:
    normalization of [serial 2668]
 


Theorem (964)                               [serial 2770] 
P [69] << (all #10#~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- #10#) or not SENSOR_CONNECTED^(- #10#) then 0 else HEART_RATE^(- #10#)) = heart_rate_store[#10#] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [70] ->
Q [76] << all #11#~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- #11#) or not SENSOR_CONNECTED^(- #11#) then 0 else HEART_RATE^(- #11#)) = heart_rate_store[#11#]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (965)                               [serial 2768] 
P [69] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [70] ->
Q [76] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = heart_rate_store[i]  >>
by Replacement of Quantified Variables with #1, #2, etc.
and theorem 964:
Theorem (964) [serial 2770] used for:
  Replacement of Quantified Variables with #1, #2, etc. [serial 2768]
 


Theorem (966)                               [serial 2766] 
P [69] << (all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))) ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [70] ->
Q [76] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = heart_rate_store[i]  >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 965:
Theorem (965) [serial 2768] used for:
    normalization of [serial 2766]
 


Theorem (967)                               [serial 2688] 
P [69] << INV_HR() and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [70] ->
Q [76] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = heart_rate_store[i]  >>
by Substitution of Assertion Labels
and theorem 966:
Theorem (966) [serial 2766] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2688]
 


Theorem (968)                               [serial 2669] 
P [69] << (INV_HR() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples))) >>
S [70] ->
Q [76] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = heart_rate_store[i]  >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 967:
Theorem (967) [serial 2688] used for:
    normalization of [serial 2669]
 


Theorem (969)                               [serial 2664] 
P [69] << INV_HR() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) >>
S [70] forall i in 1..num_samples
  {
  << (heart_rate_store[i] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) >>
  hr_nxt[i + 1] := heart_rate_store[i]
  << (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) >>
  }  
Q [76] << all i~quantity whole
  in 1..num_samples 
  are (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)))  >>
by Universal Quantification Rule:
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any (bl.ulq)
and theorems 963 968:
Theorem (963) [serial 2668] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 2664]
 
Theorem (968) [serial 2669] used for:
    <<P and (x=e) and FAT>> -> <<wp(forall,Q)>>
 where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
   (in postcondition Q, replace all occurances of
    <<all z:i in r are B>> with <<all z:i in r are A>>)
  for [serial 2664]
 


Theorem (970)                               [serial 2727] 
P [76] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i]  >>
S [79] ->
Q [79] << true >>
by True Conclusion Schema (tc): P->true


Theorem (971)                               [serial 2692] 
P [76] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i]  >>
S [79] ->
Q [79] << not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) or (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) >>
by Law of Excluded Middle: P or not P is tautology
and theorem 970:
Theorem (970) [serial 2727] used for:
  Law of Excluded Middle: P or not P is tautology [serial 2692]
 


Theorem (972)                               [serial 2670] 
P [76] << all i~quantity whole
  in 1..num_samples 
  are (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)))  >>
S [79] ->
Q [79] << ((MOTION_ARTIFACT)^0 or not (SENSOR_CONNECTED)^0) or (not ((MOTION_ARTIFACT)^0 or 
not (SENSOR_CONNECTED)^0)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 971:
Theorem (971) [serial 2692] used for:
    normalization of [serial 2670]
 


Theorem (973)                               [serial 2779] 
P [79] << (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [79] ->
Q [81] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (974)                               [serial 2777] 
P [79] << (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [79] ->
Q [81] << (all i~quantity whole
  in 1..num_samples 
  are (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 973:
Theorem (973) [serial 2779] used for:
    normalization of [serial 2777]
 


Theorem (975)                               [serial 2775] 
P [79] << (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [79] ->
Q [81] << SHFT_HR() >>
by Substitution of Assertion Labels
and theorem 974:
Theorem (974) [serial 2777] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 2775]
 


Theorem (976)                               [serial 2776] 
P [79] << (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [79] ->
Q [81] << (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (977)                               [serial 2694] 
P [79] << (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [79] ->
Q [81] << SHFT_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 975 976:
Theorem (975) [serial 2775] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2694]
 
Theorem (976) [serial 2776] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2694]
 


Theorem (978)                               [serial 2671] 
P [79] << (all i~quantity whole
  in 1..num_samples 
  are (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) ) and 
((MOTION_ARTIFACT)^0 or not (SENSOR_CONNECTED)^0) >>
S [79] ->
Q [81] << SHFT_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 977:
Theorem (977) [serial 2694] used for:
    normalization of [serial 2671]
 


Theorem (979)                               [serial 2785] 
P [81] << SHFT_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [82] ->
Q [83] << true >>
by True Conclusion Schema (tc): P->true


Theorem (980)                               [serial 2784] 
P [81] << SHFT_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [82] ->
Q [83] << 0 = 0 >>
by Equality Law (idistr):  a=a <-> true
and theorem 979:
Theorem (979) [serial 2785] used for:
  Equality Law (idistr):  a=a <-> true [serial 2784]
 


Theorem (981)                               [serial 2782] 
P [81] << SHFT_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [82] ->
Q [83] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = 0 >>
by Conditional True Expression:  b and x=e  iff  b and x=(b??e:g) 
and theorem 980:
Theorem (980) [serial 2784] used for:
   Conditional True Expression:  b and x=e  iff  b and x=(b??e:g)  [serial 2782]
 


Theorem (982)                               [serial 2783] 
P [81] << SHFT_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [82] ->
Q [83] << SHFT_HR() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (983)                               [serial 2781] 
P [81] << SHFT_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [82] ->
Q [83] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = 0 and 
SHFT_HR() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 981 982:
Theorem (981) [serial 2782] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2781]
 
Theorem (982) [serial 2783] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2781]
 


Theorem (984)                               [serial 2696] 
P [81] << SHFT_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [82] hr_nxt[1] := 0
Q [83] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
SHFT_HR() >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 983:
Theorem (983) [serial 2781] used for:
  applied wp for assignment [serial 2696]
 


Theorem (985)                               [serial 2672] 
P [81] << SHFT_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [82] hr_nxt[1] := 0
Q [83] << SHFT_HR() and ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 984:
Theorem (984) [serial 2696] used for:
    normalization of [serial 2672]
 


Theorem (986)                               [serial 2786] 
P [83] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
SHFT_HR() >>
S [79] ->
Q [90] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (987)                               [serial 2802] 
P [83] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
(all i~quantity whole
  in 0..-1 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else HEART_RATE^(-1+- i)) = hr_nxt[
      2 + i] ) >>
S [79] ->
Q [91] << all i~quantity whole
  in 0..-1 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else HEART_RATE^(-1+- i)) = hr_nxt[
      2 + i]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (988)                               [serial 2800] 
P [83] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
(all i~quantity whole
  in 0..num_samples +  -1 
  are (if MOTION_ARTIFACT^((- 1+- i)) or not SENSOR_CONNECTED^((- 1+- i)) then 0 else HEART_RATE^((- 1+- i))) = hr_nxt[
      2 + i] ) >>
S [79] ->
Q [91] << all i~quantity whole
  in 0..1 + num_samples +  -2 
  are (if MOTION_ARTIFACT^(1+- 2+- i) or not SENSOR_CONNECTED^(1+- 2+- i) then 0 else HEART_RATE^(1+- 2+- i)) = hr_nxt[
      2 + i]  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 987:
Theorem (987) [serial 2802] used for:
    normalization of [serial 2800]
 


Theorem (989)                               [serial 2798] 
P [83] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
(all i~quantity whole
  in 0..num_samples - 1 
  are (if MOTION_ARTIFACT^(- (1+i)) or not SENSOR_CONNECTED^(- (1+i)) then 0 else HEART_RATE^(- (1+i))) = hr_nxt[
      2 + i] ) >>
S [79] ->
Q [91] << all i~quantity whole
  in 0..(1 + num_samples) - 2 
  are (if MOTION_ARTIFACT^(1-(2+i)) or not SENSOR_CONNECTED^(1-(2+i)) then 0 else HEART_RATE^(1-(2+i))) = hr_nxt[
      2 + i]  >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 988:
Theorem (988) [serial 2800] used for:
   changing adding negation to subtraction  [serial 2798]
 


Theorem (990)                               [serial 2796] 
P [83] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
(all i~quantity whole
  in 0..num_samples - 1 
  are (if MOTION_ARTIFACT^(- (1+i)) or not SENSOR_CONNECTED^(- (1+i)) then 0 else HEART_RATE^(- (1+i))) = hr_nxt[
      1 + i + 1] ) >>
S [79] ->
Q [91] << all i~quantity whole
  in 0..(1 + num_samples) - 2 
  are (if MOTION_ARTIFACT^(1-(2+i)) or not SENSOR_CONNECTED^(1-(2+i)) then 0 else HEART_RATE^(1-(2+i))) = hr_nxt[
      2 + i]  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 989:
Theorem (989) [serial 2798] used for:
    normalization of [serial 2796]
 


Theorem (991)                               [serial 2794] 
P [83] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
(all i~quantity whole
  in 0..num_samples - 1 
  are (if MOTION_ARTIFACT^(- (1+i)) or not SENSOR_CONNECTED^(- (1+i)) then 0 else HEART_RATE^(- (1+i))) = hr_nxt[
      1 + (1 + i)] ) >>
S [79] ->
Q [91] << all i~quantity whole
  in 0..(1 + num_samples) - 2 
  are (if MOTION_ARTIFACT^(1-(2+i)) or not SENSOR_CONNECTED^(1-(2+i)) then 0 else HEART_RATE^(1-(2+i))) = hr_nxt[
      2 + i]  >>
by Associativity: (b.c).a = a.b.c
and theorem 990:
Theorem (990) [serial 2796] used for:
  Associativity: (b.c).a = a.b.c [serial 2794]
 


Theorem (992)                               [serial 2792] 
P [83] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
(all i~quantity whole
  in 0..(num_samples - 1) 
  are (if MOTION_ARTIFACT^(- (i+1)) or not SENSOR_CONNECTED^(- (i+1)) then 0 else HEART_RATE^(- (i+1))) = hr_nxt[
      1 + (i + 1)] ) >>
S [79] ->
Q [91] << all i~quantity whole
  in 0..((1 + num_samples) - 2) 
  are (if MOTION_ARTIFACT^(1-(i+2)) or not SENSOR_CONNECTED^(1-(i+2)) then 0 else HEART_RATE^(1-(i+2))) = hr_nxt[(
      i + 2)]  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 991:
Theorem (991) [serial 2794] used for:
    normalization of [serial 2792]
 


Theorem (993)                               [serial 2790] 
P [83] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
(all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) >>
S [79] ->
Q [91] << all i~quantity whole
  in 2..1 + num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i]  >>
by Shift Quantification Range so Lower Bound is Zero
and theorem 992:
Theorem (992) [serial 2792] used for:
  Shift Quantification Range so Lower Bound is Zero [serial 2790]
 


Theorem (994)                               [serial 2788] 
P [83] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
(all i~quantity whole
  in 1..num_samples 
  are (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) ) >>
S [79] ->
Q [91] << (all i~quantity whole
  in 2..1 + num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 993:
Theorem (993) [serial 2790] used for:
    normalization of [serial 2788]
 


Theorem (995)                               [serial 2787] 
P [83] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
SHFT_HR() >>
S [79] ->
Q [91] << (all i~quantity whole
  in 2..1 + num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
by Substitution of Assertion Labels
and theorem 994:
Theorem (994) [serial 2788] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2787]
 


Theorem (996)                               [serial 2698] 
P [83] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
SHFT_HR() >>
S [79] ->
Q [90] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
(all i~quantity whole
  in 2..1 + num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 986 995:
Theorem (986) [serial 2786] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2698]
 
Theorem (995) [serial 2787] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2698]
 


Theorem (997)                               [serial 2673] 
P [83] << SHFT_HR() and ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) >>
S [79] ->
Q [90] << ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) and 
(all i~quantity whole
  in 2..(num_samples + 1) 
  are (hr_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 996:
Theorem (996) [serial 2698] used for:
    normalization of [serial 2673]
 


Theorem (998)                               [serial 2808] 
P [79] << not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) >>
S [79] ->
Q [86] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (999)                               [serial 2806] 
P [79] << not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) >>
S [79] ->
Q [86] << (all i~quantity whole
  in 1..num_samples 
  are (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 998:
Theorem (998) [serial 2808] used for:
    normalization of [serial 2806]
 


Theorem (1000)                               [serial 2804] 
P [79] << not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) >>
S [79] ->
Q [86] << SHFT_HR() >>
by Substitution of Assertion Labels
and theorem 999:
Theorem (999) [serial 2806] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 2804]
 


Theorem (1001)                               [serial 2805] 
P [79] << not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) >>
S [79] ->
Q [86] << not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1002)                               [serial 2700] 
P [79] << not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) >>
S [79] ->
Q [86] << SHFT_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1000 1001:
Theorem (1000) [serial 2804] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2700]
 
Theorem (1001) [serial 2805] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2700]
 


Theorem (1003)                               [serial 2674] 
P [79] << (all i~quantity whole
  in 1..num_samples 
  are (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) ) and 
(not ((MOTION_ARTIFACT)^0 or not (SENSOR_CONNECTED)^0)) >>
S [79] ->
Q [86] << SHFT_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1002:
Theorem (1002) [serial 2700] used for:
    normalization of [serial 2674]
 


Theorem (1004)                               [serial 2817] 
P [86] << SHFT_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [87] ->
Q [88] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1005)                               [serial 2816] 
P [86] << SHFT_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [87] ->
Q [88] << HEART_RATE^0 = HEART_RATE^0 >>
by Equality Law (idistr):  a=a <-> true
and theorem 1004:
Theorem (1004) [serial 2817] used for:
  Equality Law (idistr):  a=a <-> true [serial 2816]
 


Theorem (1006)                               [serial 2814] 
P [86] << SHFT_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [87] ->
Q [88] << HEART_RATE^0 = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) >>
by Conditional False Expression:  not b and x=g  iff  not b and x=(b??e:g) 
and theorem 1005:
Theorem (1005) [serial 2816] used for:
   Conditional False Expression:  not b and x=g  iff  not b and x=(b??e:g)  [serial 2814]
 


Theorem (1007)                               [serial 2815] 
P [86] << SHFT_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [87] ->
Q [88] << SHFT_HR() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1008)                               [serial 2812] 
P [86] << SHFT_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [87] ->
Q [88] << HEART_RATE^0 = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) and 
SHFT_HR() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1006 1007:
Theorem (1006) [serial 2814] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2812]
 
Theorem (1007) [serial 2815] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2812]
 


Theorem (1009)                               [serial 2810] 
P [86] << SHFT_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [87] ->
Q [88] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = ((HEART_RATE)^0) and 
SHFT_HR() >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1008:
Theorem (1008) [serial 2812] used for:
    normalization of [serial 2810]
 


Theorem (1010)                               [serial 2702] 
P [86] << SHFT_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [87] hr_nxt[1] := HeartRate?
Q [88] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
SHFT_HR() >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 1009:
Theorem (1009) [serial 2810] used for:
  applied wp for assignment [serial 2702]
 


Theorem (1011)                               [serial 2675] 
P [86] << SHFT_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [87] hr_nxt[1] := HeartRate?
Q [88] << SHFT_HR() and ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1010:
Theorem (1010) [serial 2702] used for:
    normalization of [serial 2675]
 


Theorem (1012)                               [serial 2818] 
P [88] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
SHFT_HR() >>
S [79] ->
Q [90] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1013)                               [serial 2828] 
P [88] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
(all i~quantity whole
  in 0..-1 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else HEART_RATE^(-1+- i)) = hr_nxt[
      2 + i] ) >>
S [79] ->
Q [91] << all i~quantity whole
  in 0..-1 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else HEART_RATE^(-1+- i)) = hr_nxt[
      2 + i]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1014)                               [serial 2826] 
P [88] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
(all i~quantity whole
  in 0..-1 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else HEART_RATE^(-1+- i)) = hr_nxt[
      1 + i + 1] ) >>
S [79] ->
Q [91] << all i~quantity whole
  in 0..-1 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else HEART_RATE^(-1+- i)) = hr_nxt[
      2 + i]  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1013:
Theorem (1013) [serial 2828] used for:
    normalization of [serial 2826]
 


Theorem (1015)                               [serial 2824] 
P [88] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
(all i~quantity whole
  in 0..-1 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else HEART_RATE^(-1+- i)) = hr_nxt[
      1 + (1 + i)] ) >>
S [79] ->
Q [91] << all i~quantity whole
  in 0..-1 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else HEART_RATE^(-1+- i)) = hr_nxt[
      2 + i]  >>
by Associativity: (b.c).a = a.b.c
and theorem 1014:
Theorem (1014) [serial 2826] used for:
  Associativity: (b.c).a = a.b.c [serial 2824]
 


Theorem (1016)                               [serial 2822] 
P [88] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
(all i~quantity whole
  in 0..(num_samples +  -1) 
  are (hr_nxt[(i + 1) + 1] = (if MOTION_ARTIFACT^((- i+- 1)) or not SENSOR_CONNECTED^((- i+- 1)) then 0 else HEART_RATE^((- i+- 1)))) ) >>
S [79] ->
Q [91] << (all i~quantity whole
  in 0..(1 + num_samples +  -2) 
  are (if MOTION_ARTIFACT^(1+- i+- 2) or not SENSOR_CONNECTED^(1+- i+- 2) then 0 else HEART_RATE^(1+- i+- 2)) = hr_nxt[(
      i + 2)] ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1015:
Theorem (1015) [serial 2824] used for:
    normalization of [serial 2822]
 


Theorem (1017)                               [serial 2821] 
P [88] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
(all i~quantity whole
  in 0..(num_samples - 1) 
  are (hr_nxt[(i + 1) + 1] = (if MOTION_ARTIFACT^(- (i+1)) or not SENSOR_CONNECTED^(- (i+1)) then 0 else HEART_RATE^(- (i+1)))) ) >>
S [79] ->
Q [91] << (all i~quantity whole
  in 0..((1 + num_samples) - 2) 
  are (if MOTION_ARTIFACT^(1-(i+2)) or not SENSOR_CONNECTED^(1-(i+2)) then 0 else HEART_RATE^(1-(i+2))) = hr_nxt[(
      i + 2)] ) >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 1016:
Theorem (1016) [serial 2822] used for:
   changing adding negation to subtraction  [serial 2821]
 


Theorem (1018)                               [serial 2820] 
P [88] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
(all i~quantity whole
  in 1..num_samples 
  are (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) ) >>
S [79] ->
Q [91] << (all i~quantity whole
  in 2..1 + num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
by Shift Quantification Range so Lower Bound is Zero
and theorem 1017:
Theorem (1017) [serial 2821] used for:
  Shift Quantification Range so Lower Bound is Zero [serial 2820]
 


Theorem (1019)                               [serial 2819] 
P [88] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
SHFT_HR() >>
S [79] ->
Q [91] << (all i~quantity whole
  in 2..1 + num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
by Substitution of Assertion Labels
and theorem 1018:
Theorem (1018) [serial 2820] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2819]
 


Theorem (1020)                               [serial 2704] 
P [88] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
SHFT_HR() >>
S [79] ->
Q [90] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
(all i~quantity whole
  in 2..1 + num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1012 1019:
Theorem (1012) [serial 2818] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2704]
 
Theorem (1019) [serial 2819] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2704]
 


Theorem (1021)                               [serial 2676] 
P [88] << SHFT_HR() and ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) >>
S [79] ->
Q [90] << ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) and 
(all i~quantity whole
  in 2..(num_samples + 1) 
  are (hr_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1020:
Theorem (1020) [serial 2704] used for:
    normalization of [serial 2676]
 


Theorem (1022)                               [serial 2665] 
P [76] << all i~quantity whole
  in 1..num_samples 
  are (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)))  >>
S [79] if 
(MotionArtifact? or not SensorConnected?)~> 
  << SHFT_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
  hr_nxt[1] := 0
  << SHFT_HR() and ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) >> 
[]
(not (MotionArtifact? or not SensorConnected?))~> 
  << SHFT_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
  hr_nxt[1] := HeartRate?
  << SHFT_HR() and ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) >> 
fi
Q [90] << ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) and 
(all i~quantity whole
  in 2..(num_samples + 1) 
  are (hr_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) ) >>
by Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>> (bl.iffi)
and theorems 972 978 985 997 1003 1011 1021:
Theorem (972) [serial 2670] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>>  in if-[]-fi  for [serial 2665]
 
Theorem (978) [serial 2671] used for:
    <<P and B0>> -> <<P0>>  for [serial 2665]
 
Theorem (985) [serial 2672] used for:
    <<P0>> S0 <<Q0>>  for [serial 2665]
 
Theorem (997) [serial 2673] used for:
    <<Q0>> -> <<Q>>  for [serial 2665]
 
Theorem (1003) [serial 2674] used for:
    <<P and B1>> -> <<P1>>  for [serial 2665]
 
Theorem (1011) [serial 2675] used for:
    <<P1>> S1 <<Q1>>  for [serial 2665]
 
Theorem (1021) [serial 2676] used for:
    <<Q1>> -> <<Q>>  for [serial 2665]
 


Theorem (1023)                               [serial 2831] 
P [95] << all i~quantity whole
  in 1..1 + num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i]  >>
S [94] ->
Q [95] << all i~quantity whole
  in 1..1 + num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i]  >>
by Identity (id):  P->P is tautology


Theorem (1024)                               [serial 2830] 
P [90] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
(all i~quantity whole
  in 2..1 + num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
S [94] ->
Q [95] << all i~quantity whole
  in 1..(1 + num_samples) 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i]  >>
by Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
and theorem 1023:
Theorem (1023) [serial 2831] used for:
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j) [serial 2830]
 


Theorem (1025)                               [serial 2706] 
P [90] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
(all i~quantity whole
  in 2..1 + num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
S [94] num_samples := 1 + num_samples
Q [95] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i]  >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 1024:
Theorem (1024) [serial 2830] used for:
  applied wp for assignment [serial 2706]
 


Theorem (1026)                               [serial 2666] 
P [90] << ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) and 
(all i~quantity whole
  in 2..(num_samples + 1) 
  are (hr_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) ) >>
S [94] num_samples := num_samples + 1
Q [95] << all i~quantity whole
  in 1..num_samples 
  are (hr_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)))  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1025:
Theorem (1025) [serial 2706] used for:
    normalization of [serial 2666]
 


Theorem (1027)                               [serial 2834] 
P [100] << (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] >>
S [101] ->
Q [102] << (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] >>
by Identity (id):  P->P is tautology


Theorem (1028)                               [serial 2832] 
P [100] << (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] >>
S [101] ->
Q [102] << (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = (hr_nxt[i]) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1027:
Theorem (1027) [serial 2834] used for:
    normalization of [serial 2832]
 


Theorem (1029)                               [serial 2710] 
P [100] << (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] >>
S [101] heart_rate_store[i] := hr_nxt[i]
Q [102] << (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = heart_rate_store[i] >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 1028:
Theorem (1028) [serial 2832] used for:
  applied wp for assignment [serial 2710]
 


Theorem (1030)                               [serial 2677] 
P [100] << (hr_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) >>
S [101] heart_rate_store[i] := hr_nxt[i]
Q [102] << (heart_rate_store[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1029:
Theorem (1029) [serial 2710] used for:
    normalization of [serial 2677]
 


Theorem (1031)                               [serial 2708] 
P [95] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i]  >>
S [98] ->
Q [104] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i]  >>
by Identity (id):  P->P is tautology


Theorem (1032)                               [serial 2678] 
P [95] << (all i~quantity whole
  in 1..num_samples 
  are (hr_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) ) >>
S [98] ->
Q [104] << all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i]  >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1031:
Theorem (1031) [serial 2708] used for:
    normalization of [serial 2678]
 


Theorem (1033)                               [serial 2667] 
P [95] << all i~quantity whole
  in 1..num_samples 
  are (hr_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)))  >>
S [98] forall i in 1..num_samples
  {
  << (hr_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) >>
  heart_rate_store[i] := hr_nxt[i]
  << (heart_rate_store[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) >>
  }  
Q [104] << all i~quantity whole
  in 1..num_samples 
  are (heart_rate_store[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)))  >>
by Universal Quantification Rule:
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any (bl.ulq)
and theorems 1030 1032:
Theorem (1030) [serial 2677] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 2667]
 
Theorem (1032) [serial 2678] used for:
    <<P and (x=e) and FAT>> -> <<wp(forall,Q)>>
 where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
   (in postcondition Q, replace all occurances of
    <<all z:i in r are B>> with <<all z:i in r are A>>)
  for [serial 2667]
 


Theorem (1034)                               [serial 1041] 
P [48] << INV_HR() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) >>
S [61] << INV_HR() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and AXIOM_HRT() >>
HeartRateTrend!(heart_rate_store)
;
<< INV_HR() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) and AXIOM_HRT() >>
NumSamples!(num_samples)
;
<< INV_HR() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) >>
forall i in 1..num_samples
  {
  << (heart_rate_store[i] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) >>
  hr_nxt[i + 1] := heart_rate_store[i]
  << (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) >>
  }  
<< SHFT_HR: :all i~quantity whole
  in 1..num_samples 
  are (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)))  >>
;
if 
(MotionArtifact? or not SensorConnected?)~> 
  << SHFT_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
  hr_nxt[1] := 0
  << SHFT_HR() and ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) >> 
[]
(not (MotionArtifact? or not SensorConnected?))~> 
  << SHFT_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
  hr_nxt[1] := HeartRate?
  << SHFT_HR() and ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) >> 
fi
<< ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) and (all i~quantity whole
  in 2..(num_samples + 1) 
  are (hr_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) ) >>
;
num_samples := num_samples + 1
<< all i~quantity whole
  in 1..num_samples 
  are (hr_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)))  >>
;
forall i in 1..num_samples
  {
  << (hr_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) >>
  heart_rate_store[i] := hr_nxt[i]
  << (heart_rate_store[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) >>
  }  
<< all i~quantity whole
  in 1..num_samples 
  are (heart_rate_store[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)))  >>
Q [50] << HOLD_HR(num_samples) >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 930 935 946 959 969 1022 1026 1033:
Theorem (930) [serial 2660] used for:
  P -> P1 in sequential composition for [serial 1041]
 
Theorem (935) [serial 2661] used for:
  Q5 -> Q in sequential composition for [serial 1041]
 
Theorem (946) [serial 2662] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1041]
 
Theorem (959) [serial 2663] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1041]
 
Theorem (969) [serial 2664] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1041]
 
Theorem (1022) [serial 2665] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1041]
 
Theorem (1026) [serial 2666] used for:
  <<Q3 and P4>> S4 <<Q4 and P5>> in sequential composition for [serial 1041]
 
Theorem (1033) [serial 2667] used for:
  <<Q4 and P5>> S5 <<Q5>> in sequential composition for [serial 1041]
 


Theorem (1035)                               [serial 2870] 
P [50] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [108] ->
Q [35] << all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1036)                               [serial 2867] 
P [50] << (all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s))) ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [108] ->
Q [35] << (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1035:
Theorem (1035) [serial 2870] used for:
    normalization of [serial 2867]
 


Theorem (1037)                               [serial 2863] 
P [50] << HOLD_HR(num_samples) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [108] ->
Q [35] << (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) ) >>
by Substitution of Assertion Labels
and theorem 1036:
Theorem (1036) [serial 2867] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2863]
 


Theorem (1038)                               [serial 2864] 
P [50] << HOLD_HR(num_samples) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [108] ->
Q [48] << num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1039)                               [serial 2872] 
P [50] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s] ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [108] ->
Q [35] << all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1040)                               [serial 2868] 
P [50] << (all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s))) ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [108] ->
Q [35] << (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1039:
Theorem (1039) [serial 2872] used for:
    normalization of [serial 2868]
 


Theorem (1041)                               [serial 2865] 
P [50] << HOLD_HR(num_samples) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [108] ->
Q [35] << (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) ) >>
by Substitution of Assertion Labels
and theorem 1040:
Theorem (1040) [serial 2868] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2865]
 


Theorem (1042)                               [serial 2866] 
P [50] << HOLD_HR(num_samples) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [108] ->
Q [48] << num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1043)                               [serial 2862] 
P [50] << HOLD_HR(num_samples) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [108] ->
Q [48] << (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) ) and 
num_samples < #PulseOx_Properties::Num_Trending_Samples >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1037 1038 1041 1042:
Theorem (1037) [serial 2863] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2862]
 
Theorem (1038) [serial 2864] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2862]
 
Theorem (1041) [serial 2865] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2862]
 
Theorem (1042) [serial 2866] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2862]
 


Theorem (1044)                               [serial 2859] 
P [50] << HOLD_HR(num_samples) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [108] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s]^1 = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Simultaneous Assignment
and theorem 1043:
Theorem (1043) [serial 2862] used for:
  applied wp for simultaneous assignment [serial 2859]
 


Theorem (1045)                               [serial 2857] 
P [50] << HOLD_HR(num_samples) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [108] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s]^1 = (if MOTION_ARTIFACT^(1-s) or not (SENSOR_CONNECTED^(- s))^1 then 0 else HEART_RATE^(1-s)) ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axioms:
    Caret Compostition:  (x^a)^b is x^(a+b)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Associativity: (b.c).a = a.b.c
and theorem 1044:
Theorem (1044) [serial 2859] used for:
    normalization of [serial 2857]
 


Theorem (1046)                               [serial 2855] 
P [50] << HOLD_HR(num_samples) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [108] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s]^1 = (if MOTION_ARTIFACT^(1-s) or (not SENSOR_CONNECTED^(- s))^1 then 0 else HEART_RATE^(1-s)) ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1045:
Theorem (1045) [serial 2857] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2855]
 


Theorem (1047)                               [serial 2853] 
P [50] << HOLD_HR(num_samples) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [108] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s]^1 = (if (MOTION_ARTIFACT^((- s)+1) or (not SENSOR_CONNECTED^(- s))^1) then 0 else HEART_RATE^(1-s)) ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Associativity: (b.c).a = a.b.c
and theorem 1046:
Theorem (1046) [serial 2855] used for:
    normalization of [serial 2853]
 


Theorem (1048)                               [serial 2851] 
P [50] << HOLD_HR(num_samples) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [108] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s]^1 = (if (MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s))^1 then 0 else HEART_RATE^(1-s)) ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1047:
Theorem (1047) [serial 2853] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2851]
 


Theorem (1049)                               [serial 2849] 
P [50] << HOLD_HR(num_samples) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [108] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << (all s~quantity whole
  in 1..num_samples 
  are (if (MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s))^1 then (0)^1 else HEART_RATE^((- s)+1)) = heart_rate_store[s]^1 ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
    Associativity: (b.c).a = a.b.c
and theorem 1048:
Theorem (1048) [serial 2851] used for:
    normalization of [serial 2849]
 


Theorem (1050)                               [serial 2847] 
P [50] << HOLD_HR(num_samples) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [108] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))^1 = heart_rate_store[s]^1 ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1049:
Theorem (1049) [serial 2849] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2847]
 


Theorem (1051)                               [serial 2845] 
P [50] << HOLD_HR(num_samples) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [108] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << (all s~quantity whole
  in 1..num_samples 
  are (((if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)))^1 = (heart_rate_store[s])^1) ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1050:
Theorem (1050) [serial 2847] used for:
    normalization of [serial 2845]
 


Theorem (1052)                               [serial 2843] 
P [50] << HOLD_HR(num_samples) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [108] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << (all s~quantity whole
  in 1..num_samples 
  are ((if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s])^1 ) and 
num_samples^1 < #PulseOx_Properties::Num_Trending_Samples >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1051:
Theorem (1051) [serial 2845] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2843]
 


Theorem (1053)                               [serial 2841] 
P [50] << HOLD_HR(num_samples) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [108] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << (all s~quantity whole
  in 1..num_samples 
  are ((if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s])^1 ) and 
((num_samples)^1 < (#PulseOx_Properties::Num_Trending_Samples)^1) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
and theorem 1052:
Theorem (1052) [serial 2843] used for:
    normalization of [serial 2841]
 


Theorem (1054)                               [serial 2839] 
P [50] << HOLD_HR(num_samples) and num_samples < #PulseOx_Properties::Num_Trending_Samples >>
S [108] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] )^1 and 
(num_samples < #PulseOx_Properties::Num_Trending_Samples)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1053:
Theorem (1053) [serial 2841] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2839]
 


Theorem (1055)                               [serial 2837] 
P [50] << (HOLD_HR(num_samples)) and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) >>
S [108] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << ((all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))) )^1 and 
((num_samples < #PulseOx_Properties::Num_Trending_Samples))^1) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1054:
Theorem (1054) [serial 2839] used for:
    normalization of [serial 2837]
 


Theorem (1056)                               [serial 2836] 
P [50] << (HOLD_HR(num_samples)) and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) >>
S [108] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << ((all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))) ) and 
((num_samples < #PulseOx_Properties::Num_Trending_Samples)))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1055:
Theorem (1055) [serial 2837] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2836]
 


Theorem (1057)                               [serial 1042] 
P [50] << (HOLD_HR(num_samples)) and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)) >>
S [108] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [48] << (INV_HR() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples)))^1 >>
by Substitution of Assertion Labels
and theorem 1056:
Theorem (1056) [serial 2836] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 1042]
 


Theorem (1058)                               [serial 2906] 
P [50] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s] ) >>
S [110] ->
Q [52] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s] ) >>
by Identity (id):  P->P is tautology


Theorem (1059)                               [serial 2908] 
P [50] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s] ) >>
S [110] ->
Q [52] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s] ) >>
by Identity (id):  P->P is tautology


Theorem (1060)                               [serial 2904] 
P [50] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s] ) >>
S [110] ->
Q [52] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s] = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorems 1058 1059:
Theorem (1058) [serial 2906] used for:
    normalization of [serial 2904]
 
Theorem (1059) [serial 2908] used for:
    normalization of [serial 2904]
 


Theorem (1061)                               [serial 2901] 
P [50] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s] ) >>
S [110] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [52] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s]^1 = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) ) >>
by Simultaneous Assignment
and theorem 1060:
Theorem (1060) [serial 2904] used for:
  applied wp for simultaneous assignment [serial 2901]
 


Theorem (1062)                               [serial 2899] 
P [50] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s] ) >>
S [110] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [52] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s]^1 = (if MOTION_ARTIFACT^(1-s) or not (SENSOR_CONNECTED^(- s))^1 then 0 else HEART_RATE^(1-s)) ) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Caret Compostition:  (x^a)^b is x^(a+b)
    Associativity: (b.c).a = a.b.c
and theorem 1061:
Theorem (1061) [serial 2901] used for:
    normalization of [serial 2899]
 


Theorem (1063)                               [serial 2897] 
P [50] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s] ) >>
S [110] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [52] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s]^1 = (if MOTION_ARTIFACT^(1-s) or (not SENSOR_CONNECTED^(- s))^1 then 0 else HEART_RATE^(1-s)) ) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1062:
Theorem (1062) [serial 2899] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2897]
 


Theorem (1064)                               [serial 2895] 
P [50] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s] ) >>
S [110] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [52] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s]^1 = (if (MOTION_ARTIFACT^((- s)+1) or (not SENSOR_CONNECTED^(- s))^1) then 0 else HEART_RATE^(1-s)) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Associativity: (b.c).a = a.b.c
and theorem 1063:
Theorem (1063) [serial 2897] used for:
    normalization of [serial 2895]
 


Theorem (1065)                               [serial 2893] 
P [50] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s] ) >>
S [110] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [52] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s]^1 = (if (MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s))^1 then 0 else HEART_RATE^(1-s)) ) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1064:
Theorem (1064) [serial 2895] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2893]
 


Theorem (1066)                               [serial 2891] 
P [50] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s] ) >>
S [110] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [52] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if (MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s))^1 then (0)^1 else HEART_RATE^((- s)+1)) = heart_rate_store[s]^1 ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
    Associativity: (b.c).a = a.b.c
and theorem 1065:
Theorem (1065) [serial 2893] used for:
    normalization of [serial 2891]
 


Theorem (1067)                               [serial 2889] 
P [50] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s] ) >>
S [110] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [52] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))^1 = heart_rate_store[s]^1 ) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1066:
Theorem (1066) [serial 2891] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2889]
 


Theorem (1068)                               [serial 2887] 
P [50] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s] ) >>
S [110] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [52] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (((if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)))^1 = (heart_rate_store[s])^1) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1067:
Theorem (1067) [serial 2889] used for:
    normalization of [serial 2887]
 


Theorem (1069)                               [serial 2885] 
P [50] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s] ) >>
S [110] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [52] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are ((if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s])^1 ) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1068:
Theorem (1068) [serial 2887] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2885]
 


Theorem (1070)                               [serial 2883] 
P [50] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s] ) >>
S [110] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [52] << ((num_samples)^1 = (#PulseOx_Properties::Num_Trending_Samples)^1) and 
(all s~quantity whole
  in 1..num_samples 
  are ((if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s])^1 ) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
and theorem 1069:
Theorem (1069) [serial 2885] used for:
    normalization of [serial 2883]
 


Theorem (1071)                               [serial 2881] 
P [50] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s] ) >>
S [110] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [52] << (num_samples = #PulseOx_Properties::Num_Trending_Samples)^1 and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] )^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1070:
Theorem (1070) [serial 2883] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2881]
 


Theorem (1072)                               [serial 2879] 
P [50] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s] ) >>
S [110] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [52] << ((num_samples = #PulseOx_Properties::Num_Trending_Samples)^1 and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] )^1) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1071:
Theorem (1071) [serial 2881] used for:
    normalization of [serial 2879]
 


Theorem (1073)                               [serial 2877] 
P [50] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) = heart_rate_store[s] ) >>
S [110] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [52] << (num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1072:
Theorem (1072) [serial 2879] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2877]
 


Theorem (1074)                               [serial 2875] 
P [50] << ((all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s))) )) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
S [110] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [52] << ((all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)))^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1073:
Theorem (1073) [serial 2877] used for:
    normalization of [serial 2875]
 


Theorem (1075)                               [serial 1043] 
P [50] << (HOLD_HR(num_samples)) and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
S [110] |nts',heart_rate_store',hr_nxt',num_samples' := nts,heart_rate_store,hr_nxt,num_samples|  
Q [52] << (INV_HR() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)))^1 >>
by Substitution of Assertion Labels
and theorem 1074:
Theorem (1074) [serial 2875] used for:
  substituted Assertions' predicates for  labels  [serial 1043]
 


Theorem (1076)                               [serial 1044] 
P [50] << (HOLD_HR(num_samples)) and ((num_samples > #PulseOx_Properties::Num_Trending_Samples)) >>
S [111] ->
Q [54] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1077)                               [serial 3002] 
P [52] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
S [52] ->
Q [114] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
by Identity (id):  P->P is tautology


Theorem (1078)                               [serial 2999] 
P [52] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
S [52] ->
Q [114] << num_samples = #PulseOx_Properties::Num_Trending_Samples and true and 
INV_HR() >>
by Law of And-Simplification:  P and true is P
and theorem 1077:
Theorem (1077) [serial 3002] used for:
  Law of And-Simplification:  P and true is P [serial 2999]
 


Theorem (1079)                               [serial 3002] 
P [52] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
S [52] ->
Q [114] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
by Identity (id):  P->P is tautology


Theorem (1080)                               [serial 2999] 
P [52] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
S [52] ->
Q [114] << num_samples = #PulseOx_Properties::Num_Trending_Samples and true and 
INV_HR() >>
by Law of And-Simplification:  P and true is P
and theorem 1079:
Theorem (1079) [serial 3002] used for:
  Law of And-Simplification:  P and true is P [serial 2999]
 


Theorem (1081)                               [serial 2931] 
P [52] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
S [52] ->
Q [114] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR() >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 1080 1080:
Theorem (1080) [serial 2999] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (1080) [serial 2999] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (1082)                               [serial 2911] 
P [52] << INV_HR() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
S [52] ->
Q [114] << INV_HR() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_HRT() >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1081:
Theorem (1081) [serial 2931] used for:
    normalization of [serial 2911]
 


Theorem (1083)                               [serial 3031] 
P [161] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are heart_rate_store[i]^1 = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) ) >>
S [52] ->
Q [52] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1084)                               [serial 3033] 
P [161] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all #12#~quantity whole
  in 1..num_samples 
  are heart_rate_store[#12#]^1 = (if MOTION_ARTIFACT^(1-#12#) or not SENSOR_CONNECTED^(1-#12#) then 0 else HEART_RATE^(1-#12#)) ) >>
S [52] ->
Q [35] << all #13#~quantity whole
  in 1..num_samples 
  are heart_rate_store[#13#]^1 = (if MOTION_ARTIFACT^(1-#13#) or not SENSOR_CONNECTED^(1-#13#) then 0 else HEART_RATE^(1-#13#))  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1085)                               [serial 3032] 
P [161] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are heart_rate_store[i]^1 = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) ) >>
S [52] ->
Q [35] << (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s]^1 = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) ) >>
by Replacement of Quantified Variables with #1, #2, etc.
and theorem 1084:
Theorem (1084) [serial 3033] used for:
  Replacement of Quantified Variables with #1, #2, etc. [serial 3032]
 


Theorem (1086)                               [serial 3028] 
P [161] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are heart_rate_store[i]^1 = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) ) >>
S [52] ->
Q [21] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s]^1 = (if MOTION_ARTIFACT^(1-s) or not SENSOR_CONNECTED^(1-s) then 0 else HEART_RATE^(1-s)) ) >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1083 1085:
Theorem (1083) [serial 3031] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3028]
 
Theorem (1085) [serial 3032] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3028]
 


Theorem (1087)                               [serial 3026] 
P [161] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are heart_rate_store[i]^1 = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) ) >>
S [52] ->
Q [21] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s]^1 = (if MOTION_ARTIFACT^(1-s) or not (SENSOR_CONNECTED^(- s))^1 then 0 else HEART_RATE^(1-s)) ) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Caret Compostition:  (x^a)^b is x^(a+b)
    Associativity: (b.c).a = a.b.c
and theorem 1086:
Theorem (1086) [serial 3028] used for:
    normalization of [serial 3026]
 


Theorem (1088)                               [serial 3024] 
P [161] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are heart_rate_store[i]^1 = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) ) >>
S [52] ->
Q [21] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s]^1 = (if MOTION_ARTIFACT^(1-s) or (not SENSOR_CONNECTED^(- s))^1 then 0 else HEART_RATE^(1-s)) ) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1087:
Theorem (1087) [serial 3026] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3024]
 


Theorem (1089)                               [serial 3022] 
P [161] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are heart_rate_store[i]^1 = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) ) >>
S [52] ->
Q [21] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s]^1 = (if (MOTION_ARTIFACT^((- s)+1) or (not SENSOR_CONNECTED^(- s))^1) then 0 else HEART_RATE^(1-s)) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Associativity: (b.c).a = a.b.c
and theorem 1088:
Theorem (1088) [serial 3024] used for:
    normalization of [serial 3022]
 


Theorem (1090)                               [serial 3020] 
P [161] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are heart_rate_store[i]^1 = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) ) >>
S [52] ->
Q [21] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are heart_rate_store[s]^1 = (if (MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s))^1 then 0 else HEART_RATE^(1-s)) ) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1089:
Theorem (1089) [serial 3022] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3020]
 


Theorem (1091)                               [serial 3018] 
P [161] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are heart_rate_store[i]^1 = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) ) >>
S [52] ->
Q [21] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if (MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s))^1 then (0)^1 else HEART_RATE^((- s)+1)) = heart_rate_store[s]^1 ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
    Associativity: (b.c).a = a.b.c
and theorem 1090:
Theorem (1090) [serial 3020] used for:
    normalization of [serial 3018]
 


Theorem (1092)                               [serial 3016] 
P [161] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are heart_rate_store[i]^1 = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) ) >>
S [52] ->
Q [21] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))^1 = heart_rate_store[s]^1 ) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1091:
Theorem (1091) [serial 3018] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3016]
 


Theorem (1093)                               [serial 3014] 
P [161] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are heart_rate_store[i]^1 = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) ) >>
S [52] ->
Q [21] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (((if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)))^1 = (heart_rate_store[s])^1) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1092:
Theorem (1092) [serial 3016] used for:
    normalization of [serial 3014]
 


Theorem (1094)                               [serial 3012] 
P [161] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are heart_rate_store[i]^1 = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) ) >>
S [52] ->
Q [21] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are ((if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s])^1 ) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1093:
Theorem (1093) [serial 3014] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3012]
 


Theorem (1095)                               [serial 3010] 
P [161] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are heart_rate_store[i]^1 = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) ) >>
S [52] ->
Q [21] << ((num_samples)^1 = (#PulseOx_Properties::Num_Trending_Samples)^1) and 
(all s~quantity whole
  in 1..num_samples 
  are ((if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s])^1 ) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
and theorem 1094:
Theorem (1094) [serial 3012] used for:
    normalization of [serial 3010]
 


Theorem (1096)                               [serial 3008] 
P [161] << num_samples^1 = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are heart_rate_store[i]^1 = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) ) >>
S [52] ->
Q [21] << (num_samples = #PulseOx_Properties::Num_Trending_Samples)^1 and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] )^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1095:
Theorem (1095) [serial 3010] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3008]
 


Theorem (1097)                               [serial 3006] 
P [161] << #PulseOx_Properties::Num_Trending_Samples = (num_samples)^1 and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = (heart_rate_store[i])^1 ) >>
S [52] ->
Q [21] << ((num_samples = #PulseOx_Properties::Num_Trending_Samples)^1 and (all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))) )^1) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1096:
Theorem (1096) [serial 3008] used for:
    normalization of [serial 3006]
 


Theorem (1098)                               [serial 3005] 
P [161] << #PulseOx_Properties::Num_Trending_Samples = num_samples' and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = heart_rate_store[i]' ) >>
S [52] ->
Q [21] << (num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))) ))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1097:
Theorem (1097) [serial 3006] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3005]
 


Theorem (1099)                               [serial 2933] 
P [161] << #PulseOx_Properties::Num_Trending_Samples = num_samples' and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = heart_rate_store[i]' ) >>
S [52] ->
Q [21] << (num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR())^1 >>
by Substitution of Assertion Labels
and theorem 1098:
Theorem (1098) [serial 3005] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 2933]
 


Theorem (1100)                               [serial 2912] 
P [161] << (all i~quantity whole
  in 1..num_samples 
  are (heart_rate_store[i]' = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) ) and 
((num_samples' = #PulseOx_Properties::Num_Trending_Samples)) >>
S [52] ->
Q [21] << (INV_HR() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)))^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1099:
Theorem (1099) [serial 2933] used for:
    normalization of [serial 2912]
 


Theorem (1101)                               [serial 3143] 
P [114] << HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) >>
S [116] ->
Q [15] << all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1102)                               [serial 3142] 
P [114] << HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) >>
S [116] ->
Q [15] << all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = HEART_RATE_HISTORY[s]  >>
by Guided Substitution of Equals
and theorem 1101:
Theorem (1101) [serial 3143] used for:
  Guided Substitution of Equals
 replacing "HEART_RATE_HISTORY" with its = "heart_rate_store" in its postcondition [serial 3142]
 


Theorem (1103)                               [serial 3141] 
P [114] << HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) >>
S [116] ->
Q [15] << all s~quantity whole
  in 1..NUM_SAMPLES 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = HEART_RATE_HISTORY[s]  >>
by Guided Substitution of Equals
and theorem 1102:
Theorem (1102) [serial 3142] used for:
  Guided Substitution of Equals
 replacing "NUM_SAMPLES" with its = "num_samples" in its postcondition [serial 3141]
 


Theorem (1104)                               [serial 3139] 
P [114] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
(HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples) >>
S [116] ->
Q [15] << all s~quantity whole
  in 1..NUM_SAMPLES 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = HEART_RATE_HISTORY[s]  >>
by Associativity: (b.c).a = a.b.c
and theorem 1103:
Theorem (1103) [serial 3141] used for:
  Associativity: (b.c).a = a.b.c [serial 3139]
 


Theorem (1105)                               [serial 3137] 
P [114] << num_samples = #PulseOx_Properties::Num_Trending_Samples and ((num_samples = NUM_SAMPLES) and 
(heart_rate_store = HEART_RATE_HISTORY)) and (all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))) ) >>
S [116] ->
Q [15] << (all s~quantity whole
  in 1..NUM_SAMPLES 
  are (HEART_RATE_HISTORY[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1104:
Theorem (1104) [serial 3139] used for:
    normalization of [serial 3137]
 


Theorem (1106)                               [serial 3126] 
P [114] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR() >>
S [116] ->
Q [15] << HR_TREND() >>
by Substitution of Assertion Labels
and theorem 1105:
Theorem (1105) [serial 3137] used for:
  substituted Assertions' predicates for  labels  [serial 3126]
 


Theorem (1107)                               [serial 3135] 
P [116] << (HR_TREND())^0 and num_samples = #PulseOx_Properties::Num_Trending_Samples and 
AXIOM_HRT() and INV_HR() >>
S [116] ->
Q [118] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (1108)                               [serial 3132] 
P [116] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR() and (HR_TREND())^0 >>
S [116] ->
Q [118] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1107:
Theorem (1107) [serial 3135] used for:
    normalization of [serial 3132]
 


Theorem (1109)                               [serial 3130] 
P [116] << (HR_TREND())^0 and (num_samples = #PulseOx_Properties::Num_Trending_Samples and 
AXIOM_HRT() and INV_HR()) >>
S [116] ->
Q [118] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
by Associativity: (b.c).a = a.b.c
and theorem 1108:
Theorem (1108) [serial 3132] used for:
  Associativity: (b.c).a = a.b.c [serial 3130]
 


Theorem (1110)                               [serial 3127] 
P [116] << (num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR()) and (HR_TREND())^0 >>
S [116] ->
Q [118] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1109:
Theorem (1109) [serial 3130] used for:
    normalization of [serial 3127]
 


Theorem (1111)                               [serial 3003] 
P [114] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR() >>
S [116] HeartRateTrend!(heart_rate_store)
Q [118] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 1106 1110:
Theorem (1106) [serial 3126] used for:
  applied port output of value <<pre>> -> <<M(HeartRateTrend)[HeartRateTrend|heart_rate_store]>> [serial 3003]
 
Theorem (1110) [serial 3127] used for:
  applied port output <<pre and (HR_TREND())^0>> -> <<post>> [serial 3003]
 


Theorem (1112)                               [serial 3000] 
P [114] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR() >>
S [116] HeartRateTrend!(heart_rate_store)
Q [118] << num_samples = #PulseOx_Properties::Num_Trending_Samples and true and 
INV_HR() >>
by Law of And-Simplification:  P and true is P
and theorem 1111:
Theorem (1111) [serial 3003] used for:
  Law of And-Simplification:  P and true is P [serial 3000]
 


Theorem (1113)                               [serial 3143] 
P [114] << HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) >>
S [116] ->
Q [15] << all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1114)                               [serial 3142] 
P [114] << HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) >>
S [116] ->
Q [15] << all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = HEART_RATE_HISTORY[s]  >>
by Guided Substitution of Equals
and theorem 1113:
Theorem (1113) [serial 3143] used for:
  Guided Substitution of Equals
 replacing "HEART_RATE_HISTORY" with its = "heart_rate_store" in its postcondition [serial 3142]
 


Theorem (1115)                               [serial 3141] 
P [114] << HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) >>
S [116] ->
Q [15] << all s~quantity whole
  in 1..NUM_SAMPLES 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = HEART_RATE_HISTORY[s]  >>
by Guided Substitution of Equals
and theorem 1114:
Theorem (1114) [serial 3142] used for:
  Guided Substitution of Equals
 replacing "NUM_SAMPLES" with its = "num_samples" in its postcondition [serial 3141]
 


Theorem (1116)                               [serial 3139] 
P [114] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
(HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples) >>
S [116] ->
Q [15] << all s~quantity whole
  in 1..NUM_SAMPLES 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = HEART_RATE_HISTORY[s]  >>
by Associativity: (b.c).a = a.b.c
and theorem 1115:
Theorem (1115) [serial 3141] used for:
  Associativity: (b.c).a = a.b.c [serial 3139]
 


Theorem (1117)                               [serial 3137] 
P [114] << num_samples = #PulseOx_Properties::Num_Trending_Samples and ((num_samples = NUM_SAMPLES) and 
(heart_rate_store = HEART_RATE_HISTORY)) and (all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))) ) >>
S [116] ->
Q [15] << (all s~quantity whole
  in 1..NUM_SAMPLES 
  are (HEART_RATE_HISTORY[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1116:
Theorem (1116) [serial 3139] used for:
    normalization of [serial 3137]
 


Theorem (1118)                               [serial 3126] 
P [114] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR() >>
S [116] ->
Q [15] << HR_TREND() >>
by Substitution of Assertion Labels
and theorem 1117:
Theorem (1117) [serial 3137] used for:
  substituted Assertions' predicates for  labels  [serial 3126]
 


Theorem (1119)                               [serial 3135] 
P [116] << (HR_TREND())^0 and num_samples = #PulseOx_Properties::Num_Trending_Samples and 
AXIOM_HRT() and INV_HR() >>
S [116] ->
Q [118] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (1120)                               [serial 3132] 
P [116] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR() and (HR_TREND())^0 >>
S [116] ->
Q [118] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1119:
Theorem (1119) [serial 3135] used for:
    normalization of [serial 3132]
 


Theorem (1121)                               [serial 3130] 
P [116] << (HR_TREND())^0 and (num_samples = #PulseOx_Properties::Num_Trending_Samples and 
AXIOM_HRT() and INV_HR()) >>
S [116] ->
Q [118] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
by Associativity: (b.c).a = a.b.c
and theorem 1120:
Theorem (1120) [serial 3132] used for:
  Associativity: (b.c).a = a.b.c [serial 3130]
 


Theorem (1122)                               [serial 3127] 
P [116] << (num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR()) and (HR_TREND())^0 >>
S [116] ->
Q [118] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1121:
Theorem (1121) [serial 3130] used for:
    normalization of [serial 3127]
 


Theorem (1123)                               [serial 3003] 
P [114] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR() >>
S [116] HeartRateTrend!(heart_rate_store)
Q [118] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 1118 1122:
Theorem (1118) [serial 3126] used for:
  applied port output of value <<pre>> -> <<M(HeartRateTrend)[HeartRateTrend|heart_rate_store]>> [serial 3003]
 
Theorem (1122) [serial 3127] used for:
  applied port output <<pre and (HR_TREND())^0>> -> <<post>> [serial 3003]
 


Theorem (1124)                               [serial 3000] 
P [114] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR() >>
S [116] HeartRateTrend!(heart_rate_store)
Q [118] << num_samples = #PulseOx_Properties::Num_Trending_Samples and true and 
INV_HR() >>
by Law of And-Simplification:  P and true is P
and theorem 1123:
Theorem (1123) [serial 3003] used for:
  Law of And-Simplification:  P and true is P [serial 3000]
 


Theorem (1125)                               [serial 2935] 
P [114] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR() >>
S [116] HeartRateTrend!(heart_rate_store)
Q [118] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR() >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 1124 1124:
Theorem (1124) [serial 3000] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (1124) [serial 3000] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (1126)                               [serial 2913] 
P [114] << INV_HR() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_HRT() >>
S [116] HeartRateTrend!(heart_rate_store)
Q [118] << INV_HR() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_HRT() >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1125:
Theorem (1125) [serial 2935] used for:
    normalization of [serial 2913]
 


Theorem (1127)                               [serial 3152] 
P [120] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR() and (NumSamples = num_samples)^0 >>
S [120] ->
Q [122] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (1128)                               [serial 3147] 
P [120] << (NumSamples = num_samples)^0 and (num_samples = #PulseOx_Properties::Num_Trending_Samples and 
AXIOM_HRT() and INV_HR()) >>
S [120] ->
Q [122] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
by Associativity: (b.c).a = a.b.c
and theorem 1127:
Theorem (1127) [serial 3152] used for:
  Associativity: (b.c).a = a.b.c [serial 3147]
 


Theorem (1129)                               [serial 3144] 
P [120] << (num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR()) and (NumSamples = num_samples)^0 >>
S [120] ->
Q [122] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1128:
Theorem (1128) [serial 3147] used for:
    normalization of [serial 3144]
 


Theorem (1130)                               [serial 3163] 
P [120] << HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples and 
NumSamples = num_samples and num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) >>
S [120] ->
Q [120] << NUM_SAMPLES = num_samples >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1131)                               [serial 3162] 
P [120] << HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples and 
NumSamples = num_samples and num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) >>
S [120] ->
Q [120] << NUM_SAMPLES = NumSamples >>
by Guided Substitution of Equals
and theorem 1130:
Theorem (1130) [serial 3163] used for:
  Guided Substitution of Equals
 replacing "NumSamples" with its = "num_samples" in its postcondition [serial 3162]
 


Theorem (1132)                               [serial 3160] 
P [120] << (NumSamples = num_samples)^0 and HEART_RATE_HISTORY = heart_rate_store and 
NUM_SAMPLES = num_samples and num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) >>
S [120] ->
Q [120] << NUM_SAMPLES = NumSamples >>
by Assume Present:  P = P@now = P^0 
and theorem 1131:
Theorem (1131) [serial 3162] used for:
  Assume Present:  P = P@now = P^0  [serial 3160]
 


Theorem (1133)                               [serial 3158] 
P [120] << HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples and 
(NumSamples = num_samples)^0 and num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) >>
S [120] ->
Q [120] << NUM_SAMPLES = NumSamples >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1132:
Theorem (1132) [serial 3160] used for:
    normalization of [serial 3158]
 


Theorem (1134)                               [serial 3156] 
P [120] << (NumSamples = num_samples)^0 and num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
(HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples) >>
S [120] ->
Q [120] << NUM_SAMPLES = NumSamples >>
by Associativity: (b.c).a = a.b.c
and theorem 1133:
Theorem (1133) [serial 3158] used for:
  Associativity: (b.c).a = a.b.c [serial 3156]
 


Theorem (1135)                               [serial 3154] 
P [120] << num_samples = #PulseOx_Properties::Num_Trending_Samples and ((num_samples = NUM_SAMPLES) and 
(heart_rate_store = HEART_RATE_HISTORY)) and (all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))) ) and 
(NumSamples = num_samples)^0 >>
S [120] ->
Q [120] << NUM_SAMPLES = NumSamples >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1134:
Theorem (1134) [serial 3156] used for:
    normalization of [serial 3154]
 


Theorem (1136)                               [serial 3153] 
P [120] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR() and (NumSamples = num_samples)^0 >>
S [120] ->
Q [120] << NUM_SAMPLES = NumSamples >>
by Substitution of Assertion Labels
and theorem 1135:
Theorem (1135) [serial 3154] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 3153]
 


Theorem (1137)                               [serial 3149] 
P [120] << (NumSamples = num_samples)^0 and (num_samples = #PulseOx_Properties::Num_Trending_Samples and 
AXIOM_HRT() and INV_HR()) >>
S [120] ->
Q [120] << NUM_SAMPLES = NumSamples >>
by Associativity: (b.c).a = a.b.c
and theorem 1136:
Theorem (1136) [serial 3153] used for:
  Associativity: (b.c).a = a.b.c [serial 3149]
 


Theorem (1138)                               [serial 3145] 
P [120] << (num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR()) and (NumSamples = num_samples)^0 >>
S [120] ->
Q [120] << NumSamples = NUM_SAMPLES >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1137:
Theorem (1137) [serial 3149] used for:
    normalization of [serial 3145]
 


Theorem (1139)                               [serial 3004] 
P [118] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR() >>
S [120] NumSamples!(num_samples)
Q [122] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 1129 1138:
Theorem (1129) [serial 3144] used for:
  applied port output <<pre and (NumSamples=num_samples)^0>> -> <<post>> [serial 3004]
 
Theorem (1138) [serial 3145] used for:
  applied port output <<pre and (NumSamples=num_samples)^0>> -> <<(NumSamples=NUM_SAMPLES)^0>> [serial 3004]
 


Theorem (1140)                               [serial 3001] 
P [118] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR() >>
S [120] NumSamples!(num_samples)
Q [122] << num_samples = #PulseOx_Properties::Num_Trending_Samples and true and 
INV_HR() >>
by Law of And-Simplification:  P and true is P
and theorem 1139:
Theorem (1139) [serial 3004] used for:
  Law of And-Simplification:  P and true is P [serial 3001]
 


Theorem (1141)                               [serial 3152] 
P [120] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR() and (NumSamples = num_samples)^0 >>
S [120] ->
Q [122] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (1142)                               [serial 3147] 
P [120] << (NumSamples = num_samples)^0 and (num_samples = #PulseOx_Properties::Num_Trending_Samples and 
AXIOM_HRT() and INV_HR()) >>
S [120] ->
Q [122] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
by Associativity: (b.c).a = a.b.c
and theorem 1141:
Theorem (1141) [serial 3152] used for:
  Associativity: (b.c).a = a.b.c [serial 3147]
 


Theorem (1143)                               [serial 3144] 
P [120] << (num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR()) and (NumSamples = num_samples)^0 >>
S [120] ->
Q [122] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1142:
Theorem (1142) [serial 3147] used for:
    normalization of [serial 3144]
 


Theorem (1144)                               [serial 3163] 
P [120] << HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples and 
NumSamples = num_samples and num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) >>
S [120] ->
Q [120] << NUM_SAMPLES = num_samples >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1145)                               [serial 3162] 
P [120] << HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples and 
NumSamples = num_samples and num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) >>
S [120] ->
Q [120] << NUM_SAMPLES = NumSamples >>
by Guided Substitution of Equals
and theorem 1144:
Theorem (1144) [serial 3163] used for:
  Guided Substitution of Equals
 replacing "NumSamples" with its = "num_samples" in its postcondition [serial 3162]
 


Theorem (1146)                               [serial 3160] 
P [120] << (NumSamples = num_samples)^0 and HEART_RATE_HISTORY = heart_rate_store and 
NUM_SAMPLES = num_samples and num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) >>
S [120] ->
Q [120] << NUM_SAMPLES = NumSamples >>
by Assume Present:  P = P@now = P^0 
and theorem 1145:
Theorem (1145) [serial 3162] used for:
  Assume Present:  P = P@now = P^0  [serial 3160]
 


Theorem (1147)                               [serial 3158] 
P [120] << HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples and 
(NumSamples = num_samples)^0 and num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) >>
S [120] ->
Q [120] << NUM_SAMPLES = NumSamples >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1146:
Theorem (1146) [serial 3160] used for:
    normalization of [serial 3158]
 


Theorem (1148)                               [serial 3156] 
P [120] << (NumSamples = num_samples)^0 and num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all s~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s)) = heart_rate_store[s] ) and 
(HEART_RATE_HISTORY = heart_rate_store and NUM_SAMPLES = num_samples) >>
S [120] ->
Q [120] << NUM_SAMPLES = NumSamples >>
by Associativity: (b.c).a = a.b.c
and theorem 1147:
Theorem (1147) [serial 3158] used for:
  Associativity: (b.c).a = a.b.c [serial 3156]
 


Theorem (1149)                               [serial 3154] 
P [120] << num_samples = #PulseOx_Properties::Num_Trending_Samples and ((num_samples = NUM_SAMPLES) and 
(heart_rate_store = HEART_RATE_HISTORY)) and (all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))) ) and 
(NumSamples = num_samples)^0 >>
S [120] ->
Q [120] << NUM_SAMPLES = NumSamples >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1148:
Theorem (1148) [serial 3156] used for:
    normalization of [serial 3154]
 


Theorem (1150)                               [serial 3153] 
P [120] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR() and (NumSamples = num_samples)^0 >>
S [120] ->
Q [120] << NUM_SAMPLES = NumSamples >>
by Substitution of Assertion Labels
and theorem 1149:
Theorem (1149) [serial 3154] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 3153]
 


Theorem (1151)                               [serial 3149] 
P [120] << (NumSamples = num_samples)^0 and (num_samples = #PulseOx_Properties::Num_Trending_Samples and 
AXIOM_HRT() and INV_HR()) >>
S [120] ->
Q [120] << NUM_SAMPLES = NumSamples >>
by Associativity: (b.c).a = a.b.c
and theorem 1150:
Theorem (1150) [serial 3153] used for:
  Associativity: (b.c).a = a.b.c [serial 3149]
 


Theorem (1152)                               [serial 3145] 
P [120] << (num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR()) and (NumSamples = num_samples)^0 >>
S [120] ->
Q [120] << NumSamples = NUM_SAMPLES >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1151:
Theorem (1151) [serial 3149] used for:
    normalization of [serial 3145]
 


Theorem (1153)                               [serial 3004] 
P [118] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR() >>
S [120] NumSamples!(num_samples)
Q [122] << num_samples = #PulseOx_Properties::Num_Trending_Samples and INV_HR() >>
by Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 1143 1152:
Theorem (1143) [serial 3144] used for:
  applied port output <<pre and (NumSamples=num_samples)^0>> -> <<post>> [serial 3004]
 
Theorem (1152) [serial 3145] used for:
  applied port output <<pre and (NumSamples=num_samples)^0>> -> <<(NumSamples=NUM_SAMPLES)^0>> [serial 3004]
 


Theorem (1154)                               [serial 3001] 
P [118] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR() >>
S [120] NumSamples!(num_samples)
Q [122] << num_samples = #PulseOx_Properties::Num_Trending_Samples and true and 
INV_HR() >>
by Law of And-Simplification:  P and true is P
and theorem 1153:
Theorem (1153) [serial 3004] used for:
  Law of And-Simplification:  P and true is P [serial 3001]
 


Theorem (1155)                               [serial 2937] 
P [118] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_HRT() and 
INV_HR() >>
S [120] NumSamples!(num_samples)
Q [122] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_CR() and 
INV_HR() >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 1154 1154:
Theorem (1154) [serial 3001] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (1154) [serial 3001] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (1156)                               [serial 2914] 
P [118] << INV_HR() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_HRT() >>
S [120] NumSamples!(num_samples)
Q [122] << INV_HR() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_CR() >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1155:
Theorem (1155) [serial 2937] used for:
    normalization of [serial 2914]
 


Theorem (1157)                               [serial 3043] 
P [126] << (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = heart_rate_store[i] >>
S [127] ->
Q [128] << (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = heart_rate_store[i] >>
by Identity (id):  P->P is tautology


Theorem (1158)                               [serial 3041] 
P [126] << (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = heart_rate_store[i] >>
S [127] ->
Q [128] << (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = (heart_rate_store[i]) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1157:
Theorem (1157) [serial 3043] used for:
    normalization of [serial 3041]
 


Theorem (1159)                               [serial 2941] 
P [126] << (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = heart_rate_store[i] >>
S [127] hr_nxt[1 + i] := heart_rate_store[i]
Q [128] << (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
1 + i] >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 1158:
Theorem (1158) [serial 3041] used for:
  applied wp for assignment [serial 2941]
 


Theorem (1160)                               [serial 2919] 
P [126] << (heart_rate_store[i] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) >>
S [127] hr_nxt[i + 1] := heart_rate_store[i]
Q [128] << (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1159:
Theorem (1159) [serial 2941] used for:
    normalization of [serial 2919]
 


Theorem (1161)                               [serial 3040] 
P [122] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all #14#~quantity whole
  in 0..num_samples - 2 
  are (if MOTION_ARTIFACT^(- (1+#14#)) or not SENSOR_CONNECTED^(- (1+#14#)) then 0 else HEART_RATE^(- (1+#14#))) = heart_rate_store[
      1 + #14#] ) and (num_samples - 2) < (num_samples - 1) >>
S [124] ->
Q [130] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all #15#~quantity whole
  in 0..num_samples - 2 
  are (if MOTION_ARTIFACT^(- (1+#15#)) or not SENSOR_CONNECTED^(- (1+#15#)) then 0 else HEART_RATE^(- (1+#15#))) = heart_rate_store[
      1 + #15#] ) >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (1162)                               [serial 3039] 
P [122] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 0..num_samples - 2 
  are (if MOTION_ARTIFACT^(- (1+s)) or not SENSOR_CONNECTED^(- (1+s)) then 0 else HEART_RATE^(- (1+s))) = heart_rate_store[
      1 + s] ) and (num_samples - 2) < (num_samples - 1) >>
S [124] ->
Q [130] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..num_samples - 2 
  are (if MOTION_ARTIFACT^(- (1+i)) or not SENSOR_CONNECTED^(- (1+i)) then 0 else HEART_RATE^(- (1+i))) = heart_rate_store[
      1 + i] ) >>
by Replacement of Quantified Variables with #1, #2, etc.
and theorem 1161:
Theorem (1161) [serial 3040] used for:
  Replacement of Quantified Variables with #1, #2, etc. [serial 3039]
 


Theorem (1163)                               [serial 3037] 
P [122] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all s~quantity whole
  in 0..num_samples - 1 
  are (if MOTION_ARTIFACT^(- (1+s)) or not SENSOR_CONNECTED^(- (1+s)) then 0 else HEART_RATE^(- (1+s))) = heart_rate_store[
      1 + s] ) and (num_samples - 2) < (num_samples - 1) >>
S [124] ->
Q [130] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..num_samples - 2 
  are (if MOTION_ARTIFACT^(- (1+i)) or not SENSOR_CONNECTED^(- (1+i)) then 0 else HEART_RATE^(- (1+i))) = heart_rate_store[
      1 + i] ) >>
by Contract Universal Quantification Range
and theorem 1162:
Theorem (1162) [serial 3039] used for:
  Contract Universal Quantification Range [serial 3037]
 


Theorem (1164)                               [serial 3035] 
P [122] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (((num_samples - 2) < (num_samples - 1))) and 
(all s~quantity whole
  in 0..(num_samples - 1) 
  are (heart_rate_store[(s + 1)] = (if MOTION_ARTIFACT^(- (s+1)) or not SENSOR_CONNECTED^(- (s+1)) then 0 else HEART_RATE^(- (s+1)))) ) >>
S [124] ->
Q [130] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..((num_samples - 1) - 1) 
  are (if MOTION_ARTIFACT^(- (i+1)) or not SENSOR_CONNECTED^(- (i+1)) then 0 else HEART_RATE^(- (i+1))) = heart_rate_store[(
      i + 1)] ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Associativity: (b.c).a = a.b.c
and theorem 1163:
Theorem (1163) [serial 3037] used for:
    normalization of [serial 3035]
 


Theorem (1165)                               [serial 3034] 
P [122] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (((num_samples - 2) < (num_samples - 1))) and 
(all s~quantity whole
  in 1..num_samples 
  are (heart_rate_store[s] = (if MOTION_ARTIFACT^(- s) or not SENSOR_CONNECTED^(- s) then 0 else HEART_RATE^(- s))) ) >>
S [124] ->
Q [130] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = heart_rate_store[i] ) >>
by Shift Quantification Range so Lower Bound is Zero
and theorem 1164:
Theorem (1164) [serial 3035] used for:
  Shift Quantification Range so Lower Bound is Zero [serial 3034]
 


Theorem (1166)                               [serial 2939] 
P [122] << num_samples = #PulseOx_Properties::Num_Trending_Samples and AXIOM_CR() and 
INV_HR() >>
S [124] ->
Q [130] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = heart_rate_store[i] ) >>
by Substitution of Assertion Labels
and theorem 1165:
Theorem (1165) [serial 3034] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2939]
 


Theorem (1167)                               [serial 2920] 
P [122] << (INV_HR() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_CR()) >>
S [124] ->
Q [130] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = heart_rate_store[i] ) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1166:
Theorem (1166) [serial 2939] used for:
    normalization of [serial 2920]
 


Theorem (1168)                               [serial 2915] 
P [122] << INV_HR() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and 
AXIOM_CR() >>
S [124] forall i in 1..(num_samples - 1)
  {
  << (heart_rate_store[i] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) >>
  hr_nxt[i + 1] := heart_rate_store[i]
  << (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) >>
  }  
Q [130] << (all i~quantity whole
  in 1..(num_samples - 1) 
  are (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
by Universal Quantification Rule:
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any (bl.ulq)
and theorems 1160 1167:
Theorem (1160) [serial 2919] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 2915]
 
Theorem (1167) [serial 2920] used for:
    <<P and (x=e) and FAT>> -> <<wp(forall,Q)>>
 where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
   (in postcondition Q, replace all occurances of
    <<all z:i in r are B>> with <<all z:i in r are A>>)
  for [serial 2915]
 


Theorem (1169)                               [serial 2978] 
P [130] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) >>
S [134] ->
Q [134] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1170)                               [serial 2943] 
P [130] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) >>
S [134] ->
Q [134] << not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) or (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) >>
by Law of Excluded Middle: P or not P is tautology
and theorem 1169:
Theorem (1169) [serial 2978] used for:
  Law of Excluded Middle: P or not P is tautology [serial 2943]
 


Theorem (1171)                               [serial 2921] 
P [130] << (all i~quantity whole
  in 1..(num_samples - 1) 
  are (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
S [134] ->
Q [134] << ((MOTION_ARTIFACT)^0 or not (SENSOR_CONNECTED)^0) or (not ((MOTION_ARTIFACT)^0 or 
not (SENSOR_CONNECTED)^0)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 1170:
Theorem (1170) [serial 2943] used for:
    normalization of [serial 2921]
 


Theorem (1172)                               [serial 3117] 
P [134] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [134] ->
Q [136] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Identity (id):  P->P is tautology


Theorem (1173)                               [serial 3115] 
P [134] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [134] ->
Q [136] << (num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] )) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Associativity: (b.c).a = a.b.c
and theorem 1172:
Theorem (1172) [serial 3117] used for:
  Associativity: (b.c).a = a.b.c [serial 3115]
 


Theorem (1174)                               [serial 3113] 
P [134] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [134] ->
Q [136] << ((all i~quantity whole
  in 1..(num_samples - 1) 
  are (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples))) and (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1173:
Theorem (1173) [serial 3115] used for:
    normalization of [serial 3113]
 


Theorem (1175)                               [serial 2979] 
P [134] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [134] ->
Q [136] << SHFTR_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Substitution of Assertion Labels
and theorem 1174:
Theorem (1174) [serial 3113] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 2979]
 


Theorem (1176)                               [serial 2945] 
P [134] << (num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] )) and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [134] ->
Q [136] << SHFTR_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Associativity: (b.c).a = a.b.c
and theorem 1175:
Theorem (1175) [serial 2979] used for:
  Associativity: (b.c).a = a.b.c [serial 2945]
 


Theorem (1177)                               [serial 2922] 
P [134] << ((all i~quantity whole
  in 1..(num_samples - 1) 
  are (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples))) and ((MOTION_ARTIFACT)^0 or 
not (SENSOR_CONNECTED)^0) >>
S [134] ->
Q [136] << SHFTR_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1176:
Theorem (1176) [serial 2945] used for:
    normalization of [serial 2922]
 


Theorem (1178)                               [serial 3049] 
P [136] << SHFTR_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [137] ->
Q [138] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1179)                               [serial 3048] 
P [136] << SHFTR_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [137] ->
Q [138] << 0 = 0 >>
by Equality Law (idistr):  a=a <-> true
and theorem 1178:
Theorem (1178) [serial 3049] used for:
  Equality Law (idistr):  a=a <-> true [serial 3048]
 


Theorem (1180)                               [serial 3046] 
P [136] << SHFTR_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [137] ->
Q [138] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = 0 >>
by Conditional True Expression:  b and x=e  iff  b and x=(b??e:g) 
and theorem 1179:
Theorem (1179) [serial 3048] used for:
   Conditional True Expression:  b and x=e  iff  b and x=(b??e:g)  [serial 3046]
 


Theorem (1181)                               [serial 3047] 
P [136] << SHFTR_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [137] ->
Q [138] << SHFTR_HR() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1182)                               [serial 3045] 
P [136] << SHFTR_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [137] ->
Q [138] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = 0 and 
SHFTR_HR() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1180 1181:
Theorem (1180) [serial 3046] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3045]
 
Theorem (1181) [serial 3047] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3045]
 


Theorem (1183)                               [serial 2947] 
P [136] << SHFTR_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [137] hr_nxt[1] := 0
Q [138] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
SHFTR_HR() >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 1182:
Theorem (1182) [serial 3045] used for:
  applied wp for assignment [serial 2947]
 


Theorem (1184)                               [serial 2923] 
P [136] << SHFTR_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [137] hr_nxt[1] := 0
Q [138] << SHFTR_HR() and ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1183:
Theorem (1183) [serial 2947] used for:
    normalization of [serial 2923]
 


Theorem (1185)                               [serial 3058] 
P [138] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) >>
S [134] ->
Q [145] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1186)                               [serial 3059] 
P [138] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) >>
S [134] ->
Q [146] << num_samples = #PulseOx_Properties::Num_Trending_Samples >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1187)                               [serial 3071] 
P [138] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else HEART_RATE^(-1+- i)) = hr_nxt[
      2 + i] ) >>
S [134] ->
Q [147] << all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else HEART_RATE^(-1+- i)) = hr_nxt[
      2 + i]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1188)                               [serial 3069] 
P [138] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else HEART_RATE^(-1+- i)) = hr_nxt[
      1 + i + 1] ) >>
S [134] ->
Q [147] << all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else HEART_RATE^(-1+- i)) = hr_nxt[
      2 + i]  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1187:
Theorem (1187) [serial 3071] used for:
    normalization of [serial 3069]
 


Theorem (1189)                               [serial 3067] 
P [138] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else HEART_RATE^(-1+- i)) = hr_nxt[
      1 + (1 + i)] ) >>
S [134] ->
Q [147] << all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else HEART_RATE^(-1+- i)) = hr_nxt[
      2 + i]  >>
by Associativity: (b.c).a = a.b.c
and theorem 1188:
Theorem (1188) [serial 3069] used for:
  Associativity: (b.c).a = a.b.c [serial 3067]
 


Theorem (1190)                               [serial 3065] 
P [138] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..num_samples +  -2 
  are (if MOTION_ARTIFACT^((- 1+- i)) or not SENSOR_CONNECTED^((- 1+- i)) then 0 else HEART_RATE^((- 1+- i))) = hr_nxt[
      1 + (1 + i)] ) >>
S [134] ->
Q [147] << all i~quantity whole
  in 0..num_samples +  -2 
  are (if MOTION_ARTIFACT^(1+- 2+- i) or not SENSOR_CONNECTED^(1+- 2+- i) then 0 else HEART_RATE^(1+- 2+- i)) = hr_nxt[
      2 + i]  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1189:
Theorem (1189) [serial 3067] used for:
    normalization of [serial 3065]
 


Theorem (1191)                               [serial 3063] 
P [138] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..num_samples - 2 
  are (if MOTION_ARTIFACT^(- (1+i)) or not SENSOR_CONNECTED^(- (1+i)) then 0 else HEART_RATE^(- (1+i))) = hr_nxt[
      1 + (1 + i)] ) >>
S [134] ->
Q [147] << all i~quantity whole
  in 0..num_samples - 2 
  are (if MOTION_ARTIFACT^(1-(2+i)) or not SENSOR_CONNECTED^(1-(2+i)) then 0 else HEART_RATE^(1-(2+i))) = hr_nxt[
      2 + i]  >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 1190:
Theorem (1190) [serial 3065] used for:
   changing adding negation to subtraction  [serial 3063]
 


Theorem (1192)                               [serial 3061] 
P [138] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..((num_samples - 1) - 1) 
  are (if MOTION_ARTIFACT^(- (i+1)) or not SENSOR_CONNECTED^(- (i+1)) then 0 else HEART_RATE^(- (i+1))) = hr_nxt[
      1 + (i + 1)] ) >>
S [134] ->
Q [147] << (all i~quantity whole
  in 0..(num_samples - 2) 
  are (if MOTION_ARTIFACT^(1-(i+2)) or not SENSOR_CONNECTED^(1-(i+2)) then 0 else HEART_RATE^(1-(i+2))) = hr_nxt[(
      i + 2)] ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Associativity: (b.c).a = a.b.c
and theorem 1191:
Theorem (1191) [serial 3063] used for:
    normalization of [serial 3061]
 


Theorem (1193)                               [serial 3060] 
P [138] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) >>
S [134] ->
Q [147] << (all i~quantity whole
  in 2..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
by Shift Quantification Range so Lower Bound is Zero
and theorem 1192:
Theorem (1192) [serial 3061] used for:
  Shift Quantification Range so Lower Bound is Zero [serial 3060]
 


Theorem (1194)                               [serial 3056] 
P [138] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) >>
S [134] ->
Q [145] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 2..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1185 1186 1193:
Theorem (1185) [serial 3058] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3056]
 
Theorem (1186) [serial 3059] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3056]
 
Theorem (1193) [serial 3060] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3056]
 


Theorem (1195)                               [serial 3054] 
P [138] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] >>
S [134] ->
Q [145] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 2..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1194:
Theorem (1194) [serial 3056] used for:
    normalization of [serial 3054]
 


Theorem (1196)                               [serial 3052] 
P [138] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
(num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] )) >>
S [134] ->
Q [145] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 2..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
by Associativity: (b.c).a = a.b.c
and theorem 1195:
Theorem (1195) [serial 3054] used for:
  Associativity: (b.c).a = a.b.c [serial 3052]
 


Theorem (1197)                               [serial 3050] 
P [138] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
((all i~quantity whole
  in 1..(num_samples - 1) 
  are (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples))) >>
S [134] ->
Q [145] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 2..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1196:
Theorem (1196) [serial 3052] used for:
    normalization of [serial 3050]
 


Theorem (1198)                               [serial 2949] 
P [138] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
SHFTR_HR() >>
S [134] ->
Q [145] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 2..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
by Substitution of Assertion Labels
and theorem 1197:
Theorem (1197) [serial 3050] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2949]
 


Theorem (1199)                               [serial 2924] 
P [138] << SHFTR_HR() and ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) >>
S [134] ->
Q [145] << ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and (all i~quantity whole
  in 2..num_samples 
  are (hr_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1198:
Theorem (1198) [serial 2949] used for:
    normalization of [serial 2924]
 


Theorem (1200)                               [serial 3124] 
P [134] << num_samples = #PulseOx_Properties::Num_Trending_Samples and not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) >>
S [134] ->
Q [141] << num_samples = #PulseOx_Properties::Num_Trending_Samples and not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) >>
by Identity (id):  P->P is tautology


Theorem (1201)                               [serial 3122] 
P [134] << num_samples = #PulseOx_Properties::Num_Trending_Samples and not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) >>
S [134] ->
Q [141] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1200:
Theorem (1200) [serial 3124] used for:
    normalization of [serial 3122]
 


Theorem (1202)                               [serial 3120] 
P [134] << num_samples = #PulseOx_Properties::Num_Trending_Samples and not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) >>
S [134] ->
Q [141] << not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and (num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] )) >>
by Associativity: (b.c).a = a.b.c
and theorem 1201:
Theorem (1201) [serial 3122] used for:
  Associativity: (b.c).a = a.b.c [serial 3120]
 


Theorem (1203)                               [serial 3118] 
P [134] << num_samples = #PulseOx_Properties::Num_Trending_Samples and not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) >>
S [134] ->
Q [141] << ((all i~quantity whole
  in 1..(num_samples - 1) 
  are (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples))) and not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1202:
Theorem (1202) [serial 3120] used for:
    normalization of [serial 3118]
 


Theorem (1204)                               [serial 2997] 
P [134] << num_samples = #PulseOx_Properties::Num_Trending_Samples and not (MOTION_ARTIFACT^0 or 
not SENSOR_CONNECTED^0) and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) >>
S [134] ->
Q [141] << SHFTR_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Substitution of Assertion Labels
and theorem 1203:
Theorem (1203) [serial 3118] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 2997]
 


Theorem (1205)                               [serial 2980] 
P [134] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [134] ->
Q [141] << SHFTR_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1204:
Theorem (1204) [serial 2997] used for:
    normalization of [serial 2980]
 


Theorem (1206)                               [serial 2951] 
P [134] << not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) and (num_samples = #PulseOx_Properties::Num_Trending_Samples and 
(all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] )) >>
S [134] ->
Q [141] << SHFTR_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Associativity: (b.c).a = a.b.c
and theorem 1205:
Theorem (1205) [serial 2980] used for:
  Associativity: (b.c).a = a.b.c [serial 2951]
 


Theorem (1207)                               [serial 2925] 
P [134] << ((all i~quantity whole
  in 1..(num_samples - 1) 
  are (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples))) and (not ((MOTION_ARTIFACT)^0 or 
not (SENSOR_CONNECTED)^0)) >>
S [134] ->
Q [141] << SHFTR_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1206:
Theorem (1206) [serial 2951] used for:
    normalization of [serial 2925]
 


Theorem (1208)                               [serial 3080] 
P [141] << SHFTR_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [142] ->
Q [143] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1209)                               [serial 3079] 
P [141] << SHFTR_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [142] ->
Q [143] << HEART_RATE^0 = HEART_RATE^0 >>
by Equality Law (idistr):  a=a <-> true
and theorem 1208:
Theorem (1208) [serial 3080] used for:
  Equality Law (idistr):  a=a <-> true [serial 3079]
 


Theorem (1210)                               [serial 3077] 
P [141] << SHFTR_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [142] ->
Q [143] << HEART_RATE^0 = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) >>
by Conditional False Expression:  not b and x=g  iff  not b and x=(b??e:g) 
and theorem 1209:
Theorem (1209) [serial 3079] used for:
   Conditional False Expression:  not b and x=g  iff  not b and x=(b??e:g)  [serial 3077]
 


Theorem (1211)                               [serial 3078] 
P [141] << SHFTR_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [142] ->
Q [143] << SHFTR_HR() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1212)                               [serial 3075] 
P [141] << SHFTR_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [142] ->
Q [143] << HEART_RATE^0 = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) and 
SHFTR_HR() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1210 1211:
Theorem (1210) [serial 3077] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3075]
 
Theorem (1211) [serial 3078] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3075]
 


Theorem (1213)                               [serial 3073] 
P [141] << SHFTR_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [142] ->
Q [143] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = ((HEART_RATE)^0) and 
SHFTR_HR() >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1212:
Theorem (1212) [serial 3075] used for:
    normalization of [serial 3073]
 


Theorem (1214)                               [serial 2953] 
P [141] << SHFTR_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [142] hr_nxt[1] := HeartRate?
Q [143] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
SHFTR_HR() >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 1213:
Theorem (1213) [serial 3073] used for:
  applied wp for assignment [serial 2953]
 


Theorem (1215)                               [serial 2926] 
P [141] << SHFTR_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
S [142] hr_nxt[1] := HeartRate?
Q [143] << SHFTR_HR() and ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1214:
Theorem (1214) [serial 2953] used for:
    normalization of [serial 2926]
 


Theorem (1216)                               [serial 3089] 
P [143] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) >>
S [134] ->
Q [145] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1217)                               [serial 3090] 
P [143] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) >>
S [134] ->
Q [146] << num_samples = #PulseOx_Properties::Num_Trending_Samples >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1218)                               [serial 3099] 
P [143] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else HEART_RATE^(-1+- i)) = hr_nxt[
      2 + i] ) >>
S [134] ->
Q [147] << all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else HEART_RATE^(-1+- i)) = hr_nxt[
      2 + i]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1219)                               [serial 3097] 
P [143] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else HEART_RATE^(-1+- i)) = hr_nxt[
      1 + i + 1] ) >>
S [134] ->
Q [147] << all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else HEART_RATE^(-1+- i)) = hr_nxt[
      2 + i]  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1218:
Theorem (1218) [serial 3099] used for:
    normalization of [serial 3097]
 


Theorem (1220)                               [serial 3095] 
P [143] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else HEART_RATE^(-1+- i)) = hr_nxt[
      1 + (1 + i)] ) >>
S [134] ->
Q [147] << all i~quantity whole
  in 0..-2 + num_samples 
  are (if MOTION_ARTIFACT^(-1+- i) or not SENSOR_CONNECTED^(-1+- i) then 0 else HEART_RATE^(-1+- i)) = hr_nxt[
      2 + i]  >>
by Associativity: (b.c).a = a.b.c
and theorem 1219:
Theorem (1219) [serial 3097] used for:
  Associativity: (b.c).a = a.b.c [serial 3095]
 


Theorem (1221)                               [serial 3093] 
P [143] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..(num_samples +  -1 +  -1) 
  are (if MOTION_ARTIFACT^((- i+- 1)) or not SENSOR_CONNECTED^((- i+- 1)) then 0 else HEART_RATE^((- i+- 1))) = hr_nxt[
      1 + (i + 1)] ) >>
S [134] ->
Q [147] << (all i~quantity whole
  in 0..(num_samples +  -2) 
  are (if MOTION_ARTIFACT^(1+- i+- 2) or not SENSOR_CONNECTED^(1+- i+- 2) then 0 else HEART_RATE^(1+- i+- 2)) = hr_nxt[(
      i + 2)] ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1220:
Theorem (1220) [serial 3095] used for:
    normalization of [serial 3093]
 


Theorem (1222)                               [serial 3092] 
P [143] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 0..((num_samples - 1) - 1) 
  are (if MOTION_ARTIFACT^(- (i+1)) or not SENSOR_CONNECTED^(- (i+1)) then 0 else HEART_RATE^(- (i+1))) = hr_nxt[
      1 + (i + 1)] ) >>
S [134] ->
Q [147] << (all i~quantity whole
  in 0..(num_samples - 2) 
  are (if MOTION_ARTIFACT^(1-(i+2)) or not SENSOR_CONNECTED^(1-(i+2)) then 0 else HEART_RATE^(1-(i+2))) = hr_nxt[(
      i + 2)] ) >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 1221:
Theorem (1221) [serial 3093] used for:
   changing adding negation to subtraction  [serial 3092]
 


Theorem (1223)                               [serial 3091] 
P [143] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) >>
S [134] ->
Q [147] << (all i~quantity whole
  in 2..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
by Shift Quantification Range so Lower Bound is Zero
and theorem 1222:
Theorem (1222) [serial 3092] used for:
  Shift Quantification Range so Lower Bound is Zero [serial 3091]
 


Theorem (1224)                               [serial 3087] 
P [143] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) >>
S [134] ->
Q [145] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 2..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1216 1217 1223:
Theorem (1216) [serial 3089] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3087]
 
Theorem (1217) [serial 3090] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3087]
 
Theorem (1223) [serial 3091] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3087]
 


Theorem (1225)                               [serial 3085] 
P [143] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] ) and (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] >>
S [134] ->
Q [145] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 2..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1224:
Theorem (1224) [serial 3087] used for:
    normalization of [serial 3085]
 


Theorem (1226)                               [serial 3083] 
P [143] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
(num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples - 1 
  are (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i)) = hr_nxt[
      1 + i] )) >>
S [134] ->
Q [145] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 2..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
by Associativity: (b.c).a = a.b.c
and theorem 1225:
Theorem (1225) [serial 3085] used for:
  Associativity: (b.c).a = a.b.c [serial 3083]
 


Theorem (1227)                               [serial 3081] 
P [143] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
((all i~quantity whole
  in 1..(num_samples - 1) 
  are (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples))) >>
S [134] ->
Q [145] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 2..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1226:
Theorem (1226) [serial 3083] used for:
    normalization of [serial 3081]
 


Theorem (1228)                               [serial 2955] 
P [143] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
SHFTR_HR() >>
S [134] ->
Q [145] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 2..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
by Substitution of Assertion Labels
and theorem 1227:
Theorem (1227) [serial 3081] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2955]
 


Theorem (1229)                               [serial 2927] 
P [143] << SHFTR_HR() and ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) >>
S [134] ->
Q [145] << ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and (all i~quantity whole
  in 2..num_samples 
  are (hr_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1228:
Theorem (1228) [serial 2955] used for:
    normalization of [serial 2927]
 


Theorem (1230)                               [serial 2916] 
P [130] << (all i~quantity whole
  in 1..(num_samples - 1) 
  are (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
S [134] if 
(MotionArtifact? or not SensorConnected?)~> 
  << SHFTR_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
  hr_nxt[1] := 0
  << SHFTR_HR() and ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) >> 
[]
(not (MotionArtifact? or not SensorConnected?))~> 
  << SHFTR_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
  hr_nxt[1] := HeartRate?
  << SHFTR_HR() and ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) >> 
fi
Q [145] << ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and (all i~quantity whole
  in 2..num_samples 
  are (hr_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) ) >>
by Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>> (bl.iffi)
and theorems 1171 1177 1184 1199 1207 1215 1229:
Theorem (1171) [serial 2921] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>>  in if-[]-fi  for [serial 2916]
 
Theorem (1177) [serial 2922] used for:
    <<P and B0>> -> <<P0>>  for [serial 2916]
 
Theorem (1184) [serial 2923] used for:
    <<P0>> S0 <<Q0>>  for [serial 2916]
 
Theorem (1199) [serial 2924] used for:
    <<Q0>> -> <<Q>>  for [serial 2916]
 
Theorem (1207) [serial 2925] used for:
    <<P and B1>> -> <<P1>>  for [serial 2916]
 
Theorem (1215) [serial 2926] used for:
    <<P1>> S1 <<Q1>>  for [serial 2916]
 
Theorem (1229) [serial 2927] used for:
    <<Q1>> -> <<Q>>  for [serial 2916]
 


Theorem (1231)                               [serial 3104] 
P [152] << (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] >>
S [153] ->
Q [154] << (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] >>
by Identity (id):  P->P is tautology


Theorem (1232)                               [serial 3102] 
P [152] << (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] >>
S [153] ->
Q [154] << (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = (hr_nxt[i]) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1231:
Theorem (1231) [serial 3104] used for:
    normalization of [serial 3102]
 


Theorem (1233)                               [serial 2959] 
P [152] << (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] >>
S [153] heart_rate_store[i] := hr_nxt[i]
Q [154] << (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = heart_rate_store[i] >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 1232:
Theorem (1232) [serial 3102] used for:
  applied wp for assignment [serial 2959]
 


Theorem (1234)                               [serial 2928] 
P [152] << (hr_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) >>
S [153] heart_rate_store[i] := hr_nxt[i]
Q [154] << (heart_rate_store[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1233:
Theorem (1233) [serial 2959] used for:
    normalization of [serial 2928]
 


Theorem (1235)                               [serial 3101] 
P [156] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
S [150] ->
Q [156] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
by Identity (id):  P->P is tautology


Theorem (1236)                               [serial 2957] 
P [145] << (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0) = hr_nxt[1] and 
num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 2..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
S [150] ->
Q [156] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
by Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
and theorem 1235:
Theorem (1235) [serial 3101] used for:
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j) [serial 2957]
 


Theorem (1237)                               [serial 2929] 
P [145] << (((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and (all i~quantity whole
  in 2..num_samples 
  are (hr_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) )) >>
S [150] ->
Q [156] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = hr_nxt[i] ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1236:
Theorem (1236) [serial 2957] used for:
    normalization of [serial 2929]
 


Theorem (1238)                               [serial 2917] 
P [145] << ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and (all i~quantity whole
  in 2..num_samples 
  are (hr_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) ) >>
S [150] forall i in 1..num_samples
  {
  << (hr_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) >>
  heart_rate_store[i] := hr_nxt[i]
  << (heart_rate_store[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) >>
  }  
Q [156] << (all i~quantity whole
  in 1..num_samples 
  are (heart_rate_store[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
by Universal Quantification Rule:
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any (bl.ulq)
and theorems 1234 1237:
Theorem (1234) [serial 2928] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 2917]
 
Theorem (1237) [serial 2929] used for:
    <<P and (x=e) and FAT>> -> <<wp(forall,Q)>>
 where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
   (in postcondition Q, replace all occurances of
    <<all z:i in r are B>> with <<all z:i in r are A>>)
  for [serial 2917]
 


Theorem (1239)                               [serial 3108] 
P [156] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = heart_rate_store[i] ) >>
S [160] ->
Q [161] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = heart_rate_store[i] ) >>
by Identity (id):  P->P is tautology


Theorem (1240)                               [serial 3110] 
P [156] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = heart_rate_store[i] ) >>
S [160] ->
Q [161] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = heart_rate_store[i] ) >>
by Identity (id):  P->P is tautology


Theorem (1241)                               [serial 3106] 
P [156] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = heart_rate_store[i] ) >>
S [160] ->
Q [161] << #PulseOx_Properties::Num_Trending_Samples = num_samples and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = heart_rate_store[i] ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorems 1239 1240:
Theorem (1239) [serial 3108] used for:
    normalization of [serial 3106]
 
Theorem (1240) [serial 3110] used for:
    normalization of [serial 3106]
 


Theorem (1242)                               [serial 2961] 
P [156] << num_samples = #PulseOx_Properties::Num_Trending_Samples and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = heart_rate_store[i] ) >>
S [160] |heart_rate_store',num_samples' := heart_rate_store,num_samples|  
Q [161] << #PulseOx_Properties::Num_Trending_Samples = num_samples' and (all i~quantity whole
  in 1..num_samples 
  are (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i)) = heart_rate_store[i]' ) >>
by Simultaneous Assignment
and theorem 1241:
Theorem (1241) [serial 3106] used for:
  applied wp for simultaneous assignment [serial 2961]
 


Theorem (1243)                               [serial 2918] 
P [156] << (all i~quantity whole
  in 1..num_samples 
  are (heart_rate_store[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) ) and 
((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
S [160] |heart_rate_store',num_samples' := heart_rate_store,num_samples|  
Q [161] << (all i~quantity whole
  in 1..num_samples 
  are (heart_rate_store[i]' = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) ) and 
((num_samples' = #PulseOx_Properties::Num_Trending_Samples)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1242:
Theorem (1242) [serial 2961] used for:
    normalization of [serial 2918]
 


Theorem (1244)                               [serial 1045] 
P [52] << INV_HR() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
S [114] << INV_HR() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and AXIOM_HRT() >>
HeartRateTrend!(heart_rate_store)
;
<< INV_HR() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and AXIOM_HRT() >>
NumSamples!(num_samples)
;
<< INV_HR() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and AXIOM_CR() >>
forall i in 1..(num_samples - 1)
  {
  << (heart_rate_store[i] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) >>
  hr_nxt[i + 1] := heart_rate_store[i]
  << (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) >>
  }  
<< SHFTR_HR: :(all i~quantity whole
  in 1..(num_samples - 1) 
  are (hr_nxt[i + 1] = (if MOTION_ARTIFACT^(- i) or not SENSOR_CONNECTED^(- i) then 0 else HEART_RATE^(- i))) ) and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
;
if 
(MotionArtifact? or not SensorConnected?)~> 
  << SHFTR_HR() and (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
  hr_nxt[1] := 0
  << SHFTR_HR() and ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) >> 
[]
(not (MotionArtifact? or not SensorConnected?))~> 
  << SHFTR_HR() and not (MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0) >>
  hr_nxt[1] := HeartRate?
  << SHFTR_HR() and ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) >> 
fi
<< ((hr_nxt[1] = (if MOTION_ARTIFACT^0 or not SENSOR_CONNECTED^0 then 0 else HEART_RATE^0))) and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) and (all i~quantity whole
  in 2..num_samples 
  are (hr_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) ) >>
;
forall i in 1..num_samples
  {
  << (hr_nxt[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) >>
  heart_rate_store[i] := hr_nxt[i]
  << (heart_rate_store[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) >>
  }  
<< (all i~quantity whole
  in 1..num_samples 
  are (heart_rate_store[i] = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) ) and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)) >>
;
|heart_rate_store',num_samples' := heart_rate_store,num_samples|  
<< (all i~quantity whole
  in 1..num_samples 
  are (heart_rate_store[i]' = (if MOTION_ARTIFACT^(1-i) or not SENSOR_CONNECTED^(1-i) then 0 else HEART_RATE^(1-i))) ) and ((num_samples' = #PulseOx_Properties::Num_Trending_Samples)) >>
Q [52] << (INV_HR() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples)))^1 >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 1082 1100 1126 1156 1168 1230 1238 1243:
Theorem (1082) [serial 2911] used for:
  P -> P1 in sequential composition for [serial 1045]
 
Theorem (1100) [serial 2912] used for:
  Q5 -> Q in sequential composition for [serial 1045]
 
Theorem (1126) [serial 2913] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1045]
 
Theorem (1156) [serial 2914] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1045]
 
Theorem (1168) [serial 2915] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1045]
 
Theorem (1230) [serial 2916] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1045]
 
Theorem (1238) [serial 2917] used for:
  <<Q3 and P4>> S4 <<Q4 and P5>> in sequential composition for [serial 1045]
 
Theorem (1243) [serial 2918] used for:
  <<Q4 and P5>> S5 <<Q5>> in sequential composition for [serial 1045]
 


Theorem (1245)                               [serial 1046] 
P [166] << (INV_HR() and ((num_samples < #PulseOx_Properties::Num_Trending_Samples))) and 
stop@now and not (exists u~time
  in tops,,now 
  that true ) and not (exists u~time
  in tops,,now 
  that stop@u ) >>
S [166] ->
Q [53] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1246)                               [serial 1047] 
P [166] << (INV_HR() and ((num_samples = #PulseOx_Properties::Num_Trending_Samples))) and 
stop@now and not (exists u~time
  in tops,,now 
  that true ) and not (exists u~time
  in tops,,now 
  that stop@u ) >>
S [166] ->
Q [53] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1247)                               [serial 1035] 
P [28] <<   >>
S [35] ->
Q [28] << HeartRateTrendThread.imp proof obligations >>
by Initial Thread Obligations
and theorems 886 889 890 894 924 1034 1057 1075 1076 1244 1245 1246:
Theorem (886) [serial 1036] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
 
Theorem (889) [serial 1037] used for:
  <<M(fill)>> -> <<I>> from invariant I when complete state fill has Assertion <<M(fill)>> in its definition.
 
Theorem (890) [serial 1038] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
 
Theorem (894) [serial 1039] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state check, <<M(check)>> -> <<e1 or e2 or . . . en>>
 
Theorem (924) [serial 1040] used for:
   <<M(start)>> A <<M(fill)>> for hrtt0:start-[ ]->fill{A};
 
Theorem (1034) [serial 1041] used for:
   <<M(fill) and x>> A <<M(check)>> for hrtt1:fill-[x]->check{A};
 
Theorem (1057) [serial 1042] used for:
   <<M(check) and x>> A <<M(fill)>> for hrtt2a:check-[x]->fill{A};
 
Theorem (1075) [serial 1043] used for:
   <<M(check) and x>> A <<M(run)>> for hrtt2b:check-[x]->run{A};
 
Theorem (1076) [serial 1044] used for:
   <<M(check) and x>> -> <<M(fail)>> for hrtt2c:check-[x]->fail{};
 
Theorem (1244) [serial 1045] used for:
   <<M(run) and x>> A <<M(run)>> for hrtt3:run-[x]->run{A};
 
Theorem (1245) [serial 1046] used for:
   <<M(fill) and x>> -> <<M(halt)>> for hrtt4:fill-[x]->halt{};
 
Theorem (1246) [serial 1047] used for:
   <<M(run) and x>> -> <<M(halt)>> for hrtt4:run-[x]->halt{};
 


Theorem (1248)                               [serial 1049] 
P [31] << true >>
S [28] ->
Q [28] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1249)                               [serial 1050] 
P [30] << true >>
S [30] ->
Q [30] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1250)                               [serial 1088] 
P [32] << true >>
S [32] ->
Q [32] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1251)                               [serial 1086] 
P [32] << true >>
S [32] ->
Q [32] << (true) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1250:
Theorem (1250) [serial 1088] used for:
    normalization of [serial 1086]
 


Theorem (1252)                               [serial 1085] 
P [32] << true >>
S [32] ->
Q [32] << (true) and (true) >>
by Law of And-Simplification:  P and P is P
and theorem 1251:
Theorem (1251) [serial 1086] used for:
  Law of And-Simplification:  P and P is P [serial 1085]
 


Theorem (1253)                               [serial 1084] 
P [32] << true >>
S [32] ->
Q [32] << (SUPPL_OXY_ALARM_ENABLED^0 or not SUPPL_OXY_ALARM_ENABLED^0 or not (SPO2_AVERAGE())^0 < (
SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0)) and ((SPO2_AVERAGE())^0 < (
SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0) or not SUPPL_OXY_ALARM_ENABLED^0 or 
not (SPO2_AVERAGE())^0 < (SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0)) >>
by Law of Excluded Middle: P or not P is tautology
and theorem 1252:
Theorem (1252) [serial 1085] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1084]
 


Theorem (1254)                               [serial 1082] 
P [32] << true >>
S [32] ->
Q [32] << not SUPPL_OXY_ALARM_ENABLED^0 or not (SPO2_AVERAGE())^0 < (SPO2_LOWER_LIMIT^0 + 
SPO2_LOWER_LIMIT_ADJ^0) or (SUPPL_OXY_ALARM_ENABLED^0 and (SPO2_AVERAGE())^0 < (
SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0)) >>
by Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 1253:
Theorem (1253) [serial 1084] used for:
  Distributing Postcondition Or-Over-And [serial 1082]
 


Theorem (1255)                               [serial 1080] 
P [32] << true >>
S [32] ->
Q [32] << (not ((SPO2_AVERAGE())^0 < (SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0))) or 
not SUPPL_OXY_ALARM_ENABLED^0 or (SUPPL_OXY_ALARM_ENABLED^0 and (SPO2_AVERAGE())^0 < (
SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0)) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 1254:
Theorem (1254) [serial 1082] used for:
    normalization of [serial 1080]
 


Theorem (1256)                               [serial 1078] 
P [32] << true >>
S [32] ->
Q [32] << (SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0) <= (SPO2_AVERAGE())^0 or 
not SUPPL_OXY_ALARM_ENABLED^0 or (SUPPL_OXY_ALARM_ENABLED^0 and (SPO2_AVERAGE())^0 < (
SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0)) >>
by At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 1255:
Theorem (1255) [serial 1080] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a) [serial 1078]
 


Theorem (1257)                               [serial 1076] 
P [32] << true >>
S [32] ->
Q [32] << not (SUPPL_OXY_ALARM_ENABLED)^0 or (((SPO2_AVERAGE())^0 >= ((SPO2_LOWER_LIMIT)^0 + 
(SPO2_LOWER_LIMIT_ADJ)^0))) or ((SUPPL_OXY_ALARM_ENABLED)^0 and (((SPO2_AVERAGE())^0 < (
(SPO2_LOWER_LIMIT)^0 + (SPO2_LOWER_LIMIT_ADJ)^0)))) >>
by Normalization
  Normalization Axioms:
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 1256:
Theorem (1256) [serial 1078] used for:
    normalization of [serial 1076]
 


Theorem (1258)                               [serial 1051] 
P [32] << true >>
S [32] ->
Q [32] << ((SUPPL_OXY_ALARM_ENABLED)^0 and (((SPO2_AVERAGE())^0 < ((SPO2_LOWER_LIMIT)^0 + 
(SPO2_LOWER_LIMIT_ADJ)^0)))) or (not (SUPPL_OXY_ALARM_ENABLED)^0 or (((SPO2_AVERAGE())^0 >= (
(SPO2_LOWER_LIMIT)^0 + (SPO2_LOWER_LIMIT_ADJ)^0)))) >>
by Associativity: (b.c).a = a.b.c
and theorem 1257:
Theorem (1257) [serial 1076] used for:
  Associativity: (b.c).a = a.b.c [serial 1051]
 


Theorem (1259)                               [serial 1091] 
P [30] << true >>
S [35] ->
Q [31] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1260)                               [serial 1052] 
P [30] << true >>
S [35] ->
Q [31] << (true)^1 >>
by Normalization
  Normalization Axiom:
    Constants are always the same
and theorem 1259:
Theorem (1259) [serial 1091] used for:
    normalization of [serial 1052]
 


Theorem (1261)                               [serial 1053] 
P [31] << true >>
S [36] ->
Q [32] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1262)                               [serial 1102] 
P [37] << SUPPL_OXY_ALARM_ENABLED^0 and (SPO2_AVERAGE())^0 < (SPO2_LOWER_LIMIT^0 + 
SPO2_LOWER_LIMIT_ADJ^0) >>
S [37] ->
Q [38] << SUPPL_OXY_ALARM_ENABLED^0 and (SPO2_AVERAGE())^0 < (SPO2_LOWER_LIMIT^0 + 
SPO2_LOWER_LIMIT_ADJ^0) >>
by Identity (id):  P->P is tautology


Theorem (1263)                               [serial 1100] 
P [37] << SUPPL_OXY_ALARM_ENABLED^0 and (SPO2_AVERAGE())^0 < (SPO2_LOWER_LIMIT^0 + 
SPO2_LOWER_LIMIT_ADJ^0) >>
S [37] ->
Q [38] << (SUPPL_OXY_ALARM_ENABLED^0 and ((SPO2_AVERAGE())^0 < (SPO2_LOWER_LIMIT^0 + 
SPO2_LOWER_LIMIT_ADJ^0))) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1262:
Theorem (1262) [serial 1102] used for:
    normalization of [serial 1100]
 


Theorem (1264)                               [serial 1096] 
P [37] << SUPPL_OXY_ALARM_ENABLED^0 and (SPO2_AVERAGE())^0 < (SPO2_LOWER_LIMIT^0 + 
SPO2_LOWER_LIMIT_ADJ^0) >>
S [37] ->
Q [38] << SUPPL_O2_ALARM() >>
by Substitution of Assertion Labels
and theorem 1263:
Theorem (1263) [serial 1100] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 1096]
 


Theorem (1265)                               [serial 1098] 
P [38] << SUPPL_O2_ALARM() >>
S [38] ->
Q [17] << SUPPL_O2_ALARM() >>
by Identity (id):  P->P is tautology


Theorem (1266)                               [serial 1099] 
P [38] << (SUPPL_O2_ALARM()) and SpO2DerivedLowerLimitAlarm^0 >>
S [38] ->
Q [31] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1267)                               [serial 1097] 
P [38] << SUPPL_O2_ALARM() >>
S [38] SpO2DerivedLowerLimitAlarm!
Q [31] << true >>
by Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
and theorems 1265 1266:
Theorem (1265) [serial 1098] used for:
  applied port output <<pre>> -> <<M(SpO2DerivedLowerLimitAlarm)>> [serial 1097]
 
Theorem (1266) [serial 1099] used for:
  applied port output <<pre and SpO2DerivedLowerLimitAlarm^0>> -> <<post>> [serial 1097]
 


Theorem (1268)                               [serial 1094] 
P [37] << SUPPL_OXY_ALARM_ENABLED^0 and (SPO2_AVERAGE())^0 < (SPO2_LOWER_LIMIT^0 + 
SPO2_LOWER_LIMIT_ADJ^0) >>
S [38] << SUPPL_O2_ALARM() >>
SpO2DerivedLowerLimitAlarm!
Q [31] << true >>
by Introduction of Existential Quantification (bl.aapre)
and theorems 1264 1267:
Theorem (1264) [serial 1096] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1094]
 
Theorem (1267) [serial 1097] used for:
  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1094]
 


Theorem (1269)                               [serial 1054] 
P [37] << (SUPPL_OXY_ALARM_ENABLED)^0 and (((SPO2_AVERAGE())^0 < ((SPO2_LOWER_LIMIT)^0 + 
(SPO2_LOWER_LIMIT_ADJ)^0))) >>
S [38] << SUPPL_O2_ALARM() >>
SpO2DerivedLowerLimitAlarm!
Q [31] << (true)^1 >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
and theorem 1268:
Theorem (1268) [serial 1094] used for:
    normalization of [serial 1054]
 


Theorem (1270)                               [serial 1105] 
P [39] << (SPO2_LOWER_LIMIT^0 + SPO2_LOWER_LIMIT_ADJ^0) <= (SPO2_AVERAGE())^0 or 
not SUPPL_OXY_ALARM_ENABLED^0 >>
S [39] ->
Q [31] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1271)                               [serial 1055] 
P [39] << not (SUPPL_OXY_ALARM_ENABLED)^0 or (((SPO2_AVERAGE())^0 >= ((SPO2_LOWER_LIMIT)^0 + 
(SPO2_LOWER_LIMIT_ADJ)^0))) >>
S [39] ->
Q [31] << (true)^1 >>
by Normalization
  Normalization Axioms:
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Disjunction: (m or k) = (k or m)
    Constants are always the same
and theorem 1270:
Theorem (1270) [serial 1105] used for:
    normalization of [serial 1055]
 


Theorem (1272)                               [serial 1056] 
P [40] << (true) and stop@now and not (exists u~time
  in tops,,now 
  that true ) and not (exists u~time
  in tops,,now 
  that stop@u ) >>
S [40] ->
Q [33] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1273)                               [serial 1048] 
P [28] <<   >>
S [28] ->
Q [28] << SupplemetalOxygenThread.imp proof obligations >>
by Initial Thread Obligations
and theorems 1248 1249 1258 1260 1261 1269 1271 1272:
Theorem (1248) [serial 1049] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
 
Theorem (1249) [serial 1050] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
 
Theorem (1258) [serial 1051] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state check, <<M(check)>> -> <<e1 or e2 or . . . en>>
 
Theorem (1260) [serial 1052] used for:
   <<M(start)>> -> <<M(run)>> for so0:start-[ ]->run{};
 
Theorem (1261) [serial 1053] used for:
   <<M(run) and x>> -> <<M(check)>> for so1:run-[x]->check{};
 
Theorem (1269) [serial 1054] used for:
   <<M(check) and x>> A <<M(run)>> for so2:check-[x]->run{A};
 
Theorem (1271) [serial 1055] used for:
   <<M(check) and x>> -> <<M(run)>> for so3:check-[x]->run{};
 
Theorem (1272) [serial 1056] used for:
   <<M(run) and x>> -> <<M(halt)>> for so4:run-[x]->halt{};
 


Theorem (1274)                               [serial 3164] 
P [53] << (all s~quantity whole
  in 1..num_samples 
  are (spo2[s] = SPO2^(- s)) ) and ((num_samples = #PulseOx_Properties::Max_Window_Samples)) >>
S [38] ->
Q [38] << all s~quantity whole
  in 1..num_samples 
  are (spo2[s] = SPO2^(- s))  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1275)                               [serial 1058] 
P [53] << SpO2_RD() and ((num_samples = #PulseOx_Properties::Max_Window_Samples)) >>
S [38] ->
Q [38] << all s~quantity whole
  in 1..num_samples 
  are (spo2[s] = SPO2^(- s))  >>
by Substitution of Assertion Labels
and theorem 1274:
Theorem (1274) [serial 3164] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1058]
 


Theorem (1276)                               [serial 3165] 
P [49] << (all s~quantity whole
  in 1..num_samples 
  are (spo2[s] = SPO2^(- s)) ) and ((num_samples < #PulseOx_Properties::Max_Window_Samples)) >>
S [38] ->
Q [38] << all s~quantity whole
  in 1..num_samples 
  are (spo2[s] = SPO2^(- s))  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1277)                               [serial 1059] 
P [49] << SpO2_RD() and ((num_samples < #PulseOx_Properties::Max_Window_Samples)) >>
S [38] ->
Q [38] << all s~quantity whole
  in 1..num_samples 
  are (spo2[s] = SPO2^(- s))  >>
by Substitution of Assertion Labels
and theorem 1276:
Theorem (1276) [serial 3165] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1059]
 


Theorem (1278)                               [serial 1060] 
P [47] << ((num_samples < #PulseOx_Properties::Max_Window_Samples)) and ((num_samples = 0)) >>
S [47] ->
Q [47] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1279)                               [serial 3169] 
P [51] << HOLD_RD(num_samples) >>
S [51] ->
Q [51] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1280)                               [serial 3167] 
P [51] << HOLD_RD(num_samples) >>
S [51] ->
Q [51] << num_samples = #PulseOx_Properties::Max_Window_Samples or num_samples < #PulseOx_Properties::Max_Window_Samples or 
#PulseOx_Properties::Max_Window_Samples < num_samples >>
by Less than, greater than, or equal:  |-a<b or b<a or a=b
and theorem 1279:
Theorem (1279) [serial 3169] used for:
  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 3167]
 


Theorem (1281)                               [serial 1061] 
P [51] << HOLD_RD(num_samples) >>
S [51] ->
Q [51] << ((num_samples < #PulseOx_Properties::Max_Window_Samples)) or ((num_samples = #PulseOx_Properties::Max_Window_Samples)) or 
((num_samples > #PulseOx_Properties::Max_Window_Samples)) >>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 1280:
Theorem (1280) [serial 3167] used for:
    normalization of [serial 1061]
 


Theorem (1282)                               [serial 3196] 
P [47] << num_samples = 0 and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [56] ->
Q [38] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1283)                               [serial 3193] 
P [47] << num_samples = 0 and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [56] ->
Q [38] << (true) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1282:
Theorem (1282) [serial 3196] used for:
    normalization of [serial 3193]
 


Theorem (1284)                               [serial 3191] 
P [47] << num_samples = 0 and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [56] ->
Q [38] << (all s~quantity whole
  in false 
  are SPO2^(1-s) = spo2[s] ) >>
by Empty Range Law All: all a:t in false are V is tautology
and theorem 1283:
Theorem (1283) [serial 3193] used for:
  Empty Range Law All: all a:t in false are V is tautology [serial 3191]
 


Theorem (1285)                               [serial 3189] 
P [47] << num_samples = 0 and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [56] ->
Q [38] << (all s~quantity whole
  in 1..0 
  are SPO2^(1-s) = spo2[s] ) >>
by Empty Range
and theorem 1284:
Theorem (1284) [serial 3191] used for:
  Empty Range [serial 3189]
 


Theorem (1286)                               [serial 3185] 
P [47] << num_samples = 0 and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [56] ->
Q [38] << (all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s] ) >>
by Guided Substitution of Equals
and theorem 1285:
Theorem (1285) [serial 3189] used for:
  Guided Substitution of Equals
 replacing "num_samples" with its = "0" in its postcondition [serial 3185]
 


Theorem (1287)                               [serial 3186] 
P [47] << num_samples = 0 and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [56] ->
Q [49] << num_samples < #PulseOx_Properties::Max_Window_Samples >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1288)                               [serial 3198] 
P [47] << num_samples = 0 and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [56] ->
Q [38] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1289)                               [serial 3194] 
P [47] << num_samples = 0 and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [56] ->
Q [38] << (true) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1288:
Theorem (1288) [serial 3198] used for:
    normalization of [serial 3194]
 


Theorem (1290)                               [serial 3192] 
P [47] << num_samples = 0 and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [56] ->
Q [38] << (all s~quantity whole
  in false 
  are SPO2^(1-s) = spo2[s] ) >>
by Empty Range Law All: all a:t in false are V is tautology
and theorem 1289:
Theorem (1289) [serial 3194] used for:
  Empty Range Law All: all a:t in false are V is tautology [serial 3192]
 


Theorem (1291)                               [serial 3190] 
P [47] << num_samples = 0 and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [56] ->
Q [38] << (all s~quantity whole
  in 1..0 
  are SPO2^(1-s) = spo2[s] ) >>
by Empty Range
and theorem 1290:
Theorem (1290) [serial 3192] used for:
  Empty Range [serial 3190]
 


Theorem (1292)                               [serial 3187] 
P [47] << num_samples = 0 and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [56] ->
Q [38] << (all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s] ) >>
by Guided Substitution of Equals
and theorem 1291:
Theorem (1291) [serial 3190] used for:
  Guided Substitution of Equals
 replacing "num_samples" with its = "0" in its postcondition [serial 3187]
 


Theorem (1293)                               [serial 3188] 
P [47] << num_samples = 0 and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [56] ->
Q [49] << num_samples < #PulseOx_Properties::Max_Window_Samples >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1294)                               [serial 3184] 
P [47] << num_samples = 0 and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [56] ->
Q [49] << (all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s] ) and num_samples < #PulseOx_Properties::Max_Window_Samples >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1286 1287 1292 1293:
Theorem (1286) [serial 3185] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3184]
 
Theorem (1287) [serial 3186] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3184]
 
Theorem (1292) [serial 3187] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3184]
 
Theorem (1293) [serial 3188] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3184]
 


Theorem (1295)                               [serial 3181] 
P [47] << num_samples = 0 and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [56] |spo2',num_samples' := spo2,num_samples|  
Q [49] << (all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s]^1 ) and num_samples^1 < #PulseOx_Properties::Max_Window_Samples >>
by Simultaneous Assignment
and theorem 1294:
Theorem (1294) [serial 3184] used for:
  applied wp for simultaneous assignment [serial 3181]
 


Theorem (1296)                               [serial 3179] 
P [47] << num_samples = 0 and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [56] |spo2',num_samples' := spo2,num_samples|  
Q [49] << (all s~quantity whole
  in 1..num_samples 
  are (SPO2^((- s)+1) = (spo2[s])^1) ) and num_samples^1 < #PulseOx_Properties::Max_Window_Samples >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Associativity: (b.c).a = a.b.c
and theorem 1295:
Theorem (1295) [serial 3181] used for:
    normalization of [serial 3179]
 


Theorem (1297)                               [serial 3177] 
P [47] << num_samples = 0 and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [56] |spo2',num_samples' := spo2,num_samples|  
Q [49] << (all s~quantity whole
  in 1..num_samples 
  are (SPO2^(- s) = spo2[s])^1 ) and num_samples^1 < #PulseOx_Properties::Max_Window_Samples >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1296:
Theorem (1296) [serial 3179] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3177]
 


Theorem (1298)                               [serial 3175] 
P [47] << num_samples = 0 and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [56] |spo2',num_samples' := spo2,num_samples|  
Q [49] << (all s~quantity whole
  in 1..num_samples 
  are (SPO2^(- s) = spo2[s])^1 ) and ((num_samples)^1 < (#PulseOx_Properties::Max_Window_Samples)^1) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
and theorem 1297:
Theorem (1297) [serial 3177] used for:
    normalization of [serial 3175]
 


Theorem (1299)                               [serial 3173] 
P [47] << num_samples = 0 and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [56] |spo2',num_samples' := spo2,num_samples|  
Q [49] << (all s~quantity whole
  in 1..num_samples 
  are SPO2^(- s) = spo2[s] )^1 and (num_samples < #PulseOx_Properties::Max_Window_Samples)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1298:
Theorem (1298) [serial 3175] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3173]
 


Theorem (1300)                               [serial 3171] 
P [47] << ((num_samples < #PulseOx_Properties::Max_Window_Samples)) and ((num_samples = 0)) >>
S [56] |spo2',num_samples' := spo2,num_samples|  
Q [49] << ((all s~quantity whole
  in 1..num_samples 
  are (spo2[s] = SPO2^(- s)) )^1 and ((num_samples < #PulseOx_Properties::Max_Window_Samples))^1) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1299:
Theorem (1299) [serial 3173] used for:
    normalization of [serial 3171]
 


Theorem (1301)                               [serial 3170] 
P [47] << ((num_samples < #PulseOx_Properties::Max_Window_Samples)) and ((num_samples = 0)) >>
S [56] |spo2',num_samples' := spo2,num_samples|  
Q [49] << ((all s~quantity whole
  in 1..num_samples 
  are (spo2[s] = SPO2^(- s)) ) and ((num_samples < #PulseOx_Properties::Max_Window_Samples)))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1300:
Theorem (1300) [serial 3171] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3170]
 


Theorem (1302)                               [serial 1062] 
P [47] << ((num_samples < #PulseOx_Properties::Max_Window_Samples)) and ((num_samples = 0)) >>
S [56] |spo2',num_samples' := spo2,num_samples|  
Q [49] << (SpO2_RD() and ((num_samples < #PulseOx_Properties::Max_Window_Samples)))^1 >>
by Substitution of Assertion Labels
and theorem 1301:
Theorem (1301) [serial 3170] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 1062]
 


Theorem (1303)                               [serial 3201] 
P [49] << SpO2_RD() and ((num_samples < #PulseOx_Properties::Max_Window_Samples)) >>
S [49] ->
Q [59] << SpO2_RD() and ((num_samples < #PulseOx_Properties::Max_Window_Samples)) >>
by Identity (id):  P->P is tautology


Theorem (1304)                               [serial 3279] 
P [82] << all #16#~quantity whole
  in 1..num_samples 
  are SPO2^(1-#16#) = spo2[#16#]  >>
S [51] ->
Q [51] << all #17#~quantity whole
  in 1..num_samples 
  are SPO2^(1-#17#) = spo2[#17#]  >>
by Identity (id):  P->P is tautology


Theorem (1305)                               [serial 3264] 
P [82] << all i~quantity whole
  in 1..num_samples 
  are SPO2^(1-i) = spo2[i]  >>
S [51] ->
Q [51] << all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s]  >>
by Replacement of Quantified Variables with #1, #2, etc.
and theorem 1304:
Theorem (1304) [serial 3279] used for:
  Replacement of Quantified Variables with #1, #2, etc. [serial 3264]
 


Theorem (1306)                               [serial 3259] 
P [82] << all i~quantity whole
  in 1..num_samples 
  are SPO2^(1-i) = spo2[i]  >>
S [51] ->
Q [51] << (all s~quantity whole
  in 1..num_samples 
  are (spo2[s] = SPO2^(1-s)) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1305:
Theorem (1305) [serial 3264] used for:
    normalization of [serial 3259]
 


Theorem (1307)                               [serial 3212] 
P [82] << all i~quantity whole
  in 1..num_samples 
  are SPO2^(1-i) = spo2[i]  >>
S [51] ->
Q [51] << HOLD_RD(num_samples) >>
by Substitution of Assertion Labels
and theorem 1306:
Theorem (1306) [serial 3259] used for:
  substituted Assertions' predicates for  labels  [serial 3212]
 


Theorem (1308)                               [serial 3202] 
P [82] << all i~quantity whole
  in 1..num_samples 
  are (spo2[i] = SPO2^(1-i))  >>
S [51] ->
Q [51] << HOLD_RD(num_samples) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1307:
Theorem (1307) [serial 3212] used for:
    normalization of [serial 3202]
 


Theorem (1309)                               [serial 3239] 
P [62] << SPO2^(- i) = spo2[i] >>
S [63] ->
Q [64] << SPO2^(- i) = spo2[i] >>
by Identity (id):  P->P is tautology


Theorem (1310)                               [serial 3232] 
P [62] << SPO2^(- i) = spo2[i] >>
S [63] ->
Q [64] << SPO2^(- i) = (spo2[i]) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1309:
Theorem (1309) [serial 3239] used for:
    normalization of [serial 3232]
 


Theorem (1311)                               [serial 3216] 
P [62] << SPO2^(- i) = spo2[i] >>
S [63] spo2_nxt[1 + i] := spo2[i]
Q [64] << SPO2^(- i) = spo2_nxt[1 + i] >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 1310:
Theorem (1310) [serial 3232] used for:
  applied wp for assignment [serial 3216]
 


Theorem (1312)                               [serial 3207] 
P [62] << (spo2[i] = SPO2^(- i)) >>
S [63] spo2_nxt[i + 1] := spo2[i]
Q [64] << (spo2_nxt[i + 1] = SPO2^(- i)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1311:
Theorem (1311) [serial 3216] used for:
    normalization of [serial 3207]
 


Theorem (1313)                               [serial 3280] 
P [59] << (all #18#~quantity whole
  in 1..num_samples 
  are SPO2^(- #18#) = spo2[#18#] ) and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [60] ->
Q [66] << all #19#~quantity whole
  in 1..num_samples 
  are SPO2^(- #19#) = spo2[#19#]  >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1314)                               [serial 3266] 
P [59] << (all s~quantity whole
  in 1..num_samples 
  are SPO2^(- s) = spo2[s] ) and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [60] ->
Q [66] << all i~quantity whole
  in 1..num_samples 
  are SPO2^(- i) = spo2[i]  >>
by Replacement of Quantified Variables with #1, #2, etc.
and theorem 1313:
Theorem (1313) [serial 3280] used for:
  Replacement of Quantified Variables with #1, #2, etc. [serial 3266]
 


Theorem (1315)                               [serial 3260] 
P [59] << (all s~quantity whole
  in 1..num_samples 
  are (spo2[s] = SPO2^(- s)) ) and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [60] ->
Q [66] << all i~quantity whole
  in 1..num_samples 
  are SPO2^(- i) = spo2[i]  >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1314:
Theorem (1314) [serial 3266] used for:
    normalization of [serial 3260]
 


Theorem (1316)                               [serial 3214] 
P [59] << SpO2_RD() and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [60] ->
Q [66] << all i~quantity whole
  in 1..num_samples 
  are SPO2^(- i) = spo2[i]  >>
by Substitution of Assertion Labels
and theorem 1315:
Theorem (1315) [serial 3260] used for:
  substituted Assertions' predicates for  labels  [serial 3214]
 


Theorem (1317)                               [serial 3208] 
P [59] << (SpO2_RD() and ((num_samples < #PulseOx_Properties::Max_Window_Samples))) >>
S [60] ->
Q [66] << all i~quantity whole
  in 1..num_samples 
  are SPO2^(- i) = spo2[i]  >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1316:
Theorem (1316) [serial 3214] used for:
    normalization of [serial 3208]
 


Theorem (1318)                               [serial 3203] 
P [59] << SpO2_RD() and ((num_samples < #PulseOx_Properties::Max_Window_Samples)) >>
S [60] forall i in 1..num_samples
  {
  << (spo2[i] = SPO2^(- i)) >>
  spo2_nxt[i + 1] := spo2[i]
  << (spo2_nxt[i + 1] = SPO2^(- i)) >>
  }  
Q [66] << all i~quantity whole
  in 1..num_samples 
  are (spo2_nxt[i + 1] = SPO2^(- i))  >>
by Universal Quantification Rule:
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any (bl.ulq)
and theorems 1312 1317:
Theorem (1312) [serial 3207] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 3203]
 
Theorem (1317) [serial 3208] used for:
    <<P and (x=e) and FAT>> -> <<wp(forall,Q)>>
 where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
   (in postcondition Q, replace all occurances of
    <<all z:i in r are B>> with <<all z:i in r are A>>)
  for [serial 3203]
 


Theorem (1319)                               [serial 3277] 
P [66] << all i~quantity whole
  in 0..-1 + num_samples 
  are SPO2^(-1+- i) = spo2_nxt[2 + i]  >>
S [69] ->
Q [70] << all i~quantity whole
  in 0..-1 + num_samples 
  are SPO2^(-1+- i) = spo2_nxt[2 + i]  >>
by Identity (id):  P->P is tautology


Theorem (1320)                               [serial 3275] 
P [66] << all i~quantity whole
  in 0..-1 + num_samples 
  are SPO2^(-1+- i) = spo2_nxt[1 + i + 1]  >>
S [69] ->
Q [70] << all i~quantity whole
  in 0..-1 + num_samples 
  are SPO2^(-1+- i) = spo2_nxt[2 + i]  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
and theorem 1319:
Theorem (1319) [serial 3277] used for:
    normalization of [serial 3275]
 


Theorem (1321)                               [serial 3273] 
P [66] << all i~quantity whole
  in 0..-1 + num_samples 
  are SPO2^(-1+- i) = spo2_nxt[1 + (1 + i)]  >>
S [69] ->
Q [70] << all i~quantity whole
  in 0..-1 + num_samples 
  are SPO2^(-1+- i) = spo2_nxt[2 + i]  >>
by Associativity: (b.c).a = a.b.c
and theorem 1320:
Theorem (1320) [serial 3275] used for:
  Associativity: (b.c).a = a.b.c [serial 3273]
 


Theorem (1322)                               [serial 3271] 
P [66] << all i~quantity whole
  in 0..(num_samples +  -1) 
  are SPO2^((- i+- 1)) = spo2_nxt[1 + (i + 1)]  >>
S [69] ->
Q [70] << all i~quantity whole
  in 0..(1 + num_samples +  -2) 
  are SPO2^(1+- i+- 2) = spo2_nxt[(i + 2)]  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1321:
Theorem (1321) [serial 3273] used for:
    normalization of [serial 3271]
 


Theorem (1323)                               [serial 3270] 
P [66] << all i~quantity whole
  in 0..(num_samples - 1) 
  are SPO2^(- (i+1)) = spo2_nxt[1 + (i + 1)]  >>
S [69] ->
Q [70] << all i~quantity whole
  in 0..((1 + num_samples) - 2) 
  are SPO2^(1-(i+2)) = spo2_nxt[(i + 2)]  >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 1322:
Theorem (1322) [serial 3271] used for:
   changing adding negation to subtraction  [serial 3270]
 


Theorem (1324)                               [serial 3257] 
P [66] << all i~quantity whole
  in 1..num_samples 
  are SPO2^(- i) = spo2_nxt[1 + i]  >>
S [69] ->
Q [70] << all i~quantity whole
  in 2..1 + num_samples 
  are SPO2^(1-i) = spo2_nxt[i]  >>
by Shift Quantification Range so Lower Bound is Zero
and theorem 1323:
Theorem (1323) [serial 3270] used for:
  Shift Quantification Range so Lower Bound is Zero [serial 3257]
 


Theorem (1325)                               [serial 3252] 
P [66] << all i~quantity whole
  in 1..num_samples 
  are SPO2^(- i) = spo2_nxt[1 + i]  >>
S [69] ->
Q [70] << ((all i~quantity whole
  in 2..1 + num_samples 
  are SPO2^(1-i) = spo2_nxt[i] )) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1324:
Theorem (1324) [serial 3257] used for:
    normalization of [serial 3252]
 


Theorem (1326)                               [serial 3251] 
P [66] << all i~quantity whole
  in 1..num_samples 
  are SPO2^(- i) = spo2_nxt[1 + i]  >>
S [69] ->
Q [70] << true and (all i~quantity whole
  in 2..1 + num_samples 
  are SPO2^(1-i) = spo2_nxt[i] ) >>
by Law of And-Simplification:  P and true is P
and theorem 1325:
Theorem (1325) [serial 3252] used for:
  Law of And-Simplification:  P and true is P [serial 3251]
 


Theorem (1327)                               [serial 3241] 
P [66] << all i~quantity whole
  in 1..num_samples 
  are SPO2^(- i) = spo2_nxt[1 + i]  >>
S [69] ->
Q [70] << SPO2^0 = SPO2^0 and (all i~quantity whole
  in 2..1 + num_samples 
  are SPO2^(1-i) = spo2_nxt[i] ) >>
by Equality Law (idistr):  a=a <-> true
and theorem 1326:
Theorem (1326) [serial 3251] used for:
  Equality Law (idistr):  a=a <-> true [serial 3241]
 


Theorem (1328)                               [serial 3233] 
P [66] << all i~quantity whole
  in 1..num_samples 
  are SPO2^(- i) = spo2_nxt[1 + i]  >>
S [69] ->
Q [70] << SPO2^0 = ((SPO2)^0) and (all i~quantity whole
  in 2..1 + num_samples 
  are SPO2^(1-i) = spo2_nxt[i] ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1327:
Theorem (1327) [serial 3241] used for:
    normalization of [serial 3233]
 


Theorem (1329)                               [serial 3218] 
P [66] << all i~quantity whole
  in 1..num_samples 
  are SPO2^(- i) = spo2_nxt[1 + i]  >>
S [69] spo2_nxt[1] := SpO2?
Q [70] << SPO2^0 = spo2_nxt[1] and (all i~quantity whole
  in 2..1 + num_samples 
  are SPO2^(1-i) = spo2_nxt[i] ) >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 1328:
Theorem (1328) [serial 3233] used for:
  applied wp for assignment [serial 3218]
 


Theorem (1330)                               [serial 3204] 
P [66] << all i~quantity whole
  in 1..num_samples 
  are (spo2_nxt[i + 1] = SPO2^(- i))  >>
S [69] spo2_nxt[1] := SpO2?
Q [70] << ((spo2_nxt[1] = SPO2^0)) and (all i~quantity whole
  in 2..(num_samples + 1) 
  are (spo2_nxt[i] = SPO2^(1-i)) ) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1329:
Theorem (1329) [serial 3218] used for:
    normalization of [serial 3204]
 


Theorem (1331)                               [serial 3269] 
P [74] << all i~quantity whole
  in 1..1 + num_samples 
  are SPO2^(1-i) = spo2_nxt[i]  >>
S [73] ->
Q [74] << all i~quantity whole
  in 1..1 + num_samples 
  are SPO2^(1-i) = spo2_nxt[i]  >>
by Identity (id):  P->P is tautology


Theorem (1332)                               [serial 3243] 
P [70] << SPO2^0 = spo2_nxt[1] and (all i~quantity whole
  in 2..1 + num_samples 
  are SPO2^(1-i) = spo2_nxt[i] ) >>
S [73] ->
Q [74] << all i~quantity whole
  in 1..1 + num_samples 
  are SPO2^(1-i) = spo2_nxt[i]  >>
by Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j)
and theorem 1331:
Theorem (1331) [serial 3269] used for:
  Contract Universal Quantification: 
 (all j:integer in lb..ub are P(j)) and P(ub+1) is all j:integer in lb..ub+1 are P(j) [serial 3243]
 


Theorem (1333)                               [serial 3234] 
P [70] << SPO2^0 = spo2_nxt[1] and (all i~quantity whole
  in 2..1 + num_samples 
  are SPO2^(1-i) = spo2_nxt[i] ) >>
S [73] ->
Q [74] << all i~quantity whole
  in 1..(1 + num_samples) 
  are SPO2^(1-i) = spo2_nxt[i]  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
and theorem 1332:
Theorem (1332) [serial 3243] used for:
    normalization of [serial 3234]
 


Theorem (1334)                               [serial 3220] 
P [70] << SPO2^0 = spo2_nxt[1] and (all i~quantity whole
  in 2..1 + num_samples 
  are SPO2^(1-i) = spo2_nxt[i] ) >>
S [73] num_samples := 1 + num_samples
Q [74] << all i~quantity whole
  in 1..num_samples 
  are SPO2^(1-i) = spo2_nxt[i]  >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 1333:
Theorem (1333) [serial 3234] used for:
  applied wp for assignment [serial 3220]
 


Theorem (1335)                               [serial 3205] 
P [70] << ((spo2_nxt[1] = SPO2^0)) and (all i~quantity whole
  in 2..(num_samples + 1) 
  are (spo2_nxt[i] = SPO2^(1-i)) ) >>
S [73] num_samples := num_samples + 1
Q [74] << all i~quantity whole
  in 1..num_samples 
  are (spo2_nxt[i] = SPO2^(1-i))  >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses to Range Bound For No Good Reason: a..b = (a)..b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1334:
Theorem (1334) [serial 3220] used for:
    normalization of [serial 3205]
 


Theorem (1336)                               [serial 3246] 
P [78] << SPO2^(1-i) = spo2_nxt[i] >>
S [79] ->
Q [80] << SPO2^(1-i) = spo2_nxt[i] >>
by Identity (id):  P->P is tautology


Theorem (1337)                               [serial 3235] 
P [78] << SPO2^(1-i) = spo2_nxt[i] >>
S [79] ->
Q [80] << SPO2^(1-i) = (spo2_nxt[i]) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1336:
Theorem (1336) [serial 3246] used for:
    normalization of [serial 3235]
 


Theorem (1338)                               [serial 3224] 
P [78] << SPO2^(1-i) = spo2_nxt[i] >>
S [79] spo2[i] := spo2_nxt[i]
Q [80] << SPO2^(1-i) = spo2[i] >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 1337:
Theorem (1337) [serial 3235] used for:
  applied wp for assignment [serial 3224]
 


Theorem (1339)                               [serial 3209] 
P [78] << (spo2_nxt[i] = SPO2^(1-i)) >>
S [79] spo2[i] := spo2_nxt[i]
Q [80] << (spo2[i] = SPO2^(1-i)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1338:
Theorem (1338) [serial 3224] used for:
    normalization of [serial 3209]
 


Theorem (1340)                               [serial 3222] 
P [74] << all i~quantity whole
  in 1..num_samples 
  are SPO2^(1-i) = spo2_nxt[i]  >>
S [76] ->
Q [82] << all i~quantity whole
  in 1..num_samples 
  are SPO2^(1-i) = spo2_nxt[i]  >>
by Identity (id):  P->P is tautology


Theorem (1341)                               [serial 3210] 
P [74] << (all i~quantity whole
  in 1..num_samples 
  are (spo2_nxt[i] = SPO2^(1-i)) ) >>
S [76] ->
Q [82] << all i~quantity whole
  in 1..num_samples 
  are SPO2^(1-i) = spo2_nxt[i]  >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1340:
Theorem (1340) [serial 3222] used for:
    normalization of [serial 3210]
 


Theorem (1342)                               [serial 3206] 
P [74] << all i~quantity whole
  in 1..num_samples 
  are (spo2_nxt[i] = SPO2^(1-i))  >>
S [76] forall i in 1..num_samples
  {
  << (spo2_nxt[i] = SPO2^(1-i)) >>
  spo2[i] := spo2_nxt[i]
  << (spo2[i] = SPO2^(1-i)) >>
  }  
Q [82] << all i~quantity whole
  in 1..num_samples 
  are (spo2[i] = SPO2^(1-i))  >>
by Universal Quantification Rule:
                      <<A>> T <<B>>
       <<P and (z in r) and (x=e) and FAT>> -> <<wp(forall,Q)>>
 --------------------------------------------------------------------
 <<P>> forall z:i in r declare variable x:t:=e; begin <<A>> T <<B>> end <<Q>>
   where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
     (in postcondition Q, replace all occurances of
     "all z:i in r are B" with "all z:i in r are A"
   and FAT are "fetch-add terms", if any (bl.ulq)
and theorems 1339 1341:
Theorem (1339) [serial 3209] used for:
  <<A>> T <<B>> as subject for universal lattice quantification by [serial 3206]
 
Theorem (1341) [serial 3210] used for:
    <<P and (x=e) and FAT>> -> <<wp(forall,Q)>>
 where wp = Q[<<all z:i in r are B>>/<<all z:i in r are A>>]
   (in postcondition Q, replace all occurances of
    <<all z:i in r are B>> with <<all z:i in r are A>>)
  for [serial 3206]
 


Theorem (1343)                               [serial 1063] 
P [49] << SpO2_RD() and ((num_samples < #PulseOx_Properties::Max_Window_Samples)) >>
S [59] << SpO2_RD() and ((num_samples < #PulseOx_Properties::Max_Window_Samples)) >>
forall i in 1..num_samples
  {
  << (spo2[i] = SPO2^(- i)) >>
  spo2_nxt[i + 1] := spo2[i]
  << (spo2_nxt[i + 1] = SPO2^(- i)) >>
  }  
<< SHFT_RD: :all i~quantity whole
  in 1..num_samples 
  are (spo2_nxt[i + 1] = SPO2^(- i))  >>
;
spo2_nxt[1] := SpO2?
<< ((spo2_nxt[1] = SPO2^0)) and (all i~quantity whole
  in 2..(num_samples + 1) 
  are (spo2_nxt[i] = SPO2^(1-i)) ) >>
;
num_samples := num_samples + 1
<< all i~quantity whole
  in 1..num_samples 
  are (spo2_nxt[i] = SPO2^(1-i))  >>
;
forall i in 1..num_samples
  {
  << (spo2_nxt[i] = SPO2^(1-i)) >>
  spo2[i] := spo2_nxt[i]
  << (spo2[i] = SPO2^(1-i)) >>
  }  
<< all i~quantity whole
  in 1..num_samples 
  are (spo2[i] = SPO2^(1-i))  >>
Q [51] << HOLD_RD(num_samples) >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 1303 1308 1318 1330 1335 1342:
Theorem (1303) [serial 3201] used for:
  P -> P1 in sequential composition for [serial 1063]
 
Theorem (1308) [serial 3202] used for:
  Q3 -> Q in sequential composition for [serial 1063]
 
Theorem (1318) [serial 3203] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1063]
 
Theorem (1330) [serial 3204] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1063]
 
Theorem (1335) [serial 3205] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1063]
 
Theorem (1342) [serial 3206] used for:
  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1063]
 


Theorem (1344)                               [serial 3298] 
P [51] << (all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s] ) and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [85] ->
Q [49] << (all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s] ) and num_samples < #PulseOx_Properties::Max_Window_Samples >>
by Identity (id):  P->P is tautology


Theorem (1345)                               [serial 3295] 
P [51] << (all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s] ) and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [85] |spo2',num_samples' := spo2,num_samples|  
Q [49] << (all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s]^1 ) and num_samples^1 < #PulseOx_Properties::Max_Window_Samples >>
by Simultaneous Assignment
and theorem 1344:
Theorem (1344) [serial 3298] used for:
  applied wp for simultaneous assignment [serial 3295]
 


Theorem (1346)                               [serial 3293] 
P [51] << (all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s] ) and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [85] |spo2',num_samples' := spo2,num_samples|  
Q [49] << (all s~quantity whole
  in 1..num_samples 
  are (SPO2^((- s)+1) = (spo2[s])^1) ) and num_samples^1 < #PulseOx_Properties::Max_Window_Samples >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Associativity: (b.c).a = a.b.c
and theorem 1345:
Theorem (1345) [serial 3295] used for:
    normalization of [serial 3293]
 


Theorem (1347)                               [serial 3291] 
P [51] << (all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s] ) and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [85] |spo2',num_samples' := spo2,num_samples|  
Q [49] << (all s~quantity whole
  in 1..num_samples 
  are (SPO2^(- s) = spo2[s])^1 ) and num_samples^1 < #PulseOx_Properties::Max_Window_Samples >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1346:
Theorem (1346) [serial 3293] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3291]
 


Theorem (1348)                               [serial 3289] 
P [51] << (all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s] ) and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [85] |spo2',num_samples' := spo2,num_samples|  
Q [49] << (all s~quantity whole
  in 1..num_samples 
  are (SPO2^(- s) = spo2[s])^1 ) and ((num_samples)^1 < (#PulseOx_Properties::Max_Window_Samples)^1) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
and theorem 1347:
Theorem (1347) [serial 3291] used for:
    normalization of [serial 3289]
 


Theorem (1349)                               [serial 3287] 
P [51] << (all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s] ) and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [85] |spo2',num_samples' := spo2,num_samples|  
Q [49] << (all s~quantity whole
  in 1..num_samples 
  are SPO2^(- s) = spo2[s] )^1 and (num_samples < #PulseOx_Properties::Max_Window_Samples)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1348:
Theorem (1348) [serial 3289] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3287]
 


Theorem (1350)                               [serial 3285] 
P [51] << (all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s] ) and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [85] |spo2',num_samples' := spo2,num_samples|  
Q [49] << ((all s~quantity whole
  in 1..num_samples 
  are SPO2^(- s) = spo2[s] )^1 and (num_samples < #PulseOx_Properties::Max_Window_Samples)^1) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1349:
Theorem (1349) [serial 3287] used for:
    normalization of [serial 3285]
 


Theorem (1351)                               [serial 3283] 
P [51] << (all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s] ) and num_samples < #PulseOx_Properties::Max_Window_Samples >>
S [85] |spo2',num_samples' := spo2,num_samples|  
Q [49] << ((all s~quantity whole
  in 1..num_samples 
  are SPO2^(- s) = spo2[s] ) and num_samples < #PulseOx_Properties::Max_Window_Samples)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1350:
Theorem (1350) [serial 3285] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3283]
 


Theorem (1352)                               [serial 3281] 
P [51] << ((all s~quantity whole
  in 1..num_samples 
  are (spo2[s] = SPO2^(1-s)) )) and ((num_samples < #PulseOx_Properties::Max_Window_Samples)) >>
S [85] |spo2',num_samples' := spo2,num_samples|  
Q [49] << ((all s~quantity whole
  in 1..num_samples 
  are (spo2[s] = SPO2^(- s)) ) and ((num_samples < #PulseOx_Properties::Max_Window_Samples)))^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1351:
Theorem (1351) [serial 3283] used for:
    normalization of [serial 3281]
 


Theorem (1353)                               [serial 1064] 
P [51] << (HOLD_RD(num_samples)) and ((num_samples < #PulseOx_Properties::Max_Window_Samples)) >>
S [85] |spo2',num_samples' := spo2,num_samples|  
Q [49] << (SpO2_RD() and ((num_samples < #PulseOx_Properties::Max_Window_Samples)))^1 >>
by Substitution of Assertion Labels
and theorem 1352:
Theorem (1352) [serial 3281] used for:
  substituted Assertions' predicates for  labels  [serial 1064]
 


Theorem (1354)                               [serial 3316] 
P [51] << num_samples = #PulseOx_Properties::Max_Window_Samples and (all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s] ) >>
S [87] ->
Q [53] << num_samples = #PulseOx_Properties::Max_Window_Samples and (all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s] ) >>
by Identity (id):  P->P is tautology


Theorem (1355)                               [serial 3313] 
P [51] << num_samples = #PulseOx_Properties::Max_Window_Samples and (all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s] ) >>
S [87] |spo2',num_samples' := spo2,num_samples|  
Q [53] << num_samples^1 = #PulseOx_Properties::Max_Window_Samples and (all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s]^1 ) >>
by Simultaneous Assignment
and theorem 1354:
Theorem (1354) [serial 3316] used for:
  applied wp for simultaneous assignment [serial 3313]
 


Theorem (1356)                               [serial 3311] 
P [51] << num_samples = #PulseOx_Properties::Max_Window_Samples and (all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s] ) >>
S [87] |spo2',num_samples' := spo2,num_samples|  
Q [53] << num_samples^1 = #PulseOx_Properties::Max_Window_Samples and (all s~quantity whole
  in 1..num_samples 
  are (SPO2^((- s)+1) = (spo2[s])^1) ) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Associativity: (b.c).a = a.b.c
and theorem 1355:
Theorem (1355) [serial 3313] used for:
    normalization of [serial 3311]
 


Theorem (1357)                               [serial 3309] 
P [51] << num_samples = #PulseOx_Properties::Max_Window_Samples and (all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s] ) >>
S [87] |spo2',num_samples' := spo2,num_samples|  
Q [53] << num_samples^1 = #PulseOx_Properties::Max_Window_Samples and (all s~quantity whole
  in 1..num_samples 
  are (SPO2^(- s) = spo2[s])^1 ) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1356:
Theorem (1356) [serial 3311] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3309]
 


Theorem (1358)                               [serial 3307] 
P [51] << num_samples = #PulseOx_Properties::Max_Window_Samples and (all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s] ) >>
S [87] |spo2',num_samples' := spo2,num_samples|  
Q [53] << ((num_samples)^1 = (#PulseOx_Properties::Max_Window_Samples)^1) and (all s~quantity whole
  in 1..num_samples 
  are (SPO2^(- s) = spo2[s])^1 ) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
and theorem 1357:
Theorem (1357) [serial 3309] used for:
    normalization of [serial 3307]
 


Theorem (1359)                               [serial 3305] 
P [51] << num_samples = #PulseOx_Properties::Max_Window_Samples and (all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s] ) >>
S [87] |spo2',num_samples' := spo2,num_samples|  
Q [53] << (num_samples = #PulseOx_Properties::Max_Window_Samples)^1 and (all s~quantity whole
  in 1..num_samples 
  are SPO2^(- s) = spo2[s] )^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1358:
Theorem (1358) [serial 3307] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3305]
 


Theorem (1360)                               [serial 3303] 
P [51] << num_samples = #PulseOx_Properties::Max_Window_Samples and (all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s] ) >>
S [87] |spo2',num_samples' := spo2,num_samples|  
Q [53] << ((num_samples = #PulseOx_Properties::Max_Window_Samples)^1 and (all s~quantity whole
  in 1..num_samples 
  are SPO2^(- s) = spo2[s] )^1) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1359:
Theorem (1359) [serial 3305] used for:
    normalization of [serial 3303]
 


Theorem (1361)                               [serial 3301] 
P [51] << num_samples = #PulseOx_Properties::Max_Window_Samples and (all s~quantity whole
  in 1..num_samples 
  are SPO2^(1-s) = spo2[s] ) >>
S [87] |spo2',num_samples' := spo2,num_samples|  
Q [53] << (num_samples = #PulseOx_Properties::Max_Window_Samples and (all s~quantity whole
  in 1..num_samples 
  are SPO2^(- s) = spo2[s] ))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1360:
Theorem (1360) [serial 3303] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3301]
 


Theorem (1362)                               [serial 3299] 
P [51] << ((all s~quantity whole
  in 1..num_samples 
  are (spo2[s] = SPO2^(1-s)) )) and ((num_samples = #PulseOx_Properties::Max_Window_Samples)) >>
S [87] |spo2',num_samples' := spo2,num_samples|  
Q [53] << ((all s~quantity whole
  in 1..num_samples 
  are (spo2[s] = SPO2^(- s)) ) and ((num_samples = #PulseOx_Properties::Max_Window_Samples)))^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1361:
Theorem (1361) [serial 3301] used for:
    normalization of [serial 3299]
 


Theorem (1363)                               [serial 1065] 
P [51] << (HOLD_RD(num_samples)) and ((num_samples = #PulseOx_Properties::Max_Window_Samples)) >>
S [87] |spo2',num_samples' := spo2,num_samples|  
Q [53] << (SpO2_RD() and ((num_samples = #PulseOx_Properties::Max_Window_Samples)))^1 >>
by Substitution of Assertion Labels
and theorem 1362:
Theorem (1362) [serial 3299] used for:
  substituted Assertions' predicates for  labels  [serial 1065]
 


Theorem (1364)                               [serial 1066] 
P [51] << (HOLD_RD(num_samples)) and ((num_samples > #PulseOx_Properties::Max_Window_Samples)) >>
S [88] ->
Q [54] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1365)                               [serial 1057] 
P [34] <<   >>
S [38] ->
Q [34] << RapidDeclineThread.imp proof obligations >>
by Initial Thread Obligations
and theorems 1275 1277 1278 1281 1302 1343 1353 1363 1364:
Theorem (1275) [serial 1058] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
 
Theorem (1277) [serial 1059] used for:
  <<M(fill)>> -> <<I>> from invariant I when complete state fill has Assertion <<M(fill)>> in its definition.
 
Theorem (1278) [serial 1060] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
 
Theorem (1281) [serial 1061] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state check, <<M(check)>> -> <<e1 or e2 or . . . en>>
 
Theorem (1302) [serial 1062] used for:
   <<M(start)>> A <<M(fill)>> for rdt0:start-[ ]->fill{A};
 
Theorem (1343) [serial 1063] used for:
   <<M(fill) and x>> A <<M(check)>> for rdt1:fill-[x]->check{A};
 
Theorem (1353) [serial 1064] used for:
   <<M(check) and x>> A <<M(fill)>> for chk:check-[x]->fill{A};
 
Theorem (1363) [serial 1065] used for:
   <<M(check) and x>> A <<M(run)>> for chk2:check-[x]->run{A};
 
Theorem (1364) [serial 1066] used for:
   <<M(check) and x>> -> <<M(halt)>> for chk3:check-[x]->halt{};
 


Theorem (1366)                               [serial 1067] 
P [4] << SpO2Avg = (SPO2_AVERAGE()) >>
S [2] ->
Q [5] << SpO2Avg = (SPO2_AVERAGE()) >>
by Identity (id):  P->P is tautology


Theorem (1367)                               [serial 1068] 
P [4] << SpO2Avg_AverageSpO2 = (SPO2_AVERAGE()) >>
S [2] ->
Q [5] << SpO2Avg_AverageSpO2 = (SPO2_AVERAGE()) >>
by Identity (id):  P->P is tautology


Theorem (1368)                               [serial 1069] 
P [4] << HEART_RATE_LOWER_LIMIT_ALARM() >>
S [2] ->
Q [5] << HEART_RATE_LOWER_LIMIT_ALARM() >>
by Identity (id):  P->P is tautology


Theorem (1369)                               [serial 1070] 
P [4] << HEART_RATE_UPPER_LIMIT_ALARM() >>
S [2] ->
Q [5] << HEART_RATE_UPPER_LIMIT_ALARM() >>
by Identity (id):  P->P is tautology


Theorem (1370)                               [serial 1071] 
P [4] << MOTION_ARTIFACT_ALARM() >>
S [2] ->
Q [5] << MOTION_ARTIFACT_ALARM() >>
by Identity (id):  P->P is tautology


Theorem (1371)                               [serial 1072] 
P [4] << SUPPL_O2_ALARM() >>
S [2] ->
Q [5] << SUPPL_O2_ALARM() >>
by Identity (id):  P->P is tautology


Theorem (1372)                               [serial 1073] 
P [4] << RAPID_DECLINE_ALARM() >>
S [2] ->
Q [5] << RAPID_DECLINE_ALARM() >>
by Identity (id):  P->P is tautology


Theorem (1373)                               [serial 1074] 
P [4] << SPO2_TREND() >>
S [2] ->
Q [5] << SPO2_TREND() >>
by Identity (id):  P->P is tautology


Theorem (1374)                               [serial 1075] 
P [4] << HR_TREND() >>
S [2] ->
Q [5] << HR_TREND() >>
by Identity (id):  P->P is tautology


Theorem (1375)                               [serial 1001] 
P     
S     
Q     
by Initial Thread Obligations
and theorems 96 523 883 1247 1273 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374:
Theorem (96) [serial 1002] used for:
  Initial proof obligations for MotionArtifactThread.imp
 
Theorem (523) [serial 1008] used for:
  Initial proof obligations for SpO2AverageThread.imp
 
Theorem (883) [serial 1022] used for:
  Initial proof obligations for SpO2TrendThread.imp
 
Theorem (1247) [serial 1035] used for:
  Initial proof obligations for HeartRateTrendThread.imp
 
Theorem (1273) [serial 1048] used for:
  Initial proof obligations for SupplemetalOxygenThread.imp
 
Theorem (1365) [serial 1057] used for:
  Initial proof obligations for RapidDeclineThread.imp
 
Theorem (1366) [serial 1067] used for:
  Composition of Subcomponents via Directional Connection av.SpO2Avg -> so.SpO2Avg:
 SpO2Avg -> SpO2Avg
 
Theorem (1367) [serial 1068] used for:
  Composition of Subcomponents via Directional Connection av.SpO2Avg -> rd.AverageSpO2:
 SpO2Avg -> AverageSpO2
 
Theorem (1368) [serial 1069] used for:
  Composition of Subcomponents via Directional Connection po.HeartRateLowerLimitViolated -> ui.ui.HeartRateLowerLimitViolated:
 HeartRateLowerLimitViolated -> HeartRateLowerLimitViolated
 
Theorem (1369) [serial 1070] used for:
  Composition of Subcomponents via Directional Connection po.HeartRateUpperLimitViolated -> ui.ui.HeartRateUpperLimitViolated:
 HeartRateUpperLimitViolated -> HeartRateUpperLimitViolated
 
Theorem (1370) [serial 1071] used for:
  Composition of Subcomponents via Directional Connection app.app.ma.MotionArtifactAlarm -> ui.ui.MotionArtifactAlarm:
 MotionArtifactAlarm -> MotionArtifactAlarm
 
Theorem (1371) [serial 1072] used for:
  Composition of Subcomponents via Directional Connection app.app.so.SpO2DerivedLowerLimitAlarm -> ui.ui.SpO2DerivedLowerLimitAlarm:
 SpO2DerivedLowerLimitAlarm -> SpO2DerivedLowerLimitAlarm
 
Theorem (1372) [serial 1073] used for:
  Composition of Subcomponents via Directional Connection app.app.rd.RapidSpO2DeclineAlarm -> ui.ui.RapidSpO2DeclineAlarm:
 RapidSpO2DeclineAlarm -> RapidSpO2DeclineAlarm
 
Theorem (1373) [serial 1074] used for:
  Composition of Subcomponents via Directional Connection app.app.tr.SpO2Trend -> ui.ui.SpO2Trend:
 SpO2Trend -> SpO2Trend
 
Theorem (1374) [serial 1075] used for:
  Composition of Subcomponents via Directional Connection app.app.hrt.HeartRateTrend -> ui.ui.HeartRateTrend:
 HeartRateTrend -> HeartRateTrend
 


closing proof.txt file 