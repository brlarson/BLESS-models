opening dump file "/Applications/osate2_2020-06-master2/Eclipse.app/Contents/MacOS/dump.txt" Sun Mar 07 16:24:25 CST 2021
opening proof script file "/Applications/osate2_2020-06-master2/Eclipse.app/Contents/MacOS/script.txt"
 subprogram access feature "ActuatorCommand" has no precondition for subprogram type "MotorInterface".
 subprogram access feature "ActuatorCommand" has no postcondition for subprogram type "MotorInterface".
Still need to load formal_type_map for ActuatorCommand
Still need to load formal_type_map for ActuatorCommand
 subprogram access feature "ActuatorCommand" has no precondition for subprogram type "MotorInterface".
 subprogram access feature "ActuatorCommand" has no postcondition for subprogram type "MotorInterface".
Still need to load formal_type_map for ActuatorCommand
Still need to load formal_type_map for Up
Still need to load formal_type_map for Down
 subprogram access feature "ActuatorCommand" has no precondition for subprogram type "MotorInt".
 subprogram access feature "ActuatorCommand" has no postcondition for subprogram type "MotorInt".
Still need to load formal_type_map for ActuatorCommand
No SubprogramSubcomponentType returned from SubprogramAccess for 
feature "ActuatorCommand" on line 8.
Still need to load formal_type_map for ActuatorCommand
Still need to load formal_type_map for ActuatorCommand

Declarative Model has been Loaded.

 extracting initial proof obligation(s) for a package:  "Control"
  creating proof obligations for "HMI"
  no proof obligations created for "Ecu"
  creating proof obligations for "Controller"
  no proof obligations created for "Ram"
  no proof obligations created for "Fadec"
  creating proof obligations for "Controller.base"
 extracting initial proof obligation(s) for a package:  "UnitsTypesAssertions"
  no proof obligations created for "Position"
  no proof obligations created for "PositionChange"
 extracting initial proof obligation(s) for a package:  "Physical_Types"
  no proof obligations created for "Minute"
  no proof obligations created for "Voltage"
  no proof obligations created for "Fluid_Volume"
  no proof obligations created for "Light_Wavelength"
  no proof obligations created for "Sound"
  no proof obligations created for "Touch"
  no proof obligations created for "Image"
  no proof obligations created for "Current"
  no proof obligations created for "Fluid_Flow"
  no proof obligations created for "Light_Intensity"
 extracting initial proof obligation(s) for a package:  "SI"
 extracting initial proof obligation(s) for a package:  "Act"
  creating proof obligations for "FlowValve"
  creating proof obligations for "StepperMotor"
  creating proof obligations for "Actuator"
  creating proof obligations for "FlowValve.impl"
  creating proof obligations for "Actuator.common"
  creating proof obligations for "StepperMotor.impl"
 extracting initial proof obligation(s) for a package:  "MI"
  creating subprogram proof obligations for  "Fragile"
extracting proof obligation for subprogram component implementation in Fragile
  creating subprogram proof obligations for  "StepUp"
extracting proof obligation for subprogram component implementation in StepUp
  creating subprogram proof obligations for  "Move"
extracting proof obligation for subprogram component implementation in Move
  creating subprogram proof obligations for  "Robust"
extracting proof obligation for subprogram component implementation in Robust
  creating subprogram proof obligations for  "StepDown"
extracting proof obligation for subprogram component implementation in StepDown
 extracting initial proof obligation(s) for a package:  "ICE_Types"
  no proof obligations created for "PKI_key"
  no proof obligations created for "Second_Count"
  no proof obligations created for "Minute"
  no proof obligations created for "Percent"
  no proof obligations created for "Pulse_Rate"
  no proof obligations created for "Alarm_Signal"
  no proof obligations created for "Minute_Count"
  no proof obligations created for "Microliter_Per_Hour"
  no proof obligations created for "PKI_name"
  no proof obligations created for "Milliliter"
  no proof obligations created for "Milliliter_Per_Hour"
 extracting initial proof obligation(s) for a package:  "ControlSoftware"
  creating proof obligations for "RobustPositionControlThread"
  creating proof obligations for "PositionControlThread"
  creating proof obligations for "FragilePositionControlThread"
  creating proof obligations for "FragilePositionControlThread.SingleStep"
[source=Run destination=Check dispatch condition=true, source=Run destination=ShutDown dispatch condition=stop, source=StillClosing destination=ShutDown dispatch condition=true]
extracting proof obligations for "FragilePositionControlThread.SingleStep"

[serial 1002]: ControlSoftware::FragilePositionControlThread.SingleStep
P [149] <<   >>
S [149]->
Q [149] << FragilePositionControlThread.SingleStep proof obligations >>
Reason:  Initial Thread Obligations
  What for: Initial proof obligations for FragilePositionControlThread.SingleStep

making initial obligations for complete states

[serial 1003]: ControlSoftware::FragilePositionControlThread.SingleStep
P [167] << (E() and ACTUAL_IN_RANGE()) >>
S [149]->
Q [149] << ACTUAL_IN_RANGE() >>
  What for: <<M(StillClosing)>> -> <<I>> from invariant I when complete state StillClosing has Assertion <<M(StillClosing)>> in its definition.


[serial 1004]: ControlSoftware::FragilePositionControlThread.SingleStep
P [159] << (E() and D() and ACTUAL_IN_RANGE()) >>
S [149]->
Q [149] << ACTUAL_IN_RANGE() >>
  What for: <<M(Run)>> -> <<I>> from invariant I when complete state Run has Assertion <<M(Run)>> in its definition.

making Serban's theorems

[serial 1005]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << (E() and ACTUAL_IN_RANGE()) >>
S [165]->
Q [165] << (((EstimatedActualPosition = 0)) or ((EstimatedActualPosition > 0)) or 
((EstimatedActualPosition < 0))) >>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state ShutDown, <<M(ShutDown)>> -> <<e1 or e2 or . . . en>>


[serial 1006]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << (E() and ACTUAL_IN_RANGE()) >>
S [161]->
Q [161] << (((((DESIRED_POSITION)^0 >= 0)) and (((DESIRED_POSITION)^0 <= #PCS::MaxPosition))) or 
(((((DESIRED_POSITION)^0 < 0))) or ((((DESIRED_POSITION)^0 > #PCS::MaxPosition))))) >>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state Check, <<M(Check)>> -> <<e1 or e2 or . . . en>>


[serial 1007]: ControlSoftware::FragilePositionControlThread.SingleStep
P [157] << (ACTUAL_POSITION = 0) >>
S [157]->
Q [157] << true >>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state PowerOn, <<M(PowerOn)>> -> <<e1 or e2 or . . . en>>


[serial 1008]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
S [163]->
Q [163] << ((((DESIRED_POSITION)^0 = EstimatedActualPosition)) or (((EstimatedActualPosition + 
1) <= (DESIRED_POSITION)^0)) or (((DESIRED_POSITION)^0 <= (EstimatedActualPosition - 1))) or 
((((DESIRED_POSITION)^0 > (EstimatedActualPosition - 1))) and (((EstimatedActualPosition + 
1) > (DESIRED_POSITION)^0)))) >>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state Decide, <<M(Decide)>> -> <<e1 or e2 or . . . en>>

making initial proof obligations for transitions

[serial 1009]: ControlSoftware::FragilePositionControlThread.SingleStep
P [157] << (ACTUAL_POSITION = 0) >>
S [173]<< (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
ActuatorCommand(pc:0)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
;
Delta := 0
<< ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
;
EstimatedActualPosition' := 0
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [159] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(PowerOn)>> A <<M(Run)>> for fra0po:PowerOn-[ ]->Run{A};


[serial 1010]: ControlSoftware::FragilePositionControlThread.SingleStep
P [159] << (E() and D() and ACTUAL_IN_RANGE()) >>
S [186]->
Q [161] << (E() and ACTUAL_IN_RANGE()) >>
  What for:  <<M(Run) and x>> -> <<M(Check)>> for fra1run:Run-[x]->Check{};


[serial 1011]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << (E() and ACTUAL_IN_RANGE() and ((((DESIRED_POSITION)^0 >= 0)) and (((DESIRED_POSITION)^0 <= #PCS::MaxPosition)))) >>
S [187]->
Q [163] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
  What for:  <<M(Check) and x>> -> <<M(Decide)>> for fra1ok:Check-[x]->Decide{};


[serial 1012]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << (E() and ACTUAL_IN_RANGE() and (((((DESIRED_POSITION)^0 < 0))) or ((((DESIRED_POSITION)^0 > #PCS::MaxPosition))))) >>
S [189]->
Q [170] << true >>
  What for:  <<M(Check) and x>> -> <<M(Error)>> for fra1er:Check-[x]->Error{};


[serial 1013]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 = EstimatedActualPosition))) >>
S [193]<< (E() and (DESIRED_POSITION = ACTUAL_POSITION) and ACTUAL_IN_RANGE()) >>
ActuatorCommand(pc:0)
<< (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E() and ACTUAL_IN_RANGE()) >>
;
Delta := 0
<< (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E() and ACTUAL_IN_RANGE() and ((Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
;
EstimatedActualPosition' := EstimatedActualPosition
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [159] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for fra2eq:Decide-[x]->Run{A};


[serial 1014]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition + 
1) <= (DESIRED_POSITION)^0))) >>
S [208]<< (((ACTUAL_POSITION + 1) <= DESIRED_POSITION) and E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Delta := 1
<< (E() and (DESIRED_POSITION >= (ACTUAL_POSITION + 1)) and (Delta = 1) and (ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LT(ACTUAL_POSITION) and ((ACTUAL_POSITION + 1) <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E() and (Delta = 1) and (ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition + Delta)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [159] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for fra3gt:Decide-[x]->Run{A};


[serial 1015]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 <= (EstimatedActualPosition - 1)))) >>
S [228]<< ((DESIRED_POSITION <= (ACTUAL_POSITION - 1)) and E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Delta := -1
<< (E() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= DESIRED_POSITION) and AXIOM_GT(ACTUAL_POSITION) and (DESIRED_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and ((ACTUAL_POSITION + Delta) >= 0) and E() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition + Delta)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [159] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for fra4lt:Decide-[x]->Run{A};


[serial 1016]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and ((((DESIRED_POSITION)^0 > (EstimatedActualPosition - 1))) and 
(((EstimatedActualPosition + 1) > (DESIRED_POSITION)^0)))) >>
S [246]->
Q [170] << true >>
  What for:  <<M(Decide) and x>> -> <<M(Error)>> for fraSerban:Decide-[x]->Error{};


[serial 1017]: ControlSoftware::FragilePositionControlThread.SingleStep
P [249] << ((E() and D() and ACTUAL_IN_RANGE()) and stop@now and not (exists u~time
  in tops,,now 
  that true ) and not (exists u~time
  in tops,,now 
  that stop@u )) >>
S [249]->
Q [165] << (E() and ACTUAL_IN_RANGE()) >>
  What for:  <<M(Run) and x>> -> <<M(ShutDown)>> for fra5stop:Run-[x]->ShutDown{};


[serial 1018]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << (E() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition = 0))) >>
S [251]->
Q [169] << (ACTUAL_POSITION = 0) >>
  What for:  <<M(ShutDown) and x>> -> <<M(Done)>> for fra6done:ShutDown-[x]->Done{};


[serial 1019]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << (E() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition > 0))) >>
S [254]<< (E() and (ACTUAL_POSITION > 0) and ACTUAL_IN_RANGE()) >>
Delta := -1
<< (E() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= 0) and AXIOM_GT(ACTUAL_POSITION) and (ACTUAL_POSITION <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and ((ACTUAL_POSITION - 1) >= 0) and E() and ((ACTUAL_POSITION - 1) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition - 1)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [167] << (E() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(ShutDown) and x>> A <<M(StillClosing)>> for fra7sc:ShutDown-[x]->StillClosing{A};


[serial 1020]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << (E() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition < 0))) >>
S [268]->
Q [170] << true >>
  What for:  <<M(ShutDown) and x>> -> <<M(Error)>> for fra8er:ShutDown-[x]->Error{};


[serial 1021]: ControlSoftware::FragilePositionControlThread.SingleStep
P [167] << (E() and ACTUAL_IN_RANGE()) >>
S [269]->
Q [165] << (E() and ACTUAL_IN_RANGE()) >>
  What for:  <<M(StillClosing) and x>> -> <<M(ShutDown)>> for fra9cl:StillClosing-[x]->ShutDown{};

  creating proof obligations for "FragilePositionControlThread.MultiStep"
[source=Run destination=Check dispatch condition=true, source=Run destination=ShutDown dispatch condition=stop, source=StillClosing destination=ShutDown dispatch condition=true]
extracting proof obligations for "FragilePositionControlThread.MultiStep"

[serial 1022]: ControlSoftware::FragilePositionControlThread.MultiStep
P [284] <<   >>
S [284]->
Q [284] << FragilePositionControlThread.MultiStep proof obligations >>
Reason:  Initial Thread Obligations
  What for: Initial proof obligations for FragilePositionControlThread.MultiStep

making initial obligations for complete states

[serial 1023]: ControlSoftware::FragilePositionControlThread.MultiStep
P [302] << (E_MS() and ACTUAL_IN_RANGE()) >>
S [284]->
Q [284] << (E_MS() and ACTUAL_IN_RANGE()) >>
  What for: <<M(StillClosing)>> -> <<I>> from invariant I when complete state StillClosing has Assertion <<M(StillClosing)>> in its definition.


[serial 1024]: ControlSoftware::FragilePositionControlThread.MultiStep
P [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE()) >>
S [284]->
Q [284] << (E_MS() and ACTUAL_IN_RANGE()) >>
  What for: <<M(Run)>> -> <<I>> from invariant I when complete state Run has Assertion <<M(Run)>> in its definition.

making Serban's theorems

[serial 1025]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << (E_MS() and ACTUAL_IN_RANGE()) >>
S [300]->
Q [300] << (((EstimatedActualPosition = 0)) or ((EstimatedActualPosition > 0)) or 
((EstimatedActualPosition < 0))) >>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state ShutDown, <<M(ShutDown)>> -> <<e1 or e2 or . . . en>>


[serial 1026]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << (E_MS() and ACTUAL_IN_RANGE()) >>
S [296]->
Q [296] << (((((DESIRED_POSITION)^0 >= 0)) and (((DESIRED_POSITION)^0 <= #PCS::MaxPosition))) or 
(((((DESIRED_POSITION)^0 < 0))) or ((((DESIRED_POSITION)^0 > #PCS::MaxPosition))))) >>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state Check, <<M(Check)>> -> <<e1 or e2 or . . . en>>


[serial 1027]: ControlSoftware::FragilePositionControlThread.MultiStep
P [292] << (ACTUAL_POSITION = 0) >>
S [292]->
Q [292] << true >>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state PowerOn, <<M(PowerOn)>> -> <<e1 or e2 or . . . en>>


[serial 1028]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
S [298]->
Q [298] << ((((DESIRED_POSITION)^0 = EstimatedActualPosition)) or (((EstimatedActualPosition + 
#PCS::MaxStepsUp) <= (DESIRED_POSITION)^0)) or (((DESIRED_POSITION)^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp))) or 
(((EstimatedActualPosition < (DESIRED_POSITION)^0)) and (((EstimatedActualPosition + 
#PCS::MaxStepsUp) > (DESIRED_POSITION)^0))) or (((EstimatedActualPosition > (DESIRED_POSITION)^0)) and 
(((EstimatedActualPosition - #PCS::MaxStepsUp) < (DESIRED_POSITION)^0)))) >>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state Decide, <<M(Decide)>> -> <<e1 or e2 or . . . en>>

making initial proof obligations for transitions

[serial 1029]: ControlSoftware::FragilePositionControlThread.MultiStep
P [292] << (ACTUAL_POSITION = 0) >>
S [308]<< (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
ActuatorCommand(pc:0)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
;
Delta := 0
<< ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
;
EstimatedActualPosition' := 0
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(PowerOn)>> A <<M(Run)>> for ms0po:PowerOn-[ ]->Run{A};


[serial 1030]: ControlSoftware::FragilePositionControlThread.MultiStep
P [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE()) >>
S [321]->
Q [296] << (E_MS() and ACTUAL_IN_RANGE()) >>
  What for:  <<M(Run) and x>> -> <<M(Check)>> for ms1run:Run-[x]->Check{};


[serial 1031]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << (E_MS() and ACTUAL_IN_RANGE() and ((((DESIRED_POSITION)^0 >= 0)) and 
(((DESIRED_POSITION)^0 <= #PCS::MaxPosition)))) >>
S [323]->
Q [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
  What for:  <<M(Check) and x>> -> <<M(Decide)>> for ms1ok:Check-[x]->Decide{};


[serial 1032]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << (E_MS() and ACTUAL_IN_RANGE() and (((((DESIRED_POSITION)^0 < 0))) or 
((((DESIRED_POSITION)^0 > #PCS::MaxPosition))))) >>
S [325]->
Q [305] << true >>
  What for:  <<M(Check) and x>> -> <<M(Error)>> for ms1er:Check-[x]->Error{};


[serial 1033]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 = EstimatedActualPosition))) >>
S [330]<< (E_MS() and (DESIRED_POSITION = ACTUAL_POSITION) and ACTUAL_IN_RANGE()) >>
ActuatorCommand(pc:0)
<< (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E_MS() and ACTUAL_IN_RANGE()) >>
;
Delta := 0
<< (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E_MS() and ACTUAL_IN_RANGE() and ((Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
;
EstimatedActualPosition' := EstimatedActualPosition
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for ms2eq:Decide-[x]->Run{A};


[serial 1034]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition + 
#PCS::MaxStepsUp) <= (DESIRED_POSITION)^0))) >>
S [346]<< (((ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION) and E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Delta := #PCS::MaxStepsUp
<< (E_MS() and (DESIRED_POSITION >= (ACTUAL_POSITION + #PCS::MaxStepsUp)) and (Delta = #PCS::MaxStepsUp) and (ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and ((ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and (Delta = #PCS::MaxStepsUp) and (ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition + Delta)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for ms3om:Decide-[x]->Run{A};


[serial 1035]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp)))) >>
S [367]<< ((DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp)) and E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Delta := -#PCS::MaxStepsUp
<< (E_MS() and (Delta =  -#PCS::MaxStepsUp) and ((ACTUAL_POSITION - #PCS::MaxStepsUp) >= DESIRED_POSITION) and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and (DESIRED_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta =  -#PCS::MaxStepsUp) and ((ACTUAL_POSITION + Delta) >= 0) and E_MS() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition + Delta)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for ms4cm:Decide-[x]->Run{A};


[serial 1036]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition < (DESIRED_POSITION)^0)) and 
(((EstimatedActualPosition + #PCS::MaxStepsUp) > (DESIRED_POSITION)^0)))) >>
S [387]<< (((ACTUAL_POSITION + #PCS::MaxStepsUp) > DESIRED_POSITION) and (ACTUAL_POSITION < DESIRED_POSITION) and E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Delta := (DesiredPosition? - EstimatedActualPosition)
<< (E_MS() and (DESIRED_POSITION = (ACTUAL_POSITION + Delta)) and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and (ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(z:ACTUAL_POSITION,k:Delta) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and (ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition + Delta)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for ms5od:Decide-[x]->Run{A};


[serial 1037]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition > (DESIRED_POSITION)^0)) and 
(((EstimatedActualPosition - #PCS::MaxStepsUp) < (DESIRED_POSITION)^0)))) >>
S [410]<< (((ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION) and (ACTUAL_POSITION > DESIRED_POSITION) and E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Delta := (DesiredPosition? - EstimatedActualPosition)
<< (E_MS() and (DESIRED_POSITION = (ACTUAL_POSITION + Delta)) and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and (ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(z:ACTUAL_POSITION,k: -Delta) and DESIRED_IN_RANGE() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and DESIRED_IN_RANGE() and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and (ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition + Delta)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for ms6cd:Decide-[x]->Run{A};


[serial 1038]: ControlSoftware::FragilePositionControlThread.MultiStep
P [431] << ((E_MS() and D_MS() and ACTUAL_IN_RANGE()) and stop@now and not (exists u~time
  in tops,,now 
  that true ) and not (exists u~time
  in tops,,now 
  that stop@u )) >>
S [430]->
Q [300] << (E_MS() and ACTUAL_IN_RANGE()) >>
  What for:  <<M(Run) and x>> -> <<M(ShutDown)>> for ms7stop:Run-[x]->ShutDown{};


[serial 1039]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << (E_MS() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition = 0))) >>
S [432]->
Q [304] << (ACTUAL_POSITION = 0) >>
  What for:  <<M(ShutDown) and x>> -> <<M(Done)>> for ms8done:ShutDown-[x]->Done{};


[serial 1040]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << (E_MS() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition > 0))) >>
S [436]<< (E_MS() and (ACTUAL_POSITION > 0) and ACTUAL_IN_RANGE()) >>
Delta := -1
<< (E_MS() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= 0) and AXIOM_GT(ACTUAL_POSITION) and (ACTUAL_POSITION <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and ((ACTUAL_POSITION - 1) >= 0) and E_MS() and ((ACTUAL_POSITION - 1) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition - 1)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [302] << (E_MS() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(ShutDown) and x>> A <<M(StillClosing)>> for ms9sc:ShutDown-[x]->StillClosing{A};


[serial 1041]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << (E_MS() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition < 0))) >>
S [449]->
Q [305] << true >>
  What for:  <<M(ShutDown) and x>> -> <<M(Error)>> for ms10er:ShutDown-[x]->Error{};


[serial 1042]: ControlSoftware::FragilePositionControlThread.MultiStep
P [302] << (E_MS() and ACTUAL_IN_RANGE()) >>
S [451]->
Q [300] << (E_MS() and ACTUAL_IN_RANGE()) >>
  What for:  <<M(StillClosing) and x>> -> <<M(ShutDown)>> for ms11cl:StillClosing-[x]->ShutDown{};

  creating proof obligations for "RobustPositionControlThread.SingleStep"
[source=Run destination=Decide dispatch condition=true, source=Run destination=ShutDown dispatch condition=stop, source=StillClosing destination=ShutDown dispatch condition=true]
extracting proof obligations for "RobustPositionControlThread.SingleStep"

[serial 1043]: ControlSoftware::RobustPositionControlThread.SingleStep
P [40] <<   >>
S [40]->
Q [40] << RobustPositionControlThread.SingleStep proof obligations >>
Reason:  Initial Thread Obligations
  What for: Initial proof obligations for RobustPositionControlThread.SingleStep

making initial obligations for complete states

[serial 1044]: ControlSoftware::RobustPositionControlThread.SingleStep
P [59] << (E_SS() and ((ACTUAL_POSITION^(-1) > 0))) >>
S [40]->
Q [40] << true >>
  What for: <<M(StillClosing)>> -> <<I>> from invariant I when complete state StillClosing has Assertion <<M(StillClosing)>> in its definition.


[serial 1045]: ControlSoftware::RobustPositionControlThread.SingleStep
P [53] << (E_SS() and D_SS()) >>
S [40]->
Q [40] << true >>
  What for: <<M(Run)>> -> <<I>> from invariant I when complete state Run has Assertion <<M(Run)>> in its definition.

making Serban's theorems

[serial 1046]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << E_SS() >>
S [57]->
Q [57] << (((EstimatedActualPosition = 0)) or ((EstimatedActualPosition > 0)) or 
((EstimatedActualPosition < 0))) >>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state ShutDown, <<M(ShutDown)>> -> <<e1 or e2 or . . . en>>


[serial 1047]: ControlSoftware::RobustPositionControlThread.SingleStep
P [51] << (ACTUAL_POSITION = 0) >>
S [51]->
Q [51] << true >>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state PowerOn, <<M(PowerOn)>> -> <<e1 or e2 or . . . en>>


[serial 1048]: ControlSoftware::RobustPositionControlThread.SingleStep
P [55] << (E_SS() and D_SS()) >>
S [55]->
Q [55] << ((((DESIRED_POSITION)^0 = EstimatedActualPosition)) or (((DESIRED_POSITION)^0 > EstimatedActualPosition)) or 
(((DESIRED_POSITION)^0 < EstimatedActualPosition))) >>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state Decide, <<M(Decide)>> -> <<e1 or e2 or . . . en>>

making initial proof obligations for transitions

[serial 1049]: ControlSoftware::RobustPositionControlThread.SingleStep
P [51] << (ACTUAL_POSITION = 0) >>
S [65]<< (ACTUAL_POSITION = 0) >>
ActuatorCommand(pc:0)
<< (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and ((ACTUAL_POSITION = 0))) >>
;
|EstimatedActualPosition',Delta' := 0,0|  
<< (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
Q [53] << (E_SS() and D_SS())^1 >>
  What for:  <<M(PowerOn)>> A <<M(Run)>> for one0po:PowerOn-[ ]->Run{A};


[serial 1050]: ControlSoftware::RobustPositionControlThread.SingleStep
P [53] << (E_SS() and D_SS()) >>
S [73]->
Q [55] << (E_SS() and D_SS()) >>
  What for:  <<M(Run) and x>> -> <<M(Decide)>> for one1run:Run-[x]->Decide{};


[serial 1051]: ControlSoftware::RobustPositionControlThread.SingleStep
P [55] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 = EstimatedActualPosition))) >>
S [76]<< (E_SS() and (DESIRED_POSITION = ACTUAL_POSITION)) >>
ActuatorCommand(pc:0)
<< (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E_SS()) >>
;
|EstimatedActualPosition',Delta' := EstimatedActualPosition,0|  
<< (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
Q [53] << (E_SS() and D_SS())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for one2eq:Decide-[x]->Run{A};


[serial 1052]: ControlSoftware::RobustPositionControlThread.SingleStep
P [55] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 > EstimatedActualPosition))) >>
S [86]<< (E_SS() and (DESIRED_POSITION > ACTUAL_POSITION)) >>
ActuatorCommand(pc:1)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + 1)) and E_SS()) >>
;
|EstimatedActualPosition',Delta' := (EstimatedActualPosition + 1),1|  
<< (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
Q [53] << (E_SS() and D_SS())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for one3gt:Decide-[x]->Run{A};


[serial 1053]: ControlSoftware::RobustPositionControlThread.SingleStep
P [55] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 < EstimatedActualPosition))) >>
S [96]<< (E_SS() and (DESIRED_POSITION < ACTUAL_POSITION) and AXIOM_MO()) >>
ActuatorCommand(pc:MinusOne)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + MinusOne)) and E_SS() and AXIOM_MO()) >>
;
|EstimatedActualPosition',Delta' := (EstimatedActualPosition - 1),-1|  
<< (((EstimatedActualPosition' = ACTUAL_POSITION')) and (Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
Q [53] << (E_SS() and D_SS())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for one4lt:Decide-[x]->Run{A};


[serial 1054]: ControlSoftware::RobustPositionControlThread.SingleStep
P [106] << ((E_SS() and D_SS()) and stop@now and not (exists u~time
  in tops,,now 
  that true ) and not (exists u~time
  in tops,,now 
  that stop@u )) >>
S [106]->
Q [57] << E_SS() >>
  What for:  <<M(Run) and x>> -> <<M(ShutDown)>> for one5stop:Run-[x]->ShutDown{};


[serial 1055]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << ((E_SS()) and ((EstimatedActualPosition = 0))) >>
S [108]->
Q [61] << (ACTUAL_POSITION = 0) >>
  What for:  <<M(ShutDown) and x>> -> <<M(Done)>> for one6done:ShutDown-[x]->Done{};


[serial 1056]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << ((E_SS()) and ((EstimatedActualPosition > 0))) >>
S [111]<< (E_SS() and (ACTUAL_POSITION > 0)) >>
ActuatorCommand(pc:MinusOne)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + MinusOne)) and (ACTUAL_POSITION > 0) and E_SS() and AXIOM_MO()) >>
;
EstimatedActualPosition' := (EstimatedActualPosition - 1)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION > 0)) >>
Q [59] << (E_SS() and ((ACTUAL_POSITION^(-1) > 0)))^1 >>
  What for:  <<M(ShutDown) and x>> A <<M(StillClosing)>> for one7sc:ShutDown-[x]->StillClosing{A};


[serial 1057]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << ((E_SS()) and ((EstimatedActualPosition < 0))) >>
S [120]->
Q [62] << true >>
  What for:  <<M(ShutDown) and x>> -> <<M(Error)>> for one8er:ShutDown-[x]->Error{};


[serial 1058]: ControlSoftware::RobustPositionControlThread.SingleStep
P [59] << (E_SS() and ((ACTUAL_POSITION^(-1) > 0))) >>
S [121]->
Q [57] << E_SS() >>
  What for:  <<M(StillClosing) and x>> -> <<M(ShutDown)>> for one9cl:StillClosing-[x]->ShutDown{};

 extracting initial proof obligation(s) for a package:  "PositionControl"
  creating proof obligations for "PositionControlSystem"
  creating proof obligations for "PositionControlSystem.FragileSingleStep"
  creating proof obligations for "PositionControlSystem.RobustSingleStep"
  creating proof obligations for "PositionControlSystem.FragileMultiStep"
 extracting initial proof obligation(s) for a package:  "ICE"
  no proof obligations created for "ICE_Network"
  creating proof obligations for "ICE_Interface"
  no proof obligations created for "ICE_App_Interface"
source Assertion of PositionSetpoint -> c.PositionSetpoint:  << PositionSetpoint = DESIRED_POSITION >>
destination Assertion of PositionSetpoint -> c.PositionSetpoint:  << PositionSetpoint = DESIRED_POSITION >>

[serial 1059]: PositionSetpoint -> c.PositionSetpoint
P [4] << (PositionSetpoint = DESIRED_POSITION) >>
S [2]->
Q [5] << (PositionSetpoint = DESIRED_POSITION) >>
  What for: Composition of Subcomponents via Directional Connection PositionSetpoint -> c.PositionSetpoint:
 PositionSetpoint -> PositionSetpoint

1 connection assume-guarantee verication conditions generated.
Component PositionControl::PositionControlSystem.RobustSingleStep has Invariant:  <<EQUAL_OR_CLOSER()>>
  Subcomponent PositionControl::PositionControlSystem.RobustSingleStep.c has Invariant:  <<EQUAL_OR_CLOSER()>>
  Subcomponent PositionControl::PositionControlSystem.RobustSingleStep.a has Invariant:  <<EQUAL_OR_CLOSER()>>
Component PositionControl::PositionControlSystem.FragileSingleStep has Invariant:  <<EQUAL_OR_CLOSER()>>
  Subcomponent PositionControl::PositionControlSystem.FragileSingleStep.c has Invariant:  <<EQUAL_OR_CLOSER()>>
  Subcomponent PositionControl::PositionControlSystem.FragileSingleStep.a has Invariant:  <<EQUAL_OR_CLOSER()>>
Component PositionControl::PositionControlSystem.FragileMultiStep has Invariant:  <<EQUAL_OR_CLOSER()>>
  Subcomponent PositionControl::PositionControlSystem.FragileMultiStep.c has Invariant:  <<EQUAL_OR_CLOSER()>>
  Subcomponent PositionControl::PositionControlSystem.FragileMultiStep.a has Invariant:  <<EQUAL_OR_CLOSER()>>
Marker info messages:
==> c.ActuatorCommand -> a.ActuatorCommand has no source or destination BLESS::Assertion properties.
There was one connection lacking a BLESS::Assertion property on both ends.
No errors found.
new script
You chose proof script: /Users/brianlarson/Work/BLESS-2020/Stepper/proof scripts/stepper.ps
Executing proof script . . .
step:  1
#stepper.ps
step:  2
#robust thread
step:  3
****subscript****
You chose proof subscript: /Users/brianlarson/Work/BLESS-2020/Stepper/proof scripts/subscripts/RobustSingleStep.ps
step:  1
#RobustSingleStep.ps
step:  2
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  3
****sort-by-component****
sorting proof obligations for ControlSoftware::RobustPositionControlThread.SingleStep
ControlSoftware::RobustPositionControlThread.SingleStep  [serial 1044]  
ControlSoftware::RobustPositionControlThread.SingleStep  [serial 1045]  
ControlSoftware::RobustPositionControlThread.SingleStep  [serial 1046]  
ControlSoftware::RobustPositionControlThread.SingleStep  [serial 1047]  
ControlSoftware::RobustPositionControlThread.SingleStep  [serial 1048]  
ControlSoftware::RobustPositionControlThread.SingleStep  [serial 1049]  
ControlSoftware::RobustPositionControlThread.SingleStep  [serial 1050]  
ControlSoftware::RobustPositionControlThread.SingleStep  [serial 1051]  
ControlSoftware::RobustPositionControlThread.SingleStep  [serial 1052]  
ControlSoftware::RobustPositionControlThread.SingleStep  [serial 1053]  
ControlSoftware::RobustPositionControlThread.SingleStep  [serial 1054]  
ControlSoftware::RobustPositionControlThread.SingleStep  [serial 1055]  
ControlSoftware::RobustPositionControlThread.SingleStep  [serial 1056]  
ControlSoftware::RobustPositionControlThread.SingleStep  [serial 1057]  
ControlSoftware::RobustPositionControlThread.SingleStep  [serial 1058]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1003]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1004]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1005]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1006]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1007]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1008]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1009]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1010]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1011]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1012]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1013]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1014]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1015]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1016]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1017]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1018]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1019]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1020]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1021]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1023]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1024]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1025]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1026]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1027]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1028]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1029]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1030]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1031]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1032]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1033]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1034]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1035]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1036]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1037]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1038]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1039]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1040]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1041]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1042]  
PositionSetpoint -> c.PositionSetpoint  [serial 1059]  
After sort-by-component[ControlSoftware::RobustPositionControlThread.SingleStep], no change. 
step:  4
#ControlSoftware::RobustPositionControlThread.SingleStep
step:  5
#[serial 1044] <<M(StillClosing)>> -> <<I>> from invariant I when complete state StillClosing has Assertion <<M(StillClosing)>> in its definition
step:  6
****make-an****
Making obligation 0
Obligations:

[serial 1044]: ControlSoftware::RobustPositionControlThread.SingleStep
P [59] << (E_SS() and ((ACTUAL_POSITION^(-1) > 0))) >>
S [40]->
Q [40] << true >>
  What for: <<M(StillClosing)>> -> <<I>> from invariant I when complete state StillClosing has Assertion <<M(StillClosing)>> in its definition.


Done making obligation 0
step:  7
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1044]: ControlSoftware::RobustPositionControlThread.SingleStep
P [59] << (E_SS() and ((ACTUAL_POSITION^(-1) > 0))) >>
S [40]->
Q [40] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: <<M(StillClosing)>> -> <<I>> from invariant I when complete state StillClosing has Assertion <<M(StillClosing)>> in its definition.

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [19.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1045]: ControlSoftware::RobustPositionControlThread.SingleStep
P [53] << (E_SS() and D_SS()) >>
S [40]->
Q [40] << true >>
  What for: <<M(Run)>> -> <<I>> from invariant I when complete state Run has Assertion <<M(Run)>> in its definition.


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  8
#[serial 1045] <<M(Run)>> -> <<I>> from invariant I when complete state Run has Assertion <<M(Run)>> in its definition.
step:  9
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1045]: ControlSoftware::RobustPositionControlThread.SingleStep
P [53] << (E_SS() and D_SS()) >>
S [40]->
Q [40] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: <<M(Run)>> -> <<I>> from invariant I when complete state Run has Assertion <<M(Run)>> in its definition.

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [19.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1046]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << E_SS() >>
S [57]->
Q [57] << (((EstimatedActualPosition = 0)) or ((EstimatedActualPosition > 0)) or 
((EstimatedActualPosition < 0))) >>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state ShutDown, <<M(ShutDown)>> -> <<e1 or e2 or . . . en>>


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  10
#[serial 1046] Serban's Theorem:  disjunction of execute conditions leaving execution state ShutDown, <<M(ShutDown)>> -> <<e1 or e2 or . . . en>>
step:  11
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1046]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << E_SS() >>
S [57]->
Q [57] << (((EstimatedActualPosition = 0)) or ((EstimatedActualPosition > 0)) or 
((EstimatedActualPosition < 0))) >>
Reason:  Normalization
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state ShutDown, <<M(ShutDown)>> -> <<e1 or e2 or . . . en>>

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1061]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << E_SS() >>
S [57]->
Q [57] << 0 = EstimatedActualPosition or 0 < EstimatedActualPosition or EstimatedActualPosition < 0 >>
  What for:   normalization of [serial 1046]

. . . done Normalizing Unsolved Proof Obligations [19.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1061]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << E_SS() >>
S [57]->
Q [57] << 0 = EstimatedActualPosition or 0 < EstimatedActualPosition or EstimatedActualPosition < 0 >>
  What for:   normalization of [serial 1046]


Done Normalizing
step:  12
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1061]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << E_SS() >>
S [57]->
Q [57] << 0 = EstimatedActualPosition or 0 < EstimatedActualPosition or EstimatedActualPosition < 0 >>
Reason:  Less than, greater than, or equal:  |-a<b or b<a or a=b
  What for:   normalization of [serial 1046]

Has applied law "Less than, greater than, or equal:  |-a<b or b<a or a=b" to get:

[serial 1063]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << E_SS() >>
S [57]->
Q [57] << true >>
  What for: Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1061]

. . . done Applying Laws [19.9 seconds ]
After "laws" remaining 
Obligations:

[serial 1063]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << E_SS() >>
S [57]->
Q [57] << true >>
  What for: Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1061]


Done applying laws
step:  13
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1063]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << E_SS() >>
S [57]->
Q [57] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1061]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [19.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1047]: ControlSoftware::RobustPositionControlThread.SingleStep
P [51] << (ACTUAL_POSITION = 0) >>
S [51]->
Q [51] << true >>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state PowerOn, <<M(PowerOn)>> -> <<e1 or e2 or . . . en>>


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  14
#[serial 1047] Serban's Theorem:  disjunction of execute conditions leaving execution state PowerOn, <<M(PowerOn)>> -> <<e1 or e2 or . . . en>>
step:  15
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1047]: ControlSoftware::RobustPositionControlThread.SingleStep
P [51] << (ACTUAL_POSITION = 0) >>
S [51]->
Q [51] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state PowerOn, <<M(PowerOn)>> -> <<e1 or e2 or . . . en>>

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [19.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1048]: ControlSoftware::RobustPositionControlThread.SingleStep
P [55] << (E_SS() and D_SS()) >>
S [55]->
Q [55] << ((((DESIRED_POSITION)^0 = EstimatedActualPosition)) or (((DESIRED_POSITION)^0 > EstimatedActualPosition)) or 
(((DESIRED_POSITION)^0 < EstimatedActualPosition))) >>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state Decide, <<M(Decide)>> -> <<e1 or e2 or . . . en>>


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  16
#[serial 1048] Serban's Theorem:  disjunction of execute conditions leaving execution state Decide, <<M(Decide)>> -> <<e1 or e2 or . . . en>>
step:  17
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1048]: ControlSoftware::RobustPositionControlThread.SingleStep
P [55] << (E_SS() and D_SS()) >>
S [55]->
Q [55] << ((((DESIRED_POSITION)^0 = EstimatedActualPosition)) or (((DESIRED_POSITION)^0 > EstimatedActualPosition)) or 
(((DESIRED_POSITION)^0 < EstimatedActualPosition))) >>
Reason:  Normalization
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state Decide, <<M(Decide)>> -> <<e1 or e2 or . . . en>>

  Normalization Axioms:

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1065]: ControlSoftware::RobustPositionControlThread.SingleStep
P [55] << D_SS() and E_SS() >>
S [55]->
Q [55] << DESIRED_POSITION^0 = EstimatedActualPosition or DESIRED_POSITION^0 < EstimatedActualPosition or 
EstimatedActualPosition < DESIRED_POSITION^0 >>
  What for:   normalization of [serial 1048]

. . . done Normalizing Unsolved Proof Obligations [19.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1065]: ControlSoftware::RobustPositionControlThread.SingleStep
P [55] << D_SS() and E_SS() >>
S [55]->
Q [55] << DESIRED_POSITION^0 = EstimatedActualPosition or DESIRED_POSITION^0 < EstimatedActualPosition or 
EstimatedActualPosition < DESIRED_POSITION^0 >>
  What for:   normalization of [serial 1048]


Done Normalizing
step:  18
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1065]: ControlSoftware::RobustPositionControlThread.SingleStep
P [55] << D_SS() and E_SS() >>
S [55]->
Q [55] << DESIRED_POSITION^0 = EstimatedActualPosition or DESIRED_POSITION^0 < EstimatedActualPosition or 
EstimatedActualPosition < DESIRED_POSITION^0 >>
Reason:  Less than, greater than, or equal:  |-a<b or b<a or a=b
  What for:   normalization of [serial 1048]

Has applied law "Less than, greater than, or equal:  |-a<b or b<a or a=b" to get:

[serial 1067]: ControlSoftware::RobustPositionControlThread.SingleStep
P [55] << D_SS() and E_SS() >>
S [55]->
Q [55] << true >>
  What for: Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1065]

. . . done Applying Laws [19.9 seconds ]
After "laws" remaining 
Obligations:

[serial 1067]: ControlSoftware::RobustPositionControlThread.SingleStep
P [55] << D_SS() and E_SS() >>
S [55]->
Q [55] << true >>
  What for: Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1065]


Done applying laws
step:  19
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1067]: ControlSoftware::RobustPositionControlThread.SingleStep
P [55] << D_SS() and E_SS() >>
S [55]->
Q [55] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1065]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [19.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1049]: ControlSoftware::RobustPositionControlThread.SingleStep
P [51] << (ACTUAL_POSITION = 0) >>
S [65]<< (ACTUAL_POSITION = 0) >>
ActuatorCommand(pc:0)
<< (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and ((ACTUAL_POSITION = 0))) >>
;
|EstimatedActualPosition',Delta' := 0,0|  
<< (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
Q [53] << (E_SS() and D_SS())^1 >>
  What for:  <<M(PowerOn)>> A <<M(Run)>> for one0po:PowerOn-[ ]->Run{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  20
#[serial 1049]  <<M(PowerOn)>> A <<M(Run)>> for one0po:PowerOn-[ ]->Run{A};
step:  21
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1049]: ControlSoftware::RobustPositionControlThread.SingleStep
P [51] << (ACTUAL_POSITION = 0) >>
S [65]<< (ACTUAL_POSITION = 0) >>
ActuatorCommand(pc:0)
<< (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and ((ACTUAL_POSITION = 0))) >>
;
|EstimatedActualPosition',Delta' := 0,0|  
<< (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
Q [53] << (E_SS() and D_SS())^1 >>
Reason:  Normalization
  What for:  <<M(PowerOn)>> A <<M(Run)>> for one0po:PowerOn-[ ]->Run{A};

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1069]: ControlSoftware::RobustPositionControlThread.SingleStep
P [51] << 0 = ACTUAL_POSITION >>
S [65]<< 0 = ACTUAL_POSITION >>
ActuatorCommand(pc:0)
<< 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
;
|EstimatedActualPosition',Delta' := 0,0|  
<< (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
Q [53] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1049]

. . . done Normalizing Unsolved Proof Obligations [20.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1069]: ControlSoftware::RobustPositionControlThread.SingleStep
P [51] << 0 = ACTUAL_POSITION >>
S [65]<< 0 = ACTUAL_POSITION >>
ActuatorCommand(pc:0)
<< 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
;
|EstimatedActualPosition',Delta' := 0,0|  
<< (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
Q [53] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1049]


Done Normalizing
step:  22
****reduce****
This proof obligation:

[serial 1069]: ControlSoftware::RobustPositionControlThread.SingleStep
P [51] << 0 = ACTUAL_POSITION >>
S [65]<< 0 = ACTUAL_POSITION >>
ActuatorCommand(pc:0)
<< 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
;
|EstimatedActualPosition',Delta' := 0,0|  
<< (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
Q [53] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1049]

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1071]: ControlSoftware::RobustPositionControlThread.SingleStep
P [51] << 0 = ACTUAL_POSITION >>
S [51]->
Q [65] << 0 = ACTUAL_POSITION >>
  What for: P -> P1 in sequential composition for [serial 1069]


[serial 1072]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for: Q1 -> Q in sequential composition for [serial 1069]


[serial 1073]: ControlSoftware::RobustPositionControlThread.SingleStep
P [65] << 0 = ACTUAL_POSITION >>
S [66]ActuatorCommand(pc:0)
Q [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1069]


[serial 1074]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]|EstimatedActualPosition',Delta' := 0,0|  
Q [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1069]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1071]: ControlSoftware::RobustPositionControlThread.SingleStep
P [51] << 0 = ACTUAL_POSITION >>
S [51]->
Q [65] << 0 = ACTUAL_POSITION >>
  What for: P -> P1 in sequential composition for [serial 1069]



[serial 1072]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for: Q1 -> Q in sequential composition for [serial 1069]



[serial 1073]: ControlSoftware::RobustPositionControlThread.SingleStep
P [65] << 0 = ACTUAL_POSITION >>
S [66]ActuatorCommand(pc:0)
Q [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1069]



[serial 1074]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]|EstimatedActualPosition',Delta' := 0,0|  
Q [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1069]


done reducing composite actions
step:  23
****atomic****
applying atomic actions . . .
Creating weakest-precondition predicate transfer for subprogram invocation of "ActuatorCommand".

This Proof Obligation:

[serial 1073]: ControlSoftware::RobustPositionControlThread.SingleStep
P [65] << 0 = ACTUAL_POSITION >>
S [66]ActuatorCommand(pc:0)
Q [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
Reason:  Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1069]

Used weakest precondition predicate transformation on
+ <<P>> ActuatorCommand(X) <<Q>> to get:

[serial 1075]: ControlSoftware::RobustPositionControlThread.SingleStep
P [65] << 0 = ACTUAL_POSITION >>
S [66]->
Q [67] << 0 = ACTUAL_POSITION and true >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1073]

solving assignment on line 69
replacing "EstimatedActualPosition'" with "0"
makes:  << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = 0 >>
replacing "Delta'" with "0"
makes:  << (ACTUAL_POSITION' - ACTUAL_POSITION) = 0 and ACTUAL_POSITION' = 0 >>

This Proof Obligation:

[serial 1074]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]|EstimatedActualPosition',Delta' := 0,0|  
Q [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
Reason:  Simultaneous Assignment
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1069]

Has applied simultaneous assignmnet to get:

[serial 1076]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = 0 and ACTUAL_POSITION' = 0 >>
  What for: applied wp for simultaneous assignment [serial 1074]

. . . done applying atomic actions [20.0 seconds ]
After "atomic" remaining 
Obligations:

[serial 1071]: ControlSoftware::RobustPositionControlThread.SingleStep
P [51] << 0 = ACTUAL_POSITION >>
S [51]->
Q [65] << 0 = ACTUAL_POSITION >>
  What for: P -> P1 in sequential composition for [serial 1069]



[serial 1072]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for: Q1 -> Q in sequential composition for [serial 1069]



[serial 1075]: ControlSoftware::RobustPositionControlThread.SingleStep
P [65] << 0 = ACTUAL_POSITION >>
S [66]->
Q [67] << 0 = ACTUAL_POSITION and true >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1073]



[serial 1076]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = 0 and ACTUAL_POSITION' = 0 >>
  What for: applied wp for simultaneous assignment [serial 1074]



[serial 1076]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = 0 and ACTUAL_POSITION' = 0 >>
  What for: applied wp for simultaneous assignment [serial 1074]


Done reducing atomic actions
step:  24
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1076]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = 0 and ACTUAL_POSITION' = 0 >>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1074]

  Normalization Axiom:

    Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 1081]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 0 = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1076]


This Proof Obligation:

[serial 1076]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = 0 and ACTUAL_POSITION' = 0 >>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1074]

  Normalization Axiom:

    Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 1083]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 0 = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1076]

. . . done Normalizing Unsolved Proof Obligations [20.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1071]: ControlSoftware::RobustPositionControlThread.SingleStep
P [51] << 0 = ACTUAL_POSITION >>
S [51]->
Q [65] << 0 = ACTUAL_POSITION >>
  What for: P -> P1 in sequential composition for [serial 1069]



[serial 1072]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for: Q1 -> Q in sequential composition for [serial 1069]



[serial 1075]: ControlSoftware::RobustPositionControlThread.SingleStep
P [65] << 0 = ACTUAL_POSITION >>
S [66]->
Q [67] << 0 = ACTUAL_POSITION and true >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1073]



[serial 1081]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 0 = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1076]



[serial 1083]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 0 = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1076]


Done Normalizing
step:  25
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1075]: ControlSoftware::RobustPositionControlThread.SingleStep
P [65] << 0 = ACTUAL_POSITION >>
S [66]->
Q [67] << 0 = ACTUAL_POSITION and true >>
Reason:  Law of And-Simplification:  P and true is P
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1073]

Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 1086]: ControlSoftware::RobustPositionControlThread.SingleStep
P [65] << 0 = ACTUAL_POSITION >>
S [66]->
Q [67] << (0 = ACTUAL_POSITION) >>
  What for: Law of And-Simplification:  P and true is P [serial 1075]

. . . done Applying Laws [20.0 seconds ]
After "laws" remaining 
Obligations:

[serial 1071]: ControlSoftware::RobustPositionControlThread.SingleStep
P [51] << 0 = ACTUAL_POSITION >>
S [51]->
Q [65] << 0 = ACTUAL_POSITION >>
  What for: P -> P1 in sequential composition for [serial 1069]



[serial 1072]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for: Q1 -> Q in sequential composition for [serial 1069]



[serial 1081]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 0 = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1076]



[serial 1083]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 0 = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1076]



[serial 1086]: ControlSoftware::RobustPositionControlThread.SingleStep
P [65] << 0 = ACTUAL_POSITION >>
S [66]->
Q [67] << (0 = ACTUAL_POSITION) >>
  What for: Law of And-Simplification:  P and true is P [serial 1075]


Done applying laws
step:  26
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1086]: ControlSoftware::RobustPositionControlThread.SingleStep
P [65] << 0 = ACTUAL_POSITION >>
S [66]->
Q [67] << (0 = ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Law of And-Simplification:  P and true is P [serial 1075]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1092]: ControlSoftware::RobustPositionControlThread.SingleStep
P [65] << 0 = ACTUAL_POSITION >>
S [66]->
Q [67] << 0 = ACTUAL_POSITION >>
  What for:   normalization of [serial 1086]

. . . done Normalizing Unsolved Proof Obligations [20.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1071]: ControlSoftware::RobustPositionControlThread.SingleStep
P [51] << 0 = ACTUAL_POSITION >>
S [51]->
Q [65] << 0 = ACTUAL_POSITION >>
  What for: P -> P1 in sequential composition for [serial 1069]



[serial 1072]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for: Q1 -> Q in sequential composition for [serial 1069]



[serial 1081]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 0 = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1076]



[serial 1083]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 0 = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1076]



[serial 1092]: ControlSoftware::RobustPositionControlThread.SingleStep
P [65] << 0 = ACTUAL_POSITION >>
S [66]->
Q [67] << 0 = ACTUAL_POSITION >>
  What for:   normalization of [serial 1086]


Done Normalizing
step:  27
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1071]: ControlSoftware::RobustPositionControlThread.SingleStep
P [51] << 0 = ACTUAL_POSITION >>
S [51]->
Q [65] << 0 = ACTUAL_POSITION >>
Reason:  Identity (id):  P->P is tautology
  What for: P -> P1 in sequential composition for [serial 1069]

Has been solved by Identity (id):  P->P is tautology

This Proof Obligation:

[serial 1092]: ControlSoftware::RobustPositionControlThread.SingleStep
P [65] << 0 = ACTUAL_POSITION >>
S [66]->
Q [67] << 0 = ACTUAL_POSITION >>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1086]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [20.0 seconds ]
After "axioms" remaining 
Obligations:

[serial 1072]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for: Q1 -> Q in sequential composition for [serial 1069]



[serial 1081]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 0 = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1076]



[serial 1083]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 0 = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1076]


Done trying to apply axioms
step:  28
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1081]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 0 = ACTUAL_POSITION' >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 1076]

Has split postcondition to get:

[serial 1094]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [71] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]


[serial 1095]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]


This Proof Obligation:

[serial 1083]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 0 = ACTUAL_POSITION' >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 1076]

Has split postcondition to get:

[serial 1096]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [71] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1083]


[serial 1097]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1083]

. . . done splitting postcondition  [20.0 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1072]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for: Q1 -> Q in sequential composition for [serial 1069]



[serial 1094]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [71] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]



[serial 1095]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]



[serial 1096]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [71] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1083]



[serial 1097]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1083]


Done splitting postcondition
step:  29
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  ACTUAL_POSITION' = EstimatedActualPosition'
equality selected for substitution:  ACTUAL_POSITION = ACTUAL_POSITION'

This Proof Obligation:

[serial 1094]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [71] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]

Has substituted 
"ACTUAL_POSITION'" with its = "ACTUAL_POSITION"
 to get:

[serial 1098]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [71] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1094]

equality selected for substitution:  ACTUAL_POSITION = ACTUAL_POSITION'

This Proof Obligation:

[serial 1095]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]

Has substituted 
"ACTUAL_POSITION'" with its = "ACTUAL_POSITION"
 to get:

[serial 1099]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1095]

equality selected for substitution:  ACTUAL_POSITION = ACTUAL_POSITION'

This Proof Obligation:

[serial 1096]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [71] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1083]

Has substituted 
"ACTUAL_POSITION'" with its = "ACTUAL_POSITION"
 to get:

[serial 1100]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [71] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1096]

equality selected for substitution:  ACTUAL_POSITION = ACTUAL_POSITION'

This Proof Obligation:

[serial 1097]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1083]

Has substituted 
"ACTUAL_POSITION'" with its = "ACTUAL_POSITION"
 to get:

[serial 1101]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1097]

. . . done guided substitution of equals  [20.0 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1072]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
Reason:  Guided Substitution of Equals
  What for: Q1 -> Q in sequential composition for [serial 1069]



[serial 1098]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [71] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1094]



[serial 1099]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1095]



[serial 1100]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [71] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1096]



[serial 1101]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1097]


Done guided substituting an equals
step:  30
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1098]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [71] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1094]

  Normalization Axioms:

    Subtraction of Same:  a-a is 0

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1104]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [71] << 0 = 0 >>
  What for:   normalization of [serial 1098]


This Proof Obligation:

[serial 1100]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [71] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1096]

  Normalization Axioms:

    Subtraction of Same:  a-a is 0

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1107]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [71] << 0 = 0 >>
  What for:   normalization of [serial 1100]

. . . done Normalizing Unsolved Proof Obligations [20.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1072]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
Reason:  Guided Substitution of Equals
  What for: Q1 -> Q in sequential composition for [serial 1069]



[serial 1099]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1095]



[serial 1101]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1097]



[serial 1104]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [71] << 0 = 0 >>
  What for:   normalization of [serial 1098]



[serial 1107]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [71] << 0 = 0 >>
  What for:   normalization of [serial 1100]


Done Normalizing
step:  31
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1104]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [71] << 0 = 0 >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 1098]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 1111]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [71] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1104]


This Proof Obligation:

[serial 1107]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [71] << 0 = 0 >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 1100]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 1112]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [71] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1107]

. . . done Applying Laws [20.0 seconds ]
After "laws" remaining 
Obligations:

[serial 1072]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
Reason:  Guided Substitution of Equals
  What for: Q1 -> Q in sequential composition for [serial 1069]



[serial 1099]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1095]



[serial 1101]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1097]



[serial 1111]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [71] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1104]



[serial 1112]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [71] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1107]


Done applying laws
step:  32
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1099]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1095]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1101]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [70] << 0 = ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1097]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1111]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [71] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 1104]

Has been solved by True Conclusion Schema (tc): P->true

This Proof Obligation:

[serial 1112]: ControlSoftware::RobustPositionControlThread.SingleStep
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69]->
Q [71] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 1107]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [20.0 seconds ]
After "axioms" remaining 
Obligations:

[serial 1072]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
Reason:  Guided Substitution of Equals
  What for: Q1 -> Q in sequential composition for [serial 1069]


Done trying to apply axioms
step:  33
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1072]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
Reason:  Substitution of Assertion Labels
  What for: Q1 -> Q in sequential composition for [serial 1069]

Has substituted Assertions' predicates for labels to get:

[serial 1113]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels  [serial 1072]

. . . done Substituting Assertions for Labels [20.0 seconds ]
After "substitute" remaining 
Obligations:

[serial 1113]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels  [serial 1072]


Done substituting Assertion labels.
step:  34
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1113]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: substituted Assertions' predicates for  labels  [serial 1072]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1114]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) = (Delta)^1 and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [53]->
Q [15] << (((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1))))^1 and ((EstimatedActualPosition = ACTUAL_POSITION))^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1113]

. . . done spltting timed atoms  [20.1 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [20.1 seconds ]
After "dist^" remaining 
Obligations:

[serial 1114]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) = (Delta)^1 and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [53]->
Q [15] << (((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1))))^1 and ((EstimatedActualPosition = ACTUAL_POSITION))^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1113]


Done distributing ^ and @.
step:  35
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1114]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) = (Delta)^1 and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [53]->
Q [15] << (((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1))))^1 and ((EstimatedActualPosition = ACTUAL_POSITION))^1) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1113]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1116]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 >>
  What for:   normalization of [serial 1114]

. . . done Normalizing Unsolved Proof Obligations [20.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1116]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 >>
  What for:   normalization of [serial 1114]


Done Normalizing
step:  36
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1116]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1114]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1118]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((Delta)^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1116]

. . . done spltting timed atoms  [20.1 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [20.1 seconds ]
After "dist^" remaining 
Obligations:

[serial 1118]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((Delta)^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1116]


Done distributing ^ and @.
step:  37
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1118]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((Delta)^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1116]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1119]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((Delta)^1 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1))) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1118]

. . . done spltting timed atoms  [20.1 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [20.1 seconds ]
After "dist^" remaining 
Obligations:

[serial 1119]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((Delta)^1 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1))) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1118]


Done distributing ^ and @.
step:  38
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1119]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((Delta)^1 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1))) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1118]

  Normalization Axioms:

    Literal Arithmetic

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1121]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
  What for:   normalization of [serial 1119]

. . . done Normalizing Unsolved Proof Obligations [20.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1121]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
  What for:   normalization of [serial 1119]


Done Normalizing
step:  39
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1121]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1119]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1123]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1121]

. . . done spltting timed atoms  [20.1 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [20.1 seconds ]
After "dist^" remaining 
Obligations:

[serial 1123]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1121]


Done distributing ^ and @.
step:  40
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1123]: ControlSoftware::RobustPositionControlThread.SingleStep
P [70] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  Identity (id):  P->P is tautology
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1121]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [20.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1050]: ControlSoftware::RobustPositionControlThread.SingleStep
P [53] << (E_SS() and D_SS()) >>
S [73]->
Q [55] << (E_SS() and D_SS()) >>
  What for:  <<M(Run) and x>> -> <<M(Decide)>> for one1run:Run-[x]->Decide{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  41
#[serial 1050]  <<M(Run) and x>> -> <<M(Decide)>> for one1run:Run-[x]->Decide{};
step:  42
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1050]: ControlSoftware::RobustPositionControlThread.SingleStep
P [53] << (E_SS() and D_SS()) >>
S [73]->
Q [55] << (E_SS() and D_SS()) >>
Reason:  Identity (id):  P->P is tautology
  What for:  <<M(Run) and x>> -> <<M(Decide)>> for one1run:Run-[x]->Decide{};

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [20.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1051]: ControlSoftware::RobustPositionControlThread.SingleStep
P [55] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 = EstimatedActualPosition))) >>
S [76]<< (E_SS() and (DESIRED_POSITION = ACTUAL_POSITION)) >>
ActuatorCommand(pc:0)
<< (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E_SS()) >>
;
|EstimatedActualPosition',Delta' := EstimatedActualPosition,0|  
<< (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
Q [53] << (E_SS() and D_SS())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for one2eq:Decide-[x]->Run{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  43
#[serial 1051]  <<M(Decide) and x>> A <<M(Run)>> for one2eq:Decide-[x]->Run{A};
step:  44
****reduce****
This proof obligation:

[serial 1051]: ControlSoftware::RobustPositionControlThread.SingleStep
P [55] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 = EstimatedActualPosition))) >>
S [76]<< (E_SS() and (DESIRED_POSITION = ACTUAL_POSITION)) >>
ActuatorCommand(pc:0)
<< (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E_SS()) >>
;
|EstimatedActualPosition',Delta' := EstimatedActualPosition,0|  
<< (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
Q [53] << (E_SS() and D_SS())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for one2eq:Decide-[x]->Run{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1124]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 = EstimatedActualPosition))) >>
S [55]->
Q [15] << (E_SS() and (DESIRED_POSITION = ACTUAL_POSITION)) >>
  What for: P -> P1 in sequential composition for [serial 1051]


[serial 1125]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
S [53]->
Q [15] << (E_SS() and D_SS())^1 >>
  What for: Q1 -> Q in sequential composition for [serial 1051]


[serial 1126]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and (DESIRED_POSITION = ACTUAL_POSITION)) >>
S [77]ActuatorCommand(pc:0)
Q [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E_SS()) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1051]


[serial 1127]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E_SS()) >>
S [80]|EstimatedActualPosition',Delta' := EstimatedActualPosition,0|  
Q [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1051]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1124]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 = EstimatedActualPosition))) >>
S [55]->
Q [15] << (E_SS() and (DESIRED_POSITION = ACTUAL_POSITION)) >>
  What for: P -> P1 in sequential composition for [serial 1051]



[serial 1125]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
S [53]->
Q [15] << (E_SS() and D_SS())^1 >>
  What for: Q1 -> Q in sequential composition for [serial 1051]



[serial 1126]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and (DESIRED_POSITION = ACTUAL_POSITION)) >>
S [77]ActuatorCommand(pc:0)
Q [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E_SS()) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1051]



[serial 1127]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E_SS()) >>
S [80]|EstimatedActualPosition',Delta' := EstimatedActualPosition,0|  
Q [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1051]


done reducing composite actions
step:  45
****atomic****
applying atomic actions . . .
Creating weakest-precondition predicate transfer for subprogram invocation of "ActuatorCommand".
There must be occurrences of: 
  ACTUAL_POSITION = ACTUAL_POSITION'
 found in:
  << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E_SS()) >>
 for invocation of "ActuatorCommand" on line 77 to have effect.
solving assignment on line 80
replacing "EstimatedActualPosition'" with "EstimatedActualPosition"
makes:  << (((EstimatedActualPosition = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
replacing "Delta'" with "0"
makes:  << (((EstimatedActualPosition = ACTUAL_POSITION')) and ((0 = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>

This Proof Obligation:

[serial 1127]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E_SS()) >>
S [80]|EstimatedActualPosition',Delta' := EstimatedActualPosition,0|  
Q [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
Reason:  Simultaneous Assignment
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1051]

Has applied simultaneous assignmnet to get:

[serial 1128]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E_SS()) >>
S [80]->
Q [15] << (((EstimatedActualPosition = ACTUAL_POSITION')) and ((0 = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
  What for: applied wp for simultaneous assignment [serial 1127]

. . . done applying atomic actions [20.2 seconds ]
After "atomic" remaining 
Obligations:

[serial 1124]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 = EstimatedActualPosition))) >>
S [55]->
Q [15] << (E_SS() and (DESIRED_POSITION = ACTUAL_POSITION)) >>
  What for: P -> P1 in sequential composition for [serial 1051]



[serial 1125]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
S [53]->
Q [15] << (E_SS() and D_SS())^1 >>
  What for: Q1 -> Q in sequential composition for [serial 1051]



[serial 1126]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and (DESIRED_POSITION = ACTUAL_POSITION)) >>
S [77]ActuatorCommand(pc:0)
Q [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E_SS()) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1051]



[serial 1128]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E_SS()) >>
S [80]->
Q [15] << (((EstimatedActualPosition = ACTUAL_POSITION')) and ((0 = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
  What for: applied wp for simultaneous assignment [serial 1127]



[serial 1128]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E_SS()) >>
S [80]->
Q [15] << (((EstimatedActualPosition = ACTUAL_POSITION')) and ((0 = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
  What for: applied wp for simultaneous assignment [serial 1127]


Done reducing atomic actions
step:  46
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1124]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 = EstimatedActualPosition))) >>
S [55]->
Q [15] << (E_SS() and (DESIRED_POSITION = ACTUAL_POSITION)) >>
Reason:  Normalization
  What for: P -> P1 in sequential composition for [serial 1051]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1130]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and D_SS() and E_SS() >>
S [55]->
Q [15] << ACTUAL_POSITION = DESIRED_POSITION and E_SS() >>
  What for:   normalization of [serial 1124]


This Proof Obligation:

[serial 1125]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
S [53]->
Q [15] << (E_SS() and D_SS())^1 >>
Reason:  Normalization
  What for: Q1 -> Q in sequential composition for [serial 1051]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1132]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1125]


This Proof Obligation:

[serial 1126]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and (DESIRED_POSITION = ACTUAL_POSITION)) >>
S [77]ActuatorCommand(pc:0)
Q [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E_SS()) >>
Reason:  Normalization
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1051]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1134]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = DESIRED_POSITION and E_SS() >>
S [77]ActuatorCommand(pc:0)
Q [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
  What for:   normalization of [serial 1126]


This Proof Obligation:

[serial 1128]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E_SS()) >>
S [80]->
Q [15] << (((EstimatedActualPosition = ACTUAL_POSITION')) and ((0 = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1127]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1136]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1128]


This Proof Obligation:

[serial 1128]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E_SS()) >>
S [80]->
Q [15] << (((EstimatedActualPosition = ACTUAL_POSITION')) and ((0 = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1127]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1138]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1128]

. . . done Normalizing Unsolved Proof Obligations [20.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1130]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and D_SS() and E_SS() >>
S [55]->
Q [15] << ACTUAL_POSITION = DESIRED_POSITION and E_SS() >>
  What for:   normalization of [serial 1124]



[serial 1132]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1125]



[serial 1134]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = DESIRED_POSITION and E_SS() >>
S [77]ActuatorCommand(pc:0)
Q [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
  What for:   normalization of [serial 1126]



[serial 1136]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1128]



[serial 1138]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1128]


Done Normalizing
step:  47
****atomic****
applying atomic actions . . .
Creating weakest-precondition predicate transfer for subprogram invocation of "ActuatorCommand".

This Proof Obligation:

[serial 1134]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = DESIRED_POSITION and E_SS() >>
S [77]ActuatorCommand(pc:0)
Q [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
Reason:  Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
  What for:   normalization of [serial 1126]

Used weakest precondition predicate transformation on
+ <<P>> ActuatorCommand(X) <<Q>> to get:

[serial 1144]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = DESIRED_POSITION and E_SS() >>
S [77]->
Q [15] << true and E_SS() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1134]

. . . done applying atomic actions [20.2 seconds ]
After "atomic" remaining 
Obligations:

[serial 1130]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and D_SS() and E_SS() >>
S [55]->
Q [15] << ACTUAL_POSITION = DESIRED_POSITION and E_SS() >>
  What for:   normalization of [serial 1124]



[serial 1132]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1125]



[serial 1144]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = DESIRED_POSITION and E_SS() >>
S [77]->
Q [15] << true and E_SS() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1134]



[serial 1136]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1128]



[serial 1138]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1128]


Done reducing atomic actions
step:  48
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1144]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = DESIRED_POSITION and E_SS() >>
S [77]->
Q [15] << true and E_SS() >>
Reason:  Law of And-Simplification:  P and true is P
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1134]

Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 1145]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = DESIRED_POSITION and E_SS() >>
S [77]->
Q [15] << (E_SS()) >>
  What for: Law of And-Simplification:  P and true is P [serial 1144]

. . . done Applying Laws [20.2 seconds ]
After "laws" remaining 
Obligations:

[serial 1130]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and D_SS() and E_SS() >>
S [55]->
Q [15] << ACTUAL_POSITION = DESIRED_POSITION and E_SS() >>
  What for:   normalization of [serial 1124]



[serial 1132]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1125]



[serial 1136]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1128]



[serial 1138]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1128]



[serial 1145]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = DESIRED_POSITION and E_SS() >>
S [77]->
Q [15] << (E_SS()) >>
  What for: Law of And-Simplification:  P and true is P [serial 1144]


Done applying laws
step:  49
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1145]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = DESIRED_POSITION and E_SS() >>
S [77]->
Q [15] << (E_SS()) >>
Reason:  Normalization
  What for: Law of And-Simplification:  P and true is P [serial 1144]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1151]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = DESIRED_POSITION and E_SS() >>
S [77]->
Q [15] << E_SS() >>
  What for:   normalization of [serial 1145]

. . . done Normalizing Unsolved Proof Obligations [20.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1130]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and D_SS() and E_SS() >>
S [55]->
Q [15] << ACTUAL_POSITION = DESIRED_POSITION and E_SS() >>
  What for:   normalization of [serial 1124]



[serial 1132]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1125]



[serial 1136]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1128]



[serial 1138]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1128]



[serial 1151]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = DESIRED_POSITION and E_SS() >>
S [77]->
Q [15] << E_SS() >>
  What for:   normalization of [serial 1145]


Done Normalizing
step:  50
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1151]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = DESIRED_POSITION and E_SS() >>
S [77]->
Q [15] << E_SS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1145]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [20.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1130]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and D_SS() and E_SS() >>
S [55]->
Q [15] << ACTUAL_POSITION = DESIRED_POSITION and E_SS() >>
  What for:   normalization of [serial 1124]



[serial 1132]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1125]



[serial 1136]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1128]



[serial 1138]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1128]


Done trying to apply axioms
step:  51
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1130]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and D_SS() and E_SS() >>
S [55]->
Q [15] << ACTUAL_POSITION = DESIRED_POSITION and E_SS() >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 1124]

Has split postcondition to get:

[serial 1153]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and D_SS() and E_SS() >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1130]


[serial 1154]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and D_SS() and E_SS() >>
S [55]->
Q [76] << E_SS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1130]


This Proof Obligation:

[serial 1136]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and EstimatedActualPosition = ACTUAL_POSITION' >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 1128]

Has split postcondition to get:

[serial 1155]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1136]


[serial 1156]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1136]


This Proof Obligation:

[serial 1138]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and EstimatedActualPosition = ACTUAL_POSITION' >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 1128]

Has split postcondition to get:

[serial 1157]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1138]


[serial 1158]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1138]

. . . done splitting postcondition  [20.2 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1132]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1125]



[serial 1153]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and D_SS() and E_SS() >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1130]



[serial 1154]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and D_SS() and E_SS() >>
S [55]->
Q [76] << E_SS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1130]



[serial 1155]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1136]



[serial 1156]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1136]



[serial 1157]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1138]



[serial 1158]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1138]


Done splitting postcondition
step:  52
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1154]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and D_SS() and E_SS() >>
S [55]->
Q [76] << E_SS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1130]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [20.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1132]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1125]



[serial 1153]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and D_SS() and E_SS() >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1130]



[serial 1155]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1136]



[serial 1156]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1136]



[serial 1157]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1138]



[serial 1158]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1138]


Done trying to apply axioms
step:  53
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1153]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and D_SS() and E_SS() >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1130]

Has substituted Assertions' predicates for labels to get:

[serial 1159]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and ((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1153]


This Proof Obligation:

[serial 1155]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1136]

Has substituted Assertions' predicates for labels to get:

[serial 1160]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1155]


This Proof Obligation:

[serial 1156]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1136]

Has substituted Assertions' predicates for labels to get:

[serial 1161]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1156]


This Proof Obligation:

[serial 1157]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1138]

Has substituted Assertions' predicates for labels to get:

[serial 1162]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1157]


This Proof Obligation:

[serial 1158]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1138]

Has substituted Assertions' predicates for labels to get:

[serial 1163]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1158]

. . . done Substituting Assertions for Labels [20.2 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1132]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1125]



[serial 1159]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and ((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1153]



[serial 1160]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1155]



[serial 1161]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1156]



[serial 1162]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1157]



[serial 1163]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1158]


Done substituting Assertion labels in preconditions
step:  54
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1159]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and ((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1153]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1166]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 1159]


This Proof Obligation:

[serial 1160]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1155]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1168]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1160]


This Proof Obligation:

[serial 1161]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1156]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1170]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1161]


This Proof Obligation:

[serial 1162]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1157]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1172]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1162]


This Proof Obligation:

[serial 1163]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1158]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1174]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1163]

. . . done Normalizing Unsolved Proof Obligations [20.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1132]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1125]



[serial 1166]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 1159]



[serial 1168]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1160]



[serial 1170]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1161]



[serial 1172]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1162]



[serial 1174]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1163]


Done Normalizing
step:  55
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  ACTUAL_POSITION' = EstimatedActualPosition'
equality selected for substitution:  ACTUAL_POSITION = ACTUAL_POSITION'

This Proof Obligation:

[serial 1168]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 1160]

Has substituted 
"ACTUAL_POSITION'" with its = "ACTUAL_POSITION"
 to get:

[serial 1180]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1168]

equality selected for substitution:  ACTUAL_POSITION = ACTUAL_POSITION'

This Proof Obligation:

[serial 1170]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 1161]

Has substituted 
"ACTUAL_POSITION'" with its = "ACTUAL_POSITION"
 to get:

[serial 1181]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1170]

equality selected for substitution:  ACTUAL_POSITION = ACTUAL_POSITION'

This Proof Obligation:

[serial 1172]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 1162]

Has substituted 
"ACTUAL_POSITION'" with its = "ACTUAL_POSITION"
 to get:

[serial 1182]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1172]

equality selected for substitution:  ACTUAL_POSITION = ACTUAL_POSITION'

This Proof Obligation:

[serial 1174]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 1163]

Has substituted 
"ACTUAL_POSITION'" with its = "ACTUAL_POSITION"
 to get:

[serial 1183]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1174]

. . . done guided substitution of equals  [20.2 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1132]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 1125]



[serial 1166]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 1159]



[serial 1180]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1168]



[serial 1181]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1170]



[serial 1182]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1172]



[serial 1183]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1174]


Done guided substituting an equals
step:  56
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1180]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1168]

  Normalization Axioms:

    Subtraction of Same:  a-a is 0

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1187]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << 0 = 0 >>
  What for:   normalization of [serial 1180]


This Proof Obligation:

[serial 1181]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1170]

  Normalization Axiom:

    Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 1189]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [81] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1181]


This Proof Obligation:

[serial 1182]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1172]

  Normalization Axioms:

    Subtraction of Same:  a-a is 0

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1191]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << 0 = 0 >>
  What for:   normalization of [serial 1182]


This Proof Obligation:

[serial 1183]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1174]

  Normalization Axiom:

    Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 1193]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [81] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1183]

. . . done Normalizing Unsolved Proof Obligations [20.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1132]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 1125]



[serial 1166]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 1159]



[serial 1187]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << 0 = 0 >>
  What for:   normalization of [serial 1180]



[serial 1189]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [81] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1181]



[serial 1191]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << 0 = 0 >>
  What for:   normalization of [serial 1182]



[serial 1193]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [81] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1183]


Done Normalizing
step:  57
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1189]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [81] << ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1181]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1193]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [81] << ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1183]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [20.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 1132]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 1125]



[serial 1166]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 1159]



[serial 1187]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << 0 = 0 >>
  What for:   normalization of [serial 1180]



[serial 1191]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << 0 = 0 >>
  What for:   normalization of [serial 1182]


Done trying to apply axioms
step:  58
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1187]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << 0 = 0 >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 1180]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 1198]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1187]


This Proof Obligation:

[serial 1191]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << 0 = 0 >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 1182]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 1199]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1191]

. . . done Applying Laws [20.3 seconds ]
After "laws" remaining 
Obligations:

[serial 1132]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 1125]



[serial 1166]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 1159]



[serial 1198]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1187]



[serial 1199]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1191]


Done applying laws
step:  59
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1198]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 1187]

Has been solved by True Conclusion Schema (tc): P->true

This Proof Obligation:

[serial 1199]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80]->
Q [82] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 1191]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [20.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 1132]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 1125]



[serial 1166]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 1159]


Done trying to apply axioms
step:  60
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1132]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 1125]

Has substituted Assertions' predicates for labels to get:

[serial 1200]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels  [serial 1132]

. . . done Substituting Assertions for Labels [20.3 seconds ]
After "substitute" remaining 
Obligations:

[serial 1166]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 1159]



[serial 1200]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels  [serial 1132]


Done substituting Assertion labels.
step:  61
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1166]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1159]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1201]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1166]


This Proof Obligation:

[serial 1200]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: substituted Assertions' predicates for  labels  [serial 1132]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1202]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) = (Delta)^1 and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [53]->
Q [15] << (((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1))))^1 and ((EstimatedActualPosition = ACTUAL_POSITION))^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1200]

. . . done spltting timed atoms  [20.3 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [20.3 seconds ]
After "dist^" remaining 
Obligations:

[serial 1201]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1166]



[serial 1202]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) = (Delta)^1 and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [53]->
Q [15] << (((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1))))^1 and ((EstimatedActualPosition = ACTUAL_POSITION))^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1200]


Done distributing ^ and @.
step:  62
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1201]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << DESIRED_POSITION = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1166]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1204]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 1201]


This Proof Obligation:

[serial 1202]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) = (Delta)^1 and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [53]->
Q [15] << (((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1))))^1 and ((EstimatedActualPosition = ACTUAL_POSITION))^1) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1200]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1206]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 >>
  What for:   normalization of [serial 1202]

. . . done Normalizing Unsolved Proof Obligations [20.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1204]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 1201]



[serial 1206]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 >>
  What for:   normalization of [serial 1202]


Done Normalizing
step:  63
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1206]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1202]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1209]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((Delta)^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1206]

. . . done spltting timed atoms  [20.3 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [20.3 seconds ]
After "dist^" remaining 
Obligations:

[serial 1204]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 1201]



[serial 1209]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((Delta)^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1206]


Done distributing ^ and @.
step:  64
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1209]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((Delta)^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1206]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1212]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 >>
  What for:   normalization of [serial 1209]

. . . done Normalizing Unsolved Proof Obligations [20.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1204]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 1201]



[serial 1212]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 >>
  What for:   normalization of [serial 1209]


Done Normalizing
step:  65
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1212]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1209]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1214]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1212]

. . . done spltting timed atoms  [20.3 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [20.3 seconds ]
After "dist^" remaining 
Obligations:

[serial 1204]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 1201]



[serial 1214]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1212]


Done distributing ^ and @.
step:  66
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1214]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1212]

  Normalization Axioms:

    Literal Arithmetic

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1217]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
  What for:   normalization of [serial 1214]

. . . done Normalizing Unsolved Proof Obligations [20.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1204]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 1201]



[serial 1217]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
  What for:   normalization of [serial 1214]


Done Normalizing
step:  67
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1217]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1214]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1219]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1217]

. . . done spltting timed atoms  [20.3 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [20.3 seconds ]
After "dist^" remaining 
Obligations:

[serial 1204]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 1201]



[serial 1219]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1217]


Done distributing ^ and @.
step:  68
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1219]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  Identity (id):  P->P is tautology
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1217]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [20.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 1204]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 1201]


Done trying to apply axioms
step:  69
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION" . . .
equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 1204]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 1201]

Has substituted 
"ACTUAL_POSITION" with its = "EstimatedActualPosition"
 to get:

[serial 1220]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << EstimatedActualPosition = DESIRED_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1204]

. . . done guided substitution of equals  [20.3 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1220]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << EstimatedActualPosition = DESIRED_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1204]


Done guided substituting an equals
step:  70
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1220]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << EstimatedActualPosition = DESIRED_POSITION >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1204]

  Normalization Axiom:

    Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 1222]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << DESIRED_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1220]

. . . done Normalizing Unsolved Proof Obligations [20.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1222]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << DESIRED_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1220]


Done Normalizing
step:  71
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1222]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55]->
Q [76] << DESIRED_POSITION = EstimatedActualPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1220]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [20.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1052]: ControlSoftware::RobustPositionControlThread.SingleStep
P [55] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 > EstimatedActualPosition))) >>
S [86]<< (E_SS() and (DESIRED_POSITION > ACTUAL_POSITION)) >>
ActuatorCommand(pc:1)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + 1)) and E_SS()) >>
;
|EstimatedActualPosition',Delta' := (EstimatedActualPosition + 1),1|  
<< (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
Q [53] << (E_SS() and D_SS())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for one3gt:Decide-[x]->Run{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  72
#[serial 1052]  <<M(Decide) and x>> A <<M(Run)>> for one3gt:Decide-[x]->Run{A};
step:  73
****reduce****
This proof obligation:

[serial 1052]: ControlSoftware::RobustPositionControlThread.SingleStep
P [55] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 > EstimatedActualPosition))) >>
S [86]<< (E_SS() and (DESIRED_POSITION > ACTUAL_POSITION)) >>
ActuatorCommand(pc:1)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + 1)) and E_SS()) >>
;
|EstimatedActualPosition',Delta' := (EstimatedActualPosition + 1),1|  
<< (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
Q [53] << (E_SS() and D_SS())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for one3gt:Decide-[x]->Run{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1224]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 > EstimatedActualPosition))) >>
S [55]->
Q [15] << (E_SS() and (DESIRED_POSITION > ACTUAL_POSITION)) >>
  What for: P -> P1 in sequential composition for [serial 1052]


[serial 1225]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
S [53]->
Q [15] << (E_SS() and D_SS())^1 >>
  What for: Q1 -> Q in sequential composition for [serial 1052]


[serial 1226]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and (DESIRED_POSITION > ACTUAL_POSITION)) >>
S [87]ActuatorCommand(pc:1)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 1)) and E_SS()) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1052]


[serial 1227]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 1)) and E_SS()) >>
S [90]|EstimatedActualPosition',Delta' := (EstimatedActualPosition + 1),1|  
Q [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1052]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1224]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 > EstimatedActualPosition))) >>
S [55]->
Q [15] << (E_SS() and (DESIRED_POSITION > ACTUAL_POSITION)) >>
  What for: P -> P1 in sequential composition for [serial 1052]



[serial 1225]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
S [53]->
Q [15] << (E_SS() and D_SS())^1 >>
  What for: Q1 -> Q in sequential composition for [serial 1052]



[serial 1226]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and (DESIRED_POSITION > ACTUAL_POSITION)) >>
S [87]ActuatorCommand(pc:1)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 1)) and E_SS()) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1052]



[serial 1227]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 1)) and E_SS()) >>
S [90]|EstimatedActualPosition',Delta' := (EstimatedActualPosition + 1),1|  
Q [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1052]


done reducing composite actions
step:  74
****atomic****
applying atomic actions . . .
Creating weakest-precondition predicate transfer for subprogram invocation of "ActuatorCommand".
There must be occurrences of: 
  (1 + ACTUAL_POSITION) = ACTUAL_POSITION'
 found in:
  << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 1)) and E_SS()) >>
 for invocation of "ActuatorCommand" on line 87 to have effect.
solving assignment on line 90
replacing "EstimatedActualPosition'" with "((EstimatedActualPosition + 1))"
makes:  << ((((((EstimatedActualPosition + 1))) = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
replacing "Delta'" with "1"
makes:  << ((((((EstimatedActualPosition + 1))) = ACTUAL_POSITION')) and ((1 = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>

This Proof Obligation:

[serial 1227]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 1)) and E_SS()) >>
S [90]|EstimatedActualPosition',Delta' := (EstimatedActualPosition + 1),1|  
Q [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
Reason:  Simultaneous Assignment
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1052]

Has applied simultaneous assignmnet to get:

[serial 1228]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 1)) and E_SS()) >>
S [90]->
Q [15] << ((((((EstimatedActualPosition + 1))) = ACTUAL_POSITION')) and ((1 = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
  What for: applied wp for simultaneous assignment [serial 1227]

. . . done applying atomic actions [20.4 seconds ]
After "atomic" remaining 
Obligations:

[serial 1224]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 > EstimatedActualPosition))) >>
S [55]->
Q [15] << (E_SS() and (DESIRED_POSITION > ACTUAL_POSITION)) >>
  What for: P -> P1 in sequential composition for [serial 1052]



[serial 1225]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
S [53]->
Q [15] << (E_SS() and D_SS())^1 >>
  What for: Q1 -> Q in sequential composition for [serial 1052]



[serial 1226]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and (DESIRED_POSITION > ACTUAL_POSITION)) >>
S [87]ActuatorCommand(pc:1)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 1)) and E_SS()) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1052]



[serial 1228]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 1)) and E_SS()) >>
S [90]->
Q [15] << ((((((EstimatedActualPosition + 1))) = ACTUAL_POSITION')) and ((1 = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
  What for: applied wp for simultaneous assignment [serial 1227]



[serial 1228]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 1)) and E_SS()) >>
S [90]->
Q [15] << ((((((EstimatedActualPosition + 1))) = ACTUAL_POSITION')) and ((1 = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
  What for: applied wp for simultaneous assignment [serial 1227]


Done reducing atomic actions
step:  75
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1224]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 > EstimatedActualPosition))) >>
S [55]->
Q [15] << (E_SS() and (DESIRED_POSITION > ACTUAL_POSITION)) >>
Reason:  Normalization
  What for: P -> P1 in sequential composition for [serial 1052]

  Normalization Axioms:

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1230]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
  What for:   normalization of [serial 1224]


This Proof Obligation:

[serial 1225]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
S [53]->
Q [15] << (E_SS() and D_SS())^1 >>
Reason:  Normalization
  What for: Q1 -> Q in sequential composition for [serial 1052]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1232]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1225]


This Proof Obligation:

[serial 1226]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and (DESIRED_POSITION > ACTUAL_POSITION)) >>
S [87]ActuatorCommand(pc:1)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 1)) and E_SS()) >>
Reason:  Normalization
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1052]

  Normalization Axioms:

    Reflexivity of Addition: a+b=b+a

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1234]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
S [87]ActuatorCommand(pc:1)
Q [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and E_SS() >>
  What for:   normalization of [serial 1226]


This Proof Obligation:

[serial 1228]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 1)) and E_SS()) >>
S [90]->
Q [15] << ((((((EstimatedActualPosition + 1))) = ACTUAL_POSITION')) and ((1 = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1227]

  Normalization Axioms:

    Reflexivity of Addition: a+b=b+a

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1236]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and E_SS() >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1228]


This Proof Obligation:

[serial 1228]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 1)) and E_SS()) >>
S [90]->
Q [15] << ((((((EstimatedActualPosition + 1))) = ACTUAL_POSITION')) and ((1 = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1227]

  Normalization Axioms:

    Reflexivity of Addition: a+b=b+a

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1238]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and E_SS() >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1228]

. . . done Normalizing Unsolved Proof Obligations [20.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1230]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
  What for:   normalization of [serial 1224]



[serial 1232]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1225]



[serial 1234]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
S [87]ActuatorCommand(pc:1)
Q [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and E_SS() >>
  What for:   normalization of [serial 1226]



[serial 1236]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and E_SS() >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1228]



[serial 1238]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and E_SS() >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1228]


Done Normalizing
step:  76
****atomic****
applying atomic actions . . .
Creating weakest-precondition predicate transfer for subprogram invocation of "ActuatorCommand".

This Proof Obligation:

[serial 1234]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
S [87]ActuatorCommand(pc:1)
Q [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and E_SS() >>
Reason:  Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
  What for:   normalization of [serial 1226]

Used weakest precondition predicate transformation on
+ <<P>> ActuatorCommand(X) <<Q>> to get:

[serial 1244]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
S [87]->
Q [15] << true and E_SS() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1234]

. . . done applying atomic actions [20.4 seconds ]
After "atomic" remaining 
Obligations:

[serial 1230]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
  What for:   normalization of [serial 1224]



[serial 1232]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1225]



[serial 1244]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
S [87]->
Q [15] << true and E_SS() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1234]



[serial 1236]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and E_SS() >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1228]



[serial 1238]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and E_SS() >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1228]


Done reducing atomic actions
step:  77
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1244]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
S [87]->
Q [15] << true and E_SS() >>
Reason:  Law of And-Simplification:  P and true is P
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1234]

Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 1245]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
S [87]->
Q [15] << (E_SS()) >>
  What for: Law of And-Simplification:  P and true is P [serial 1244]

. . . done Applying Laws [20.4 seconds ]
After "laws" remaining 
Obligations:

[serial 1230]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
  What for:   normalization of [serial 1224]



[serial 1232]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1225]



[serial 1236]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and E_SS() >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1228]



[serial 1238]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and E_SS() >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1228]



[serial 1245]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
S [87]->
Q [15] << (E_SS()) >>
  What for: Law of And-Simplification:  P and true is P [serial 1244]


Done applying laws
step:  78
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1245]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
S [87]->
Q [15] << (E_SS()) >>
Reason:  Normalization
  What for: Law of And-Simplification:  P and true is P [serial 1244]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1251]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
S [87]->
Q [15] << E_SS() >>
  What for:   normalization of [serial 1245]

. . . done Normalizing Unsolved Proof Obligations [20.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1230]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
  What for:   normalization of [serial 1224]



[serial 1232]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1225]



[serial 1236]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and E_SS() >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1228]



[serial 1238]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and E_SS() >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1228]



[serial 1251]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
S [87]->
Q [15] << E_SS() >>
  What for:   normalization of [serial 1245]


Done Normalizing
step:  79
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1251]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
S [87]->
Q [15] << E_SS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1245]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [20.4 seconds ]
After "axioms" remaining 
Obligations:

[serial 1230]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
  What for:   normalization of [serial 1224]



[serial 1232]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1225]



[serial 1236]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and E_SS() >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1228]



[serial 1238]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and E_SS() >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1228]


Done trying to apply axioms
step:  80
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1230]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 1224]

Has substituted Assertions' predicates for labels to get:

[serial 1253]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1230]


This Proof Obligation:

[serial 1236]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and E_SS() >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 1228]

Has substituted Assertions' predicates for labels to get:

[serial 1254]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1236]


This Proof Obligation:

[serial 1238]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and E_SS() >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 1228]

Has substituted Assertions' predicates for labels to get:

[serial 1255]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1238]

. . . done Substituting Assertions for Labels [20.4 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1232]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1225]



[serial 1253]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1230]



[serial 1254]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1236]



[serial 1255]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1238]


Done substituting Assertion labels in preconditions
step:  81
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1253]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1230]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1258]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
  What for:   normalization of [serial 1253]


This Proof Obligation:

[serial 1254]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1236]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1260]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1254]


This Proof Obligation:

[serial 1255]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1238]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1262]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1255]

. . . done Normalizing Unsolved Proof Obligations [20.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 1232]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1225]



[serial 1258]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
  What for:   normalization of [serial 1253]



[serial 1260]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1254]



[serial 1262]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1255]


Done Normalizing
step:  82
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1258]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 1253]

Has split postcondition to get:

[serial 1266]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [86] << E_SS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1258]


[serial 1267]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1258]


This Proof Obligation:

[serial 1260]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 1254]

Has split postcondition to get:

[serial 1268]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1260]


[serial 1269]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [91] << (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1260]


This Proof Obligation:

[serial 1262]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 1255]

Has split postcondition to get:

[serial 1270]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1262]


[serial 1271]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [91] << (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1262]

. . . done splitting postcondition  [20.5 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1232]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1225]



[serial 1266]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [86] << E_SS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1258]



[serial 1267]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1258]



[serial 1268]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1260]



[serial 1269]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [91] << (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1260]



[serial 1270]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1262]



[serial 1271]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [91] << (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1262]


Done splitting postcondition
step:  83
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1232]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 1225]

Has substituted Assertions' predicates for labels to get:

[serial 1272]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels  [serial 1232]


This Proof Obligation:

[serial 1266]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [86] << E_SS() >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1258]

Has substituted Assertions' predicates for labels to get:

[serial 1273]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [86] << ((EstimatedActualPosition = ACTUAL_POSITION)) >>
  What for: substituted Assertions' predicates for  labels  [serial 1266]

. . . done Substituting Assertions for Labels [20.5 seconds ]
After "substitute" remaining 
Obligations:

[serial 1267]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1258]



[serial 1268]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1260]



[serial 1269]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [91] << (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1260]



[serial 1270]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1262]



[serial 1271]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [91] << (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1262]



[serial 1272]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels  [serial 1232]



[serial 1273]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [86] << ((EstimatedActualPosition = ACTUAL_POSITION)) >>
  What for: substituted Assertions' predicates for  labels  [serial 1266]


Done substituting Assertion labels.
step:  84
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1272]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1232]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1280]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 >>
  What for:   normalization of [serial 1272]


This Proof Obligation:

[serial 1273]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [86] << ((EstimatedActualPosition = ACTUAL_POSITION)) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1266]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1282]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [86] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1273]

. . . done Normalizing Unsolved Proof Obligations [20.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 1267]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1258]



[serial 1268]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1260]



[serial 1269]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [91] << (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1260]



[serial 1270]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1262]



[serial 1271]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [91] << (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1262]



[serial 1280]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 >>
  What for:   normalization of [serial 1272]



[serial 1282]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [86] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1273]


Done Normalizing
step:  85
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1282]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [86] << ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1273]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [20.5 seconds ]
After "axioms" remaining 
Obligations:

[serial 1267]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1258]



[serial 1268]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1260]



[serial 1269]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [91] << (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1260]



[serial 1270]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1262]



[serial 1271]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [91] << (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1262]



[serial 1280]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 >>
  What for:   normalization of [serial 1272]


Done trying to apply axioms
step:  86
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1267]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55]->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1258]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1285]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55]->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1267]


This Proof Obligation:

[serial 1268]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1260]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1286]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = (ACTUAL_POSITION)^1 >>
S [90]->
Q [92] << 1 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1268]


This Proof Obligation:

[serial 1269]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [91] << (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1260]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1287]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = (ACTUAL_POSITION)^1 >>
S [90]->
Q [91] << (1 + EstimatedActualPosition) = (ACTUAL_POSITION)^1 >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1269]


This Proof Obligation:

[serial 1270]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1262]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1288]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = (ACTUAL_POSITION)^1 >>
S [90]->
Q [92] << 1 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1270]


This Proof Obligation:

[serial 1271]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90]->
Q [91] << (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1262]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1289]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = (ACTUAL_POSITION)^1 >>
S [90]->
Q [91] << (1 + EstimatedActualPosition) = (ACTUAL_POSITION)^1 >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1271]


This Proof Obligation:

[serial 1280]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1272]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1290]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) = (Delta)^1 and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [53]->
Q [15] << ((ACTUAL_POSITION = EstimatedActualPosition)^1 and (Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1280]

. . . done spltting timed atoms  [20.5 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [20.5 seconds ]
After "dist^" remaining 
Obligations:

[serial 1285]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55]->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1267]



[serial 1286]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = (ACTUAL_POSITION)^1 >>
S [90]->
Q [92] << 1 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1268]



[serial 1287]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = (ACTUAL_POSITION)^1 >>
S [90]->
Q [91] << (1 + EstimatedActualPosition) = (ACTUAL_POSITION)^1 >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1269]



[serial 1288]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = (ACTUAL_POSITION)^1 >>
S [90]->
Q [92] << 1 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1270]



[serial 1289]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = (ACTUAL_POSITION)^1 >>
S [90]->
Q [91] << (1 + EstimatedActualPosition) = (ACTUAL_POSITION)^1 >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1271]



[serial 1290]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) = (Delta)^1 and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [53]->
Q [15] << ((ACTUAL_POSITION = EstimatedActualPosition)^1 and (Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1280]


Done distributing ^ and @.
step:  87
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1286]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = (ACTUAL_POSITION)^1 >>
S [90]->
Q [92] << 1 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1268]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1293]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1286]


This Proof Obligation:

[serial 1287]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = (ACTUAL_POSITION)^1 >>
S [90]->
Q [91] << (1 + EstimatedActualPosition) = (ACTUAL_POSITION)^1 >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1269]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1295]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ACTUAL_POSITION^1 = (1 + EstimatedActualPosition) >>
  What for:   normalization of [serial 1287]


This Proof Obligation:

[serial 1288]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = (ACTUAL_POSITION)^1 >>
S [90]->
Q [92] << 1 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1270]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1297]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1288]


This Proof Obligation:

[serial 1289]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = (ACTUAL_POSITION)^1 >>
S [90]->
Q [91] << (1 + EstimatedActualPosition) = (ACTUAL_POSITION)^1 >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1271]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1299]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ACTUAL_POSITION^1 = (1 + EstimatedActualPosition) >>
  What for:   normalization of [serial 1289]


This Proof Obligation:

[serial 1290]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) = (Delta)^1 and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [53]->
Q [15] << ((ACTUAL_POSITION = EstimatedActualPosition)^1 and (Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1280]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1301]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 >>
  What for:   normalization of [serial 1290]

. . . done Normalizing Unsolved Proof Obligations [20.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 1285]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55]->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1267]



[serial 1293]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1286]



[serial 1295]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ACTUAL_POSITION^1 = (1 + EstimatedActualPosition) >>
  What for:   normalization of [serial 1287]



[serial 1297]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1288]



[serial 1299]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ACTUAL_POSITION^1 = (1 + EstimatedActualPosition) >>
  What for:   normalization of [serial 1289]



[serial 1301]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 >>
  What for:   normalization of [serial 1290]


Done Normalizing
step:  88
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1301]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1290]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1307]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((Delta)^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1301]

. . . done spltting timed atoms  [20.6 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [20.6 seconds ]
After "dist^" remaining 
Obligations:

[serial 1285]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55]->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1267]



[serial 1293]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1286]



[serial 1295]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ACTUAL_POSITION^1 = (1 + EstimatedActualPosition) >>
  What for:   normalization of [serial 1287]



[serial 1297]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1288]



[serial 1299]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ACTUAL_POSITION^1 = (1 + EstimatedActualPosition) >>
  What for:   normalization of [serial 1289]



[serial 1307]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((Delta)^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1301]


Done distributing ^ and @.
step:  89
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1307]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((Delta)^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1301]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1314]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 >>
  What for:   normalization of [serial 1307]

. . . done Normalizing Unsolved Proof Obligations [20.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 1285]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55]->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1267]



[serial 1293]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1286]



[serial 1295]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ACTUAL_POSITION^1 = (1 + EstimatedActualPosition) >>
  What for:   normalization of [serial 1287]



[serial 1297]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1288]



[serial 1299]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ACTUAL_POSITION^1 = (1 + EstimatedActualPosition) >>
  What for:   normalization of [serial 1289]



[serial 1314]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 >>
  What for:   normalization of [serial 1307]


Done Normalizing
step:  90
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1314]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1307]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1316]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1314]

. . . done spltting timed atoms  [20.6 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [20.6 seconds ]
After "dist^" remaining 
Obligations:

[serial 1285]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55]->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1267]



[serial 1293]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1286]



[serial 1295]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ACTUAL_POSITION^1 = (1 + EstimatedActualPosition) >>
  What for:   normalization of [serial 1287]



[serial 1297]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1288]



[serial 1299]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ACTUAL_POSITION^1 = (1 + EstimatedActualPosition) >>
  What for:   normalization of [serial 1289]



[serial 1316]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1314]


Done distributing ^ and @.
step:  91
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1316]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1314]

  Normalization Axioms:

    Literal Arithmetic

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1323]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
  What for:   normalization of [serial 1316]

. . . done Normalizing Unsolved Proof Obligations [20.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 1285]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55]->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1267]



[serial 1293]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1286]



[serial 1295]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ACTUAL_POSITION^1 = (1 + EstimatedActualPosition) >>
  What for:   normalization of [serial 1287]



[serial 1297]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1288]



[serial 1299]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ACTUAL_POSITION^1 = (1 + EstimatedActualPosition) >>
  What for:   normalization of [serial 1289]



[serial 1323]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
  What for:   normalization of [serial 1316]


Done Normalizing
step:  92
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1323]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1316]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1325]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1323]

. . . done spltting timed atoms  [20.6 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [20.6 seconds ]
After "dist^" remaining 
Obligations:

[serial 1285]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55]->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1267]



[serial 1293]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1286]



[serial 1295]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ACTUAL_POSITION^1 = (1 + EstimatedActualPosition) >>
  What for:   normalization of [serial 1287]



[serial 1297]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1288]



[serial 1299]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ACTUAL_POSITION^1 = (1 + EstimatedActualPosition) >>
  What for:   normalization of [serial 1289]



[serial 1325]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1323]


Done distributing ^ and @.
step:  93
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1325]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  Identity (id):  P->P is tautology
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1323]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [20.6 seconds ]
After "axioms" remaining 
Obligations:

[serial 1285]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55]->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1267]



[serial 1293]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1286]



[serial 1295]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ACTUAL_POSITION^1 = (1 + EstimatedActualPosition) >>
  What for:   normalization of [serial 1287]



[serial 1297]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1288]



[serial 1299]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ACTUAL_POSITION^1 = (1 + EstimatedActualPosition) >>
  What for:   normalization of [serial 1289]


Done trying to apply axioms
step:  94
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION" . . .
equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 1285]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55]->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
Reason:  Guided Substitution of Equals
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1267]

Has substituted 
"ACTUAL_POSITION" with its = "EstimatedActualPosition"
 to get:

[serial 1326]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55]->
Q [1] << EstimatedActualPosition < DESIRED_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1285]

equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 1293]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 1286]

Has substituted 
"ACTUAL_POSITION" with its = "EstimatedActualPosition"
 to get:

[serial 1327]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (EstimatedActualPosition^1 - EstimatedActualPosition) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1293]

equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 1295]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ACTUAL_POSITION^1 = (1 + EstimatedActualPosition) >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 1287]

Has substituted 
"ACTUAL_POSITION" with its = "EstimatedActualPosition"
 to get:

[serial 1328]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << EstimatedActualPosition^1 = (1 + EstimatedActualPosition) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1295]

equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 1297]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 1288]

Has substituted 
"ACTUAL_POSITION" with its = "EstimatedActualPosition"
 to get:

[serial 1329]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (EstimatedActualPosition^1 - EstimatedActualPosition) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1297]

equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 1299]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ACTUAL_POSITION^1 = (1 + EstimatedActualPosition) >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 1289]

Has substituted 
"ACTUAL_POSITION" with its = "EstimatedActualPosition"
 to get:

[serial 1330]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << EstimatedActualPosition^1 = (1 + EstimatedActualPosition) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1299]

. . . done guided substitution of equals  [20.7 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1326]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55]->
Q [1] << EstimatedActualPosition < DESIRED_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1285]



[serial 1327]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (EstimatedActualPosition^1 - EstimatedActualPosition) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1293]



[serial 1328]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << EstimatedActualPosition^1 = (1 + EstimatedActualPosition) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1295]



[serial 1329]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (EstimatedActualPosition^1 - EstimatedActualPosition) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1297]



[serial 1330]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << EstimatedActualPosition^1 = (1 + EstimatedActualPosition) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1299]


Done guided substituting an equals
step:  95
****guided-sub-equals****
guided substitution of equals "EstimatedActualPosition" . . .
equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 1326]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55]->
Q [1] << EstimatedActualPosition < DESIRED_POSITION >>
Reason:  Guided Substitution of Equals
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1285]

Has substituted 
"EstimatedActualPosition" with its = "ACTUAL_POSITION"
 to get:

[serial 1331]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55]->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 1326]

equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 1327]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (EstimatedActualPosition^1 - EstimatedActualPosition) >>
Reason:  Guided Substitution of Equals
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1293]

Has substituted 
"EstimatedActualPosition" with its = "ACTUAL_POSITION"
 to get:

[serial 1332]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 1327]

equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 1328]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << EstimatedActualPosition^1 = (1 + EstimatedActualPosition) >>
Reason:  Guided Substitution of Equals
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1295]

Has substituted 
"EstimatedActualPosition" with its = "ACTUAL_POSITION"
 to get:

[serial 1333]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 1328]

equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 1329]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (EstimatedActualPosition^1 - EstimatedActualPosition) >>
Reason:  Guided Substitution of Equals
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1297]

Has substituted 
"EstimatedActualPosition" with its = "ACTUAL_POSITION"
 to get:

[serial 1334]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 1329]

equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 1330]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << EstimatedActualPosition^1 = (1 + EstimatedActualPosition) >>
Reason:  Guided Substitution of Equals
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1299]

Has substituted 
"EstimatedActualPosition" with its = "ACTUAL_POSITION"
 to get:

[serial 1335]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 1330]

. . . done guided substitution of equals  [20.7 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1331]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55]->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 1326]



[serial 1332]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 1327]



[serial 1333]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 1328]



[serial 1334]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 1329]



[serial 1335]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 1330]


Done guided substituting an equals
step:  96
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION^1" . . .
equality selected for substitution:  ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION)

This Proof Obligation:

[serial 1332]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  Guided Substitution of Equals
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 1327]

Has substituted 
"ACTUAL_POSITION^1" with its = "((1 + ACTUAL_POSITION))"
 to get:

[serial 1336]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (((1 + ACTUAL_POSITION)) - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((1 + ACTUAL_POSITION))" in its postcondition [serial 1332]

equality selected for substitution:  ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION)

This Proof Obligation:

[serial 1333]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) >>
Reason:  Guided Substitution of Equals
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 1328]

Has substituted 
"ACTUAL_POSITION^1" with its = "((1 + ACTUAL_POSITION))"
 to get:

[serial 1337]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ((1 + ACTUAL_POSITION)) = (1 + ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((1 + ACTUAL_POSITION))" in its postcondition [serial 1333]

equality selected for substitution:  ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION)

This Proof Obligation:

[serial 1334]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  Guided Substitution of Equals
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 1329]

Has substituted 
"ACTUAL_POSITION^1" with its = "((1 + ACTUAL_POSITION))"
 to get:

[serial 1338]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (((1 + ACTUAL_POSITION)) - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((1 + ACTUAL_POSITION))" in its postcondition [serial 1334]

equality selected for substitution:  ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION)

This Proof Obligation:

[serial 1335]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) >>
Reason:  Guided Substitution of Equals
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 1330]

Has substituted 
"ACTUAL_POSITION^1" with its = "((1 + ACTUAL_POSITION))"
 to get:

[serial 1339]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ((1 + ACTUAL_POSITION)) = (1 + ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((1 + ACTUAL_POSITION))" in its postcondition [serial 1335]

. . . done guided substitution of equals  [20.7 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1331]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55]->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 1326]



[serial 1336]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (((1 + ACTUAL_POSITION)) - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((1 + ACTUAL_POSITION))" in its postcondition [serial 1332]



[serial 1337]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ((1 + ACTUAL_POSITION)) = (1 + ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((1 + ACTUAL_POSITION))" in its postcondition [serial 1333]



[serial 1338]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (((1 + ACTUAL_POSITION)) - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((1 + ACTUAL_POSITION))" in its postcondition [serial 1334]



[serial 1339]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ((1 + ACTUAL_POSITION)) = (1 + ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((1 + ACTUAL_POSITION))" in its postcondition [serial 1335]


Done guided substituting an equals
step:  97
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1336]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (((1 + ACTUAL_POSITION)) - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((1 + ACTUAL_POSITION))" in its postcondition [serial 1332]

  Normalization Axioms:

    Subtaction of Added Value:  (a+b)-a is b

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1342]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = 1 >>
  What for:   normalization of [serial 1336]


This Proof Obligation:

[serial 1337]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ((1 + ACTUAL_POSITION)) = (1 + ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((1 + ACTUAL_POSITION))" in its postcondition [serial 1333]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1344]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << (1 + ACTUAL_POSITION) = (1 + ACTUAL_POSITION) >>
  What for:   normalization of [serial 1337]


This Proof Obligation:

[serial 1338]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = (((1 + ACTUAL_POSITION)) - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((1 + ACTUAL_POSITION))" in its postcondition [serial 1334]

  Normalization Axioms:

    Subtaction of Added Value:  (a+b)-a is b

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1346]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = 1 >>
  What for:   normalization of [serial 1338]


This Proof Obligation:

[serial 1339]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << ((1 + ACTUAL_POSITION)) = (1 + ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((1 + ACTUAL_POSITION))" in its postcondition [serial 1335]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1348]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << (1 + ACTUAL_POSITION) = (1 + ACTUAL_POSITION) >>
  What for:   normalization of [serial 1339]

. . . done Normalizing Unsolved Proof Obligations [20.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1331]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55]->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 1326]



[serial 1342]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = 1 >>
  What for:   normalization of [serial 1336]



[serial 1344]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << (1 + ACTUAL_POSITION) = (1 + ACTUAL_POSITION) >>
  What for:   normalization of [serial 1337]



[serial 1346]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = 1 >>
  What for:   normalization of [serial 1338]



[serial 1348]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << (1 + ACTUAL_POSITION) = (1 + ACTUAL_POSITION) >>
  What for:   normalization of [serial 1339]


Done Normalizing
step:  98
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1342]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = 1 >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 1336]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 1353]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1342]


This Proof Obligation:

[serial 1344]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << (1 + ACTUAL_POSITION) = (1 + ACTUAL_POSITION) >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 1337]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 1354]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1344]


This Proof Obligation:

[serial 1346]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << 1 = 1 >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 1338]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 1355]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1346]


This Proof Obligation:

[serial 1348]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << (1 + ACTUAL_POSITION) = (1 + ACTUAL_POSITION) >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 1339]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 1356]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1348]

. . . done Applying Laws [20.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1331]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55]->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 1326]



[serial 1353]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1342]



[serial 1354]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1344]



[serial 1355]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1346]



[serial 1356]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1348]


Done applying laws
step:  99
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1353]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 1342]

Has been solved by True Conclusion Schema (tc): P->true

This Proof Obligation:

[serial 1354]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 1344]

Has been solved by True Conclusion Schema (tc): P->true

This Proof Obligation:

[serial 1355]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [92] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 1346]

Has been solved by True Conclusion Schema (tc): P->true

This Proof Obligation:

[serial 1356]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90]->
Q [91] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 1348]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [20.7 seconds ]
After "axioms" remaining 
Obligations:

[serial 1331]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55]->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 1326]


Done trying to apply axioms
step:  100
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION" . . .
equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 1331]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55]->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
Reason:  Guided Substitution of Equals
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 1326]

Has substituted 
"ACTUAL_POSITION" with its = "EstimatedActualPosition"
 to get:

[serial 1357]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55]->
Q [1] << EstimatedActualPosition < DESIRED_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1331]

. . . done guided substitution of equals  [20.7 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1357]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55]->
Q [1] << EstimatedActualPosition < DESIRED_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1331]


Done guided substituting an equals
step:  101
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1357]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55]->
Q [1] << EstimatedActualPosition < DESIRED_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1331]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [20.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1053]: ControlSoftware::RobustPositionControlThread.SingleStep
P [55] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 < EstimatedActualPosition))) >>
S [96]<< (E_SS() and (DESIRED_POSITION < ACTUAL_POSITION) and AXIOM_MO()) >>
ActuatorCommand(pc:MinusOne)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + MinusOne)) and E_SS() and AXIOM_MO()) >>
;
|EstimatedActualPosition',Delta' := (EstimatedActualPosition - 1),-1|  
<< (((EstimatedActualPosition' = ACTUAL_POSITION')) and (Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
Q [53] << (E_SS() and D_SS())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for one4lt:Decide-[x]->Run{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  102
#[serial 1053]  <<M(Decide) and x>> A <<M(Run)>> for one4lt:Decide-[x]->Run{A};
step:  103
****reduce****
This proof obligation:

[serial 1053]: ControlSoftware::RobustPositionControlThread.SingleStep
P [55] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 < EstimatedActualPosition))) >>
S [96]<< (E_SS() and (DESIRED_POSITION < ACTUAL_POSITION) and AXIOM_MO()) >>
ActuatorCommand(pc:MinusOne)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + MinusOne)) and E_SS() and AXIOM_MO()) >>
;
|EstimatedActualPosition',Delta' := (EstimatedActualPosition - 1),-1|  
<< (((EstimatedActualPosition' = ACTUAL_POSITION')) and (Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
Q [53] << (E_SS() and D_SS())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for one4lt:Decide-[x]->Run{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1358]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 < EstimatedActualPosition))) >>
S [55]->
Q [15] << (E_SS() and (DESIRED_POSITION < ACTUAL_POSITION) and AXIOM_MO()) >>
  What for: P -> P1 in sequential composition for [serial 1053]


[serial 1359]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and (Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
S [53]->
Q [15] << (E_SS() and D_SS())^1 >>
  What for: Q1 -> Q in sequential composition for [serial 1053]


[serial 1360]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and (DESIRED_POSITION < ACTUAL_POSITION) and AXIOM_MO()) >>
S [97]ActuatorCommand(pc:MinusOne)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + MinusOne)) and E_SS() and AXIOM_MO()) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1053]


[serial 1361]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + MinusOne)) and E_SS() and AXIOM_MO()) >>
S [101]|EstimatedActualPosition',Delta' := (EstimatedActualPosition - 1),-1|  
Q [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and (Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1053]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1358]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 < EstimatedActualPosition))) >>
S [55]->
Q [15] << (E_SS() and (DESIRED_POSITION < ACTUAL_POSITION) and AXIOM_MO()) >>
  What for: P -> P1 in sequential composition for [serial 1053]



[serial 1359]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and (Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
S [53]->
Q [15] << (E_SS() and D_SS())^1 >>
  What for: Q1 -> Q in sequential composition for [serial 1053]



[serial 1360]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and (DESIRED_POSITION < ACTUAL_POSITION) and AXIOM_MO()) >>
S [97]ActuatorCommand(pc:MinusOne)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + MinusOne)) and E_SS() and AXIOM_MO()) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1053]



[serial 1361]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + MinusOne)) and E_SS() and AXIOM_MO()) >>
S [101]|EstimatedActualPosition',Delta' := (EstimatedActualPosition - 1),-1|  
Q [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and (Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1053]


done reducing composite actions
step:  104
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1358]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 < EstimatedActualPosition))) >>
S [55]->
Q [15] << (E_SS() and (DESIRED_POSITION < ACTUAL_POSITION) and AXIOM_MO()) >>
Reason:  Normalization
  What for: P -> P1 in sequential composition for [serial 1053]

  Normalization Axioms:

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1363]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [15] << AXIOM_MO() and E_SS() and DESIRED_POSITION < ACTUAL_POSITION >>
  What for:   normalization of [serial 1358]


This Proof Obligation:

[serial 1359]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and (Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
S [53]->
Q [15] << (E_SS() and D_SS())^1 >>
Reason:  Normalization
  What for: Q1 -> Q in sequential composition for [serial 1053]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1365]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1359]


This Proof Obligation:

[serial 1360]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and (DESIRED_POSITION < ACTUAL_POSITION) and AXIOM_MO()) >>
S [97]ActuatorCommand(pc:MinusOne)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + MinusOne)) and E_SS() and AXIOM_MO()) >>
Reason:  Normalization
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1053]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1367]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << AXIOM_MO() and E_SS() and DESIRED_POSITION < ACTUAL_POSITION >>
S [97]ActuatorCommand(pc:MinusOne)
Q [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
  What for:   normalization of [serial 1360]


This Proof Obligation:

[serial 1361]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + MinusOne)) and E_SS() and AXIOM_MO()) >>
S [101]|EstimatedActualPosition',Delta' := (EstimatedActualPosition - 1),-1|  
Q [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and (Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
Reason:  Normalization
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1053]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1369]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]|EstimatedActualPosition',Delta' := (EstimatedActualPosition - 1),-1|  
Q [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
  What for:   normalization of [serial 1361]

. . . done Normalizing Unsolved Proof Obligations [20.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1363]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [15] << AXIOM_MO() and E_SS() and DESIRED_POSITION < ACTUAL_POSITION >>
  What for:   normalization of [serial 1358]



[serial 1365]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1359]



[serial 1367]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << AXIOM_MO() and E_SS() and DESIRED_POSITION < ACTUAL_POSITION >>
S [97]ActuatorCommand(pc:MinusOne)
Q [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
  What for:   normalization of [serial 1360]



[serial 1369]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]|EstimatedActualPosition',Delta' := (EstimatedActualPosition - 1),-1|  
Q [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
  What for:   normalization of [serial 1361]


Done Normalizing
step:  105
****atomic****
applying atomic actions . . .
Creating weakest-precondition predicate transfer for subprogram invocation of "ActuatorCommand".

This Proof Obligation:

[serial 1367]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << AXIOM_MO() and E_SS() and DESIRED_POSITION < ACTUAL_POSITION >>
S [97]ActuatorCommand(pc:MinusOne)
Q [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
Reason:  Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
  What for:   normalization of [serial 1360]

Used weakest precondition predicate transformation on
+ <<P>> ActuatorCommand(X) <<Q>> to get:

[serial 1374]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << AXIOM_MO() and E_SS() and DESIRED_POSITION < ACTUAL_POSITION >>
S [97]->
Q [15] << true and AXIOM_MO() and E_SS() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1367]

solving assignment on line 101
replacing "EstimatedActualPosition'" with "((EstimatedActualPosition - 1))"
makes:  << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = (((EstimatedActualPosition - 1))) >>
replacing "Delta'" with "-1"
makes:  << (ACTUAL_POSITION' - ACTUAL_POSITION) = -1 and ACTUAL_POSITION' = (((EstimatedActualPosition - 1))) >>

This Proof Obligation:

[serial 1369]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]|EstimatedActualPosition',Delta' := (EstimatedActualPosition - 1),-1|  
Q [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
Reason:  Simultaneous Assignment
  What for:   normalization of [serial 1361]

Has applied simultaneous assignmnet to get:

[serial 1375]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = -1 and ACTUAL_POSITION' = (((EstimatedActualPosition - 1))) >>
  What for: applied wp for simultaneous assignment [serial 1369]

. . . done applying atomic actions [20.8 seconds ]
After "atomic" remaining 
Obligations:

[serial 1363]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [15] << AXIOM_MO() and E_SS() and DESIRED_POSITION < ACTUAL_POSITION >>
  What for:   normalization of [serial 1358]



[serial 1365]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1359]



[serial 1374]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << AXIOM_MO() and E_SS() and DESIRED_POSITION < ACTUAL_POSITION >>
S [97]->
Q [15] << true and AXIOM_MO() and E_SS() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1367]



[serial 1375]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = -1 and ACTUAL_POSITION' = (((EstimatedActualPosition - 1))) >>
  What for: applied wp for simultaneous assignment [serial 1369]



[serial 1375]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = -1 and ACTUAL_POSITION' = (((EstimatedActualPosition - 1))) >>
  What for: applied wp for simultaneous assignment [serial 1369]


Done reducing atomic actions
step:  106
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1374]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << AXIOM_MO() and E_SS() and DESIRED_POSITION < ACTUAL_POSITION >>
S [97]->
Q [15] << true and AXIOM_MO() and E_SS() >>
Reason:  Normalization
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1367]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1379]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << AXIOM_MO() and E_SS() and DESIRED_POSITION < ACTUAL_POSITION >>
S [97]->
Q [15] << AXIOM_MO() and E_SS() and true >>
  What for:   normalization of [serial 1374]


This Proof Obligation:

[serial 1375]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = -1 and ACTUAL_POSITION' = (((EstimatedActualPosition - 1))) >>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1369]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1381]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [15] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1375]


This Proof Obligation:

[serial 1375]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = -1 and ACTUAL_POSITION' = (((EstimatedActualPosition - 1))) >>
Reason:  Normalization
  What for: applied wp for simultaneous assignment [serial 1369]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1383]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [15] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1375]

. . . done Normalizing Unsolved Proof Obligations [20.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1363]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [15] << AXIOM_MO() and E_SS() and DESIRED_POSITION < ACTUAL_POSITION >>
  What for:   normalization of [serial 1358]



[serial 1365]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1359]



[serial 1379]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << AXIOM_MO() and E_SS() and DESIRED_POSITION < ACTUAL_POSITION >>
S [97]->
Q [15] << AXIOM_MO() and E_SS() and true >>
  What for:   normalization of [serial 1374]



[serial 1381]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [15] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1375]



[serial 1383]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [15] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1375]


Done Normalizing
step:  107
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1379]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << AXIOM_MO() and E_SS() and DESIRED_POSITION < ACTUAL_POSITION >>
S [97]->
Q [15] << AXIOM_MO() and E_SS() and true >>
Reason:  Law of And-Simplification:  P and true is P
  What for:   normalization of [serial 1374]

Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 1387]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << AXIOM_MO() and E_SS() and DESIRED_POSITION < ACTUAL_POSITION >>
S [97]->
Q [15] << AXIOM_MO() and E_SS() >>
  What for: Law of And-Simplification:  P and true is P [serial 1379]

. . . done Applying Laws [20.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1363]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [15] << AXIOM_MO() and E_SS() and DESIRED_POSITION < ACTUAL_POSITION >>
  What for:   normalization of [serial 1358]



[serial 1365]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1359]



[serial 1381]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [15] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1375]



[serial 1383]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [15] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1375]



[serial 1387]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << AXIOM_MO() and E_SS() and DESIRED_POSITION < ACTUAL_POSITION >>
S [97]->
Q [15] << AXIOM_MO() and E_SS() >>
  What for: Law of And-Simplification:  P and true is P [serial 1379]


Done applying laws
step:  108
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1387]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << AXIOM_MO() and E_SS() and DESIRED_POSITION < ACTUAL_POSITION >>
S [97]->
Q [15] << AXIOM_MO() and E_SS() >>
Reason:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
  What for: Law of And-Simplification:  P and true is P [serial 1379]

Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [20.8 seconds ]
After "axioms" remaining 
Obligations:

[serial 1363]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [15] << AXIOM_MO() and E_SS() and DESIRED_POSITION < ACTUAL_POSITION >>
  What for:   normalization of [serial 1358]



[serial 1365]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1359]



[serial 1381]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [15] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1375]



[serial 1383]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [15] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1375]


Done trying to apply axioms
step:  109
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1363]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [15] << AXIOM_MO() and E_SS() and DESIRED_POSITION < ACTUAL_POSITION >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 1358]

Has split postcondition to get:

[serial 1388]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << AXIOM_MO() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1363]


[serial 1389]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << E_SS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1363]


[serial 1390]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1363]


This Proof Obligation:

[serial 1381]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [15] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 1375]

Has split postcondition to get:

[serial 1391]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [103] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1381]


[serial 1392]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1381]


This Proof Obligation:

[serial 1383]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [15] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 1375]

Has split postcondition to get:

[serial 1393]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [103] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1383]


[serial 1394]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1383]

. . . done splitting postcondition  [20.8 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1365]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1359]



[serial 1388]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << AXIOM_MO() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1363]



[serial 1389]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << E_SS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1363]



[serial 1390]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1363]



[serial 1391]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [103] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1381]



[serial 1392]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1381]



[serial 1393]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [103] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1383]



[serial 1394]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1383]


Done splitting postcondition
step:  110
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1389]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << E_SS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1363]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [20.8 seconds ]
After "axioms" remaining 
Obligations:

[serial 1365]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1359]



[serial 1388]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << AXIOM_MO() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1363]



[serial 1390]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1363]



[serial 1391]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [103] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1381]



[serial 1392]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1381]



[serial 1393]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [103] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1383]



[serial 1394]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1383]


Done trying to apply axioms
step:  111
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1388]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << AXIOM_MO() >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1363]

Has substituted Assertions' predicates for labels to get:

[serial 1395]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)) and 
DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << AXIOM_MO() >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1388]


This Proof Obligation:

[serial 1390]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << D_SS() and E_SS() and DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << DESIRED_POSITION < ACTUAL_POSITION >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1363]

Has substituted Assertions' predicates for labels to get:

[serial 1396]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)) and 
DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1390]


This Proof Obligation:

[serial 1391]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [103] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1381]

Has substituted Assertions' predicates for labels to get:

[serial 1397]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [103] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1391]


This Proof Obligation:

[serial 1392]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1381]

Has substituted Assertions' predicates for labels to get:

[serial 1398]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1392]


This Proof Obligation:

[serial 1393]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [103] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1383]

Has substituted Assertions' predicates for labels to get:

[serial 1399]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [103] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1393]


This Proof Obligation:

[serial 1394]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1383]

Has substituted Assertions' predicates for labels to get:

[serial 1400]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1394]

. . . done Substituting Assertions for Labels [20.8 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1365]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1359]



[serial 1395]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)) and 
DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << AXIOM_MO() >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1388]



[serial 1396]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)) and 
DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1390]



[serial 1397]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [103] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1391]



[serial 1398]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1392]



[serial 1399]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [103] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1393]



[serial 1400]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1394]


Done substituting Assertion labels in preconditions
step:  112
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1395]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)) and 
DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << AXIOM_MO() >>
Reason:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1388]

has been transformed into:

[serial 1401]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)) and 
DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << true >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


by removing axioms from postconditions.

. . . done removing axioms from postconditions  [20.8 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1365]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1359]



[serial 1396]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)) and 
DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1390]



[serial 1397]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [103] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1391]



[serial 1398]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1392]



[serial 1399]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [103] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1393]



[serial 1400]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1394]



[serial 1401]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)) and 
DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << true >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 



Done removing axioms from postconditions
step:  113
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1401]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)) and 
DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [20.8 seconds ]
After "axioms" remaining 
Obligations:

[serial 1365]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
  What for:   normalization of [serial 1359]



[serial 1396]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)) and 
DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1390]



[serial 1397]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [103] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1391]



[serial 1398]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1392]



[serial 1399]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [103] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1393]



[serial 1400]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1394]


Done trying to apply axioms
step:  114
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  ACTUAL_POSITION' = EstimatedActualPosition'
equality selected for substitution:  (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION'

This Proof Obligation:

[serial 1397]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [103] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Guided Substitution of Equals
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1391]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + MinusOne))"
 to get:

[serial 1402]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [103] << -1 = (((ACTUAL_POSITION + MinusOne)) - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + MinusOne))" in its postcondition [serial 1397]

equality selected for substitution:  (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION'

This Proof Obligation:

[serial 1398]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1392]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + MinusOne))"
 to get:

[serial 1403]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + MinusOne)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + MinusOne))" in its postcondition [serial 1398]

equality selected for substitution:  (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION'

This Proof Obligation:

[serial 1399]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [103] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Guided Substitution of Equals
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1393]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + MinusOne))"
 to get:

[serial 1404]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [103] << -1 = (((ACTUAL_POSITION + MinusOne)) - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + MinusOne))" in its postcondition [serial 1399]

equality selected for substitution:  (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION'

This Proof Obligation:

[serial 1400]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1394]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + MinusOne))"
 to get:

[serial 1405]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + MinusOne)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + MinusOne))" in its postcondition [serial 1400]

. . . done guided substitution of equals  [20.9 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1365]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 1359]



[serial 1396]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)) and 
DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1390]



[serial 1402]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [103] << -1 = (((ACTUAL_POSITION + MinusOne)) - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + MinusOne))" in its postcondition [serial 1397]



[serial 1403]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + MinusOne)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + MinusOne))" in its postcondition [serial 1398]



[serial 1404]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [103] << -1 = (((ACTUAL_POSITION + MinusOne)) - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + MinusOne))" in its postcondition [serial 1399]



[serial 1405]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + MinusOne)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + MinusOne))" in its postcondition [serial 1400]


Done guided substituting an equals
step:  115
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1396]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)) and 
DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << DESIRED_POSITION < ACTUAL_POSITION >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1390]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1408]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for:   normalization of [serial 1396]


This Proof Obligation:

[serial 1402]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [103] << -1 = (((ACTUAL_POSITION + MinusOne)) - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + MinusOne))" in its postcondition [serial 1397]

  Normalization Axioms:

    Subtaction of Added Value:  (a+b)-a is b

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1410]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' >>
S [101]->
Q [103] << -1 = MinusOne >>
  What for:   normalization of [serial 1402]


This Proof Obligation:

[serial 1403]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + MinusOne)) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + MinusOne))" in its postcondition [serial 1398]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1412]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (ACTUAL_POSITION + MinusOne) >>
  What for:   normalization of [serial 1403]


This Proof Obligation:

[serial 1404]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [103] << -1 = (((ACTUAL_POSITION + MinusOne)) - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + MinusOne))" in its postcondition [serial 1399]

  Normalization Axioms:

    Subtaction of Added Value:  (a+b)-a is b

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1414]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' >>
S [101]->
Q [103] << -1 = MinusOne >>
  What for:   normalization of [serial 1404]


This Proof Obligation:

[serial 1405]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + MinusOne)) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + MinusOne))" in its postcondition [serial 1400]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1416]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (ACTUAL_POSITION + MinusOne) >>
  What for:   normalization of [serial 1405]

. . . done Normalizing Unsolved Proof Obligations [20.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1365]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 1359]



[serial 1408]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for:   normalization of [serial 1396]



[serial 1410]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' >>
S [101]->
Q [103] << -1 = MinusOne >>
  What for:   normalization of [serial 1402]



[serial 1412]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (ACTUAL_POSITION + MinusOne) >>
  What for:   normalization of [serial 1403]



[serial 1414]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' >>
S [101]->
Q [103] << -1 = MinusOne >>
  What for:   normalization of [serial 1404]



[serial 1416]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (ACTUAL_POSITION + MinusOne) >>
  What for:   normalization of [serial 1405]


Done Normalizing
step:  116
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1410]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' >>
S [101]->
Q [103] << -1 = MinusOne >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1402]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1414]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' >>
S [101]->
Q [103] << -1 = MinusOne >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1404]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [20.9 seconds ]
After "axioms" remaining 
Obligations:

[serial 1365]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 1359]



[serial 1408]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for:   normalization of [serial 1396]



[serial 1412]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (ACTUAL_POSITION + MinusOne) >>
  What for:   normalization of [serial 1403]



[serial 1416]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (ACTUAL_POSITION + MinusOne) >>
  What for:   normalization of [serial 1405]


Done trying to apply axioms
step:  117
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1365]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53]->
Q [15] << (D_SS() and E_SS())^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1359]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1422]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) = (Delta)^1 and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [53]->
Q [15] << ((D_SS())^1 and (E_SS())^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1365]


This Proof Obligation:

[serial 1408]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55]->
Q [96] << DESIRED_POSITION < ACTUAL_POSITION >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1396]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1423]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
DESIRED_POSITION < EstimatedActualPosition >>
S [55]->
Q [96] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1408]


This Proof Obligation:

[serial 1412]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (ACTUAL_POSITION + MinusOne) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1403]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1424]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (ACTUAL_POSITION + MinusOne) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1412]


This Proof Obligation:

[serial 1416]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (ACTUAL_POSITION + MinusOne) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1405]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1425]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (ACTUAL_POSITION + MinusOne) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1416]

. . . done spltting timed atoms  [20.9 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [20.9 seconds ]
After "dist^" remaining 
Obligations:

[serial 1422]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) = (Delta)^1 and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [53]->
Q [15] << ((D_SS())^1 and (E_SS())^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1365]



[serial 1423]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
DESIRED_POSITION < EstimatedActualPosition >>
S [55]->
Q [96] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1408]



[serial 1424]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (ACTUAL_POSITION + MinusOne) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1412]



[serial 1425]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (ACTUAL_POSITION + MinusOne) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1416]


Done distributing ^ and @.
step:  118
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION" . . .
equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 1423]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
DESIRED_POSITION < EstimatedActualPosition >>
S [55]->
Q [96] << DESIRED_POSITION < ACTUAL_POSITION >>
Reason:  Guided Substitution of Equals
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1408]

Has substituted 
"ACTUAL_POSITION" with its = "EstimatedActualPosition"
 to get:

[serial 1426]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
DESIRED_POSITION < EstimatedActualPosition >>
S [55]->
Q [96] << DESIRED_POSITION < EstimatedActualPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1423]

equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 1424]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (ACTUAL_POSITION + MinusOne) >>
Reason:  Guided Substitution of Equals
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1412]

Has substituted 
"ACTUAL_POSITION" with its = "EstimatedActualPosition"
 to get:

[serial 1427]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (EstimatedActualPosition + MinusOne) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1424]

equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 1425]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (ACTUAL_POSITION + MinusOne) >>
Reason:  Guided Substitution of Equals
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1416]

Has substituted 
"ACTUAL_POSITION" with its = "EstimatedActualPosition"
 to get:

[serial 1428]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (EstimatedActualPosition + MinusOne) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1425]

. . . done guided substitution of equals  [20.9 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1422]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) = (Delta)^1 and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [53]->
Q [15] << ((D_SS())^1 and (E_SS())^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1365]



[serial 1426]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
DESIRED_POSITION < EstimatedActualPosition >>
S [55]->
Q [96] << DESIRED_POSITION < EstimatedActualPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1423]



[serial 1427]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (EstimatedActualPosition + MinusOne) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1424]



[serial 1428]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (EstimatedActualPosition + MinusOne) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1425]


Done guided substituting an equals
step:  119
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1426]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
DESIRED_POSITION < EstimatedActualPosition >>
S [55]->
Q [96] << DESIRED_POSITION < EstimatedActualPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1423]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [21.0 seconds ]
After "axioms" remaining 
Obligations:

[serial 1422]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) = (Delta)^1 and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [53]->
Q [15] << ((D_SS())^1 and (E_SS())^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1365]



[serial 1427]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (EstimatedActualPosition + MinusOne) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1424]



[serial 1428]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (EstimatedActualPosition + MinusOne) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1425]


Done trying to apply axioms
step:  120
****guided-sub-equals****
guided substitution of equals "MinusOne" . . .
equality selected for substitution:  -1 = MinusOne

This Proof Obligation:

[serial 1427]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (EstimatedActualPosition + MinusOne) >>
Reason:  Guided Substitution of Equals
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1424]

Has substituted 
"MinusOne" with its = "-1"
 to get:

[serial 1429]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (EstimatedActualPosition + -1) >>
  What for: Guided Substitution of Equals
 replacing "MinusOne" with its = "-1" in its postcondition [serial 1427]

equality selected for substitution:  -1 = MinusOne

This Proof Obligation:

[serial 1428]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (EstimatedActualPosition + MinusOne) >>
Reason:  Guided Substitution of Equals
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1425]

Has substituted 
"MinusOne" with its = "-1"
 to get:

[serial 1430]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (EstimatedActualPosition + -1) >>
  What for: Guided Substitution of Equals
 replacing "MinusOne" with its = "-1" in its postcondition [serial 1428]

. . . done guided substitution of equals  [21.0 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1422]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) = (Delta)^1 and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [53]->
Q [15] << ((D_SS())^1 and (E_SS())^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1365]



[serial 1429]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (EstimatedActualPosition + -1) >>
  What for: Guided Substitution of Equals
 replacing "MinusOne" with its = "-1" in its postcondition [serial 1427]



[serial 1430]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (EstimatedActualPosition + -1) >>
  What for: Guided Substitution of Equals
 replacing "MinusOne" with its = "-1" in its postcondition [serial 1428]


Done guided substituting an equals
step:  121
****change subtraction to adding unary minus****
changing subtraction to adding negation . . .

This Proof Obligation:

[serial 1422]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) = (Delta)^1 and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [53]->
Q [15] << ((D_SS())^1 and (E_SS())^1) >>
Reason:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1365]

Has changed subtraction to adding negation to get:

[serial 1431]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) = (Delta)^1 and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [53]->
Q [15] << ((D_SS())^1 and (E_SS())^1) >>
  What for:  changing adding negation to subtraction  [serial 1422]


This Proof Obligation:

[serial 1429]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (EstimatedActualPosition + -1) >>
Reason:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
  What for: Guided Substitution of Equals
 replacing "MinusOne" with its = "-1" in its postcondition [serial 1427]

Has changed subtraction to adding negation to get:

[serial 1432]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] <<  -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition +  -1) = (EstimatedActualPosition +  -1) >>
  What for:  changing adding negation to subtraction  [serial 1429]


This Proof Obligation:

[serial 1430]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition - 1) = (EstimatedActualPosition + -1) >>
Reason:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
  What for: Guided Substitution of Equals
 replacing "MinusOne" with its = "-1" in its postcondition [serial 1428]

Has changed subtraction to adding negation to get:

[serial 1433]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] <<  -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition +  -1) = (EstimatedActualPosition +  -1) >>
  What for:  changing adding negation to subtraction  [serial 1430]

. . . done substituting all equals  [21.0 seconds ]
After changing subtraction to adding unary minus remaining 
Obligations:

[serial 1431]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) = (Delta)^1 and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [53]->
Q [15] << ((D_SS())^1 and (E_SS())^1) >>
  What for:  changing adding negation to subtraction  [serial 1422]



[serial 1432]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] <<  -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition +  -1) = (EstimatedActualPosition +  -1) >>
  What for:  changing adding negation to subtraction  [serial 1429]



[serial 1433]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] <<  -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition +  -1) = (EstimatedActualPosition +  -1) >>
  What for:  changing adding negation to subtraction  [serial 1430]


Done changing subtraction to adding unary minus
step:  122
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1431]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) = (Delta)^1 and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [53]->
Q [15] << ((D_SS())^1 and (E_SS())^1) >>
Reason:  Normalization
  What for:  changing adding negation to subtraction  [serial 1422]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1435]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << (D_SS())^1 and (E_SS())^1 >>
  What for:   normalization of [serial 1431]


This Proof Obligation:

[serial 1432]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] <<  -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition +  -1) = (EstimatedActualPosition +  -1) >>
Reason:  Normalization
  What for:  changing adding negation to subtraction  [serial 1429]

  Normalization Axioms:

    Literal Arithmetic

    Reflexivity of Equality: (a=b) = (b=a)

    Unary Minus:  -(x-y) is (y-x)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1437]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [101]->
Q [102] << (-1 + EstimatedActualPosition) = (-1 + EstimatedActualPosition) >>
  What for:   normalization of [serial 1432]


This Proof Obligation:

[serial 1433]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] <<  -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101]->
Q [102] << (EstimatedActualPosition +  -1) = (EstimatedActualPosition +  -1) >>
Reason:  Normalization
  What for:  changing adding negation to subtraction  [serial 1430]

  Normalization Axioms:

    Literal Arithmetic

    Reflexivity of Equality: (a=b) = (b=a)

    Unary Minus:  -(x-y) is (y-x)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1439]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [101]->
Q [102] << (-1 + EstimatedActualPosition) = (-1 + EstimatedActualPosition) >>
  What for:   normalization of [serial 1433]

. . . done Normalizing Unsolved Proof Obligations [21.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1435]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << (D_SS())^1 and (E_SS())^1 >>
  What for:   normalization of [serial 1431]



[serial 1437]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [101]->
Q [102] << (-1 + EstimatedActualPosition) = (-1 + EstimatedActualPosition) >>
  What for:   normalization of [serial 1432]



[serial 1439]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [101]->
Q [102] << (-1 + EstimatedActualPosition) = (-1 + EstimatedActualPosition) >>
  What for:   normalization of [serial 1433]


Done Normalizing
step:  123
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1437]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [101]->
Q [102] << (-1 + EstimatedActualPosition) = (-1 + EstimatedActualPosition) >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 1432]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 1443]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [101]->
Q [102] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1437]


This Proof Obligation:

[serial 1439]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [101]->
Q [102] << (-1 + EstimatedActualPosition) = (-1 + EstimatedActualPosition) >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 1433]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 1444]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [101]->
Q [102] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1439]

. . . done Applying Laws [21.0 seconds ]
After "laws" remaining 
Obligations:

[serial 1435]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << (D_SS())^1 and (E_SS())^1 >>
  What for:   normalization of [serial 1431]



[serial 1443]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [101]->
Q [102] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1437]



[serial 1444]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [101]->
Q [102] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1439]


Done applying laws
step:  124
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1443]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [101]->
Q [102] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 1437]

Has been solved by True Conclusion Schema (tc): P->true

This Proof Obligation:

[serial 1444]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [101]->
Q [102] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 1439]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [21.0 seconds ]
After "axioms" remaining 
Obligations:

[serial 1435]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << (D_SS())^1 and (E_SS())^1 >>
  What for:   normalization of [serial 1431]


Done trying to apply axioms
step:  125
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1435]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << (D_SS())^1 and (E_SS())^1 >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 1431]

Has substituted Assertions' predicates for labels to get:

[serial 1445]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << (((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))))^1 and (((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels in postconditions [serial 1435]

. . . done Substituting Assertions for Labels [21.0 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1445]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << (((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))))^1 and (((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels in postconditions [serial 1435]


Done substituting Assertion labels in postconditions.
step:  126
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1445]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << (((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))))^1 and (((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in postconditions [serial 1435]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1447]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 >>
  What for:   normalization of [serial 1445]

. . . done Normalizing Unsolved Proof Obligations [21.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1447]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 >>
  What for:   normalization of [serial 1445]


Done Normalizing
step:  127
****completely distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1447]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1445]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1449]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((Delta)^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1447]

. . . done spltting timed atoms  [21.0 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [21.0 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1449]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((Delta)^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1447]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1451]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 >>
  What for:   normalization of [serial 1449]

. . . done Normalizing Unsolved Proof Obligations [21.0 seconds ]
After "completely distribute ^ and @" round 0 remaining 
Obligations:

[serial 1451]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 >>
  What for:   normalization of [serial 1449]


Done completely distributing ^ and @, round 0.
Distributing carets . .

This Proof Obligation:

[serial 1451]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1449]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1453]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1451]

. . . done spltting timed atoms  [21.1 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [21.1 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1453]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1451]

  Normalization Axioms:

    Literal Arithmetic

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1455]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
  What for:   normalization of [serial 1453]

. . . done Normalizing Unsolved Proof Obligations [21.1 seconds ]
After "completely distribute ^ and @" round 1 remaining 
Obligations:

[serial 1455]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
  What for:   normalization of [serial 1453]


Done completely distributing ^ and @, round 1.
Distributing carets . .

This Proof Obligation:

[serial 1455]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1453]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1457]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1455]

. . . done spltting timed atoms  [21.1 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [21.1 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [21.1 seconds ]
After "completely distribute ^ and @" round 2 remaining 
Obligations:

[serial 1457]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1455]


Done completely distributing ^ and @, round 2.
Distributing carets . .
. . . done spltting timed atoms  [21.1 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [21.1 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [21.1 seconds ]
step:  128
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1457]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  Identity (id):  P->P is tautology
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1455]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [21.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1054]: ControlSoftware::RobustPositionControlThread.SingleStep
P [106] << ((E_SS() and D_SS()) and stop@now and not (exists u~time
  in tops,,now 
  that true ) and not (exists u~time
  in tops,,now 
  that stop@u )) >>
S [106]->
Q [57] << E_SS() >>
  What for:  <<M(Run) and x>> -> <<M(ShutDown)>> for one5stop:Run-[x]->ShutDown{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  129
#[serial 1054]  <<M(Run) and x>> -> <<M(ShutDown)>> for one5stop:Run-[x]->ShutDown{};
step:  130
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1054]: ControlSoftware::RobustPositionControlThread.SingleStep
P [106] << ((E_SS() and D_SS()) and stop@now and not (exists u~time
  in tops,,now 
  that true ) and not (exists u~time
  in tops,,now 
  that stop@u )) >>
S [106]->
Q [57] << E_SS() >>
Reason:  Normalization
  What for:  <<M(Run) and x>> -> <<M(ShutDown)>> for one5stop:Run-[x]->ShutDown{};

  Normalization Axioms:

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1461]: ControlSoftware::RobustPositionControlThread.SingleStep
P [106] << stop@now and not (exists u~time
  in tops,,now 
  that stop@u ) and not (exists u~time
  in tops,,now 
  that true ) and (D_SS() and E_SS()) >>
S [106]->
Q [57] << E_SS() >>
  What for:   normalization of [serial 1054]

. . . done Normalizing Unsolved Proof Obligations [21.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1461]: ControlSoftware::RobustPositionControlThread.SingleStep
P [106] << stop@now and not (exists u~time
  in tops,,now 
  that stop@u ) and not (exists u~time
  in tops,,now 
  that true ) and (D_SS() and E_SS()) >>
S [106]->
Q [57] << E_SS() >>
  What for:   normalization of [serial 1054]


Done Normalizing
step:  131
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1461]: ControlSoftware::RobustPositionControlThread.SingleStep
P [106] << stop@now and not (exists u~time
  in tops,,now 
  that stop@u ) and not (exists u~time
  in tops,,now 
  that true ) and (D_SS() and E_SS()) >>
S [106]->
Q [57] << E_SS() >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1054]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1463]: ControlSoftware::RobustPositionControlThread.SingleStep
P [106] << D_SS() and E_SS() and stop@now and not (exists u~time
  in tops,,now 
  that stop@u ) and not (exists u~time
  in tops,,now 
  that true ) >>
S [106]->
Q [57] << E_SS() >>
  What for: Associativity: (b.c).a = a.b.c [serial 1461]


This Proof Obligation:

[serial 1463]: ControlSoftware::RobustPositionControlThread.SingleStep
P [106] << D_SS() and E_SS() and stop@now and not (exists u~time
  in tops,,now 
  that stop@u ) and not (exists u~time
  in tops,,now 
  that true ) >>
S [106]->
Q [57] << E_SS() >>
Reason:  Existential Quantification Introduction
  What for: Associativity: (b.c).a = a.b.c [serial 1461]

Has applied law "Existential Quantification Introduction" to get:

[serial 1464]: ControlSoftware::RobustPositionControlThread.SingleStep
P [106] << D_SS() and E_SS() and stop@now and not (exists u~time
  in tops,,now 
  that stop@u ) and not (true) >>
S [106]->
Q [57] << E_SS() >>
  What for: Existential Quantification Introduction [serial 1463]

. . . done Applying Laws [21.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1464]: ControlSoftware::RobustPositionControlThread.SingleStep
P [106] << D_SS() and E_SS() and stop@now and not (exists u~time
  in tops,,now 
  that stop@u ) and not (true) >>
S [106]->
Q [57] << E_SS() >>
  What for: Existential Quantification Introduction [serial 1463]


Done applying laws
step:  132
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1464]: ControlSoftware::RobustPositionControlThread.SingleStep
P [106] << D_SS() and E_SS() and stop@now and not (exists u~time
  in tops,,now 
  that stop@u ) and not (true) >>
S [106]->
Q [57] << E_SS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Existential Quantification Introduction [serial 1463]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [21.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1055]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << ((E_SS()) and ((EstimatedActualPosition = 0))) >>
S [108]->
Q [61] << (ACTUAL_POSITION = 0) >>
  What for:  <<M(ShutDown) and x>> -> <<M(Done)>> for one6done:ShutDown-[x]->Done{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  133
#[serial 1055]  <<M(ShutDown) and x>> -> <<M(Done)>> for one6done:ShutDown-[x]->Done{};
step:  134
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1055]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << ((E_SS()) and ((EstimatedActualPosition = 0))) >>
S [108]->
Q [61] << (ACTUAL_POSITION = 0) >>
Reason:  Substitution of Assertion Labels
  What for:  <<M(ShutDown) and x>> -> <<M(Done)>> for one6done:ShutDown-[x]->Done{};

Has substituted Assertions' predicates for labels to get:

[serial 1465]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << ((((EstimatedActualPosition = ACTUAL_POSITION))) and ((EstimatedActualPosition = 0))) >>
S [108]->
Q [61] << (ACTUAL_POSITION = 0) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1055]

. . . done Substituting Assertions for Labels [21.1 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1465]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << ((((EstimatedActualPosition = ACTUAL_POSITION))) and ((EstimatedActualPosition = 0))) >>
S [108]->
Q [61] << (ACTUAL_POSITION = 0) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1055]


Done substituting Assertion labels in preconditions
step:  135
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1465]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << ((((EstimatedActualPosition = ACTUAL_POSITION))) and ((EstimatedActualPosition = 0))) >>
S [108]->
Q [61] << (ACTUAL_POSITION = 0) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 1055]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1467]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << 0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [108]->
Q [61] << 0 = ACTUAL_POSITION >>
  What for:   normalization of [serial 1465]

. . . done Normalizing Unsolved Proof Obligations [21.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1467]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << 0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [108]->
Q [61] << 0 = ACTUAL_POSITION >>
  What for:   normalization of [serial 1465]


Done Normalizing
step:  136
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION" . . .
equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 1467]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << 0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [108]->
Q [61] << 0 = ACTUAL_POSITION >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 1465]

Has substituted 
"ACTUAL_POSITION" with its = "EstimatedActualPosition"
 to get:

[serial 1469]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << 0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [108]->
Q [61] << 0 = EstimatedActualPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1467]

. . . done guided substitution of equals  [21.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1469]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << 0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [108]->
Q [61] << 0 = EstimatedActualPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1467]


Done guided substituting an equals
step:  137
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1469]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << 0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [108]->
Q [61] << 0 = EstimatedActualPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1467]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [21.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1056]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << ((E_SS()) and ((EstimatedActualPosition > 0))) >>
S [111]<< (E_SS() and (ACTUAL_POSITION > 0)) >>
ActuatorCommand(pc:MinusOne)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + MinusOne)) and (ACTUAL_POSITION > 0) and E_SS() and AXIOM_MO()) >>
;
EstimatedActualPosition' := (EstimatedActualPosition - 1)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION > 0)) >>
Q [59] << (E_SS() and ((ACTUAL_POSITION^(-1) > 0)))^1 >>
  What for:  <<M(ShutDown) and x>> A <<M(StillClosing)>> for one7sc:ShutDown-[x]->StillClosing{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  138
#[serial 1056]  <<M(ShutDown) and x>> A <<M(StillClosing)>> for one7sc:ShutDown-[x]->StillClosing{A};
step:  139
****reduce****
This proof obligation:

[serial 1056]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << ((E_SS()) and ((EstimatedActualPosition > 0))) >>
S [111]<< (E_SS() and (ACTUAL_POSITION > 0)) >>
ActuatorCommand(pc:MinusOne)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + MinusOne)) and (ACTUAL_POSITION > 0) and E_SS() and AXIOM_MO()) >>
;
EstimatedActualPosition' := (EstimatedActualPosition - 1)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION > 0)) >>
Q [59] << (E_SS() and ((ACTUAL_POSITION^(-1) > 0)))^1 >>
  What for:  <<M(ShutDown) and x>> A <<M(StillClosing)>> for one7sc:ShutDown-[x]->StillClosing{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1470]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((E_SS()) and ((EstimatedActualPosition > 0))) >>
S [57]->
Q [15] << (E_SS() and (ACTUAL_POSITION > 0)) >>
  What for: P -> P1 in sequential composition for [serial 1056]


[serial 1471]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION > 0)) >>
S [59]->
Q [15] << (E_SS() and ((ACTUAL_POSITION^(-1) > 0)))^1 >>
  What for: Q1 -> Q in sequential composition for [serial 1056]


[serial 1472]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and (ACTUAL_POSITION > 0)) >>
S [112]ActuatorCommand(pc:MinusOne)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + MinusOne)) and (ACTUAL_POSITION > 0) and 
E_SS() and AXIOM_MO()) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1056]


[serial 1473]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + MinusOne)) and (ACTUAL_POSITION > 0) and 
E_SS() and AXIOM_MO()) >>
S [116]EstimatedActualPosition' := (EstimatedActualPosition - 1)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION > 0)) >>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1056]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1470]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((E_SS()) and ((EstimatedActualPosition > 0))) >>
S [57]->
Q [15] << (E_SS() and (ACTUAL_POSITION > 0)) >>
  What for: P -> P1 in sequential composition for [serial 1056]



[serial 1471]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION > 0)) >>
S [59]->
Q [15] << (E_SS() and ((ACTUAL_POSITION^(-1) > 0)))^1 >>
  What for: Q1 -> Q in sequential composition for [serial 1056]



[serial 1472]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and (ACTUAL_POSITION > 0)) >>
S [112]ActuatorCommand(pc:MinusOne)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + MinusOne)) and (ACTUAL_POSITION > 0) and 
E_SS() and AXIOM_MO()) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1056]



[serial 1473]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + MinusOne)) and (ACTUAL_POSITION > 0) and 
E_SS() and AXIOM_MO()) >>
S [116]EstimatedActualPosition' := (EstimatedActualPosition - 1)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION > 0)) >>
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1056]


done reducing composite actions
step:  140
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1470]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((E_SS()) and ((EstimatedActualPosition > 0))) >>
S [57]->
Q [15] << (E_SS() and (ACTUAL_POSITION > 0)) >>
Reason:  Normalization
  What for: P -> P1 in sequential composition for [serial 1056]

  Normalization Axioms:

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1475]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << E_SS() and 0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 1470]


This Proof Obligation:

[serial 1471]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION > 0)) >>
S [59]->
Q [15] << (E_SS() and ((ACTUAL_POSITION^(-1) > 0)))^1 >>
Reason:  Normalization
  What for: Q1 -> Q in sequential composition for [serial 1056]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1477]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (E_SS() and 0 < ACTUAL_POSITION^-1)^1 >>
  What for:   normalization of [serial 1471]


This Proof Obligation:

[serial 1472]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (E_SS() and (ACTUAL_POSITION > 0)) >>
S [112]ActuatorCommand(pc:MinusOne)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + MinusOne)) and (ACTUAL_POSITION > 0) and 
E_SS() and AXIOM_MO()) >>
Reason:  Normalization
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1056]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1479]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and 0 < ACTUAL_POSITION >>
S [112]ActuatorCommand(pc:MinusOne)
Q [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() and 
0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 1472]


This Proof Obligation:

[serial 1473]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + MinusOne)) and (ACTUAL_POSITION > 0) and 
E_SS() and AXIOM_MO()) >>
S [116]EstimatedActualPosition' := (EstimatedActualPosition - 1)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION > 0)) >>
Reason:  Normalization
  What for: <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1056]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1481]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() and 
0 < ACTUAL_POSITION >>
S [116]EstimatedActualPosition' := (EstimatedActualPosition - 1)
Q [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 1473]

. . . done Normalizing Unsolved Proof Obligations [21.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1475]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << E_SS() and 0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 1470]



[serial 1477]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (E_SS() and 0 < ACTUAL_POSITION^-1)^1 >>
  What for:   normalization of [serial 1471]



[serial 1479]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and 0 < ACTUAL_POSITION >>
S [112]ActuatorCommand(pc:MinusOne)
Q [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() and 
0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 1472]



[serial 1481]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() and 
0 < ACTUAL_POSITION >>
S [116]EstimatedActualPosition' := (EstimatedActualPosition - 1)
Q [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 1473]


Done Normalizing
step:  141
****atomic****
applying atomic actions . . .
Creating weakest-precondition predicate transfer for subprogram invocation of "ActuatorCommand".

This Proof Obligation:

[serial 1479]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and 0 < ACTUAL_POSITION >>
S [112]ActuatorCommand(pc:MinusOne)
Q [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() and 
0 < ACTUAL_POSITION >>
Reason:  Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
  What for:   normalization of [serial 1472]

Used weakest precondition predicate transformation on
+ <<P>> ActuatorCommand(X) <<Q>> to get:

[serial 1486]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and 0 < ACTUAL_POSITION >>
S [112]->
Q [15] << true and AXIOM_MO() and E_SS() and 0 < ACTUAL_POSITION >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1479]

solving assignment on line 116
replacing "EstimatedActualPosition'" with "(EstimatedActualPosition - 1)"
makes:  << ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) and 0 < ACTUAL_POSITION >>

This Proof Obligation:

[serial 1481]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() and 
0 < ACTUAL_POSITION >>
S [116]EstimatedActualPosition' := (EstimatedActualPosition - 1)
Q [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for:   normalization of [serial 1473]

Has applied := to get:

[serial 1487]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() and 
0 < ACTUAL_POSITION >>
S [116]->
Q [15] << ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) and 0 < ACTUAL_POSITION >>
  What for: applied wp for assignment [serial 1481]

. . . done applying atomic actions [21.1 seconds ]
After "atomic" remaining 
Obligations:

[serial 1475]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << E_SS() and 0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 1470]



[serial 1477]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (E_SS() and 0 < ACTUAL_POSITION^-1)^1 >>
  What for:   normalization of [serial 1471]



[serial 1486]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and 0 < ACTUAL_POSITION >>
S [112]->
Q [15] << true and AXIOM_MO() and E_SS() and 0 < ACTUAL_POSITION >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1479]



[serial 1487]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() and 
0 < ACTUAL_POSITION >>
S [116]->
Q [15] << ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) and 0 < ACTUAL_POSITION >>
  What for: applied wp for assignment [serial 1481]


Done reducing atomic actions
step:  142
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1486]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and 0 < ACTUAL_POSITION >>
S [112]->
Q [15] << true and AXIOM_MO() and E_SS() and 0 < ACTUAL_POSITION >>
Reason:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1479]

has been transformed into:

[serial 1488]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and 0 < ACTUAL_POSITION >>
S [112]->
Q [15] << true and true and E_SS() and 0 < ACTUAL_POSITION >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


by removing axioms from postconditions.

. . . done removing axioms from postconditions  [21.1 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1475]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << E_SS() and 0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 1470]



[serial 1477]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (E_SS() and 0 < ACTUAL_POSITION^-1)^1 >>
  What for:   normalization of [serial 1471]



[serial 1487]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() and 
0 < ACTUAL_POSITION >>
S [116]->
Q [15] << ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) and 0 < ACTUAL_POSITION >>
  What for: applied wp for assignment [serial 1481]



[serial 1488]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and 0 < ACTUAL_POSITION >>
S [112]->
Q [15] << true and true and E_SS() and 0 < ACTUAL_POSITION >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 



Done removing axioms from postconditions
step:  143
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1488]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and 0 < ACTUAL_POSITION >>
S [112]->
Q [15] << true and true and E_SS() and 0 < ACTUAL_POSITION >>
Reason:  Law of And-Simplification:  P and true is P
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 1489]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and 0 < ACTUAL_POSITION >>
S [112]->
Q [15] << E_SS() and 0 < ACTUAL_POSITION >>
  What for: Law of And-Simplification:  P and true is P [serial 1488]

. . . done Applying Laws [21.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1475]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << E_SS() and 0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 1470]



[serial 1477]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (E_SS() and 0 < ACTUAL_POSITION^-1)^1 >>
  What for:   normalization of [serial 1471]



[serial 1487]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() and 
0 < ACTUAL_POSITION >>
S [116]->
Q [15] << ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) and 0 < ACTUAL_POSITION >>
  What for: applied wp for assignment [serial 1481]



[serial 1489]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and 0 < ACTUAL_POSITION >>
S [112]->
Q [15] << E_SS() and 0 < ACTUAL_POSITION >>
  What for: Law of And-Simplification:  P and true is P [serial 1488]


Done applying laws
step:  144
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1489]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and 0 < ACTUAL_POSITION >>
S [112]->
Q [15] << E_SS() and 0 < ACTUAL_POSITION >>
Reason:  Identity (id):  P->P is tautology
  What for: Law of And-Simplification:  P and true is P [serial 1488]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [21.1 seconds ]
After "axioms" remaining 
Obligations:

[serial 1475]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << E_SS() and 0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 1470]



[serial 1477]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (E_SS() and 0 < ACTUAL_POSITION^-1)^1 >>
  What for:   normalization of [serial 1471]



[serial 1487]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() and 
0 < ACTUAL_POSITION >>
S [116]->
Q [15] << ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) and 0 < ACTUAL_POSITION >>
  What for: applied wp for assignment [serial 1481]


Done trying to apply axioms
step:  145
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1475]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << E_SS() and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << E_SS() and 0 < ACTUAL_POSITION >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 1470]

Has substituted Assertions' predicates for labels to get:

[serial 1490]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << ((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels  [serial 1475]


This Proof Obligation:

[serial 1477]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (E_SS() and 0 < ACTUAL_POSITION^-1)^1 >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 1471]

Has substituted Assertions' predicates for labels to get:

[serial 1491]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION^-1)^1 >>
  What for: substituted Assertions' predicates for  labels  [serial 1477]


This Proof Obligation:

[serial 1487]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() and 
0 < ACTUAL_POSITION >>
S [116]->
Q [15] << ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) and 0 < ACTUAL_POSITION >>
Reason:  Substitution of Assertion Labels
  What for: applied wp for assignment [serial 1481]

Has substituted Assertions' predicates for labels to get:

[serial 1492]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) and 0 < ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels  [serial 1487]

. . . done Substituting Assertions for Labels [21.2 seconds ]
After "substitute" remaining 
Obligations:

[serial 1490]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << ((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels  [serial 1475]



[serial 1491]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION^-1)^1 >>
  What for: substituted Assertions' predicates for  labels  [serial 1477]



[serial 1492]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) and 0 < ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels  [serial 1487]


Done substituting Assertion labels.
step:  146
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1490]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << ((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1475]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1494]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 1490]


This Proof Obligation:

[serial 1491]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION^-1)^1 >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1477]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1496]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION^-1)^1 >>
  What for:   normalization of [serial 1491]


This Proof Obligation:

[serial 1492]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) and 0 < ACTUAL_POSITION >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1487]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1498]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 1492]

. . . done Normalizing Unsolved Proof Obligations [21.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1494]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 1490]



[serial 1496]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION^-1)^1 >>
  What for:   normalization of [serial 1491]



[serial 1498]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 1492]


Done Normalizing
step:  147
****substitute all equivalents****
substituting all equals . . .
Replacing all "EstimatedActualPosition" with  "ACTUAL_POSITION" in  "ASSERTION[15]" makes:
<< ACTUAL_POSITION = ACTUAL_POSITION and 0 < ACTUAL_POSITION >>

This Proof Obligation:

[serial 1494]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
Reason:  Substitution in Postcondition of All Equivalents in Precondition
  What for:   normalization of [serial 1490]

Has substituted in postcondition all equivalents in precondition to get:

[serial 1502]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << ACTUAL_POSITION = ACTUAL_POSITION and 0 < ACTUAL_POSITION >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1494]

Replacing all "EstimatedActualPosition" with  "ACTUAL_POSITION" in  "ASSERTION[15]" makes:
<< (ACTUAL_POSITION - 1) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
Replacing all "ACTUAL_POSITION'" with  "(ACTUAL_POSITION + MinusOne)" in  "ASSERTION[15]" makes:
<< (ACTUAL_POSITION - 1) = (ACTUAL_POSITION + MinusOne) and 0 < ACTUAL_POSITION >>

This Proof Obligation:

[serial 1498]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
Reason:  Substitution in Postcondition of All Equivalents in Precondition
  What for:   normalization of [serial 1492]

Has substituted in postcondition all equivalents in precondition to get:

[serial 1503]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (ACTUAL_POSITION - 1) = (ACTUAL_POSITION + MinusOne) and 0 < ACTUAL_POSITION >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1498]

. . . done substituting all equals  [21.2 seconds ]
After substituting all equivalents remaining 
Obligations:

[serial 1496]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION^-1)^1 >>
  What for:   normalization of [serial 1491]



[serial 1502]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << ACTUAL_POSITION = ACTUAL_POSITION and 0 < ACTUAL_POSITION >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1494]



[serial 1503]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (ACTUAL_POSITION - 1) = (ACTUAL_POSITION + MinusOne) and 0 < ACTUAL_POSITION >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1498]


Done substituting all equivalents
step:  148
****substitute all equivalents****
substituting all equals . . .
Replacing all "ACTUAL_POSITION" with  "EstimatedActualPosition" in  "ASSERTION[15]" makes:
<< EstimatedActualPosition = EstimatedActualPosition and 0 < EstimatedActualPosition >>

This Proof Obligation:

[serial 1502]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << ACTUAL_POSITION = ACTUAL_POSITION and 0 < ACTUAL_POSITION >>
Reason:  Substitution in Postcondition of All Equivalents in Precondition
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1494]

Has substituted in postcondition all equivalents in precondition to get:

[serial 1504]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << EstimatedActualPosition = EstimatedActualPosition and 0 < EstimatedActualPosition >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1502]

Replacing all "MinusOne" with  "-1" in  "ASSERTION[15]" makes:
<< (ACTUAL_POSITION - 1) = (ACTUAL_POSITION + -1) and 0 < ACTUAL_POSITION >>
Replacing all "ACTUAL_POSITION" with  "EstimatedActualPosition" in  "ASSERTION[15]" makes:
<< (EstimatedActualPosition - 1) = (EstimatedActualPosition + -1) and 0 < EstimatedActualPosition >>
Replacing all "(ACTUAL_POSITION + MinusOne)" with  "ACTUAL_POSITION'" in  "ASSERTION[15]" makes:
<< (EstimatedActualPosition - 1) = (EstimatedActualPosition + -1) and 0 < EstimatedActualPosition >>

This Proof Obligation:

[serial 1503]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (ACTUAL_POSITION - 1) = (ACTUAL_POSITION + MinusOne) and 0 < ACTUAL_POSITION >>
Reason:  Substitution in Postcondition of All Equivalents in Precondition
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1498]

Has substituted in postcondition all equivalents in precondition to get:

[serial 1505]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (EstimatedActualPosition - 1) = (EstimatedActualPosition + -1) and 0 < EstimatedActualPosition >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1503]

. . . done substituting all equals  [21.2 seconds ]
After substituting all equivalents remaining 
Obligations:

[serial 1496]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION^-1)^1 >>
  What for:   normalization of [serial 1491]



[serial 1504]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << EstimatedActualPosition = EstimatedActualPosition and 0 < EstimatedActualPosition >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1502]



[serial 1505]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (EstimatedActualPosition - 1) = (EstimatedActualPosition + -1) and 0 < EstimatedActualPosition >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1503]


Done substituting all equivalents
step:  149
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1504]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << EstimatedActualPosition = EstimatedActualPosition and 0 < EstimatedActualPosition >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1502]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 1506]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << true and 0 < EstimatedActualPosition >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1504]


This Proof Obligation:

[serial 1506]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << true and 0 < EstimatedActualPosition >>
Reason:  Law of And-Simplification:  P and true is P
  What for: Equality Law (idistr):  a=a <-> true [serial 1504]

Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 1507]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << (0 < EstimatedActualPosition) >>
  What for: Law of And-Simplification:  P and true is P [serial 1506]

. . . done Applying Laws [21.2 seconds ]
After "laws" remaining 
Obligations:

[serial 1496]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION^-1)^1 >>
  What for:   normalization of [serial 1491]



[serial 1505]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (EstimatedActualPosition - 1) = (EstimatedActualPosition + -1) and 0 < EstimatedActualPosition >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1503]



[serial 1507]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << (0 < EstimatedActualPosition) >>
  What for: Law of And-Simplification:  P and true is P [serial 1506]


Done applying laws
step:  150
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1505]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (EstimatedActualPosition - 1) = (EstimatedActualPosition + -1) and 0 < EstimatedActualPosition >>
Reason:  Normalization
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1503]

  Normalization Axiom:

    Reflexivity of Addition: a+b=b+a
Has been normalized to get:

[serial 1510]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (EstimatedActualPosition - 1) = (-1 + EstimatedActualPosition) and 0 < EstimatedActualPosition >>
  What for:   normalization of [serial 1505]


This Proof Obligation:

[serial 1507]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << (0 < EstimatedActualPosition) >>
Reason:  Normalization
  What for: Law of And-Simplification:  P and true is P [serial 1506]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1512]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << 0 < EstimatedActualPosition >>
  What for:   normalization of [serial 1507]

. . . done Normalizing Unsolved Proof Obligations [21.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1496]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION^-1)^1 >>
  What for:   normalization of [serial 1491]



[serial 1510]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (EstimatedActualPosition - 1) = (-1 + EstimatedActualPosition) and 0 < EstimatedActualPosition >>
  What for:   normalization of [serial 1505]



[serial 1512]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << 0 < EstimatedActualPosition >>
  What for:   normalization of [serial 1507]


Done Normalizing
step:  151
****change subtraction to adding unary minus****
changing subtraction to adding negation . . .

This Proof Obligation:

[serial 1496]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION^-1)^1 >>
Reason:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
  What for:   normalization of [serial 1491]

Has changed subtraction to adding negation to get:

[serial 1515]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION^- 1)^1 >>
  What for:  changing adding negation to subtraction  [serial 1496]


This Proof Obligation:

[serial 1510]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (EstimatedActualPosition - 1) = (-1 + EstimatedActualPosition) and 0 < EstimatedActualPosition >>
Reason:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
  What for:   normalization of [serial 1505]

Has changed subtraction to adding negation to get:

[serial 1516]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] <<  -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (EstimatedActualPosition +  -1) = ( -1 + EstimatedActualPosition) and 
0 < EstimatedActualPosition >>
  What for:  changing adding negation to subtraction  [serial 1510]


This Proof Obligation:

[serial 1512]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << 0 < EstimatedActualPosition >>
Reason:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
  What for:   normalization of [serial 1507]

Has changed subtraction to adding negation to get:

[serial 1517]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << 0 < EstimatedActualPosition >>
  What for:  changing adding negation to subtraction  [serial 1512]

. . . done substituting all equals  [21.2 seconds ]
After changing subtraction to adding unary minus remaining 
Obligations:

[serial 1515]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION^- 1)^1 >>
  What for:  changing adding negation to subtraction  [serial 1496]



[serial 1516]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] <<  -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (EstimatedActualPosition +  -1) = ( -1 + EstimatedActualPosition) and 
0 < EstimatedActualPosition >>
  What for:  changing adding negation to subtraction  [serial 1510]



[serial 1517]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << 0 < EstimatedActualPosition >>
  What for:  changing adding negation to subtraction  [serial 1512]


Done changing subtraction to adding unary minus
step:  152
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1515]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION^- 1)^1 >>
Reason:  Normalization
  What for:  changing adding negation to subtraction  [serial 1496]

  Normalization Axiom:

    Unary Minus:  -(x-y) is (y-x)
Has been normalized to get:

[serial 1519]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION^-1)^1 >>
  What for:   normalization of [serial 1515]


This Proof Obligation:

[serial 1516]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] <<  -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (EstimatedActualPosition +  -1) = ( -1 + EstimatedActualPosition) and 
0 < EstimatedActualPosition >>
Reason:  Normalization
  What for:  changing adding negation to subtraction  [serial 1510]

  Normalization Axioms:

    Literal Arithmetic

    Reflexivity of Addition: a+b=b+a

    Reflexivity of Equality: (a=b) = (b=a)

    Unary Minus:  -(x-y) is (y-x)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1521]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (-1 + EstimatedActualPosition) = (-1 + EstimatedActualPosition) and 0 < EstimatedActualPosition >>
  What for:   normalization of [serial 1516]

. . . done Normalizing Unsolved Proof Obligations [21.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1517]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << 0 < EstimatedActualPosition >>
  What for:  changing adding negation to subtraction  [serial 1512]



[serial 1519]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION^-1)^1 >>
  What for:   normalization of [serial 1515]



[serial 1521]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (-1 + EstimatedActualPosition) = (-1 + EstimatedActualPosition) and 0 < EstimatedActualPosition >>
  What for:   normalization of [serial 1516]


Done Normalizing
step:  153
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1517]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57]->
Q [15] << 0 < EstimatedActualPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:  changing adding negation to subtraction  [serial 1512]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [21.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1519]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION^-1)^1 >>
  What for:   normalization of [serial 1515]



[serial 1521]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (-1 + EstimatedActualPosition) = (-1 + EstimatedActualPosition) and 0 < EstimatedActualPosition >>
  What for:   normalization of [serial 1516]


Done trying to apply axioms
step:  154
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1519]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION^-1)^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1515]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1525]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << ((ACTUAL_POSITION = EstimatedActualPosition)^1 and (0 < ACTUAL_POSITION^-1)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1519]


This Proof Obligation:

[serial 1521]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (-1 + EstimatedActualPosition) = (-1 + EstimatedActualPosition) and 0 < EstimatedActualPosition >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1516]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1526]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (-1 + EstimatedActualPosition) = (-1 + EstimatedActualPosition) and 0 < EstimatedActualPosition >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1521]

. . . done spltting timed atoms  [21.2 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [21.2 seconds ]
After "dist^" remaining 
Obligations:

[serial 1525]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << ((ACTUAL_POSITION = EstimatedActualPosition)^1 and (0 < ACTUAL_POSITION^-1)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1519]



[serial 1526]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (-1 + EstimatedActualPosition) = (-1 + EstimatedActualPosition) and 0 < EstimatedActualPosition >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1521]


Done distributing ^ and @.
step:  155
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1525]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << ((ACTUAL_POSITION = EstimatedActualPosition)^1 and (0 < ACTUAL_POSITION^-1)^1) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1519]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1528]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (0 < ACTUAL_POSITION^-1)^1 >>
  What for:   normalization of [serial 1525]


This Proof Obligation:

[serial 1526]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (-1 + EstimatedActualPosition) = (-1 + EstimatedActualPosition) and 0 < EstimatedActualPosition >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1521]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1530]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (-1 + EstimatedActualPosition) = (-1 + EstimatedActualPosition) and 0 < EstimatedActualPosition >>
  What for:   normalization of [serial 1526]

. . . done Normalizing Unsolved Proof Obligations [21.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1528]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (0 < ACTUAL_POSITION^-1)^1 >>
  What for:   normalization of [serial 1525]



[serial 1530]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (-1 + EstimatedActualPosition) = (-1 + EstimatedActualPosition) and 0 < EstimatedActualPosition >>
  What for:   normalization of [serial 1526]


Done Normalizing
step:  156
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1530]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (-1 + EstimatedActualPosition) = (-1 + EstimatedActualPosition) and 0 < EstimatedActualPosition >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 1526]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 1533]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << true and 0 < EstimatedActualPosition >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1530]


This Proof Obligation:

[serial 1533]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << true and 0 < EstimatedActualPosition >>
Reason:  Law of And-Simplification:  P and true is P
  What for: Equality Law (idistr):  a=a <-> true [serial 1530]

Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 1534]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (0 < EstimatedActualPosition) >>
  What for: Law of And-Simplification:  P and true is P [serial 1533]

. . . done Applying Laws [21.2 seconds ]
After "laws" remaining 
Obligations:

[serial 1528]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (0 < ACTUAL_POSITION^-1)^1 >>
  What for:   normalization of [serial 1525]



[serial 1534]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (0 < EstimatedActualPosition) >>
  What for: Law of And-Simplification:  P and true is P [serial 1533]


Done applying laws
step:  157
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1528]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (0 < ACTUAL_POSITION^-1)^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1525]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1535]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((0)^1 < ACTUAL_POSITION^(-1+1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1528]

. . . done spltting timed atoms  [21.2 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [21.2 seconds ]
After "dist^" remaining 
Obligations:

[serial 1534]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (0 < EstimatedActualPosition) >>
  What for: Law of And-Simplification:  P and true is P [serial 1533]



[serial 1535]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((0)^1 < ACTUAL_POSITION^(-1+1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1528]


Done distributing ^ and @.
step:  158
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1534]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << (0 < EstimatedActualPosition) >>
Reason:  Normalization
  What for: Law of And-Simplification:  P and true is P [serial 1533]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1537]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << 0 < EstimatedActualPosition >>
  What for:   normalization of [serial 1534]


This Proof Obligation:

[serial 1535]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((0)^1 < ACTUAL_POSITION^(-1+1)) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1528]

  Normalization Axioms:

    Literal Arithmetic

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Constants are always the same
Has been normalized to get:

[serial 1539]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION^0 >>
  What for:   normalization of [serial 1535]

. . . done Normalizing Unsolved Proof Obligations [21.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1537]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << 0 < EstimatedActualPosition >>
  What for:   normalization of [serial 1534]



[serial 1539]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION^0 >>
  What for:   normalization of [serial 1535]


Done Normalizing
step:  159
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1539]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION^0 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1535]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1542]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1539]

. . . done spltting timed atoms  [21.3 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [21.3 seconds ]
After "dist^" remaining 
Obligations:

[serial 1537]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << 0 < EstimatedActualPosition >>
  What for:   normalization of [serial 1534]



[serial 1542]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1539]


Done distributing ^ and @.
step:  160
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1542]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION >>
S [59]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION >>
Reason:  Identity (id):  P->P is tautology
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1539]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [21.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 1537]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << 0 < EstimatedActualPosition >>
  What for:   normalization of [serial 1534]


Done trying to apply axioms
step:  161
****substitute all equivalents****
substituting all equals . . .
Replacing all "EstimatedActualPosition" with  "ACTUAL_POSITION" in  "ASSERTION[15]" makes:
<< 0 < ACTUAL_POSITION >>

This Proof Obligation:

[serial 1537]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << 0 < EstimatedActualPosition >>
Reason:  Substitution in Postcondition of All Equivalents in Precondition
  What for:   normalization of [serial 1534]

Has substituted in postcondition all equivalents in precondition to get:

[serial 1543]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << 0 < ACTUAL_POSITION >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1537]

. . . done substituting all equals  [21.3 seconds ]
After substituting all equivalents remaining 
Obligations:

[serial 1543]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << 0 < ACTUAL_POSITION >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1537]


Done substituting all equivalents
step:  162
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1543]: ControlSoftware::RobustPositionControlThread.SingleStep
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
S [116]->
Q [15] << 0 < ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1537]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [21.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1057]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << ((E_SS()) and ((EstimatedActualPosition < 0))) >>
S [120]->
Q [62] << true >>
  What for:  <<M(ShutDown) and x>> -> <<M(Error)>> for one8er:ShutDown-[x]->Error{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  163
#[serial 1057]  <<M(ShutDown) and x>> -> <<M(Error)>> for one8er:ShutDown-[x]->Error{};
step:  164
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1057]: ControlSoftware::RobustPositionControlThread.SingleStep
P [57] << ((E_SS()) and ((EstimatedActualPosition < 0))) >>
S [120]->
Q [62] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for:  <<M(ShutDown) and x>> -> <<M(Error)>> for one8er:ShutDown-[x]->Error{};

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [21.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1058]: ControlSoftware::RobustPositionControlThread.SingleStep
P [59] << (E_SS() and ((ACTUAL_POSITION^(-1) > 0))) >>
S [121]->
Q [57] << E_SS() >>
  What for:  <<M(StillClosing) and x>> -> <<M(ShutDown)>> for one9cl:StillClosing-[x]->ShutDown{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  165
#[serial 1058]  <<M(StillClosing) and x>> -> <<M(ShutDown)>> for one9cl:StillClosing-[x]->ShutDown{};
step:  166
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1058]: ControlSoftware::RobustPositionControlThread.SingleStep
P [59] << (E_SS() and ((ACTUAL_POSITION^(-1) > 0))) >>
S [121]->
Q [57] << E_SS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:  <<M(StillClosing) and x>> -> <<M(ShutDown)>> for one9cl:StillClosing-[x]->ShutDown{};

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [21.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1003]: ControlSoftware::FragilePositionControlThread.SingleStep
P [167] << (E() and ACTUAL_IN_RANGE()) >>
S [149]->
Q [149] << ACTUAL_IN_RANGE() >>
  What for: <<M(StillClosing)>> -> <<I>> from invariant I when complete state StillClosing has Assertion <<M(StillClosing)>> in its definition.


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
Main proof script resumed.
step:  4
#fragile thread
step:  5
****subscript****
You chose proof subscript: /Users/brianlarson/Work/BLESS-2020/Stepper/proof scripts/subscripts/FragileSingleStep.ps
step:  1
#FragileSingleStep.ps
step:  2
#This file was produced the BLESS Proof Assistant v3.1
step:  3
#  at Sat Mar 06 21:47:35 CST 2021 by brianlarson
step:  4
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  5
****sort-by-component****
sorting proof obligations for ControlSoftware::FragilePositionControlThread.SingleStep
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1003]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1004]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1005]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1006]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1007]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1008]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1009]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1010]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1011]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1012]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1013]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1014]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1015]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1016]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1017]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1018]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1019]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1020]  
ControlSoftware::FragilePositionControlThread.SingleStep  [serial 1021]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1023]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1024]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1025]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1026]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1027]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1028]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1029]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1030]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1031]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1032]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1033]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1034]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1035]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1036]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1037]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1038]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1039]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1040]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1041]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1042]  
PositionSetpoint -> c.PositionSetpoint  [serial 1059]  
After sort-by-component[ControlSoftware::FragilePositionControlThread.SingleStep], no change. 
step:  6
#ControlSoftware::FragilePositionControlThread.SingleStep
step:  7
#[serial 1003] <<M(StillClosing)>> -> <<I>> from invariant I when complete state StillClosing has Assertion <<M(StillClosing)>> in its definition
step:  8
****make-an****
Making obligation 16
Obligations:

[serial 1003]: ControlSoftware::FragilePositionControlThread.SingleStep
P [167] << (E() and ACTUAL_IN_RANGE()) >>
S [149]->
Q [149] << ACTUAL_IN_RANGE() >>
  What for: <<M(StillClosing)>> -> <<I>> from invariant I when complete state StillClosing has Assertion <<M(StillClosing)>> in its definition.


Done making obligation 16
step:  9
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1003]: ControlSoftware::FragilePositionControlThread.SingleStep
P [167] << (E() and ACTUAL_IN_RANGE()) >>
S [149]->
Q [149] << ACTUAL_IN_RANGE() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: <<M(StillClosing)>> -> <<I>> from invariant I when complete state StillClosing has Assertion <<M(StillClosing)>> in its definition.

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [21.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1004]: ControlSoftware::FragilePositionControlThread.SingleStep
P [159] << (E() and D() and ACTUAL_IN_RANGE()) >>
S [149]->
Q [149] << ACTUAL_IN_RANGE() >>
  What for: <<M(Run)>> -> <<I>> from invariant I when complete state Run has Assertion <<M(Run)>> in its definition.


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  10
#[serial 1004] <<M(Run)>> -> <<I>> from invariant I when complete state Run has Assertion <<M(Run)>> in its definition.
step:  11
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1004]: ControlSoftware::FragilePositionControlThread.SingleStep
P [159] << (E() and D() and ACTUAL_IN_RANGE()) >>
S [149]->
Q [149] << ACTUAL_IN_RANGE() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: <<M(Run)>> -> <<I>> from invariant I when complete state Run has Assertion <<M(Run)>> in its definition.

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [21.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1005]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << (E() and ACTUAL_IN_RANGE()) >>
S [165]->
Q [165] << (((EstimatedActualPosition = 0)) or ((EstimatedActualPosition > 0)) or 
((EstimatedActualPosition < 0))) >>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state ShutDown, <<M(ShutDown)>> -> <<e1 or e2 or . . . en>>


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  12
#[serial 1005] Serban's Theorem:  disjunction of execute conditions leaving execution state ShutDown, <<M(ShutDown)>> -> <<e1 or e2 or . . . en>>
step:  13
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1005]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << (E() and ACTUAL_IN_RANGE()) >>
S [165]->
Q [165] << (((EstimatedActualPosition = 0)) or ((EstimatedActualPosition > 0)) or 
((EstimatedActualPosition < 0))) >>
Reason:  Normalization
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state ShutDown, <<M(ShutDown)>> -> <<e1 or e2 or . . . en>>

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1545]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << ACTUAL_IN_RANGE() and E() >>
S [165]->
Q [165] << 0 = EstimatedActualPosition or 0 < EstimatedActualPosition or EstimatedActualPosition < 0 >>
  What for:   normalization of [serial 1005]

. . . done Normalizing Unsolved Proof Obligations [21.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1545]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << ACTUAL_IN_RANGE() and E() >>
S [165]->
Q [165] << 0 = EstimatedActualPosition or 0 < EstimatedActualPosition or EstimatedActualPosition < 0 >>
  What for:   normalization of [serial 1005]


Done Normalizing
step:  14
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1545]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << ACTUAL_IN_RANGE() and E() >>
S [165]->
Q [165] << 0 = EstimatedActualPosition or 0 < EstimatedActualPosition or EstimatedActualPosition < 0 >>
Reason:  Less than, greater than, or equal:  |-a<b or b<a or a=b
  What for:   normalization of [serial 1005]

Has applied law "Less than, greater than, or equal:  |-a<b or b<a or a=b" to get:

[serial 1547]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << ACTUAL_IN_RANGE() and E() >>
S [165]->
Q [165] << true >>
  What for: Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1545]

. . . done Applying Laws [21.3 seconds ]
After "laws" remaining 
Obligations:

[serial 1547]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << ACTUAL_IN_RANGE() and E() >>
S [165]->
Q [165] << true >>
  What for: Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1545]


Done applying laws
step:  15
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1547]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << ACTUAL_IN_RANGE() and E() >>
S [165]->
Q [165] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1545]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [21.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1006]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << (E() and ACTUAL_IN_RANGE()) >>
S [161]->
Q [161] << (((((DESIRED_POSITION)^0 >= 0)) and (((DESIRED_POSITION)^0 <= #PCS::MaxPosition))) or 
(((((DESIRED_POSITION)^0 < 0))) or ((((DESIRED_POSITION)^0 > #PCS::MaxPosition))))) >>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state Check, <<M(Check)>> -> <<e1 or e2 or . . . en>>


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  16
#[serial 1006] Serban's Theorem:  disjunction of execute conditions leaving execution state Check, <<M(Check)>> -> <<e1 or e2 or . . . en>>
step:  17
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1006]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << (E() and ACTUAL_IN_RANGE()) >>
S [161]->
Q [161] << (((((DESIRED_POSITION)^0 >= 0)) and (((DESIRED_POSITION)^0 <= #PCS::MaxPosition))) or 
(((((DESIRED_POSITION)^0 < 0))) or ((((DESIRED_POSITION)^0 > #PCS::MaxPosition))))) >>
Reason:  Normalization
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state Check, <<M(Check)>> -> <<e1 or e2 or . . . en>>

  Normalization Axioms:

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1549]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161]->
Q [161] << (0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition) or 
(DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0) >>
  What for:   normalization of [serial 1006]

. . . done Normalizing Unsolved Proof Obligations [21.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1549]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161]->
Q [161] << (0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition) or 
(DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0) >>
  What for:   normalization of [serial 1006]


Done Normalizing
step:  18
****conjunctive-normal-form****
Transforming into Conjunctive Normal Form . . .
Replacing A->B with not A or B
Substituting A->B with not A or B
done Substituting A->B with not A or B [21.3 seconds ]
Applying DeMorgan's Law . . .
. . . done applying DeMorgan's Law  [21.3 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [21.3 seconds ]

This Proof Obligation:

[serial 1549]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161]->
Q [161] << (0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition) or 
(DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0) >>
Reason:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
  What for:   normalization of [serial 1006]

Has applied Distribution of preconditions, and over or, and distribution of postcondtitions, or over and while transforming into conjunctive normal form to get:

[serial 1552]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161]->
Q [161] << (0 <= DESIRED_POSITION^0 or (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0)) and 
(DESIRED_POSITION^0 <= #PCS::MaxPosition or (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0)) >>
  What for: Distribution of preconditions, and over or, and distribution of postcondtitions, or over and while transforming into
  conjunctive normal form [serial 1549]

. . . done putting into conjunctive normal form [21.3 seconds ]
After "conjunctive normal form" remaining 
Obligations:

[serial 1552]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161]->
Q [161] << (0 <= DESIRED_POSITION^0 or (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0)) and 
(DESIRED_POSITION^0 <= #PCS::MaxPosition or (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0)) >>
  What for: Distribution of preconditions, and over or, and distribution of postcondtitions, or over and while transforming into
  conjunctive normal form [serial 1549]


Done making conjunctive normal forms.
step:  19
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1552]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161]->
Q [161] << (0 <= DESIRED_POSITION^0 or (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0)) and 
(DESIRED_POSITION^0 <= #PCS::MaxPosition or (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0)) >>
Reason:  At Most Is Not Less Than: (a<=b) = not(b<a)
  What for: Distribution of preconditions, and over or, and distribution of postcondtitions, or over and while transforming into
  conjunctive normal form [serial 1549]

Has applied At Most Is Not Less Than: (a<=b) = not(b<a) to get:

[serial 1553]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161]->
Q [161] << ((not (DESIRED_POSITION^0 < 0)) or (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0)) and 
((not (#PCS::MaxPosition < DESIRED_POSITION^0)) or (DESIRED_POSITION^0 < 0 or 
#PCS::MaxPosition < DESIRED_POSITION^0)) >>
  What for: At Most Is Not Less Than: (a<=b) = not(b<a) [serial 1552]

. . . Substituting <= with not < [21.3 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1553]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161]->
Q [161] << ((not (DESIRED_POSITION^0 < 0)) or (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0)) and 
((not (#PCS::MaxPosition < DESIRED_POSITION^0)) or (DESIRED_POSITION^0 < 0 or 
#PCS::MaxPosition < DESIRED_POSITION^0)) >>
  What for: At Most Is Not Less Than: (a<=b) = not(b<a) [serial 1552]


Done replacing a<=b with (not b<a)
step:  20
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1553]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161]->
Q [161] << ((not (DESIRED_POSITION^0 < 0)) or (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0)) and 
((not (#PCS::MaxPosition < DESIRED_POSITION^0)) or (DESIRED_POSITION^0 < 0 or 
#PCS::MaxPosition < DESIRED_POSITION^0)) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for: At Most Is Not Less Than: (a<=b) = not(b<a) [serial 1552]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1554]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161]->
Q [161] << (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0 or 
(not (DESIRED_POSITION^0 < 0))) and (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0 or 
(not (#PCS::MaxPosition < DESIRED_POSITION^0))) >>
  What for: Associativity: (b.c).a = a.b.c [serial 1553]


This Proof Obligation:

[serial 1554]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161]->
Q [161] << (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0 or 
(not (DESIRED_POSITION^0 < 0))) and (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0 or 
(not (#PCS::MaxPosition < DESIRED_POSITION^0))) >>
Reason:  Law of Excluded Middle: P or not P is tautology
  What for: Associativity: (b.c).a = a.b.c [serial 1553]

Has applied law "Law of Excluded Middle: P or not P is tautology" to get:

[serial 1555]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161]->
Q [161] << (true) and (true) >>
  What for: Law of Excluded Middle: P or not P is tautology [serial 1554]


This Proof Obligation:

[serial 1555]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161]->
Q [161] << (true) and (true) >>
Reason:  Law of And-Simplification:  P and P is P
  What for: Law of Excluded Middle: P or not P is tautology [serial 1554]

Has applied law "Law of And-Simplification:  P and P is P" to get:

[serial 1556]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161]->
Q [161] << (true) >>
  What for: Law of And-Simplification:  P and P is P [serial 1555]

. . . done Applying Laws [21.3 seconds ]
After "laws" remaining 
Obligations:

[serial 1556]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161]->
Q [161] << (true) >>
  What for: Law of And-Simplification:  P and P is P [serial 1555]


Done applying laws
step:  21
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1556]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161]->
Q [161] << (true) >>
Reason:  Normalization
  What for: Law of And-Simplification:  P and P is P [serial 1555]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1558]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161]->
Q [161] << true >>
  What for:   normalization of [serial 1556]

. . . done Normalizing Unsolved Proof Obligations [21.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1558]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161]->
Q [161] << true >>
  What for:   normalization of [serial 1556]


Done Normalizing
step:  22
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1558]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161]->
Q [161] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for:   normalization of [serial 1556]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [21.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1007]: ControlSoftware::FragilePositionControlThread.SingleStep
P [157] << (ACTUAL_POSITION = 0) >>
S [157]->
Q [157] << true >>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state PowerOn, <<M(PowerOn)>> -> <<e1 or e2 or . . . en>>


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  23
#[serial 1007] Serban's Theorem:  disjunction of execute conditions leaving execution state PowerOn, <<M(PowerOn)>> -> <<e1 or e2 or . . . en>>
step:  24
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1007]: ControlSoftware::FragilePositionControlThread.SingleStep
P [157] << (ACTUAL_POSITION = 0) >>
S [157]->
Q [157] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state PowerOn, <<M(PowerOn)>> -> <<e1 or e2 or . . . en>>

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [21.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1008]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
S [163]->
Q [163] << ((((DESIRED_POSITION)^0 = EstimatedActualPosition)) or (((EstimatedActualPosition + 
1) <= (DESIRED_POSITION)^0)) or (((DESIRED_POSITION)^0 <= (EstimatedActualPosition - 1))) or 
((((DESIRED_POSITION)^0 > (EstimatedActualPosition - 1))) and (((EstimatedActualPosition + 
1) > (DESIRED_POSITION)^0)))) >>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state Decide, <<M(Decide)>> -> <<e1 or e2 or . . . en>>


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  25
#[serial 1008] Serban's Theorem:  disjunction of execute conditions leaving execution state Decide, <<M(Decide)>> -> <<e1 or e2 or . . . en>>
step:  26
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1008]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
S [163]->
Q [163] << ((((DESIRED_POSITION)^0 = EstimatedActualPosition)) or (((EstimatedActualPosition + 
1) <= (DESIRED_POSITION)^0)) or (((DESIRED_POSITION)^0 <= (EstimatedActualPosition - 1))) or 
((((DESIRED_POSITION)^0 > (EstimatedActualPosition - 1))) and (((EstimatedActualPosition + 
1) > (DESIRED_POSITION)^0)))) >>
Reason:  Normalization
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state Decide, <<M(Decide)>> -> <<e1 or e2 or . . . en>>

  Normalization Axioms:

    Reflexivity of Addition: a+b=b+a

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1561]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E() >>
S [163]->
Q [163] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) or (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 or 
DESIRED_POSITION^0 = EstimatedActualPosition or (DESIRED_POSITION^0 < (1 + 
EstimatedActualPosition) and (EstimatedActualPosition - 1) < DESIRED_POSITION^0) >>
  What for:   normalization of [serial 1008]

. . . done Normalizing Unsolved Proof Obligations [21.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1561]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E() >>
S [163]->
Q [163] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) or (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 or 
DESIRED_POSITION^0 = EstimatedActualPosition or (DESIRED_POSITION^0 < (1 + 
EstimatedActualPosition) and (EstimatedActualPosition - 1) < DESIRED_POSITION^0) >>
  What for:   normalization of [serial 1008]


Done Normalizing
step:  27
****conjunctive-normal-form****
Transforming into Conjunctive Normal Form . . .
Replacing A->B with not A or B
Substituting A->B with not A or B
done Substituting A->B with not A or B [21.3 seconds ]
Applying DeMorgan's Law . . .
. . . done applying DeMorgan's Law  [21.3 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [21.3 seconds ]

This Proof Obligation:

[serial 1561]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E() >>
S [163]->
Q [163] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) or (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 or 
DESIRED_POSITION^0 = EstimatedActualPosition or (DESIRED_POSITION^0 < (1 + 
EstimatedActualPosition) and (EstimatedActualPosition - 1) < DESIRED_POSITION^0) >>
Reason:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
  What for:   normalization of [serial 1008]

Has applied Distribution of preconditions, and over or, and distribution of postcondtitions, or over and while transforming into conjunctive normal form to get:

[serial 1564]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E() >>
S [163]->
Q [163] << (DESIRED_POSITION^0 < (1 + EstimatedActualPosition) or DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) or 
(1 + EstimatedActualPosition) <= DESIRED_POSITION^0 or DESIRED_POSITION^0 = EstimatedActualPosition) and 
((EstimatedActualPosition - 1) < DESIRED_POSITION^0 or DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) or 
(1 + EstimatedActualPosition) <= DESIRED_POSITION^0 or DESIRED_POSITION^0 = EstimatedActualPosition) >>
  What for: Distribution of preconditions, and over or, and distribution of postcondtitions, or over and while transforming into
  conjunctive normal form [serial 1561]

. . . done putting into conjunctive normal form [21.3 seconds ]
After "conjunctive normal form" remaining 
Obligations:

[serial 1564]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E() >>
S [163]->
Q [163] << (DESIRED_POSITION^0 < (1 + EstimatedActualPosition) or DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) or 
(1 + EstimatedActualPosition) <= DESIRED_POSITION^0 or DESIRED_POSITION^0 = EstimatedActualPosition) and 
((EstimatedActualPosition - 1) < DESIRED_POSITION^0 or DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) or 
(1 + EstimatedActualPosition) <= DESIRED_POSITION^0 or DESIRED_POSITION^0 = EstimatedActualPosition) >>
  What for: Distribution of preconditions, and over or, and distribution of postcondtitions, or over and while transforming into
  conjunctive normal form [serial 1561]


Done making conjunctive normal forms.
step:  28
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1564]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E() >>
S [163]->
Q [163] << (DESIRED_POSITION^0 < (1 + EstimatedActualPosition) or DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) or 
(1 + EstimatedActualPosition) <= DESIRED_POSITION^0 or DESIRED_POSITION^0 = EstimatedActualPosition) and 
((EstimatedActualPosition - 1) < DESIRED_POSITION^0 or DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) or 
(1 + EstimatedActualPosition) <= DESIRED_POSITION^0 or DESIRED_POSITION^0 = EstimatedActualPosition) >>
Reason:  At Most Is Not Less Than: (a<=b) = not(b<a)
  What for: Distribution of preconditions, and over or, and distribution of postcondtitions, or over and while transforming into
  conjunctive normal form [serial 1561]

Has applied At Most Is Not Less Than: (a<=b) = not(b<a) to get:

[serial 1565]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E() >>
S [163]->
Q [163] << (DESIRED_POSITION^0 < (1 + EstimatedActualPosition) or (not ((EstimatedActualPosition - 1) < DESIRED_POSITION^0)) or 
(not (DESIRED_POSITION^0 < (1 + EstimatedActualPosition))) or DESIRED_POSITION^0 = EstimatedActualPosition) and 
((EstimatedActualPosition - 1) < DESIRED_POSITION^0 or (not ((EstimatedActualPosition - 1) < DESIRED_POSITION^0)) or 
(not (DESIRED_POSITION^0 < (1 + EstimatedActualPosition))) or DESIRED_POSITION^0 = EstimatedActualPosition) >>
  What for: At Most Is Not Less Than: (a<=b) = not(b<a) [serial 1564]

. . . Substituting <= with not < [21.4 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1565]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E() >>
S [163]->
Q [163] << (DESIRED_POSITION^0 < (1 + EstimatedActualPosition) or (not ((EstimatedActualPosition - 1) < DESIRED_POSITION^0)) or 
(not (DESIRED_POSITION^0 < (1 + EstimatedActualPosition))) or DESIRED_POSITION^0 = EstimatedActualPosition) and 
((EstimatedActualPosition - 1) < DESIRED_POSITION^0 or (not ((EstimatedActualPosition - 1) < DESIRED_POSITION^0)) or 
(not (DESIRED_POSITION^0 < (1 + EstimatedActualPosition))) or DESIRED_POSITION^0 = EstimatedActualPosition) >>
  What for: At Most Is Not Less Than: (a<=b) = not(b<a) [serial 1564]


Done replacing a<=b with (not b<a)
step:  29
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1565]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E() >>
S [163]->
Q [163] << (DESIRED_POSITION^0 < (1 + EstimatedActualPosition) or (not ((EstimatedActualPosition - 1) < DESIRED_POSITION^0)) or 
(not (DESIRED_POSITION^0 < (1 + EstimatedActualPosition))) or DESIRED_POSITION^0 = EstimatedActualPosition) and 
((EstimatedActualPosition - 1) < DESIRED_POSITION^0 or (not ((EstimatedActualPosition - 1) < DESIRED_POSITION^0)) or 
(not (DESIRED_POSITION^0 < (1 + EstimatedActualPosition))) or DESIRED_POSITION^0 = EstimatedActualPosition) >>
Reason:  Law of Excluded Middle: P or not P is tautology
  What for: At Most Is Not Less Than: (a<=b) = not(b<a) [serial 1564]

Has applied law "Law of Excluded Middle: P or not P is tautology" to get:

[serial 1566]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E() >>
S [163]->
Q [163] << (true) and (true) >>
  What for: Law of Excluded Middle: P or not P is tautology [serial 1565]


This Proof Obligation:

[serial 1566]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E() >>
S [163]->
Q [163] << (true) and (true) >>
Reason:  Law of And-Simplification:  P and P is P
  What for: Law of Excluded Middle: P or not P is tautology [serial 1565]

Has applied law "Law of And-Simplification:  P and P is P" to get:

[serial 1567]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E() >>
S [163]->
Q [163] << (true) >>
  What for: Law of And-Simplification:  P and P is P [serial 1566]

. . . done Applying Laws [21.4 seconds ]
After "laws" remaining 
Obligations:

[serial 1567]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E() >>
S [163]->
Q [163] << (true) >>
  What for: Law of And-Simplification:  P and P is P [serial 1566]


Done applying laws
step:  30
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1567]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E() >>
S [163]->
Q [163] << (true) >>
Reason:  Normalization
  What for: Law of And-Simplification:  P and P is P [serial 1566]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1569]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E() >>
S [163]->
Q [163] << true >>
  What for:   normalization of [serial 1567]

. . . done Normalizing Unsolved Proof Obligations [21.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1569]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E() >>
S [163]->
Q [163] << true >>
  What for:   normalization of [serial 1567]


Done Normalizing
step:  31
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1569]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E() >>
S [163]->
Q [163] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for:   normalization of [serial 1567]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [21.4 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1009]: ControlSoftware::FragilePositionControlThread.SingleStep
P [157] << (ACTUAL_POSITION = 0) >>
S [173]<< (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
ActuatorCommand(pc:0)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
;
Delta := 0
<< ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
;
EstimatedActualPosition' := 0
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [159] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(PowerOn)>> A <<M(Run)>> for fra0po:PowerOn-[ ]->Run{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  32
#[serial 1009]  <<M(PowerOn)>> A <<M(Run)>> for fra0po:PowerOn-[ ]->Run{A};
step:  33
****reduce****
This proof obligation:

[serial 1009]: ControlSoftware::FragilePositionControlThread.SingleStep
P [157] << (ACTUAL_POSITION = 0) >>
S [173]<< (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
ActuatorCommand(pc:0)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
;
Delta := 0
<< ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
;
EstimatedActualPosition' := 0
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [159] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(PowerOn)>> A <<M(Run)>> for fra0po:PowerOn-[ ]->Run{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P2>> S2 <<Q2>>
 
was reduced to:

[serial 1571]: ControlSoftware::FragilePositionControlThread.SingleStep
P [157] << (ACTUAL_POSITION = 0) >>
S [157]->
Q [15] << (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
  What for: P -> P1 in sequential composition for [serial 1009]


[serial 1572]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [159]->
Q [15] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 1009]


[serial 1573]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
S [174]ActuatorCommand(pc:0)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1009]


[serial 1574]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
S [177]Delta := 0
Q [15] << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1009]


[serial 1575]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
S [181]EstimatedActualPosition' := 0
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1009]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1571]: ControlSoftware::FragilePositionControlThread.SingleStep
P [157] << (ACTUAL_POSITION = 0) >>
S [157]->
Q [15] << (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
  What for: P -> P1 in sequential composition for [serial 1009]



[serial 1572]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [159]->
Q [15] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 1009]



[serial 1573]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
S [174]ActuatorCommand(pc:0)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1009]



[serial 1574]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
S [177]Delta := 0
Q [15] << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1009]



[serial 1575]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
S [181]EstimatedActualPosition' := 0
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1009]


done reducing composite actions
step:  34
****atomic****
applying atomic actions . . .
Creating weakest-precondition predicate transfer for subprogram invocation of "ActuatorCommand".
There must be occurrences of: 
  ACTUAL_POSITION = ACTUAL_POSITION'
 found in:
  << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
 for invocation of "ActuatorCommand" on line 174 to have effect.
solving assignment on line 177
replacing "Delta" with "0"
makes:  << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(0 = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>

This Proof Obligation:

[serial 1574]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
S [177]Delta := 0
Q [15] << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1009]

Has applied := to get:

[serial 1576]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
S [177]->
Q [15] << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(0 = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
  What for: applied wp for assignment [serial 1574]

solving assignment on line 181
replacing "EstimatedActualPosition'" with "0"
makes:  << ((0 = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>

This Proof Obligation:

[serial 1575]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
S [181]EstimatedActualPosition' := 0
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1009]

Has applied := to get:

[serial 1577]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
S [181]->
Q [15] << ((0 = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
  What for: applied wp for assignment [serial 1575]

. . . done applying atomic actions [21.4 seconds ]
After "atomic" remaining 
Obligations:

[serial 1571]: ControlSoftware::FragilePositionControlThread.SingleStep
P [157] << (ACTUAL_POSITION = 0) >>
S [157]->
Q [15] << (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
  What for: P -> P1 in sequential composition for [serial 1009]



[serial 1572]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [159]->
Q [15] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 1009]



[serial 1573]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
S [174]ActuatorCommand(pc:0)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1009]



[serial 1576]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
S [177]->
Q [15] << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(0 = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
  What for: applied wp for assignment [serial 1574]



[serial 1577]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
S [181]->
Q [15] << ((0 = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
  What for: applied wp for assignment [serial 1575]


Done reducing atomic actions
step:  35
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1571]: ControlSoftware::FragilePositionControlThread.SingleStep
P [157] << (ACTUAL_POSITION = 0) >>
S [157]->
Q [15] << (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
Reason:  Normalization
  What for: P -> P1 in sequential composition for [serial 1009]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1579]: ControlSoftware::FragilePositionControlThread.SingleStep
P [157] << 0 = ACTUAL_POSITION >>
S [157]->
Q [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
  What for:   normalization of [serial 1571]


This Proof Obligation:

[serial 1572]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [159]->
Q [15] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
Reason:  Normalization
  What for: Q2 -> Q in sequential composition for [serial 1009]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1581]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1572]


This Proof Obligation:

[serial 1573]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
S [174]ActuatorCommand(pc:0)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
Reason:  Normalization
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1009]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1583]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [174]ActuatorCommand(pc:0)
Q [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1573]


This Proof Obligation:

[serial 1576]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
S [177]->
Q [15] << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(0 = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
Reason:  Normalization
  What for: applied wp for assignment [serial 1574]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1585]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' and AXIOM_MPGT0() >>
  What for:   normalization of [serial 1576]


This Proof Obligation:

[serial 1577]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
S [181]->
Q [15] << ((0 = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: applied wp for assignment [serial 1575]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1587]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [181]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1577]

. . . done Normalizing Unsolved Proof Obligations [21.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1579]: ControlSoftware::FragilePositionControlThread.SingleStep
P [157] << 0 = ACTUAL_POSITION >>
S [157]->
Q [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
  What for:   normalization of [serial 1571]



[serial 1581]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1572]



[serial 1583]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [174]ActuatorCommand(pc:0)
Q [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1573]



[serial 1585]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' and AXIOM_MPGT0() >>
  What for:   normalization of [serial 1576]



[serial 1587]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [181]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1577]


Done Normalizing
step:  36
****atomic****
applying atomic actions . . .
Creating weakest-precondition predicate transfer for subprogram invocation of "ActuatorCommand".

This Proof Obligation:

[serial 1583]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [174]ActuatorCommand(pc:0)
Q [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
Reason:  Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
  What for:   normalization of [serial 1573]

Used weakest precondition predicate transformation on
+ <<P>> ActuatorCommand(X) <<Q>> to get:

[serial 1593]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [174]->
Q [15] << 0 = ACTUAL_POSITION and (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1583]

. . . done applying atomic actions [21.4 seconds ]
After "atomic" remaining 
Obligations:

[serial 1579]: ControlSoftware::FragilePositionControlThread.SingleStep
P [157] << 0 = ACTUAL_POSITION >>
S [157]->
Q [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
  What for:   normalization of [serial 1571]



[serial 1581]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1572]



[serial 1593]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [174]->
Q [15] << 0 = ACTUAL_POSITION and (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1583]



[serial 1585]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' and AXIOM_MPGT0() >>
  What for:   normalization of [serial 1576]



[serial 1587]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [181]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1577]


Done reducing atomic actions
step:  37
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1593]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [174]->
Q [15] << 0 = ACTUAL_POSITION and (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1583]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1594]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [174]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 1593]

. . . done Applying Laws [21.4 seconds ]
After "laws" remaining 
Obligations:

[serial 1579]: ControlSoftware::FragilePositionControlThread.SingleStep
P [157] << 0 = ACTUAL_POSITION >>
S [157]->
Q [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
  What for:   normalization of [serial 1571]



[serial 1581]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1572]



[serial 1585]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' and AXIOM_MPGT0() >>
  What for:   normalization of [serial 1576]



[serial 1587]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [181]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1577]



[serial 1594]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [174]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 1593]


Done applying laws
step:  38
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1579]: ControlSoftware::FragilePositionControlThread.SingleStep
P [157] << 0 = ACTUAL_POSITION >>
S [157]->
Q [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
Reason:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
  What for:   normalization of [serial 1571]

has been transformed into:

[serial 1595]: ControlSoftware::FragilePositionControlThread.SingleStep
P [157] << 0 = ACTUAL_POSITION >>
S [157]->
Q [15] << 0 = ACTUAL_POSITION and true >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


by removing axioms from postconditions.

This proof obligation:

[serial 1585]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' and AXIOM_MPGT0() >>
Reason:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
  What for:   normalization of [serial 1576]

has been transformed into:

[serial 1596]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' and true >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


by removing axioms from postconditions.

. . . done removing axioms from postconditions  [21.4 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1581]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1572]



[serial 1587]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [181]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1577]



[serial 1594]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [174]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 1593]



[serial 1595]: ControlSoftware::FragilePositionControlThread.SingleStep
P [157] << 0 = ACTUAL_POSITION >>
S [157]->
Q [15] << 0 = ACTUAL_POSITION and true >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 




[serial 1596]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' and true >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 



Done removing axioms from postconditions
step:  39
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1595]: ControlSoftware::FragilePositionControlThread.SingleStep
P [157] << 0 = ACTUAL_POSITION >>
S [157]->
Q [15] << 0 = ACTUAL_POSITION and true >>
Reason:  Law of And-Simplification:  P and true is P
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 1597]: ControlSoftware::FragilePositionControlThread.SingleStep
P [157] << 0 = ACTUAL_POSITION >>
S [157]->
Q [15] << (0 = ACTUAL_POSITION) >>
  What for: Law of And-Simplification:  P and true is P [serial 1595]


This Proof Obligation:

[serial 1596]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' and true >>
Reason:  Law of And-Simplification:  P and true is P
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 1598]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for: Law of And-Simplification:  P and true is P [serial 1596]

. . . done Applying Laws [21.5 seconds ]
After "laws" remaining 
Obligations:

[serial 1581]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1572]



[serial 1587]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [181]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1577]



[serial 1594]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [174]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 1593]



[serial 1597]: ControlSoftware::FragilePositionControlThread.SingleStep
P [157] << 0 = ACTUAL_POSITION >>
S [157]->
Q [15] << (0 = ACTUAL_POSITION) >>
  What for: Law of And-Simplification:  P and true is P [serial 1595]



[serial 1598]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for: Law of And-Simplification:  P and true is P [serial 1596]


Done applying laws
step:  40
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1597]: ControlSoftware::FragilePositionControlThread.SingleStep
P [157] << 0 = ACTUAL_POSITION >>
S [157]->
Q [15] << (0 = ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Law of And-Simplification:  P and true is P [serial 1595]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1603]: ControlSoftware::FragilePositionControlThread.SingleStep
P [157] << 0 = ACTUAL_POSITION >>
S [157]->
Q [15] << 0 = ACTUAL_POSITION >>
  What for:   normalization of [serial 1597]

. . . done Normalizing Unsolved Proof Obligations [21.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 1581]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1572]



[serial 1587]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [181]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1577]



[serial 1594]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [174]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 1593]



[serial 1598]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for: Law of And-Simplification:  P and true is P [serial 1596]



[serial 1603]: ControlSoftware::FragilePositionControlThread.SingleStep
P [157] << 0 = ACTUAL_POSITION >>
S [157]->
Q [15] << 0 = ACTUAL_POSITION >>
  What for:   normalization of [serial 1597]


Done Normalizing
step:  41
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1603]: ControlSoftware::FragilePositionControlThread.SingleStep
P [157] << 0 = ACTUAL_POSITION >>
S [157]->
Q [15] << 0 = ACTUAL_POSITION >>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 1597]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [21.5 seconds ]
After "axioms" remaining 
Obligations:

[serial 1581]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1572]



[serial 1587]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [181]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1577]



[serial 1594]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [174]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 1593]



[serial 1598]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for: Law of And-Simplification:  P and true is P [serial 1596]


Done trying to apply axioms
step:  42
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1581]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 1572]

Has substituted Assertions' predicates for labels to get:

[serial 1606]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels  [serial 1581]


This Proof Obligation:

[serial 1587]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [181]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 1577]

Has substituted Assertions' predicates for labels to get:

[serial 1607]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((0 <= #PCS::MaxPosition)) >>
S [181]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: substituted Assertions' predicates for  labels  [serial 1587]


This Proof Obligation:

[serial 1594]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [174]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
Reason:  Substitution of Assertion Labels
  What for: Associativity: (b.c).a = a.b.c [serial 1593]

Has substituted Assertions' predicates for labels to get:

[serial 1608]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ((0 <= #PCS::MaxPosition)) >>
S [174]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels  [serial 1594]

. . . done Substituting Assertions for Labels [21.5 seconds ]
After "substitute" remaining 
Obligations:

[serial 1598]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for: Law of And-Simplification:  P and true is P [serial 1596]



[serial 1606]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels  [serial 1581]



[serial 1607]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((0 <= #PCS::MaxPosition)) >>
S [181]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: substituted Assertions' predicates for  labels  [serial 1587]



[serial 1608]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ((0 <= #PCS::MaxPosition)) >>
S [174]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels  [serial 1594]


Done substituting Assertion labels.
step:  43
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1606]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1581]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1611]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
  What for:   normalization of [serial 1606]


This Proof Obligation:

[serial 1607]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((0 <= #PCS::MaxPosition)) >>
S [181]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1587]

  Normalization Axioms:

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1613]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1607]


This Proof Obligation:

[serial 1608]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ((0 <= #PCS::MaxPosition)) >>
S [174]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1594]

  Normalization Axioms:

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1615]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
  What for:   normalization of [serial 1608]

. . . done Normalizing Unsolved Proof Obligations [21.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 1598]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for: Law of And-Simplification:  P and true is P [serial 1596]



[serial 1611]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
  What for:   normalization of [serial 1606]



[serial 1613]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1607]



[serial 1615]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
  What for:   normalization of [serial 1608]


Done Normalizing
step:  44
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1598]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for: Law of And-Simplification:  P and true is P [serial 1596]

Has split postcondition to get:

[serial 1619]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [178] << 0 = ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1598]


[serial 1620]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [179] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1598]


[serial 1621]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [178] << ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1598]


This Proof Obligation:

[serial 1613]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 1607]

Has split postcondition to get:

[serial 1622]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1613]


[serial 1623]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [184] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1613]


[serial 1624]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [182] << 0 = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1613]


[serial 1625]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [183] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1613]


This Proof Obligation:

[serial 1615]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 1608]

Has split postcondition to get:

[serial 1626]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]


[serial 1627]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]


[serial 1628]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [175] << 0 = ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]

. . . done splitting postcondition  [21.5 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1611]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
  What for:   normalization of [serial 1606]



[serial 1619]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [178] << 0 = ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1598]



[serial 1620]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [179] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1598]



[serial 1621]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [178] << ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1598]



[serial 1622]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1613]



[serial 1623]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [184] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1613]



[serial 1624]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [182] << 0 = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1613]



[serial 1625]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [183] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1613]



[serial 1626]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]



[serial 1627]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]



[serial 1628]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [175] << 0 = ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]


Done splitting postcondition
step:  45
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1619]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [178] << 0 = ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1598]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1621]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [178] << ACTUAL_POSITION = ACTUAL_POSITION' >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1598]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1625]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [183] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1613]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1628]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [175] << 0 = ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [21.5 seconds ]
After "axioms" remaining 
Obligations:

[serial 1611]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
  What for:   normalization of [serial 1606]



[serial 1620]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [179] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1598]



[serial 1622]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1613]



[serial 1623]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [184] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1613]



[serial 1624]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [182] << 0 = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1613]



[serial 1626]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]



[serial 1627]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]


Done trying to apply axioms
step:  46
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  ACTUAL_POSITION' = EstimatedActualPosition'
equality selected for substitution:  ACTUAL_POSITION = ACTUAL_POSITION'

This Proof Obligation:

[serial 1620]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [179] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1598]

Has substituted 
"ACTUAL_POSITION'" with its = "ACTUAL_POSITION"
 to get:

[serial 1629]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [179] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1620]

equality selected for substitution:  ACTUAL_POSITION = ACTUAL_POSITION'

This Proof Obligation:

[serial 1622]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [1] << 0 <= ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1613]

Has substituted 
"ACTUAL_POSITION'" with its = "ACTUAL_POSITION"
 to get:

[serial 1630]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1622]

equality selected for substitution:  ACTUAL_POSITION = ACTUAL_POSITION'

This Proof Obligation:

[serial 1623]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [184] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1613]

Has substituted 
"ACTUAL_POSITION'" with its = "ACTUAL_POSITION"
 to get:

[serial 1631]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [184] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1623]

equality selected for substitution:  ACTUAL_POSITION = ACTUAL_POSITION'

This Proof Obligation:

[serial 1624]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [182] << 0 = ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1613]

Has substituted 
"ACTUAL_POSITION'" with its = "ACTUAL_POSITION"
 to get:

[serial 1632]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [182] << 0 = ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1624]

. . . done guided substitution of equals  [21.6 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1611]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 1606]



[serial 1626]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]



[serial 1627]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]



[serial 1629]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [179] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1620]



[serial 1630]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1622]



[serial 1631]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [184] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1623]



[serial 1632]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [182] << 0 = ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1624]


Done guided substituting an equals
step:  47
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1629]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [179] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1620]

  Normalization Axioms:

    Subtraction of Same:  a-a is 0

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1637]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [179] << 0 = 0 >>
  What for:   normalization of [serial 1629]

. . . done Normalizing Unsolved Proof Obligations [21.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 1611]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 1606]



[serial 1626]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]



[serial 1627]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]



[serial 1630]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1622]



[serial 1631]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [184] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1623]



[serial 1632]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [182] << 0 = ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1624]



[serial 1637]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [179] << 0 = 0 >>
  What for:   normalization of [serial 1629]


Done Normalizing
step:  48
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1611]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1606]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1642]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
  What for: Associativity: (b.c).a = a.b.c [serial 1611]


This Proof Obligation:

[serial 1637]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [179] << 0 = 0 >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 1629]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 1643]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [179] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1637]

. . . done Applying Laws [21.6 seconds ]
After "laws" remaining 
Obligations:

[serial 1626]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]



[serial 1627]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]



[serial 1630]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1622]



[serial 1631]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [184] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1623]



[serial 1632]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [182] << 0 = ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1624]



[serial 1642]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
  What for: Associativity: (b.c).a = a.b.c [serial 1611]



[serial 1643]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [179] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1637]


Done applying laws
step:  49
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1632]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [182] << 0 = ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1624]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1643]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177]->
Q [179] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 1637]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [21.6 seconds ]
After "axioms" remaining 
Obligations:

[serial 1626]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]



[serial 1627]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]



[serial 1630]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1622]



[serial 1631]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [184] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1623]



[serial 1642]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
  What for: Associativity: (b.c).a = a.b.c [serial 1611]


Done trying to apply axioms
step:  50
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1630]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1622]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1644]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = (ACTUAL_POSITION)^1 and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
S [181]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1630]


This Proof Obligation:

[serial 1631]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181]->
Q [184] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1623]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1645]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = (ACTUAL_POSITION)^1 and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
S [181]->
Q [184] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1631]


This Proof Obligation:

[serial 1642]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Associativity: (b.c).a = a.b.c [serial 1611]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1646]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << ((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1 and 
(Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1642]

. . . done spltting timed atoms  [21.6 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [21.6 seconds ]
After "dist^" remaining 
Obligations:

[serial 1626]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]



[serial 1627]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]



[serial 1644]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = (ACTUAL_POSITION)^1 and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
S [181]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1630]



[serial 1645]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = (ACTUAL_POSITION)^1 and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
S [181]->
Q [184] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1631]



[serial 1646]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << ((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1 and 
(Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1642]


Done distributing ^ and @.
step:  51
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1646]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << ((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1 and 
(Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1642]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1647]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1646]

. . . done spltting timed atoms  [21.6 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [21.6 seconds ]
After "dist^" remaining 
Obligations:

[serial 1626]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]



[serial 1627]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]



[serial 1644]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = (ACTUAL_POSITION)^1 and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
S [181]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1630]



[serial 1645]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = (ACTUAL_POSITION)^1 and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
S [181]->
Q [184] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1631]



[serial 1647]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1646]


Done distributing ^ and @.
step:  52
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1647]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1646]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1648]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1))) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1647]

. . . done spltting timed atoms  [21.6 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [21.6 seconds ]
After "dist^" remaining 
Obligations:

[serial 1626]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]



[serial 1627]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]



[serial 1644]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = (ACTUAL_POSITION)^1 and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
S [181]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1630]



[serial 1645]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = (ACTUAL_POSITION)^1 and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
S [181]->
Q [184] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1631]



[serial 1648]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1))) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1647]


Done distributing ^ and @.
step:  53
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1644]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = (ACTUAL_POSITION)^1 and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
S [181]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1630]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1652]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for:   normalization of [serial 1644]


This Proof Obligation:

[serial 1645]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = (ACTUAL_POSITION)^1 and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
S [181]->
Q [184] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1631]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1654]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181]->
Q [184] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 1645]


This Proof Obligation:

[serial 1648]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1))) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1647]

  Normalization Axioms:

    Literal Arithmetic

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Constants are always the same
Has been normalized to get:

[serial 1656]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
  What for:   normalization of [serial 1648]

. . . done Normalizing Unsolved Proof Obligations [21.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1626]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]



[serial 1627]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]



[serial 1652]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for:   normalization of [serial 1644]



[serial 1654]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181]->
Q [184] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 1645]



[serial 1656]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
  What for:   normalization of [serial 1648]


Done Normalizing
step:  54
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1656]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1648]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1660]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1656]

. . . done spltting timed atoms  [21.7 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [21.7 seconds ]
After "dist^" remaining 
Obligations:

[serial 1626]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]



[serial 1627]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]



[serial 1652]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for:   normalization of [serial 1644]



[serial 1654]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181]->
Q [184] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 1645]



[serial 1660]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1656]


Done distributing ^ and @.
step:  55
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1660]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  Identity (id):  P->P is tautology
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1656]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [21.7 seconds ]
After "axioms" remaining 
Obligations:

[serial 1626]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]



[serial 1627]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]



[serial 1652]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for:   normalization of [serial 1644]



[serial 1654]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181]->
Q [184] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 1645]


Done trying to apply axioms
step:  56
****substitute all equivalents****
substituting all equals . . .
Replacing all "ACTUAL_POSITION" with  "0" in  "ASSERTION[1]" makes:
<< 0 <= 0 >>

This Proof Obligation:

[serial 1626]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  Substitution in Postcondition of All Equivalents in Precondition
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]

Has substituted in postcondition all equivalents in precondition to get:

[serial 1661]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [1] << 0 <= 0 >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1626]

Replacing all "ACTUAL_POSITION" with  "0" in  "ASSERTION[130]" makes:
<< 0 <= #PCS::MaxPosition >>

This Proof Obligation:

[serial 1627]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  Substitution in Postcondition of All Equivalents in Precondition
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]

Has substituted in postcondition all equivalents in precondition to get:

[serial 1662]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [130] << 0 <= #PCS::MaxPosition >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1627]

Replacing all "ACTUAL_POSITION" with  "0" in  "ASSERTION[1]" makes:
<< 0 <= 0 >>
Replacing all "ACTUAL_POSITION" with  "ACTUAL_POSITION^1" in  "ASSERTION[1]" makes:
<< 0 <= 0 >>

This Proof Obligation:

[serial 1652]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  Substitution in Postcondition of All Equivalents in Precondition
  What for:   normalization of [serial 1644]

Has substituted in postcondition all equivalents in precondition to get:

[serial 1663]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181]->
Q [1] << 0 <= 0 >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1652]

Replacing all "ACTUAL_POSITION" with  "0" in  "ASSERTION[184]" makes:
<< 0 <= #PCS::MaxPosition >>
Replacing all "ACTUAL_POSITION" with  "ACTUAL_POSITION^1" in  "ASSERTION[184]" makes:
<< 0 <= #PCS::MaxPosition >>

This Proof Obligation:

[serial 1654]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181]->
Q [184] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  Substitution in Postcondition of All Equivalents in Precondition
  What for:   normalization of [serial 1645]

Has substituted in postcondition all equivalents in precondition to get:

[serial 1664]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181]->
Q [184] << 0 <= #PCS::MaxPosition >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1654]

. . . done substituting all equals  [21.7 seconds ]
After substituting all equivalents remaining 
Obligations:

[serial 1661]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [1] << 0 <= 0 >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1626]



[serial 1662]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [130] << 0 <= #PCS::MaxPosition >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1627]



[serial 1663]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181]->
Q [1] << 0 <= 0 >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1652]



[serial 1664]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181]->
Q [184] << 0 <= #PCS::MaxPosition >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1654]


Done substituting all equivalents
step:  57
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1662]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [130] << 0 <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1627]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1664]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181]->
Q [184] << 0 <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1654]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [21.7 seconds ]
After "axioms" remaining 
Obligations:

[serial 1661]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [1] << 0 <= 0 >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1626]



[serial 1663]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181]->
Q [1] << 0 <= 0 >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1652]


Done trying to apply axioms
step:  58
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1661]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [1] << 0 <= 0 >>
Reason:  Partial Order Law 1:  a<=a by definition
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1626]

Has applied law "Partial Order Law 1:  a<=a by definition" to get:

[serial 1665]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [1] << true >>
  What for: Partial Order Law 1:  a<=a by definition [serial 1661]


This Proof Obligation:

[serial 1663]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181]->
Q [1] << 0 <= 0 >>
Reason:  Partial Order Law 1:  a<=a by definition
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1652]

Has applied law "Partial Order Law 1:  a<=a by definition" to get:

[serial 1666]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181]->
Q [1] << true >>
  What for: Partial Order Law 1:  a<=a by definition [serial 1663]

. . . done Applying Laws [21.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1665]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [1] << true >>
  What for: Partial Order Law 1:  a<=a by definition [serial 1661]



[serial 1666]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181]->
Q [1] << true >>
  What for: Partial Order Law 1:  a<=a by definition [serial 1663]


Done applying laws
step:  59
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1665]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174]->
Q [1] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Partial Order Law 1:  a<=a by definition [serial 1661]

Has been solved by True Conclusion Schema (tc): P->true

This Proof Obligation:

[serial 1666]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181]->
Q [1] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Partial Order Law 1:  a<=a by definition [serial 1663]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [21.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1010]: ControlSoftware::FragilePositionControlThread.SingleStep
P [159] << (E() and D() and ACTUAL_IN_RANGE()) >>
S [186]->
Q [161] << (E() and ACTUAL_IN_RANGE()) >>
  What for:  <<M(Run) and x>> -> <<M(Check)>> for fra1run:Run-[x]->Check{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  60
#[serial 1010]  <<M(Run) and x>> -> <<M(Check)>> for fra1run:Run-[x]->Check{};
step:  61
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1010]: ControlSoftware::FragilePositionControlThread.SingleStep
P [159] << (E() and D() and ACTUAL_IN_RANGE()) >>
S [186]->
Q [161] << (E() and ACTUAL_IN_RANGE()) >>
Reason:  Normalization
  What for:  <<M(Run) and x>> -> <<M(Check)>> for fra1run:Run-[x]->Check{};

  Normalization Axioms:

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1668]: ControlSoftware::FragilePositionControlThread.SingleStep
P [159] << ACTUAL_IN_RANGE() and D() and E() >>
S [186]->
Q [161] << ACTUAL_IN_RANGE() and E() >>
  What for:   normalization of [serial 1010]

. . . done Normalizing Unsolved Proof Obligations [21.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1668]: ControlSoftware::FragilePositionControlThread.SingleStep
P [159] << ACTUAL_IN_RANGE() and D() and E() >>
S [186]->
Q [161] << ACTUAL_IN_RANGE() and E() >>
  What for:   normalization of [serial 1010]


Done Normalizing
step:  62
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1668]: ControlSoftware::FragilePositionControlThread.SingleStep
P [159] << ACTUAL_IN_RANGE() and D() and E() >>
S [186]->
Q [161] << ACTUAL_IN_RANGE() and E() >>
Reason:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
  What for:   normalization of [serial 1010]

Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [21.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1011]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << (E() and ACTUAL_IN_RANGE() and ((((DESIRED_POSITION)^0 >= 0)) and (((DESIRED_POSITION)^0 <= #PCS::MaxPosition)))) >>
S [187]->
Q [163] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
  What for:  <<M(Check) and x>> -> <<M(Decide)>> for fra1ok:Check-[x]->Decide{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  63
#[serial 1011]  <<M(Check) and x>> -> <<M(Decide)>> for fra1ok:Check-[x]->Decide{};
step:  64
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1011]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << (E() and ACTUAL_IN_RANGE() and ((((DESIRED_POSITION)^0 >= 0)) and (((DESIRED_POSITION)^0 <= #PCS::MaxPosition)))) >>
S [187]->
Q [163] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Reason:  Substitution of Assertion Labels
  What for:  <<M(Check) and x>> -> <<M(Decide)>> for fra1ok:Check-[x]->Decide{};

Has substituted Assertions' predicates for labels to get:

[serial 1670]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << (((EstimatedActualPosition = ACTUAL_POSITION)) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((((DESIRED_POSITION)^0 >= 0)) and 
(((DESIRED_POSITION)^0 <= #PCS::MaxPosition)))) >>
S [187]->
Q [163] << (((EstimatedActualPosition = ACTUAL_POSITION)) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition))) >>
  What for: substituted Assertions' predicates for  labels  [serial 1011]

. . . done Substituting Assertions for Labels [21.7 seconds ]
After "substitute" remaining 
Obligations:

[serial 1670]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << (((EstimatedActualPosition = ACTUAL_POSITION)) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((((DESIRED_POSITION)^0 >= 0)) and 
(((DESIRED_POSITION)^0 <= #PCS::MaxPosition)))) >>
S [187]->
Q [163] << (((EstimatedActualPosition = ACTUAL_POSITION)) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition))) >>
  What for: substituted Assertions' predicates for  labels  [serial 1011]


Done substituting Assertion labels.
step:  65
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1670]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << (((EstimatedActualPosition = ACTUAL_POSITION)) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((((DESIRED_POSITION)^0 >= 0)) and 
(((DESIRED_POSITION)^0 <= #PCS::MaxPosition)))) >>
S [187]->
Q [163] << (((EstimatedActualPosition = ACTUAL_POSITION)) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition))) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1011]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1672]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= DESIRED_POSITION^0 and 
DESIRED_POSITION^0 <= #PCS::MaxPosition) and (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [187]->
Q [163] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 1670]

. . . done Normalizing Unsolved Proof Obligations [21.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1672]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= DESIRED_POSITION^0 and 
DESIRED_POSITION^0 <= #PCS::MaxPosition) and (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [187]->
Q [163] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 1670]


Done Normalizing
step:  66
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1672]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= DESIRED_POSITION^0 and 
DESIRED_POSITION^0 <= #PCS::MaxPosition) and (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [187]->
Q [163] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1670]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1674]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) and (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [187]->
Q [163] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1672]

. . . done spltting timed atoms  [21.7 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [21.7 seconds ]
After "dist^" remaining 
Obligations:

[serial 1674]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) and (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [187]->
Q [163] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1672]


Done distributing ^ and @.
step:  67
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1674]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) and (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [187]->
Q [163] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1672]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1675]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [187]->
Q [163] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 1674]

. . . done Applying Laws [21.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1675]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [187]->
Q [163] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 1674]


Done applying laws
step:  68
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1675]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [187]->
Q [163] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
  What for: Associativity: (b.c).a = a.b.c [serial 1674]

Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [21.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1012]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << (E() and ACTUAL_IN_RANGE() and (((((DESIRED_POSITION)^0 < 0))) or ((((DESIRED_POSITION)^0 > #PCS::MaxPosition))))) >>
S [189]->
Q [170] << true >>
  What for:  <<M(Check) and x>> -> <<M(Error)>> for fra1er:Check-[x]->Error{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  69
#[serial 1012]  <<M(Check) and x>> -> <<M(Error)>> for fra1er:Check-[x]->Error{};
step:  70
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1012]: ControlSoftware::FragilePositionControlThread.SingleStep
P [161] << (E() and ACTUAL_IN_RANGE() and (((((DESIRED_POSITION)^0 < 0))) or ((((DESIRED_POSITION)^0 > #PCS::MaxPosition))))) >>
S [189]->
Q [170] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for:  <<M(Check) and x>> -> <<M(Error)>> for fra1er:Check-[x]->Error{};

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [21.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1013]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 = EstimatedActualPosition))) >>
S [193]<< (E() and (DESIRED_POSITION = ACTUAL_POSITION) and ACTUAL_IN_RANGE()) >>
ActuatorCommand(pc:0)
<< (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E() and ACTUAL_IN_RANGE()) >>
;
Delta := 0
<< (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E() and ACTUAL_IN_RANGE() and ((Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
;
EstimatedActualPosition' := EstimatedActualPosition
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [159] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for fra2eq:Decide-[x]->Run{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  71
#[serial 1013]  <<M(Decide) and x>> A <<M(Run)>> for fra2eq:Decide-[x]->Run{A};
step:  72
****reduce****
This proof obligation:

[serial 1013]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 = EstimatedActualPosition))) >>
S [193]<< (E() and (DESIRED_POSITION = ACTUAL_POSITION) and ACTUAL_IN_RANGE()) >>
ActuatorCommand(pc:0)
<< (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E() and ACTUAL_IN_RANGE()) >>
;
Delta := 0
<< (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E() and ACTUAL_IN_RANGE() and ((Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
;
EstimatedActualPosition' := EstimatedActualPosition
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [159] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for fra2eq:Decide-[x]->Run{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P2>> S2 <<Q2>>
 
was reduced to:

[serial 1676]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 = EstimatedActualPosition))) >>
S [163]->
Q [15] << (E() and (DESIRED_POSITION = ACTUAL_POSITION) and ACTUAL_IN_RANGE()) >>
  What for: P -> P1 in sequential composition for [serial 1013]


[serial 1677]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [159]->
Q [15] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 1013]


[serial 1678]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and (DESIRED_POSITION = ACTUAL_POSITION) and ACTUAL_IN_RANGE()) >>
S [194]ActuatorCommand(pc:0)
Q [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E() and ACTUAL_IN_RANGE()) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1013]


[serial 1679]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E() and ACTUAL_IN_RANGE()) >>
S [197]Delta := 0
Q [15] << (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E() and ACTUAL_IN_RANGE() and 
((Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1013]


[serial 1680]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E() and ACTUAL_IN_RANGE() and 
((Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
S [201]EstimatedActualPosition' := EstimatedActualPosition
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1013]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1676]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 = EstimatedActualPosition))) >>
S [163]->
Q [15] << (E() and (DESIRED_POSITION = ACTUAL_POSITION) and ACTUAL_IN_RANGE()) >>
  What for: P -> P1 in sequential composition for [serial 1013]



[serial 1677]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [159]->
Q [15] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 1013]



[serial 1678]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and (DESIRED_POSITION = ACTUAL_POSITION) and ACTUAL_IN_RANGE()) >>
S [194]ActuatorCommand(pc:0)
Q [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E() and ACTUAL_IN_RANGE()) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1013]



[serial 1679]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E() and ACTUAL_IN_RANGE()) >>
S [197]Delta := 0
Q [15] << (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E() and ACTUAL_IN_RANGE() and 
((Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1013]



[serial 1680]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E() and ACTUAL_IN_RANGE() and 
((Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
S [201]EstimatedActualPosition' := EstimatedActualPosition
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1013]


done reducing composite actions
step:  73
****atomic****
applying atomic actions . . .
Creating weakest-precondition predicate transfer for subprogram invocation of "ActuatorCommand".
There must be occurrences of: 
  ACTUAL_POSITION = ACTUAL_POSITION'
 found in:
  << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E() and ACTUAL_IN_RANGE()) >>
 for invocation of "ActuatorCommand" on line 194 to have effect.
solving assignment on line 197
replacing "Delta" with "0"
makes:  << (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E() and ACTUAL_IN_RANGE() and 
((0 = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>

This Proof Obligation:

[serial 1679]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E() and ACTUAL_IN_RANGE()) >>
S [197]Delta := 0
Q [15] << (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E() and ACTUAL_IN_RANGE() and 
((Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1013]

Has applied := to get:

[serial 1681]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E() and ACTUAL_IN_RANGE()) >>
S [197]->
Q [15] << (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E() and ACTUAL_IN_RANGE() and 
((0 = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
  What for: applied wp for assignment [serial 1679]

solving assignment on line 201
replacing "EstimatedActualPosition'" with "EstimatedActualPosition"
makes:  << ((EstimatedActualPosition = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>

This Proof Obligation:

[serial 1680]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E() and ACTUAL_IN_RANGE() and 
((Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
S [201]EstimatedActualPosition' := EstimatedActualPosition
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1013]

Has applied := to get:

[serial 1682]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E() and ACTUAL_IN_RANGE() and 
((Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
S [201]->
Q [15] << ((EstimatedActualPosition = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
  What for: applied wp for assignment [serial 1680]

. . . done applying atomic actions [21.8 seconds ]
After "atomic" remaining 
Obligations:

[serial 1676]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 = EstimatedActualPosition))) >>
S [163]->
Q [15] << (E() and (DESIRED_POSITION = ACTUAL_POSITION) and ACTUAL_IN_RANGE()) >>
  What for: P -> P1 in sequential composition for [serial 1013]



[serial 1677]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [159]->
Q [15] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 1013]



[serial 1678]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and (DESIRED_POSITION = ACTUAL_POSITION) and ACTUAL_IN_RANGE()) >>
S [194]ActuatorCommand(pc:0)
Q [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E() and ACTUAL_IN_RANGE()) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1013]



[serial 1681]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E() and ACTUAL_IN_RANGE()) >>
S [197]->
Q [15] << (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E() and ACTUAL_IN_RANGE() and 
((0 = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
  What for: applied wp for assignment [serial 1679]



[serial 1682]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E() and ACTUAL_IN_RANGE() and 
((Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
S [201]->
Q [15] << ((EstimatedActualPosition = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
  What for: applied wp for assignment [serial 1680]


Done reducing atomic actions
step:  74
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1676]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 = EstimatedActualPosition))) >>
S [163]->
Q [15] << (E() and (DESIRED_POSITION = ACTUAL_POSITION) and ACTUAL_IN_RANGE()) >>
Reason:  Normalization
  What for: P -> P1 in sequential composition for [serial 1013]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1684]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [15] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E() >>
  What for:   normalization of [serial 1676]


This Proof Obligation:

[serial 1677]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [159]->
Q [15] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
Reason:  Normalization
  What for: Q2 -> Q in sequential composition for [serial 1013]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1686]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1677]


This Proof Obligation:

[serial 1678]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and (DESIRED_POSITION = ACTUAL_POSITION) and ACTUAL_IN_RANGE()) >>
S [194]ActuatorCommand(pc:0)
Q [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E() and ACTUAL_IN_RANGE()) >>
Reason:  Normalization
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1013]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1688]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E() >>
S [194]ActuatorCommand(pc:0)
Q [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E() >>
  What for:   normalization of [serial 1678]


This Proof Obligation:

[serial 1681]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E() and ACTUAL_IN_RANGE()) >>
S [197]->
Q [15] << (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E() and ACTUAL_IN_RANGE() and 
((0 = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
Reason:  Normalization
  What for: applied wp for assignment [serial 1679]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1690]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E() >>
S [197]->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION = ACTUAL_POSITION' and 
ACTUAL_IN_RANGE() and E() >>
  What for:   normalization of [serial 1681]


This Proof Obligation:

[serial 1682]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E() and ACTUAL_IN_RANGE() and 
((Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
S [201]->
Q [15] << ((EstimatedActualPosition = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: applied wp for assignment [serial 1680]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1692]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E() >>
S [201]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1682]

. . . done Normalizing Unsolved Proof Obligations [21.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1684]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [15] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E() >>
  What for:   normalization of [serial 1676]



[serial 1686]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1677]



[serial 1688]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E() >>
S [194]ActuatorCommand(pc:0)
Q [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E() >>
  What for:   normalization of [serial 1678]



[serial 1690]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E() >>
S [197]->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION = ACTUAL_POSITION' and 
ACTUAL_IN_RANGE() and E() >>
  What for:   normalization of [serial 1681]



[serial 1692]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E() >>
S [201]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1682]


Done Normalizing
step:  75
****atomic****
applying atomic actions . . .
Creating weakest-precondition predicate transfer for subprogram invocation of "ActuatorCommand".

This Proof Obligation:

[serial 1688]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E() >>
S [194]ActuatorCommand(pc:0)
Q [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E() >>
Reason:  Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
  What for:   normalization of [serial 1678]

Used weakest precondition predicate transformation on
+ <<P>> ActuatorCommand(X) <<Q>> to get:

[serial 1698]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E() >>
S [194]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and ACTUAL_IN_RANGE() and 
E() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1688]

. . . done applying atomic actions [21.8 seconds ]
After "atomic" remaining 
Obligations:

[serial 1684]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [15] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E() >>
  What for:   normalization of [serial 1676]



[serial 1686]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1677]



[serial 1698]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E() >>
S [194]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and ACTUAL_IN_RANGE() and 
E() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1688]



[serial 1690]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E() >>
S [197]->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION = ACTUAL_POSITION' and 
ACTUAL_IN_RANGE() and E() >>
  What for:   normalization of [serial 1681]



[serial 1692]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E() >>
S [201]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1682]


Done reducing atomic actions
step:  76
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1698]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E() >>
S [194]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and ACTUAL_IN_RANGE() and 
E() >>
Reason:  Associativity: (b.c).a = a.b.c
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1688]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1699]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E() >>
S [194]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_IN_RANGE() and 
E() >>
  What for: Associativity: (b.c).a = a.b.c [serial 1698]

. . . done Applying Laws [21.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1684]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [15] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E() >>
  What for:   normalization of [serial 1676]



[serial 1686]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1677]



[serial 1690]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E() >>
S [197]->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION = ACTUAL_POSITION' and 
ACTUAL_IN_RANGE() and E() >>
  What for:   normalization of [serial 1681]



[serial 1692]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E() >>
S [201]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1682]



[serial 1699]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E() >>
S [194]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_IN_RANGE() and 
E() >>
  What for: Associativity: (b.c).a = a.b.c [serial 1698]


Done applying laws
step:  77
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1684]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [15] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E() >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 1676]

Has substituted Assertions' predicates for labels to get:

[serial 1700]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [163]->
Q [15] << ACTUAL_POSITION = DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
  What for: substituted Assertions' predicates for  labels  [serial 1684]


This Proof Obligation:

[serial 1686]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 1677]

Has substituted Assertions' predicates for labels to get:

[serial 1701]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels  [serial 1686]


This Proof Obligation:

[serial 1690]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E() >>
S [197]->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION = ACTUAL_POSITION' and 
ACTUAL_IN_RANGE() and E() >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 1681]

Has substituted Assertions' predicates for labels to get:

[serial 1702]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [197]->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION = ACTUAL_POSITION' and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
  What for: substituted Assertions' predicates for  labels  [serial 1690]


This Proof Obligation:

[serial 1692]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E() >>
S [201]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 1682]

Has substituted Assertions' predicates for labels to get:

[serial 1703]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [201]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels  [serial 1692]


This Proof Obligation:

[serial 1699]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E() >>
S [194]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_IN_RANGE() and 
E() >>
Reason:  Substitution of Assertion Labels
  What for: Associativity: (b.c).a = a.b.c [serial 1698]

Has substituted Assertions' predicates for labels to get:

[serial 1704]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [194]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
  What for: substituted Assertions' predicates for  labels  [serial 1699]

. . . done Substituting Assertions for Labels [21.8 seconds ]
After "substitute" remaining 
Obligations:

[serial 1700]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [163]->
Q [15] << ACTUAL_POSITION = DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
  What for: substituted Assertions' predicates for  labels  [serial 1684]



[serial 1701]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels  [serial 1686]



[serial 1702]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [197]->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION = ACTUAL_POSITION' and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
  What for: substituted Assertions' predicates for  labels  [serial 1690]



[serial 1703]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [201]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels  [serial 1692]



[serial 1704]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [194]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
  What for: substituted Assertions' predicates for  labels  [serial 1699]


Done substituting Assertion labels.
step:  78
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1700]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [163]->
Q [15] << ACTUAL_POSITION = DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for: substituted Assertions' predicates for  labels  [serial 1684]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1705]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
(DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION^0 = EstimatedActualPosition and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [163]->
Q [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION = DESIRED_POSITION and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
  What for: Associativity: (b.c).a = a.b.c [serial 1700]


This Proof Obligation:

[serial 1701]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
Reason:  Associativity: (b.c).a = a.b.c
  What for: substituted Assertions' predicates for  labels  [serial 1686]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1706]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: Associativity: (b.c).a = a.b.c [serial 1701]


This Proof Obligation:

[serial 1702]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [197]->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION = ACTUAL_POSITION' and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for: substituted Assertions' predicates for  labels  [serial 1690]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1707]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [197]->
Q [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION = ACTUAL_POSITION' and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
  What for: Associativity: (b.c).a = a.b.c [serial 1702]


This Proof Obligation:

[serial 1703]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [201]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
Reason:  Associativity: (b.c).a = a.b.c
  What for: substituted Assertions' predicates for  labels  [serial 1692]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1708]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [201]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
  What for: Associativity: (b.c).a = a.b.c [serial 1703]


This Proof Obligation:

[serial 1704]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [194]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for: substituted Assertions' predicates for  labels  [serial 1699]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1709]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION = DESIRED_POSITION and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [194]->
Q [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
  What for: Associativity: (b.c).a = a.b.c [serial 1704]

. . . done Applying Laws [21.9 seconds ]
After "laws" remaining 
Obligations:

[serial 1705]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
(DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION^0 = EstimatedActualPosition and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [163]->
Q [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION = DESIRED_POSITION and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
  What for: Associativity: (b.c).a = a.b.c [serial 1700]



[serial 1706]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: Associativity: (b.c).a = a.b.c [serial 1701]



[serial 1707]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [197]->
Q [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION = ACTUAL_POSITION' and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
  What for: Associativity: (b.c).a = a.b.c [serial 1702]



[serial 1708]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [201]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
  What for: Associativity: (b.c).a = a.b.c [serial 1703]



[serial 1709]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION = DESIRED_POSITION and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [194]->
Q [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
  What for: Associativity: (b.c).a = a.b.c [serial 1704]


Done applying laws
step:  79
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1705]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
(DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION^0 = EstimatedActualPosition and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [163]->
Q [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION = DESIRED_POSITION and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 1700]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1711]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1705]


This Proof Obligation:

[serial 1706]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 1701]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1713]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
  What for:   normalization of [serial 1706]


This Proof Obligation:

[serial 1707]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [197]->
Q [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION = ACTUAL_POSITION' and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 1702]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1715]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [197]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1707]


This Proof Obligation:

[serial 1708]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [201]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 1703]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1717]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [201]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1708]


This Proof Obligation:

[serial 1709]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION = DESIRED_POSITION and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [194]->
Q [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 1704]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1719]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [194]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1709]

. . . done Normalizing Unsolved Proof Obligations [21.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1711]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1705]



[serial 1713]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
  What for:   normalization of [serial 1706]



[serial 1715]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [197]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1707]



[serial 1717]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [201]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1708]



[serial 1719]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [194]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1709]


Done Normalizing
step:  80
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1719]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [194]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  Law of And-Simplification:  P and P is P
  What for:   normalization of [serial 1709]

Has applied law "Law of And-Simplification:  P and P is P" to get:

[serial 1725]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [194]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Law of And-Simplification:  P and P is P [serial 1719]

. . . done Applying Laws [21.9 seconds ]
After "laws" remaining 
Obligations:

[serial 1711]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1705]



[serial 1713]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
  What for:   normalization of [serial 1706]



[serial 1715]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [197]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1707]



[serial 1717]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [201]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1708]



[serial 1725]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [194]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Law of And-Simplification:  P and P is P [serial 1719]


Done applying laws
step:  81
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1725]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [194]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
  What for: Law of And-Simplification:  P and P is P [serial 1719]

Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [21.9 seconds ]
After "axioms" remaining 
Obligations:

[serial 1711]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1705]



[serial 1713]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
  What for:   normalization of [serial 1706]



[serial 1715]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [197]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1707]



[serial 1717]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [201]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1708]


Done trying to apply axioms
step:  82
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1711]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1705]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1726]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1711]


This Proof Obligation:

[serial 1713]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1706]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1727]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << ((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1 and 
(Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1713]


This Proof Obligation:

[serial 1715]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [197]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1707]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1728]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = (ACTUAL_POSITION)^1 >>
S [197]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and 
ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = (ACTUAL_POSITION)^1 >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1715]


This Proof Obligation:

[serial 1717]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [201]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1708]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1729]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = (ACTUAL_POSITION)^1 and Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
S [201]->
Q [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and EstimatedActualPosition = (ACTUAL_POSITION)^1 >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1717]

. . . done spltting timed atoms  [22.0 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [22.0 seconds ]
After "dist^" remaining 
Obligations:

[serial 1726]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1711]



[serial 1727]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << ((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1 and 
(Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1713]



[serial 1728]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = (ACTUAL_POSITION)^1 >>
S [197]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and 
ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = (ACTUAL_POSITION)^1 >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1715]



[serial 1729]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = (ACTUAL_POSITION)^1 and Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
S [201]->
Q [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and EstimatedActualPosition = (ACTUAL_POSITION)^1 >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1717]


Done distributing ^ and @.
step:  83
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1727]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << ((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1 and 
(Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1713]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1730]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1727]

. . . done spltting timed atoms  [22.0 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [22.0 seconds ]
After "dist^" remaining 
Obligations:

[serial 1726]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1711]



[serial 1728]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = (ACTUAL_POSITION)^1 >>
S [197]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and 
ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = (ACTUAL_POSITION)^1 >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1715]



[serial 1729]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = (ACTUAL_POSITION)^1 and Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
S [201]->
Q [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and EstimatedActualPosition = (ACTUAL_POSITION)^1 >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1717]



[serial 1730]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1727]


Done distributing ^ and @.
step:  84
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1730]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1727]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1731]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1))) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1730]

. . . done spltting timed atoms  [22.0 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [22.0 seconds ]
After "dist^" remaining 
Obligations:

[serial 1726]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1711]



[serial 1728]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = (ACTUAL_POSITION)^1 >>
S [197]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and 
ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = (ACTUAL_POSITION)^1 >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1715]



[serial 1729]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = (ACTUAL_POSITION)^1 and Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
S [201]->
Q [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and EstimatedActualPosition = (ACTUAL_POSITION)^1 >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1717]



[serial 1731]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1))) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1730]


Done distributing ^ and @.
step:  85
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1726]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1711]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1733]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1726]


This Proof Obligation:

[serial 1728]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = (ACTUAL_POSITION)^1 >>
S [197]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and 
ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = (ACTUAL_POSITION)^1 >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1715]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1735]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
ACTUAL_POSITION^1 = ACTUAL_POSITION and ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1728]


This Proof Obligation:

[serial 1729]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = (ACTUAL_POSITION)^1 and Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
S [201]->
Q [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and EstimatedActualPosition = (ACTUAL_POSITION)^1 >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1717]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1737]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1729]


This Proof Obligation:

[serial 1731]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1))) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1730]

  Normalization Axioms:

    Literal Arithmetic

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Constants are always the same
Has been normalized to get:

[serial 1739]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
  What for:   normalization of [serial 1731]

. . . done Normalizing Unsolved Proof Obligations [22.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1733]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1726]



[serial 1735]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
ACTUAL_POSITION^1 = ACTUAL_POSITION and ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1728]



[serial 1737]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1729]



[serial 1739]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
  What for:   normalization of [serial 1731]


Done Normalizing
step:  86
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1739]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1731]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1744]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1739]

. . . done spltting timed atoms  [22.0 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [22.0 seconds ]
After "dist^" remaining 
Obligations:

[serial 1733]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1726]



[serial 1735]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
ACTUAL_POSITION^1 = ACTUAL_POSITION and ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1728]



[serial 1737]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 1729]



[serial 1744]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1739]


Done distributing ^ and @.
step:  87
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1733]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 1726]

Has split postcondition to get:

[serial 1745]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]


[serial 1746]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [25] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]


[serial 1747]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [193] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]


[serial 1748]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [152] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]


This Proof Obligation:

[serial 1735]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
ACTUAL_POSITION^1 = ACTUAL_POSITION and ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 1728]

Has split postcondition to get:

[serial 1749]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735]


[serial 1750]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [25] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735]


[serial 1751]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [199] << 0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735]


[serial 1752]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [198] << ACTUAL_POSITION^1 = ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735]


[serial 1753]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [152] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735]


This Proof Obligation:

[serial 1737]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 1729]

Has split postcondition to get:

[serial 1754]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [1] << 0 <= ACTUAL_POSITION^1 >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737]


[serial 1755]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [204] << ACTUAL_POSITION^1 <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737]


[serial 1756]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [202] << ACTUAL_POSITION^1 = EstimatedActualPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737]


[serial 1757]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [203] << Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737]


This Proof Obligation:

[serial 1744]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1739]

Has split postcondition to get:

[serial 1758]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [1] << 0 <= ACTUAL_POSITION^1 >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1744]


[serial 1759]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [25] << ACTUAL_POSITION^1 <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1744]


[serial 1760]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [152] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1744]


[serial 1761]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [154] << Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1744]

. . . done splitting postcondition  [22.1 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1745]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]



[serial 1746]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [25] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]



[serial 1747]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [193] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]



[serial 1748]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [152] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]



[serial 1749]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735]



[serial 1750]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [25] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735]



[serial 1751]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [199] << 0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735]



[serial 1752]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [198] << ACTUAL_POSITION^1 = ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735]



[serial 1753]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [152] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735]



[serial 1754]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [1] << 0 <= ACTUAL_POSITION^1 >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737]



[serial 1755]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [204] << ACTUAL_POSITION^1 <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737]



[serial 1756]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [202] << ACTUAL_POSITION^1 = EstimatedActualPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737]



[serial 1757]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [203] << Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737]



[serial 1758]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [1] << 0 <= ACTUAL_POSITION^1 >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1744]



[serial 1759]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [25] << ACTUAL_POSITION^1 <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1744]



[serial 1760]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [152] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1744]



[serial 1761]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [154] << Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1744]


Done splitting postcondition
step:  88
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1745]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1746]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [25] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1748]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [152] << ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1749]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1750]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [25] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1752]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [198] << ACTUAL_POSITION^1 = ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1753]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [152] << ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1757]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [203] << Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1758]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [1] << 0 <= ACTUAL_POSITION^1 >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1744]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1759]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [25] << ACTUAL_POSITION^1 <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1744]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1760]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [152] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1744]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1761]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [154] << Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1744]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [22.1 seconds ]
After "axioms" remaining 
Obligations:

[serial 1747]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [193] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]



[serial 1751]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [199] << 0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735]



[serial 1754]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [1] << 0 <= ACTUAL_POSITION^1 >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737]



[serial 1755]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [204] << ACTUAL_POSITION^1 <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737]



[serial 1756]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [202] << ACTUAL_POSITION^1 = EstimatedActualPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737]


Done trying to apply axioms
step:  89
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION^1" . . .
equality selected for substitution:  ACTUAL_POSITION^1 = ACTUAL_POSITION

This Proof Obligation:

[serial 1751]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [199] << 0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735]

Has substituted 
"ACTUAL_POSITION^1" with its = "ACTUAL_POSITION"
 to get:

[serial 1762]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [199] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "ACTUAL_POSITION" in its postcondition [serial 1751]

equality selected for substitution:  ACTUAL_POSITION^1 = ACTUAL_POSITION

This Proof Obligation:

[serial 1754]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [1] << 0 <= ACTUAL_POSITION^1 >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737]

Has substituted 
"ACTUAL_POSITION^1" with its = "ACTUAL_POSITION"
 to get:

[serial 1763]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "ACTUAL_POSITION" in its postcondition [serial 1754]

equality selected for substitution:  ACTUAL_POSITION^1 = ACTUAL_POSITION

This Proof Obligation:

[serial 1755]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [204] << ACTUAL_POSITION^1 <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737]

Has substituted 
"ACTUAL_POSITION^1" with its = "ACTUAL_POSITION"
 to get:

[serial 1764]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [204] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "ACTUAL_POSITION" in its postcondition [serial 1755]

equality selected for substitution:  ACTUAL_POSITION^1 = ACTUAL_POSITION

This Proof Obligation:

[serial 1756]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [202] << ACTUAL_POSITION^1 = EstimatedActualPosition >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737]

Has substituted 
"ACTUAL_POSITION^1" with its = "ACTUAL_POSITION"
 to get:

[serial 1765]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [202] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "ACTUAL_POSITION" in its postcondition [serial 1756]

. . . done guided substitution of equals  [22.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1747]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [193] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]



[serial 1762]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [199] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "ACTUAL_POSITION" in its postcondition [serial 1751]



[serial 1763]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "ACTUAL_POSITION" in its postcondition [serial 1754]



[serial 1764]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [204] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "ACTUAL_POSITION" in its postcondition [serial 1755]



[serial 1765]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [202] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "ACTUAL_POSITION" in its postcondition [serial 1756]


Done guided substituting an equals
step:  90
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1763]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "ACTUAL_POSITION" in its postcondition [serial 1754]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1764]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [204] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "ACTUAL_POSITION" in its postcondition [serial 1755]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1765]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201]->
Q [202] << ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "ACTUAL_POSITION" in its postcondition [serial 1756]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [22.1 seconds ]
After "axioms" remaining 
Obligations:

[serial 1747]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [193] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]



[serial 1762]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [199] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "ACTUAL_POSITION" in its postcondition [serial 1751]


Done trying to apply axioms
step:  91
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1762]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [199] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "ACTUAL_POSITION" in its postcondition [serial 1751]

  Normalization Axioms:

    Subtraction of Same:  a-a is 0

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1768]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [199] << 0 = 0 >>
  What for:   normalization of [serial 1762]

. . . done Normalizing Unsolved Proof Obligations [22.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1747]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [193] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]



[serial 1768]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [199] << 0 = 0 >>
  What for:   normalization of [serial 1762]


Done Normalizing
step:  92
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1768]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [199] << 0 = 0 >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 1762]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 1770]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [199] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1768]

. . . done Applying Laws [22.2 seconds ]
After "laws" remaining 
Obligations:

[serial 1747]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [193] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]



[serial 1770]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [199] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1768]


Done applying laws
step:  93
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1770]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197]->
Q [199] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 1768]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [22.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1747]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [193] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]


Done trying to apply axioms
step:  94
****substitute all equivalents****
substituting all equals . . .
Replacing all "ACTUAL_POSITION" with  "EstimatedActualPosition" in  "ASSERTION[193]" makes:
<< EstimatedActualPosition = DESIRED_POSITION >>
Replacing all "DESIRED_POSITION" with  "EstimatedActualPosition" in  "ASSERTION[193]" makes:
<< EstimatedActualPosition = EstimatedActualPosition >>

This Proof Obligation:

[serial 1747]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [193] << ACTUAL_POSITION = DESIRED_POSITION >>
Reason:  Substitution in Postcondition of All Equivalents in Precondition
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]

Has substituted in postcondition all equivalents in precondition to get:

[serial 1771]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [193] << EstimatedActualPosition = EstimatedActualPosition >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1747]

. . . done substituting all equals  [22.2 seconds ]
After substituting all equivalents remaining 
Obligations:

[serial 1771]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [193] << EstimatedActualPosition = EstimatedActualPosition >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1747]


Done substituting all equivalents
step:  95
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1771]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [193] << EstimatedActualPosition = EstimatedActualPosition >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1747]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 1772]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [193] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1771]

. . . done Applying Laws [22.2 seconds ]
After "laws" remaining 
Obligations:

[serial 1772]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [193] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1771]


Done applying laws
step:  96
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1772]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163]->
Q [193] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 1771]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [22.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1014]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition + 
1) <= (DESIRED_POSITION)^0))) >>
S [208]<< (((ACTUAL_POSITION + 1) <= DESIRED_POSITION) and E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Delta := 1
<< (E() and (DESIRED_POSITION >= (ACTUAL_POSITION + 1)) and (Delta = 1) and (ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LT(ACTUAL_POSITION) and ((ACTUAL_POSITION + 1) <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E() and (Delta = 1) and (ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition + Delta)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [159] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for fra3gt:Decide-[x]->Run{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  97
#[serial 1014]  <<M(Decide) and x>> A <<M(Run)>> for fra3gt:Decide-[x]->Run{A};
step:  98
****reduce****
This proof obligation:

[serial 1014]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition + 
1) <= (DESIRED_POSITION)^0))) >>
S [208]<< (((ACTUAL_POSITION + 1) <= DESIRED_POSITION) and E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Delta := 1
<< (E() and (DESIRED_POSITION >= (ACTUAL_POSITION + 1)) and (Delta = 1) and (ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LT(ACTUAL_POSITION) and ((ACTUAL_POSITION + 1) <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E() and (Delta = 1) and (ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition + Delta)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [159] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for fra3gt:Decide-[x]->Run{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P2>> S2 <<Q2>>
 
was reduced to:

[serial 1773]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition + 
1) <= (DESIRED_POSITION)^0))) >>
S [163]->
Q [15] << (((ACTUAL_POSITION + 1) <= DESIRED_POSITION) and E() and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE()) >>
  What for: P -> P1 in sequential composition for [serial 1014]


[serial 1774]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [159]->
Q [15] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 1014]


[serial 1775]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (((ACTUAL_POSITION + 1) <= DESIRED_POSITION) and E() and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE()) >>
S [210]Delta := 1
Q [15] << (E() and (DESIRED_POSITION >= (ACTUAL_POSITION + 1)) and (Delta = 1) and 
(ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LT(ACTUAL_POSITION) and 
((ACTUAL_POSITION + 1) <= #PCS::MaxPosition)) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1014]


[serial 1776]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and (DESIRED_POSITION >= (ACTUAL_POSITION + 1)) and (Delta = 1) and 
(ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LT(ACTUAL_POSITION) and 
((ACTUAL_POSITION + 1) <= #PCS::MaxPosition)) >>
S [216]ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E() and (Delta = 1) and 
(ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1014]


[serial 1777]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E() and (Delta = 1) and 
(ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
S [221]EstimatedActualPosition' := (EstimatedActualPosition + Delta)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1014]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1773]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition + 
1) <= (DESIRED_POSITION)^0))) >>
S [163]->
Q [15] << (((ACTUAL_POSITION + 1) <= DESIRED_POSITION) and E() and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE()) >>
  What for: P -> P1 in sequential composition for [serial 1014]



[serial 1774]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [159]->
Q [15] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 1014]



[serial 1775]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (((ACTUAL_POSITION + 1) <= DESIRED_POSITION) and E() and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE()) >>
S [210]Delta := 1
Q [15] << (E() and (DESIRED_POSITION >= (ACTUAL_POSITION + 1)) and (Delta = 1) and 
(ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LT(ACTUAL_POSITION) and 
((ACTUAL_POSITION + 1) <= #PCS::MaxPosition)) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1014]



[serial 1776]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and (DESIRED_POSITION >= (ACTUAL_POSITION + 1)) and (Delta = 1) and 
(ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LT(ACTUAL_POSITION) and 
((ACTUAL_POSITION + 1) <= #PCS::MaxPosition)) >>
S [216]ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E() and (Delta = 1) and 
(ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1014]



[serial 1777]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E() and (Delta = 1) and 
(ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
S [221]EstimatedActualPosition' := (EstimatedActualPosition + Delta)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1014]


done reducing composite actions
step:  99
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1773]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition + 
1) <= (DESIRED_POSITION)^0))) >>
S [163]->
Q [15] << (((ACTUAL_POSITION + 1) <= DESIRED_POSITION) and E() and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE()) >>
Reason:  Normalization
  What for: P -> P1 in sequential composition for [serial 1014]

  Normalization Axioms:

    Reflexivity of Addition: a+b=b+a

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1779]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
  What for:   normalization of [serial 1773]


This Proof Obligation:

[serial 1774]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [159]->
Q [15] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
Reason:  Normalization
  What for: Q2 -> Q in sequential composition for [serial 1014]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1781]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1774]


This Proof Obligation:

[serial 1775]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (((ACTUAL_POSITION + 1) <= DESIRED_POSITION) and E() and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE()) >>
S [210]Delta := 1
Q [15] << (E() and (DESIRED_POSITION >= (ACTUAL_POSITION + 1)) and (Delta = 1) and 
(ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LT(ACTUAL_POSITION) and 
((ACTUAL_POSITION + 1) <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1014]

  Normalization Axioms:

    Reflexivity of Addition: a+b=b+a

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1783]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210]Delta := 1
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
  What for:   normalization of [serial 1775]


This Proof Obligation:

[serial 1776]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and (DESIRED_POSITION >= (ACTUAL_POSITION + 1)) and (Delta = 1) and 
(ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LT(ACTUAL_POSITION) and 
((ACTUAL_POSITION + 1) <= #PCS::MaxPosition)) >>
S [216]ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E() and (Delta = 1) and 
(ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1014]

  Normalization Axioms:

    Reflexivity of Addition: a+b=b+a

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1785]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
S [216]ActuatorCommand(pc:Delta)
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E() >>
  What for:   normalization of [serial 1776]


This Proof Obligation:

[serial 1777]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E() and (Delta = 1) and 
(ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
S [221]EstimatedActualPosition' := (EstimatedActualPosition + Delta)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1014]

  Normalization Axioms:

    Reflexivity of Addition: a+b=b+a

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1787]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E() >>
S [221]EstimatedActualPosition' := (Delta + EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
  What for:   normalization of [serial 1777]

. . . done Normalizing Unsolved Proof Obligations [22.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1779]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
  What for:   normalization of [serial 1773]



[serial 1781]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1774]



[serial 1783]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210]Delta := 1
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
  What for:   normalization of [serial 1775]



[serial 1785]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
S [216]ActuatorCommand(pc:Delta)
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E() >>
  What for:   normalization of [serial 1776]



[serial 1787]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E() >>
S [221]EstimatedActualPosition' := (Delta + EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
  What for:   normalization of [serial 1777]


Done Normalizing
step:  100
****atomic****
applying atomic actions . . .
solving assignment on line 210
replacing "Delta" with "1"
makes:  << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = 1 and AXIOM_LT(ACTUAL_POSITION) and E() >>

This Proof Obligation:

[serial 1783]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210]Delta := 1
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for:   normalization of [serial 1775]

Has applied := to get:

[serial 1793]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = 1 and AXIOM_LT(ACTUAL_POSITION) and E() >>
  What for: applied wp for assignment [serial 1783]

Creating weakest-precondition predicate transfer for subprogram invocation of "ActuatorCommand".

This Proof Obligation:

[serial 1785]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
S [216]ActuatorCommand(pc:Delta)
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E() >>
Reason:  Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
  What for:   normalization of [serial 1776]

Used weakest precondition predicate transformation on
+ <<P>> ActuatorCommand(X) <<Q>> to get:

[serial 1794]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
S [216]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (0 <= (ACTUAL_POSITION + Delta) and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and E() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1785]

solving assignment on line 221
replacing "EstimatedActualPosition'" with "(Delta + EstimatedActualPosition)"
makes:  << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>

This Proof Obligation:

[serial 1787]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E() >>
S [221]EstimatedActualPosition' := (Delta + EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for:   normalization of [serial 1777]

Has applied := to get:

[serial 1795]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E() >>
S [221]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
  What for: applied wp for assignment [serial 1787]

. . . done applying atomic actions [22.3 seconds ]
After "atomic" remaining 
Obligations:

[serial 1779]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
  What for:   normalization of [serial 1773]



[serial 1781]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1774]



[serial 1793]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = 1 and AXIOM_LT(ACTUAL_POSITION) and E() >>
  What for: applied wp for assignment [serial 1783]



[serial 1794]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
S [216]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (0 <= (ACTUAL_POSITION + Delta) and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and E() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1785]



[serial 1795]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E() >>
S [221]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
  What for: applied wp for assignment [serial 1787]


Done reducing atomic actions
step:  101
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1793]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = 1 and AXIOM_LT(ACTUAL_POSITION) and E() >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for: applied wp for assignment [serial 1783]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 1796]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
true and AXIOM_LT(ACTUAL_POSITION) and E() >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1793]


This Proof Obligation:

[serial 1794]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
S [216]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (0 <= (ACTUAL_POSITION + Delta) and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and E() >>
Reason:  Associativity: (b.c).a = a.b.c
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1785]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1797]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
S [216]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and E() >>
  What for: Associativity: (b.c).a = a.b.c [serial 1794]


This Proof Obligation:

[serial 1796]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
true and AXIOM_LT(ACTUAL_POSITION) and E() >>
Reason:  Law of And-Simplification:  P and true is P
  What for: Equality Law (idistr):  a=a <-> true [serial 1793]

Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 1798]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
AXIOM_LT(ACTUAL_POSITION) and E() >>
  What for: Law of And-Simplification:  P and true is P [serial 1796]

. . . done Applying Laws [22.3 seconds ]
After "laws" remaining 
Obligations:

[serial 1779]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
  What for:   normalization of [serial 1773]



[serial 1781]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1774]



[serial 1795]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E() >>
S [221]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
  What for: applied wp for assignment [serial 1787]



[serial 1797]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
S [216]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and E() >>
  What for: Associativity: (b.c).a = a.b.c [serial 1794]



[serial 1798]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
AXIOM_LT(ACTUAL_POSITION) and E() >>
  What for: Law of And-Simplification:  P and true is P [serial 1796]


Done applying laws
step:  102
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1795]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E() >>
S [221]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
Reason:  Normalization
  What for: applied wp for assignment [serial 1787]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1802]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E() >>
S [221]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1795]


This Proof Obligation:

[serial 1797]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
S [216]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and E() >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 1794]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1804]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
S [216]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + 
Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and E() >>
  What for:   normalization of [serial 1797]

. . . done Normalizing Unsolved Proof Obligations [22.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1779]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
  What for:   normalization of [serial 1773]



[serial 1781]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1774]



[serial 1798]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
AXIOM_LT(ACTUAL_POSITION) and E() >>
  What for: Law of And-Simplification:  P and true is P [serial 1796]



[serial 1802]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E() >>
S [221]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1795]



[serial 1804]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
S [216]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + 
Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and E() >>
  What for:   normalization of [serial 1797]


Done Normalizing
step:  103
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1804]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
S [216]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + 
Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and E() >>
Reason:  Law of And-Simplification:  P and P is P
  What for:   normalization of [serial 1797]

Has applied law "Law of And-Simplification:  P and P is P" to get:

[serial 1808]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
S [216]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and E() >>
  What for: Law of And-Simplification:  P and P is P [serial 1804]

. . . done Applying Laws [22.3 seconds ]
After "laws" remaining 
Obligations:

[serial 1779]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
  What for:   normalization of [serial 1773]



[serial 1781]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1774]



[serial 1798]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
AXIOM_LT(ACTUAL_POSITION) and E() >>
  What for: Law of And-Simplification:  P and true is P [serial 1796]



[serial 1802]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E() >>
S [221]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1795]



[serial 1808]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
S [216]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and E() >>
  What for: Law of And-Simplification:  P and P is P [serial 1804]


Done applying laws
step:  104
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1798]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
AXIOM_LT(ACTUAL_POSITION) and E() >>
Reason:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
  What for: Law of And-Simplification:  P and true is P [serial 1796]

has been transformed into:

[serial 1809]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
true and E() >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


by removing axioms from postconditions.

. . . done removing axioms from postconditions  [22.3 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1779]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
  What for:   normalization of [serial 1773]



[serial 1781]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1774]



[serial 1802]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E() >>
S [221]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1795]



[serial 1808]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
S [216]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and E() >>
  What for: Law of And-Simplification:  P and P is P [serial 1804]



[serial 1809]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
true and E() >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 



Done removing axioms from postconditions
step:  105
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1809]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
true and E() >>
Reason:  Law of And-Simplification:  P and true is P
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 1810]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
E() >>
  What for: Law of And-Simplification:  P and true is P [serial 1809]

. . . done Applying Laws [22.3 seconds ]
After "laws" remaining 
Obligations:

[serial 1779]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
  What for:   normalization of [serial 1773]



[serial 1781]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1774]



[serial 1802]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E() >>
S [221]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1795]



[serial 1808]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
S [216]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and E() >>
  What for: Law of And-Simplification:  P and P is P [serial 1804]



[serial 1810]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
E() >>
  What for: Law of And-Simplification:  P and true is P [serial 1809]


Done applying laws
step:  106
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1779]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 1773]

Has substituted Assertions' predicates for labels to get:

[serial 1811]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [163]->
Q [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
  What for: substituted Assertions' predicates for  labels  [serial 1779]


This Proof Obligation:

[serial 1781]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 1774]

Has substituted Assertions' predicates for labels to get:

[serial 1812]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels  [serial 1781]


This Proof Obligation:

[serial 1802]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E() >>
S [221]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 1795]

Has substituted Assertions' predicates for labels to get:

[serial 1813]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [221]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels  [serial 1802]


This Proof Obligation:

[serial 1808]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
S [216]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and E() >>
Reason:  Substitution of Assertion Labels
  What for: Law of And-Simplification:  P and P is P [serial 1804]

Has substituted Assertions' predicates for labels to get:

[serial 1814]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ((ACTUAL_POSITION < (ACTUAL_POSITION + 1))) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [216]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
  What for: substituted Assertions' predicates for  labels  [serial 1808]


This Proof Obligation:

[serial 1810]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
E() >>
Reason:  Substitution of Assertion Labels
  What for: Law of And-Simplification:  P and true is P [serial 1809]

Has substituted Assertions' predicates for labels to get:

[serial 1815]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
  What for: substituted Assertions' predicates for  labels  [serial 1810]

. . . done Substituting Assertions for Labels [22.4 seconds ]
After "substitute" remaining 
Obligations:

[serial 1811]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [163]->
Q [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
  What for: substituted Assertions' predicates for  labels  [serial 1779]



[serial 1812]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels  [serial 1781]



[serial 1813]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [221]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels  [serial 1802]



[serial 1814]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ((ACTUAL_POSITION < (ACTUAL_POSITION + 1))) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [216]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
  What for: substituted Assertions' predicates for  labels  [serial 1808]



[serial 1815]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
  What for: substituted Assertions' predicates for  labels  [serial 1810]


Done substituting Assertion labels.
step:  107
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1811]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [163]->
Q [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1779]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1817]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [163]->
Q [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 1811]


This Proof Obligation:

[serial 1812]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1781]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1819]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
  What for:   normalization of [serial 1812]


This Proof Obligation:

[serial 1813]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [221]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1802]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1821]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1813]


This Proof Obligation:

[serial 1814]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ((ACTUAL_POSITION < (ACTUAL_POSITION + 1))) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [216]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1808]

  Normalization Axioms:

    Reflexivity of Addition: a+b=b+a

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1823]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1814]


This Proof Obligation:

[serial 1815]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1810]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1825]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1815]

. . . done Normalizing Unsolved Proof Obligations [22.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1817]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [163]->
Q [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 1811]



[serial 1819]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
  What for:   normalization of [serial 1812]



[serial 1821]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1813]



[serial 1823]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1814]



[serial 1825]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1815]


Done Normalizing
step:  108
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1817]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [163]->
Q [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1811]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1831]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 1817]


This Proof Obligation:

[serial 1819]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1812]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1832]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
  What for: Associativity: (b.c).a = a.b.c [serial 1819]


This Proof Obligation:

[serial 1825]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1815]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1833]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 1825]

. . . done Applying Laws [22.4 seconds ]
After "laws" remaining 
Obligations:

[serial 1821]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1813]



[serial 1823]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1814]



[serial 1831]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 1817]



[serial 1832]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
  What for: Associativity: (b.c).a = a.b.c [serial 1819]



[serial 1833]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 1825]


Done applying laws
step:  109
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1821]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 1813]

Has split postcondition to get:

[serial 1834]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1821]


[serial 1835]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [224] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1821]


[serial 1836]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [223] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1821]


[serial 1837]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [222] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1821]


This Proof Obligation:

[serial 1823]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 1814]

Has split postcondition to get:

[serial 1838]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]


[serial 1839]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]


[serial 1840]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]


[serial 1841]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [218] << 1 = Delta >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]


[serial 1842]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [152] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]


This Proof Obligation:

[serial 1831]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for: Associativity: (b.c).a = a.b.c [serial 1817]

Has split postcondition to get:

[serial 1843]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]


[serial 1844]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [25] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]


[serial 1845]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [1] << 0 <= DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]


[serial 1846]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [22] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]


[serial 1847]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [208] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]


[serial 1848]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [152] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]


This Proof Obligation:

[serial 1833]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for: Associativity: (b.c).a = a.b.c [serial 1825]

Has split postcondition to get:

[serial 1849]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]


[serial 1850]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [212] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]


[serial 1851]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [1] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]


[serial 1852]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]


[serial 1853]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [152] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]

. . . done splitting postcondition  [22.4 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1832]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
  What for: Associativity: (b.c).a = a.b.c [serial 1819]



[serial 1834]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1821]



[serial 1835]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [224] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1821]



[serial 1836]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [223] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1821]



[serial 1837]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [222] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1821]



[serial 1838]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]



[serial 1839]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]



[serial 1840]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]



[serial 1841]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [218] << 1 = Delta >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]



[serial 1842]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [152] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]



[serial 1843]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]



[serial 1844]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [25] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]



[serial 1845]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [1] << 0 <= DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]



[serial 1846]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [22] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]



[serial 1847]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [208] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]



[serial 1848]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [152] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]



[serial 1849]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]



[serial 1850]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [212] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]



[serial 1851]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [1] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]



[serial 1852]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]



[serial 1853]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [152] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]


Done splitting postcondition
step:  110
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1838]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1841]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [218] << 1 = Delta >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1842]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [152] << ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1843]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1844]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [25] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1845]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [1] << 0 <= DESIRED_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1846]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [22] << DESIRED_POSITION <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1848]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [152] << ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1849]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1850]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [212] << DESIRED_POSITION <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1851]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [1] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1853]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [152] << ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [22.5 seconds ]
After "axioms" remaining 
Obligations:

[serial 1832]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
  What for: Associativity: (b.c).a = a.b.c [serial 1819]



[serial 1834]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1821]



[serial 1835]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [224] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1821]



[serial 1836]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [223] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1821]



[serial 1837]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [222] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1821]



[serial 1839]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]



[serial 1840]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]



[serial 1847]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [208] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]



[serial 1852]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]


Done trying to apply axioms
step:  111
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1847]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [208] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
Reason:  Normalization
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1862]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [208] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
  What for:   normalization of [serial 1847]


This Proof Obligation:

[serial 1852]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1864]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 1852]

. . . done Normalizing Unsolved Proof Obligations [22.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 1832]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
  What for: Associativity: (b.c).a = a.b.c [serial 1819]



[serial 1834]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1821]



[serial 1835]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [224] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1821]



[serial 1836]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [223] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1821]



[serial 1837]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [222] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1821]



[serial 1839]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]



[serial 1840]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]



[serial 1862]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [208] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
  What for:   normalization of [serial 1847]



[serial 1864]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 1852]


Done Normalizing
step:  112
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  ACTUAL_POSITION' = EstimatedActualPosition'
equality selected for substitution:  (ACTUAL_POSITION + Delta) = ACTUAL_POSITION'

This Proof Obligation:

[serial 1834]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [1] << 0 <= ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1821]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 1867]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 1834]

equality selected for substitution:  (ACTUAL_POSITION + Delta) = ACTUAL_POSITION'

This Proof Obligation:

[serial 1835]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [224] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1821]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 1868]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [224] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 1835]

equality selected for substitution:  (ACTUAL_POSITION + Delta) = ACTUAL_POSITION'

This Proof Obligation:

[serial 1836]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [223] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1821]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 1869]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [223] << Delta = (((ACTUAL_POSITION + Delta)) - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 1836]

equality selected for substitution:  (ACTUAL_POSITION + Delta) = ACTUAL_POSITION'

This Proof Obligation:

[serial 1837]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [222] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1821]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 1870]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [222] << (Delta + EstimatedActualPosition) = ((ACTUAL_POSITION + Delta)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 1837]

. . . done guided substitution of equals  [22.5 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1832]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
Reason:  Guided Substitution of Equals
  What for: Associativity: (b.c).a = a.b.c [serial 1819]



[serial 1839]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]



[serial 1840]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]



[serial 1862]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [208] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
  What for:   normalization of [serial 1847]



[serial 1864]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 1852]



[serial 1867]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 1834]



[serial 1868]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [224] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 1835]



[serial 1869]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [223] << Delta = (((ACTUAL_POSITION + Delta)) - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 1836]



[serial 1870]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [222] << (Delta + EstimatedActualPosition) = ((ACTUAL_POSITION + Delta)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 1837]


Done guided substituting an equals
step:  113
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1867]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 1834]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1877]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 1867]


This Proof Obligation:

[serial 1868]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [224] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 1835]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1879]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [224] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 1868]


This Proof Obligation:

[serial 1869]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [223] << Delta = (((ACTUAL_POSITION + Delta)) - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 1836]

  Normalization Axioms:

    Subtaction of Added Value:  (a+b)-a is b

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1881]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [223] << Delta = Delta >>
  What for:   normalization of [serial 1869]


This Proof Obligation:

[serial 1870]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [222] << (Delta + EstimatedActualPosition) = ((ACTUAL_POSITION + Delta)) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 1837]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1883]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [222] << (ACTUAL_POSITION + Delta) = (Delta + EstimatedActualPosition) >>
  What for:   normalization of [serial 1870]

. . . done Normalizing Unsolved Proof Obligations [22.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 1832]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
Reason:  Guided Substitution of Equals
  What for: Associativity: (b.c).a = a.b.c [serial 1819]



[serial 1839]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]



[serial 1840]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]



[serial 1862]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [208] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
  What for:   normalization of [serial 1847]



[serial 1864]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 1852]



[serial 1877]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 1867]



[serial 1879]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [224] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 1868]



[serial 1881]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [223] << Delta = Delta >>
  What for:   normalization of [serial 1869]



[serial 1883]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [222] << (ACTUAL_POSITION + Delta) = (Delta + EstimatedActualPosition) >>
  What for:   normalization of [serial 1870]


Done Normalizing
step:  114
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1881]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [223] << Delta = Delta >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 1869]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 1888]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [223] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1881]

Law2.removeCommonTermFromAdd:  
^{= 
 ^{( ACTUAL_POSITION )} 
 ^{( EstimatedActualPosition )}}

This Proof Obligation:

[serial 1883]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [222] << (ACTUAL_POSITION + Delta) = (Delta + EstimatedActualPosition) >>
Reason:  Add both sides of equality:  a=b -> x+a=x+b
  What for:   normalization of [serial 1870]

Has applied law "Add both sides of equality:  a=b -> x+a=x+b" to get:

[serial 1889]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [222] << (ACTUAL_POSITION) = (EstimatedActualPosition) >>
  What for: Add both sides of equality:  a=b -> x+a=x+b [serial 1883]

. . . done Applying Laws [22.6 seconds ]
After "laws" remaining 
Obligations:

[serial 1832]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
Reason:  Guided Substitution of Equals
  What for: Associativity: (b.c).a = a.b.c [serial 1819]



[serial 1839]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]



[serial 1840]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]



[serial 1862]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [208] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
  What for:   normalization of [serial 1847]



[serial 1864]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 1852]



[serial 1877]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 1867]



[serial 1879]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [224] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 1868]



[serial 1888]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [223] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1881]



[serial 1889]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [222] << (ACTUAL_POSITION) = (EstimatedActualPosition) >>
  What for: Add both sides of equality:  a=b -> x+a=x+b [serial 1883]


Done applying laws
step:  115
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1877]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1867]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1879]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [224] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1868]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1888]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [223] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 1881]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [22.6 seconds ]
After "axioms" remaining 
Obligations:

[serial 1832]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
Reason:  Guided Substitution of Equals
  What for: Associativity: (b.c).a = a.b.c [serial 1819]



[serial 1839]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]



[serial 1840]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]



[serial 1862]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [208] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
  What for:   normalization of [serial 1847]



[serial 1864]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 1852]



[serial 1889]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [222] << (ACTUAL_POSITION) = (EstimatedActualPosition) >>
  What for: Add both sides of equality:  a=b -> x+a=x+b [serial 1883]


Done trying to apply axioms
step:  116
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition -> 0 <= #PCS::MaxPosition

This Proof Obligation:

[serial 1832]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for: Associativity: (b.c).a = a.b.c [serial 1819]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 1890]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' and 0 <= #PCS::MaxPosition >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
  What for: Transitivity: x<y and y<z -> x<z [serial 1832]

Transitivity:  0 <= ACTUAL_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) -> 0 < (1 + ACTUAL_POSITION)
Transitivity:  ACTUAL_POSITION < (1 + ACTUAL_POSITION) and (1 + ACTUAL_POSITION) <= DESIRED_POSITION -> ACTUAL_POSITION < DESIRED_POSITION
Transitivity:  0 < (1 + ACTUAL_POSITION) and (1 + ACTUAL_POSITION) <= DESIRED_POSITION -> 0 < DESIRED_POSITION
Transitivity:  ACTUAL_POSITION < (1 + ACTUAL_POSITION) and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition -> ACTUAL_POSITION < #PCS::MaxPosition
Transitivity:  0 < (1 + ACTUAL_POSITION) and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition -> 0 < #PCS::MaxPosition

This Proof Obligation:

[serial 1839]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 1891]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) and 0 < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < DESIRED_POSITION and 
0 < DESIRED_POSITION and ACTUAL_POSITION < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [216]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Transitivity: x<y and y<z -> x<z [serial 1839]

Transitivity:  0 <= ACTUAL_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) -> 0 < (1 + ACTUAL_POSITION)
Transitivity:  ACTUAL_POSITION < (1 + ACTUAL_POSITION) and (1 + ACTUAL_POSITION) <= DESIRED_POSITION -> ACTUAL_POSITION < DESIRED_POSITION
Transitivity:  0 < (1 + ACTUAL_POSITION) and (1 + ACTUAL_POSITION) <= DESIRED_POSITION -> 0 < DESIRED_POSITION
Transitivity:  ACTUAL_POSITION < (1 + ACTUAL_POSITION) and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition -> ACTUAL_POSITION < #PCS::MaxPosition
Transitivity:  0 < (1 + ACTUAL_POSITION) and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition -> 0 < #PCS::MaxPosition

This Proof Obligation:

[serial 1840]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 1892]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) and 0 < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < DESIRED_POSITION and 
0 < DESIRED_POSITION and ACTUAL_POSITION < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Transitivity: x<y and y<z -> x<z [serial 1840]

Transitivity:  0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition -> 0 <= #PCS::MaxPosition

This Proof Obligation:

[serial 1862]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [208] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for:   normalization of [serial 1847]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 1893]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition and 0 <= #PCS::MaxPosition >>
S [163]->
Q [208] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
  What for: Transitivity: x<y and y<z -> x<z [serial 1862]

Transitivity:  0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition -> 0 <= #PCS::MaxPosition
Transitivity:  (1 + ACTUAL_POSITION) <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition -> (1 + ACTUAL_POSITION) <= #PCS::MaxPosition

This Proof Obligation:

[serial 1864]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for:   normalization of [serial 1852]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 1894]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and 0 <= #PCS::MaxPosition and 
(1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
S [210]->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for: Transitivity: x<y and y<z -> x<z [serial 1864]

Transitivity:  0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition -> 0 <= #PCS::MaxPosition

This Proof Obligation:

[serial 1889]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [222] << (ACTUAL_POSITION) = (EstimatedActualPosition) >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for: Add both sides of equality:  a=b -> x+a=x+b [serial 1883]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 1895]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 0 <= #PCS::MaxPosition >>
S [221]->
Q [222] << (ACTUAL_POSITION) = (EstimatedActualPosition) >>
  What for: Transitivity: x<y and y<z -> x<z [serial 1889]

. . . done adding transitive terms [22.6 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 1890]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' and 0 <= #PCS::MaxPosition >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
  What for: Transitivity: x<y and y<z -> x<z [serial 1832]



[serial 1891]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) and 0 < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < DESIRED_POSITION and 
0 < DESIRED_POSITION and ACTUAL_POSITION < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [216]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Transitivity: x<y and y<z -> x<z [serial 1839]



[serial 1892]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) and 0 < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < DESIRED_POSITION and 
0 < DESIRED_POSITION and ACTUAL_POSITION < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Transitivity: x<y and y<z -> x<z [serial 1840]



[serial 1893]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition and 0 <= #PCS::MaxPosition >>
S [163]->
Q [208] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
  What for: Transitivity: x<y and y<z -> x<z [serial 1862]



[serial 1894]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and 0 <= #PCS::MaxPosition and 
(1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
S [210]->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for: Transitivity: x<y and y<z -> x<z [serial 1864]



[serial 1895]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 0 <= #PCS::MaxPosition >>
S [221]->
Q [222] << (ACTUAL_POSITION) = (EstimatedActualPosition) >>
  What for: Transitivity: x<y and y<z -> x<z [serial 1889]


Done adding transitive relations
step:  117
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1890]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' and 0 <= #PCS::MaxPosition >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
Reason:  Normalization
  What for: Transitivity: x<y and y<z -> x<z [serial 1832]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1897]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
  What for:   normalization of [serial 1890]


This Proof Obligation:

[serial 1891]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) and 0 < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < DESIRED_POSITION and 
0 < DESIRED_POSITION and ACTUAL_POSITION < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [216]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Normalization
  What for: Transitivity: x<y and y<z -> x<z [serial 1839]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1899]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 
0 < (1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 1891]


This Proof Obligation:

[serial 1892]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) and 0 < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < DESIRED_POSITION and 
0 < DESIRED_POSITION and ACTUAL_POSITION < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Transitivity: x<y and y<z -> x<z [serial 1840]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1901]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 
0 < (1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 1892]


This Proof Obligation:

[serial 1893]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition and 0 <= #PCS::MaxPosition >>
S [163]->
Q [208] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
Reason:  Normalization
  What for: Transitivity: x<y and y<z -> x<z [serial 1862]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1903]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
(1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [208] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
  What for:   normalization of [serial 1893]


This Proof Obligation:

[serial 1894]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and 0 <= #PCS::MaxPosition and 
(1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
S [210]->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Transitivity: x<y and y<z -> x<z [serial 1864]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1905]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
(1 + ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 1894]


This Proof Obligation:

[serial 1895]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 0 <= #PCS::MaxPosition >>
S [221]->
Q [222] << (ACTUAL_POSITION) = (EstimatedActualPosition) >>
Reason:  Normalization
  What for: Transitivity: x<y and y<z -> x<z [serial 1889]

  Normalization Axioms:

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1907]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [222] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1895]

. . . done Normalizing Unsolved Proof Obligations [22.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1897]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
  What for:   normalization of [serial 1890]



[serial 1899]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 
0 < (1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 1891]



[serial 1901]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 
0 < (1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 1892]



[serial 1903]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
(1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [208] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
  What for:   normalization of [serial 1893]



[serial 1905]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
(1 + ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 1894]



[serial 1907]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [222] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 1895]


Done Normalizing
step:  118
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1905]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
(1 + ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210]->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1894]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1907]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221]->
Q [222] << ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 1895]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [22.7 seconds ]
After "axioms" remaining 
Obligations:

[serial 1897]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
  What for:   normalization of [serial 1890]



[serial 1899]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 
0 < (1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 1891]



[serial 1901]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 
0 < (1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 1892]



[serial 1903]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
(1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [208] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
  What for:   normalization of [serial 1893]


Done trying to apply axioms
step:  119
****partial to total order****
Making partial orders into total orders . . .
Making partial orders into total orders . . .

This Proof Obligation:

[serial 1899]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 
0 < (1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Partial Order Law 2:  (1+a)<=b  is  a<b
  What for:   normalization of [serial 1891]

Has applied Partial Order Law 2:  (1+a)<=b  is  a<b ((1+ACTUAL_POSITION)<=DESIRED_POSITION  is  ACTUAL_POSITION<DESIRED_POSITION
(1+ACTUAL_POSITION)<=#PCS::MaxPosition  is  ACTUAL_POSITION<#PCS::MaxPosition
  0<=(-ACTUAL_POSITION+Delta)  is  0<Delta
) to get:

[serial 1914]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < DESIRED_POSITION and 0 < (1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [1] << 0 < Delta >>
  What for: (1+ACTUAL_POSITION)<=DESIRED_POSITION  is  ACTUAL_POSITION<DESIRED_POSITION
(1+ACTUAL_POSITION)<=#PCS::MaxPosition  is  ACTUAL_POSITION<#PCS::MaxPosition
  0<=(-ACTUAL_POSITION+Delta)  is  0<Delta

Partial Order Law 2:  (1+a)<=b  is  a<b [serial 1899]


This Proof Obligation:

[serial 1901]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 
0 < (1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  Partial Order Law 2:  (1+a)<=b  is  a<b
  What for:   normalization of [serial 1892]

Has applied Partial Order Law 2:  (1+a)<=b  is  a<b ((1+ACTUAL_POSITION)<=DESIRED_POSITION  is  ACTUAL_POSITION<DESIRED_POSITION
(1+ACTUAL_POSITION)<=#PCS::MaxPosition  is  ACTUAL_POSITION<#PCS::MaxPosition
  ) to get:

[serial 1915]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < DESIRED_POSITION and 0 < (1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: (1+ACTUAL_POSITION)<=DESIRED_POSITION  is  ACTUAL_POSITION<DESIRED_POSITION
(1+ACTUAL_POSITION)<=#PCS::MaxPosition  is  ACTUAL_POSITION<#PCS::MaxPosition
  
Partial Order Law 2:  (1+a)<=b  is  a<b [serial 1901]


This Proof Obligation:

[serial 1903]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
(1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [208] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
Reason:  Partial Order Law 2:  (1+a)<=b  is  a<b
  What for:   normalization of [serial 1893]

Has applied Partial Order Law 2:  (1+a)<=b  is  a<b ((1+EstimatedActualPosition)<=DESIRED_POSITION^0  is  EstimatedActualPosition<DESIRED_POSITION^0
  (1+ACTUAL_POSITION)<=DESIRED_POSITION  is  ACTUAL_POSITION<DESIRED_POSITION
) to get:

[serial 1916]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
EstimatedActualPosition < DESIRED_POSITION^0 and ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [208] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: (1+EstimatedActualPosition)<=DESIRED_POSITION^0  is  EstimatedActualPosition<DESIRED_POSITION^0
  (1+ACTUAL_POSITION)<=DESIRED_POSITION  is  ACTUAL_POSITION<DESIRED_POSITION

Partial Order Law 2:  (1+a)<=b  is  a<b [serial 1903]

. . . done making partial orders into total orders [22.7 seconds ]
After making partial orders into total orders 
Obligations:

[serial 1897]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
  What for:   normalization of [serial 1890]



[serial 1914]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < DESIRED_POSITION and 0 < (1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [1] << 0 < Delta >>
  What for: (1+ACTUAL_POSITION)<=DESIRED_POSITION  is  ACTUAL_POSITION<DESIRED_POSITION
(1+ACTUAL_POSITION)<=#PCS::MaxPosition  is  ACTUAL_POSITION<#PCS::MaxPosition
  0<=(-ACTUAL_POSITION+Delta)  is  0<Delta

Partial Order Law 2:  (1+a)<=b  is  a<b [serial 1899]



[serial 1915]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < DESIRED_POSITION and 0 < (1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: (1+ACTUAL_POSITION)<=DESIRED_POSITION  is  ACTUAL_POSITION<DESIRED_POSITION
(1+ACTUAL_POSITION)<=#PCS::MaxPosition  is  ACTUAL_POSITION<#PCS::MaxPosition
  
Partial Order Law 2:  (1+a)<=b  is  a<b [serial 1901]



[serial 1916]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
EstimatedActualPosition < DESIRED_POSITION^0 and ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [208] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: (1+EstimatedActualPosition)<=DESIRED_POSITION^0  is  EstimatedActualPosition<DESIRED_POSITION^0
  (1+ACTUAL_POSITION)<=DESIRED_POSITION  is  ACTUAL_POSITION<DESIRED_POSITION

Partial Order Law 2:  (1+a)<=b  is  a<b [serial 1903]


Done making partial orders into total orders
step:  120
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1897]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1890]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1917]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << ((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1 and 
(Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1897]


This Proof Obligation:

[serial 1916]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
EstimatedActualPosition < DESIRED_POSITION^0 and ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [208] << ACTUAL_POSITION < DESIRED_POSITION >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: (1+EstimatedActualPosition)<=DESIRED_POSITION^0  is  EstimatedActualPosition<DESIRED_POSITION^0
  (1+ACTUAL_POSITION)<=DESIRED_POSITION  is  ACTUAL_POSITION<DESIRED_POSITION

Partial Order Law 2:  (1+a)<=b  is  a<b [serial 1903]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1918]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
EstimatedActualPosition < DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [208] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1916]

. . . done spltting timed atoms  [22.7 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [22.7 seconds ]
After "dist^" remaining 
Obligations:

[serial 1914]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < DESIRED_POSITION and 0 < (1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [1] << 0 < Delta >>
  What for: (1+ACTUAL_POSITION)<=DESIRED_POSITION  is  ACTUAL_POSITION<DESIRED_POSITION
(1+ACTUAL_POSITION)<=#PCS::MaxPosition  is  ACTUAL_POSITION<#PCS::MaxPosition
  0<=(-ACTUAL_POSITION+Delta)  is  0<Delta

Partial Order Law 2:  (1+a)<=b  is  a<b [serial 1899]



[serial 1915]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < DESIRED_POSITION and 0 < (1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: (1+ACTUAL_POSITION)<=DESIRED_POSITION  is  ACTUAL_POSITION<DESIRED_POSITION
(1+ACTUAL_POSITION)<=#PCS::MaxPosition  is  ACTUAL_POSITION<#PCS::MaxPosition
  
Partial Order Law 2:  (1+a)<=b  is  a<b [serial 1901]



[serial 1917]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << ((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1 and 
(Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1897]



[serial 1918]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
EstimatedActualPosition < DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [208] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1916]


Done distributing ^ and @.
step:  121
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1917]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << ((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1 and 
(Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1897]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1919]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1917]

. . . done spltting timed atoms  [22.8 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [22.8 seconds ]
After "dist^" remaining 
Obligations:

[serial 1914]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < DESIRED_POSITION and 0 < (1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [1] << 0 < Delta >>
  What for: (1+ACTUAL_POSITION)<=DESIRED_POSITION  is  ACTUAL_POSITION<DESIRED_POSITION
(1+ACTUAL_POSITION)<=#PCS::MaxPosition  is  ACTUAL_POSITION<#PCS::MaxPosition
  0<=(-ACTUAL_POSITION+Delta)  is  0<Delta

Partial Order Law 2:  (1+a)<=b  is  a<b [serial 1899]



[serial 1915]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < DESIRED_POSITION and 0 < (1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: (1+ACTUAL_POSITION)<=DESIRED_POSITION  is  ACTUAL_POSITION<DESIRED_POSITION
(1+ACTUAL_POSITION)<=#PCS::MaxPosition  is  ACTUAL_POSITION<#PCS::MaxPosition
  
Partial Order Law 2:  (1+a)<=b  is  a<b [serial 1901]



[serial 1918]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
EstimatedActualPosition < DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [208] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1916]



[serial 1919]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1917]


Done distributing ^ and @.
step:  122
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1919]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1917]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1920]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1))) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1919]

. . . done spltting timed atoms  [22.8 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [22.8 seconds ]
After "dist^" remaining 
Obligations:

[serial 1914]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < DESIRED_POSITION and 0 < (1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [1] << 0 < Delta >>
  What for: (1+ACTUAL_POSITION)<=DESIRED_POSITION  is  ACTUAL_POSITION<DESIRED_POSITION
(1+ACTUAL_POSITION)<=#PCS::MaxPosition  is  ACTUAL_POSITION<#PCS::MaxPosition
  0<=(-ACTUAL_POSITION+Delta)  is  0<Delta

Partial Order Law 2:  (1+a)<=b  is  a<b [serial 1899]



[serial 1915]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < DESIRED_POSITION and 0 < (1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: (1+ACTUAL_POSITION)<=DESIRED_POSITION  is  ACTUAL_POSITION<DESIRED_POSITION
(1+ACTUAL_POSITION)<=#PCS::MaxPosition  is  ACTUAL_POSITION<#PCS::MaxPosition
  
Partial Order Law 2:  (1+a)<=b  is  a<b [serial 1901]



[serial 1918]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
EstimatedActualPosition < DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [208] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1916]



[serial 1920]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1))) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1919]


Done distributing ^ and @.
step:  123
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1914]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < DESIRED_POSITION and 0 < (1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [1] << 0 < Delta >>
Reason:  Normalization
  What for: (1+ACTUAL_POSITION)<=DESIRED_POSITION  is  ACTUAL_POSITION<DESIRED_POSITION
(1+ACTUAL_POSITION)<=#PCS::MaxPosition  is  ACTUAL_POSITION<#PCS::MaxPosition
  0<=(-ACTUAL_POSITION+Delta)  is  0<Delta

Partial Order Law 2:  (1+a)<=b  is  a<b [serial 1899]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1922]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [1] << 0 < Delta >>
  What for:   normalization of [serial 1914]


This Proof Obligation:

[serial 1915]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < DESIRED_POSITION and 0 < (1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: (1+ACTUAL_POSITION)<=DESIRED_POSITION  is  ACTUAL_POSITION<DESIRED_POSITION
(1+ACTUAL_POSITION)<=#PCS::MaxPosition  is  ACTUAL_POSITION<#PCS::MaxPosition
  
Partial Order Law 2:  (1+a)<=b  is  a<b [serial 1901]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1924]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 1915]


This Proof Obligation:

[serial 1918]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
EstimatedActualPosition < DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [208] << ACTUAL_POSITION < DESIRED_POSITION >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1916]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1926]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and EstimatedActualPosition < DESIRED_POSITION >>
S [163]->
Q [208] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for:   normalization of [serial 1918]


This Proof Obligation:

[serial 1920]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= #PCS::MaxPosition and 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1))) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1919]

  Normalization Axioms:

    Literal Arithmetic

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Constants are always the same
Has been normalized to get:

[serial 1928]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and 0 <= #PCS::MaxPosition and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
  What for:   normalization of [serial 1920]

. . . done Normalizing Unsolved Proof Obligations [22.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1922]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [1] << 0 < Delta >>
  What for:   normalization of [serial 1914]



[serial 1924]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 1915]



[serial 1926]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and EstimatedActualPosition < DESIRED_POSITION >>
S [163]->
Q [208] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for:   normalization of [serial 1918]



[serial 1928]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and 0 <= #PCS::MaxPosition and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
  What for:   normalization of [serial 1920]


Done Normalizing
step:  124
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 1928]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and 0 <= #PCS::MaxPosition and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 1920]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 1933]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and 0 <= #PCS::MaxPosition and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1928]

. . . done spltting timed atoms  [22.8 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [22.8 seconds ]
After "dist^" remaining 
Obligations:

[serial 1922]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [1] << 0 < Delta >>
  What for:   normalization of [serial 1914]



[serial 1924]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 1915]



[serial 1926]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and EstimatedActualPosition < DESIRED_POSITION >>
S [163]->
Q [208] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for:   normalization of [serial 1918]



[serial 1933]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and 0 <= #PCS::MaxPosition and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1928]


Done distributing ^ and @.
step:  125
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1933]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and 0 <= #PCS::MaxPosition and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1928]

Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [22.8 seconds ]
After "axioms" remaining 
Obligations:

[serial 1922]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [1] << 0 < Delta >>
  What for:   normalization of [serial 1914]



[serial 1924]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 1915]



[serial 1926]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and EstimatedActualPosition < DESIRED_POSITION >>
S [163]->
Q [208] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for:   normalization of [serial 1918]


Done trying to apply axioms
step:  126
****substitute all equivalents****
substituting all equals . . .
Replacing all "Delta" with  "1" in  "ASSERTION[1]" makes:
<< 0 < 1 >>

This Proof Obligation:

[serial 1922]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [1] << 0 < Delta >>
Reason:  Substitution in Postcondition of All Equivalents in Precondition
  What for:   normalization of [serial 1914]

Has substituted in postcondition all equivalents in precondition to get:

[serial 1934]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [1] << 0 < 1 >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1922]

Replacing all "Delta" with  "1" in  "ASSERTION[130]" makes:
<< (ACTUAL_POSITION + 1) <= #PCS::MaxPosition >>
Replacing all "ACTUAL_POSITION" with  "EstimatedActualPosition" in  "ASSERTION[130]" makes:
<< (EstimatedActualPosition + 1) <= #PCS::MaxPosition >>

This Proof Obligation:

[serial 1924]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  Substitution in Postcondition of All Equivalents in Precondition
  What for:   normalization of [serial 1915]

Has substituted in postcondition all equivalents in precondition to get:

[serial 1935]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (EstimatedActualPosition + 1) <= #PCS::MaxPosition >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1924]

Replacing all "ACTUAL_POSITION" with  "EstimatedActualPosition" in  "ASSERTION[208]" makes:
<< EstimatedActualPosition < DESIRED_POSITION >>

This Proof Obligation:

[serial 1926]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and EstimatedActualPosition < DESIRED_POSITION >>
S [163]->
Q [208] << ACTUAL_POSITION < DESIRED_POSITION >>
Reason:  Substitution in Postcondition of All Equivalents in Precondition
  What for:   normalization of [serial 1918]

Has substituted in postcondition all equivalents in precondition to get:

[serial 1936]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and EstimatedActualPosition < DESIRED_POSITION >>
S [163]->
Q [208] << EstimatedActualPosition < DESIRED_POSITION >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1926]

. . . done substituting all equals  [22.8 seconds ]
After substituting all equivalents remaining 
Obligations:

[serial 1934]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [1] << 0 < 1 >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1922]



[serial 1935]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (EstimatedActualPosition + 1) <= #PCS::MaxPosition >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1924]



[serial 1936]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and EstimatedActualPosition < DESIRED_POSITION >>
S [163]->
Q [208] << EstimatedActualPosition < DESIRED_POSITION >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1926]


Done substituting all equivalents
step:  127
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1934]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [1] << 0 < 1 >>
Reason:  Law of And-Simplification:  P and P is P
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1922]

Has applied law "Law of And-Simplification:  P and P is P" to get:

[serial 1937]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [1] << 0 < 1 >>
  What for: Law of And-Simplification:  P and P is P [serial 1934]


This Proof Obligation:

[serial 1935]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (EstimatedActualPosition + 1) <= #PCS::MaxPosition >>
Reason:  Law of And-Simplification:  P and P is P
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1924]

Has applied law "Law of And-Simplification:  P and P is P" to get:

[serial 1938]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (EstimatedActualPosition + 1) <= #PCS::MaxPosition >>
  What for: Law of And-Simplification:  P and P is P [serial 1935]


This Proof Obligation:

[serial 1937]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [1] << 0 < 1 >>
Reason:  Literal Value Comparison
  What for: Law of And-Simplification:  P and P is P [serial 1934]

Has applied law "Literal Value Comparison" to get:

[serial 1939]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [1] << true >>
  What for: Literal Value Comparison [serial 1937]

. . . done Applying Laws [22.9 seconds ]
After "laws" remaining 
Obligations:

[serial 1936]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and EstimatedActualPosition < DESIRED_POSITION >>
S [163]->
Q [208] << EstimatedActualPosition < DESIRED_POSITION >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1926]



[serial 1938]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (EstimatedActualPosition + 1) <= #PCS::MaxPosition >>
  What for: Law of And-Simplification:  P and P is P [serial 1935]



[serial 1939]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [1] << true >>
  What for: Literal Value Comparison [serial 1937]


Done applying laws
step:  128
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1936]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and EstimatedActualPosition < DESIRED_POSITION >>
S [163]->
Q [208] << EstimatedActualPosition < DESIRED_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1926]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1939]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [1] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Literal Value Comparison [serial 1937]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [22.9 seconds ]
After "axioms" remaining 
Obligations:

[serial 1938]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (EstimatedActualPosition + 1) <= #PCS::MaxPosition >>
  What for: Law of And-Simplification:  P and P is P [serial 1935]


Done trying to apply axioms
step:  129
****substitute all equivalents****
substituting all equals . . .
Replacing all "EstimatedActualPosition" with  "ACTUAL_POSITION" in  "ASSERTION[130]" makes:
<< (ACTUAL_POSITION + 1) <= #PCS::MaxPosition >>

This Proof Obligation:

[serial 1938]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (EstimatedActualPosition + 1) <= #PCS::MaxPosition >>
Reason:  Substitution in Postcondition of All Equivalents in Precondition
  What for: Law of And-Simplification:  P and P is P [serial 1935]

Has substituted in postcondition all equivalents in precondition to get:

[serial 1940]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (ACTUAL_POSITION + 1) <= #PCS::MaxPosition >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1938]

. . . done substituting all equals  [22.9 seconds ]
After substituting all equivalents remaining 
Obligations:

[serial 1940]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (ACTUAL_POSITION + 1) <= #PCS::MaxPosition >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1938]


Done substituting all equivalents
step:  130
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1940]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (ACTUAL_POSITION + 1) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1938]

  Normalization Axiom:

    Reflexivity of Addition: a+b=b+a
Has been normalized to get:

[serial 1942]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 1940]

. . . done Normalizing Unsolved Proof Obligations [22.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1942]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 1940]


Done Normalizing
step:  131
****partial to total order****
Making partial orders into total orders . . .
Making partial orders into total orders . . .

This Proof Obligation:

[serial 1942]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
Reason:  Partial Order Law 2:  (1+a)<=b  is  a<b
  What for:   normalization of [serial 1940]

Has applied Partial Order Law 2:  (1+a)<=b  is  a<b (  (1+ACTUAL_POSITION)<=#PCS::MaxPosition  is  ACTUAL_POSITION<#PCS::MaxPosition
) to get:

[serial 1944]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << ACTUAL_POSITION < #PCS::MaxPosition >>
  What for:   (1+ACTUAL_POSITION)<=#PCS::MaxPosition  is  ACTUAL_POSITION<#PCS::MaxPosition

Partial Order Law 2:  (1+a)<=b  is  a<b [serial 1942]

. . . done making partial orders into total orders [22.9 seconds ]
After making partial orders into total orders 
Obligations:

[serial 1944]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << ACTUAL_POSITION < #PCS::MaxPosition >>
  What for:   (1+ACTUAL_POSITION)<=#PCS::MaxPosition  is  ACTUAL_POSITION<#PCS::MaxPosition

Partial Order Law 2:  (1+a)<=b  is  a<b [serial 1942]


Done making partial orders into total orders
step:  132
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1944]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216]->
Q [130] << ACTUAL_POSITION < #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   (1+ACTUAL_POSITION)<=#PCS::MaxPosition  is  ACTUAL_POSITION<#PCS::MaxPosition

Partial Order Law 2:  (1+a)<=b  is  a<b [serial 1942]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [22.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1015]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 <= (EstimatedActualPosition - 1)))) >>
S [228]<< ((DESIRED_POSITION <= (ACTUAL_POSITION - 1)) and E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Delta := -1
<< (E() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= DESIRED_POSITION) and AXIOM_GT(ACTUAL_POSITION) and (DESIRED_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and ((ACTUAL_POSITION + Delta) >= 0) and E() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition + Delta)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [159] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for fra4lt:Decide-[x]->Run{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  133
#[serial 1015]  <<M(Decide) and x>> A <<M(Run)>> for fra4lt:Decide-[x]->Run{A};
step:  134
****reduce****
This proof obligation:

[serial 1015]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 <= (EstimatedActualPosition - 1)))) >>
S [228]<< ((DESIRED_POSITION <= (ACTUAL_POSITION - 1)) and E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Delta := -1
<< (E() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= DESIRED_POSITION) and AXIOM_GT(ACTUAL_POSITION) and (DESIRED_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and ((ACTUAL_POSITION + Delta) >= 0) and E() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition + Delta)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [159] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for fra4lt:Decide-[x]->Run{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P2>> S2 <<Q2>>
 
was reduced to:

[serial 1945]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 <= (EstimatedActualPosition - 1)))) >>
S [163]->
Q [15] << ((DESIRED_POSITION <= (ACTUAL_POSITION - 1)) and E() and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE()) >>
  What for: P -> P1 in sequential composition for [serial 1015]


[serial 1946]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [159]->
Q [15] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 1015]


[serial 1947]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((DESIRED_POSITION <= (ACTUAL_POSITION - 1)) and E() and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE()) >>
S [230]Delta := -1
Q [15] << (E() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= DESIRED_POSITION) and 
AXIOM_GT(ACTUAL_POSITION) and (DESIRED_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1015]


[serial 1948]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= DESIRED_POSITION) and 
AXIOM_GT(ACTUAL_POSITION) and (DESIRED_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) >>
S [235]ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and 
((ACTUAL_POSITION + Delta) >= 0) and E() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1015]


[serial 1949]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and 
((ACTUAL_POSITION + Delta) >= 0) and E() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
S [240]EstimatedActualPosition' := (EstimatedActualPosition + Delta)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1015]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1945]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 <= (EstimatedActualPosition - 1)))) >>
S [163]->
Q [15] << ((DESIRED_POSITION <= (ACTUAL_POSITION - 1)) and E() and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE()) >>
  What for: P -> P1 in sequential composition for [serial 1015]



[serial 1946]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [159]->
Q [15] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 1015]



[serial 1947]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((DESIRED_POSITION <= (ACTUAL_POSITION - 1)) and E() and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE()) >>
S [230]Delta := -1
Q [15] << (E() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= DESIRED_POSITION) and 
AXIOM_GT(ACTUAL_POSITION) and (DESIRED_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1015]



[serial 1948]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= DESIRED_POSITION) and 
AXIOM_GT(ACTUAL_POSITION) and (DESIRED_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) >>
S [235]ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and 
((ACTUAL_POSITION + Delta) >= 0) and E() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1015]



[serial 1949]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and 
((ACTUAL_POSITION + Delta) >= 0) and E() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
S [240]EstimatedActualPosition' := (EstimatedActualPosition + Delta)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1015]


done reducing composite actions
step:  135
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1945]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 <= (EstimatedActualPosition - 1)))) >>
S [163]->
Q [15] << ((DESIRED_POSITION <= (ACTUAL_POSITION - 1)) and E() and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE()) >>
Reason:  Normalization
  What for: P -> P1 in sequential composition for [serial 1015]

  Normalization Axioms:

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1951]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
  What for:   normalization of [serial 1945]


This Proof Obligation:

[serial 1946]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [159]->
Q [15] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
Reason:  Normalization
  What for: Q2 -> Q in sequential composition for [serial 1015]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1953]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1946]


This Proof Obligation:

[serial 1947]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((DESIRED_POSITION <= (ACTUAL_POSITION - 1)) and E() and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE()) >>
S [230]Delta := -1
Q [15] << (E() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= DESIRED_POSITION) and 
AXIOM_GT(ACTUAL_POSITION) and (DESIRED_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1015]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1955]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]Delta := -1
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
  What for:   normalization of [serial 1947]


This Proof Obligation:

[serial 1948]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= DESIRED_POSITION) and 
AXIOM_GT(ACTUAL_POSITION) and (DESIRED_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) >>
S [235]ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and 
((ACTUAL_POSITION + Delta) >= 0) and E() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1015]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1957]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]ActuatorCommand(pc:Delta)
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
  What for:   normalization of [serial 1948]


This Proof Obligation:

[serial 1949]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and 
((ACTUAL_POSITION + Delta) >= 0) and E() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
S [240]EstimatedActualPosition' := (EstimatedActualPosition + Delta)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1015]

  Normalization Axioms:

    Reflexivity of Addition: a+b=b+a

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1959]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]EstimatedActualPosition' := (Delta + EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
  What for:   normalization of [serial 1949]

. . . done Normalizing Unsolved Proof Obligations [22.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1951]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
  What for:   normalization of [serial 1945]



[serial 1953]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1946]



[serial 1955]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]Delta := -1
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
  What for:   normalization of [serial 1947]



[serial 1957]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]ActuatorCommand(pc:Delta)
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
  What for:   normalization of [serial 1948]



[serial 1959]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]EstimatedActualPosition' := (Delta + EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
  What for:   normalization of [serial 1949]


Done Normalizing
step:  136
****atomic****
applying atomic actions . . .
solving assignment on line 230
replacing "Delta" with "-1"
makes:  << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = -1 and AXIOM_GT(ACTUAL_POSITION) and E() >>

This Proof Obligation:

[serial 1955]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]Delta := -1
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for:   normalization of [serial 1947]

Has applied := to get:

[serial 1965]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = -1 and AXIOM_GT(ACTUAL_POSITION) and E() >>
  What for: applied wp for assignment [serial 1955]

Creating weakest-precondition predicate transfer for subprogram invocation of "ActuatorCommand".

This Proof Obligation:

[serial 1957]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]ActuatorCommand(pc:Delta)
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
Reason:  Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
  What for:   normalization of [serial 1948]

Used weakest precondition predicate transformation on
+ <<P>> ActuatorCommand(X) <<Q>> to get:

[serial 1966]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and 
E() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1957]

solving assignment on line 240
replacing "EstimatedActualPosition'" with "(Delta + EstimatedActualPosition)"
makes:  << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>

This Proof Obligation:

[serial 1959]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]EstimatedActualPosition' := (Delta + EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for:   normalization of [serial 1949]

Has applied := to get:

[serial 1967]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
  What for: applied wp for assignment [serial 1959]

. . . done applying atomic actions [23.0 seconds ]
After "atomic" remaining 
Obligations:

[serial 1951]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
  What for:   normalization of [serial 1945]



[serial 1953]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1946]



[serial 1965]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = -1 and AXIOM_GT(ACTUAL_POSITION) and E() >>
  What for: applied wp for assignment [serial 1955]



[serial 1966]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and 
E() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1957]



[serial 1967]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
  What for: applied wp for assignment [serial 1959]


Done reducing atomic actions
step:  137
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1965]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = -1 and AXIOM_GT(ACTUAL_POSITION) and E() >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for: applied wp for assignment [serial 1955]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 1968]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
true and AXIOM_GT(ACTUAL_POSITION) and E() >>
  What for: Equality Law (idistr):  a=a <-> true [serial 1965]


This Proof Obligation:

[serial 1966]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and 
E() >>
Reason:  Associativity: (b.c).a = a.b.c
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1957]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 1969]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and E() >>
  What for: Associativity: (b.c).a = a.b.c [serial 1966]


This Proof Obligation:

[serial 1968]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
true and AXIOM_GT(ACTUAL_POSITION) and E() >>
Reason:  Law of And-Simplification:  P and true is P
  What for: Equality Law (idistr):  a=a <-> true [serial 1965]

Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 1970]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
AXIOM_GT(ACTUAL_POSITION) and E() >>
  What for: Law of And-Simplification:  P and true is P [serial 1968]

. . . done Applying Laws [23.0 seconds ]
After "laws" remaining 
Obligations:

[serial 1951]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
  What for:   normalization of [serial 1945]



[serial 1953]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1946]



[serial 1967]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
  What for: applied wp for assignment [serial 1959]



[serial 1969]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and E() >>
  What for: Associativity: (b.c).a = a.b.c [serial 1966]



[serial 1970]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
AXIOM_GT(ACTUAL_POSITION) and E() >>
  What for: Law of And-Simplification:  P and true is P [serial 1968]


Done applying laws
step:  138
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1967]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
Reason:  Normalization
  What for: applied wp for assignment [serial 1959]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1974]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1967]


This Proof Obligation:

[serial 1969]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and E() >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 1966]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1976]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + Delta) and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and E() >>
  What for:   normalization of [serial 1969]

. . . done Normalizing Unsolved Proof Obligations [23.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1951]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
  What for:   normalization of [serial 1945]



[serial 1953]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1946]



[serial 1970]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
AXIOM_GT(ACTUAL_POSITION) and E() >>
  What for: Law of And-Simplification:  P and true is P [serial 1968]



[serial 1974]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1967]



[serial 1976]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + Delta) and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and E() >>
  What for:   normalization of [serial 1969]


Done Normalizing
step:  139
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1970]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
AXIOM_GT(ACTUAL_POSITION) and E() >>
Reason:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
  What for: Law of And-Simplification:  P and true is P [serial 1968]

has been transformed into:

[serial 1980]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
true and E() >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


by removing axioms from postconditions.

. . . done removing axioms from postconditions  [23.0 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1951]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
  What for:   normalization of [serial 1945]



[serial 1953]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1946]



[serial 1974]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1967]



[serial 1976]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + Delta) and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and E() >>
  What for:   normalization of [serial 1969]



[serial 1980]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
true and E() >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 



Done removing axioms from postconditions
step:  140
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1976]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + Delta) and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and E() >>
Reason:  Law of And-Simplification:  P and P is P
  What for:   normalization of [serial 1969]

Has applied law "Law of And-Simplification:  P and P is P" to get:

[serial 1981]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and E() >>
  What for: Law of And-Simplification:  P and P is P [serial 1976]


This Proof Obligation:

[serial 1980]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
true and E() >>
Reason:  Law of And-Simplification:  P and true is P
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 1982]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
E() >>
  What for: Law of And-Simplification:  P and true is P [serial 1980]

. . . done Applying Laws [23.0 seconds ]
After "laws" remaining 
Obligations:

[serial 1951]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
  What for:   normalization of [serial 1945]



[serial 1953]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1946]



[serial 1974]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 1967]



[serial 1981]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and E() >>
  What for: Law of And-Simplification:  P and P is P [serial 1976]



[serial 1982]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
E() >>
  What for: Law of And-Simplification:  P and true is P [serial 1980]


Done applying laws
step:  141
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1951]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 1945]

Has split postcondition to get:

[serial 1983]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1951]


[serial 1984]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [229] << ACTUAL_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1951]


[serial 1985]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [229] << DESIRED_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1951]


[serial 1986]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [229] << E() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1951]


This Proof Obligation:

[serial 1974]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 1967]

Has split postcondition to get:

[serial 1987]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1974]


[serial 1988]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [243] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1974]


[serial 1989]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [242] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1974]


[serial 1990]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [241] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1974]


This Proof Obligation:

[serial 1981]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and E() >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for: Law of And-Simplification:  P and P is P [serial 1976]

Has split postcondition to get:

[serial 1991]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1981]


[serial 1992]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1981]


[serial 1993]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [236] << -1 = Delta >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1981]


[serial 1994]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [237] << E() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1981]


This Proof Obligation:

[serial 1982]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
E() >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for: Law of And-Simplification:  P and true is P [serial 1980]

Has split postcondition to get:

[serial 1995]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [1] << 0 <= DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1982]


[serial 1996]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [233] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1982]


[serial 1997]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [1] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1982]


[serial 1998]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [231] << E() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1982]

. . . done splitting postcondition  [23.0 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1953]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1946]



[serial 1983]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1951]



[serial 1984]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [229] << ACTUAL_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1951]



[serial 1985]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [229] << DESIRED_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1951]



[serial 1986]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [229] << E() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1951]



[serial 1987]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1974]



[serial 1988]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [243] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1974]



[serial 1989]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [242] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1974]



[serial 1990]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [241] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1974]



[serial 1991]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1981]



[serial 1992]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1981]



[serial 1993]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [236] << -1 = Delta >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1981]



[serial 1994]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [237] << E() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1981]



[serial 1995]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [1] << 0 <= DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1982]



[serial 1996]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [233] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1982]



[serial 1997]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [1] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1982]



[serial 1998]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [231] << E() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1982]


Done splitting postcondition
step:  142
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1984]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [229] << ACTUAL_IN_RANGE() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1951]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1985]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [229] << DESIRED_IN_RANGE() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1951]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1986]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [229] << E() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1951]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1993]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [236] << -1 = Delta >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1981]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1994]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [237] << E() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1981]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1997]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [1] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1982]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1998]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [231] << E() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1982]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [23.0 seconds ]
After "axioms" remaining 
Obligations:

[serial 1953]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
  What for:   normalization of [serial 1946]



[serial 1983]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1951]



[serial 1987]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1974]



[serial 1988]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [243] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1974]



[serial 1989]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [242] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1974]



[serial 1990]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [241] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1974]



[serial 1991]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1981]



[serial 1992]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1981]



[serial 1995]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [1] << 0 <= DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1982]



[serial 1996]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [233] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1982]


Done trying to apply axioms
step:  143
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1953]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 1946]

Has substituted Assertions' predicates for labels to get:

[serial 1999]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels  [serial 1953]


This Proof Obligation:

[serial 1983]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1951]

Has substituted Assertions' predicates for labels to get:

[serial 2000]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for: substituted Assertions' predicates for  labels  [serial 1983]


This Proof Obligation:

[serial 1987]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [1] << 0 <= ACTUAL_POSITION' >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1974]

Has substituted Assertions' predicates for labels to get:

[serial 2001]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [240]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels  [serial 1987]


This Proof Obligation:

[serial 1988]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [243] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1974]

Has substituted Assertions' predicates for labels to get:

[serial 2002]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [240]->
Q [243] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels  [serial 1988]


This Proof Obligation:

[serial 1989]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [242] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1974]

Has substituted Assertions' predicates for labels to get:

[serial 2003]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [240]->
Q [242] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: substituted Assertions' predicates for  labels  [serial 1989]


This Proof Obligation:

[serial 1990]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240]->
Q [241] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1974]

Has substituted Assertions' predicates for labels to get:

[serial 2004]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [240]->
Q [241] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels  [serial 1990]


This Proof Obligation:

[serial 1991]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1981]

Has substituted Assertions' predicates for labels to get:

[serial 2005]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and (((ACTUAL_POSITION - 1) < ACTUAL_POSITION)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: substituted Assertions' predicates for  labels  [serial 1991]


This Proof Obligation:

[serial 1992]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1981]

Has substituted Assertions' predicates for labels to get:

[serial 2006]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and (((ACTUAL_POSITION - 1) < ACTUAL_POSITION)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels  [serial 1992]


This Proof Obligation:

[serial 1995]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [1] << 0 <= DESIRED_POSITION >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1982]

Has substituted Assertions' predicates for labels to get:

[serial 2007]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [230]->
Q [1] << 0 <= DESIRED_POSITION >>
  What for: substituted Assertions' predicates for  labels  [serial 1995]


This Proof Obligation:

[serial 1996]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230]->
Q [233] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1982]

Has substituted Assertions' predicates for labels to get:

[serial 2008]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [230]->
Q [233] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels  [serial 1996]

. . . done Substituting Assertions for Labels [23.1 seconds ]
After "substitute" remaining 
Obligations:

[serial 1999]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels  [serial 1953]



[serial 2000]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for: substituted Assertions' predicates for  labels  [serial 1983]



[serial 2001]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [240]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels  [serial 1987]



[serial 2002]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [240]->
Q [243] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels  [serial 1988]



[serial 2003]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [240]->
Q [242] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: substituted Assertions' predicates for  labels  [serial 1989]



[serial 2004]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [240]->
Q [241] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels  [serial 1990]



[serial 2005]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and (((ACTUAL_POSITION - 1) < ACTUAL_POSITION)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: substituted Assertions' predicates for  labels  [serial 1991]



[serial 2006]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and (((ACTUAL_POSITION - 1) < ACTUAL_POSITION)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels  [serial 1992]



[serial 2007]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [230]->
Q [1] << 0 <= DESIRED_POSITION >>
  What for: substituted Assertions' predicates for  labels  [serial 1995]



[serial 2008]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [230]->
Q [233] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels  [serial 1996]


Done substituting Assertion labels.
step:  144
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1999]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1953]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2010]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
  What for:   normalization of [serial 1999]


This Proof Obligation:

[serial 2000]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1983]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2012]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for:   normalization of [serial 2000]


This Proof Obligation:

[serial 2001]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [240]->
Q [1] << 0 <= ACTUAL_POSITION' >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1987]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2014]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [240]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for:   normalization of [serial 2001]


This Proof Obligation:

[serial 2002]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [240]->
Q [243] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1988]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2016]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [240]->
Q [243] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2002]


This Proof Obligation:

[serial 2003]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [240]->
Q [242] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1989]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2018]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [240]->
Q [242] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 2003]


This Proof Obligation:

[serial 2004]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [240]->
Q [241] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1990]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2020]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [240]->
Q [241] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2004]


This Proof Obligation:

[serial 2005]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and (((ACTUAL_POSITION - 1) < ACTUAL_POSITION)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1991]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2022]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2005]


This Proof Obligation:

[serial 2006]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and (((ACTUAL_POSITION - 1) < ACTUAL_POSITION)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1992]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2024]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2006]


This Proof Obligation:

[serial 2007]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [230]->
Q [1] << 0 <= DESIRED_POSITION >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1995]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2026]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [230]->
Q [1] << 0 <= DESIRED_POSITION >>
  What for:   normalization of [serial 2007]


This Proof Obligation:

[serial 2008]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [230]->
Q [233] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1996]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2028]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [230]->
Q [233] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2008]

. . . done Normalizing Unsolved Proof Obligations [23.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 2010]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
  What for:   normalization of [serial 1999]



[serial 2012]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for:   normalization of [serial 2000]



[serial 2014]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [240]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for:   normalization of [serial 2001]



[serial 2016]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [240]->
Q [243] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2002]



[serial 2018]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [240]->
Q [242] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 2003]



[serial 2020]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [240]->
Q [241] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2004]



[serial 2022]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2005]



[serial 2024]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2006]



[serial 2026]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [230]->
Q [1] << 0 <= DESIRED_POSITION >>
  What for:   normalization of [serial 2007]



[serial 2028]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [230]->
Q [233] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2008]


Done Normalizing
step:  145
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2010]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1999]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2039]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
  What for: Associativity: (b.c).a = a.b.c [serial 2010]


This Proof Obligation:

[serial 2012]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2000]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2040]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2012]


This Proof Obligation:

[serial 2026]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [230]->
Q [1] << 0 <= DESIRED_POSITION >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2007]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2041]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [230]->
Q [1] << 0 <= DESIRED_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 2026]


This Proof Obligation:

[serial 2028]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [230]->
Q [233] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2008]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2042]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [230]->
Q [233] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 2028]

. . . done Applying Laws [23.2 seconds ]
After "laws" remaining 
Obligations:

[serial 2014]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [240]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for:   normalization of [serial 2001]



[serial 2016]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [240]->
Q [243] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2002]



[serial 2018]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [240]->
Q [242] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 2003]



[serial 2020]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [240]->
Q [241] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2004]



[serial 2022]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2005]



[serial 2024]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2006]



[serial 2039]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
  What for: Associativity: (b.c).a = a.b.c [serial 2010]



[serial 2040]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2012]



[serial 2041]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [230]->
Q [1] << 0 <= DESIRED_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 2026]



[serial 2042]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [230]->
Q [233] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 2028]


Done applying laws
step:  146
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2041]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [230]->
Q [1] << 0 <= DESIRED_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Associativity: (b.c).a = a.b.c [serial 2026]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2042]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [230]->
Q [233] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Associativity: (b.c).a = a.b.c [serial 2028]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [23.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 2014]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [240]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for:   normalization of [serial 2001]



[serial 2016]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [240]->
Q [243] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2002]



[serial 2018]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [240]->
Q [242] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 2003]



[serial 2020]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [240]->
Q [241] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2004]



[serial 2022]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2005]



[serial 2024]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2006]



[serial 2039]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
  What for: Associativity: (b.c).a = a.b.c [serial 2010]



[serial 2040]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2012]


Done trying to apply axioms
step:  147
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2014]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [240]->
Q [1] << 0 <= ACTUAL_POSITION' >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2001]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2043]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = (ACTUAL_POSITION)^1 >>
S [240]->
Q [1] << 0 <= (ACTUAL_POSITION)^1 >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2014]


This Proof Obligation:

[serial 2016]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [240]->
Q [243] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2002]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2044]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = (ACTUAL_POSITION)^1 >>
S [240]->
Q [243] << (ACTUAL_POSITION)^1 <= #PCS::MaxPosition >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2016]


This Proof Obligation:

[serial 2018]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [240]->
Q [242] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2003]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2045]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = (ACTUAL_POSITION)^1 >>
S [240]->
Q [242] << Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2018]


This Proof Obligation:

[serial 2020]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [240]->
Q [241] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2004]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2046]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = (ACTUAL_POSITION)^1 >>
S [240]->
Q [241] << (Delta + EstimatedActualPosition) = (ACTUAL_POSITION)^1 >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2020]


This Proof Obligation:

[serial 2039]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Associativity: (b.c).a = a.b.c [serial 2010]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2047]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << ((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1 and 
(Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2039]


This Proof Obligation:

[serial 2040]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Associativity: (b.c).a = a.b.c [serial 2012]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2048]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (EstimatedActualPosition - 1) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2040]

. . . done spltting timed atoms  [23.2 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [23.2 seconds ]
After "dist^" remaining 
Obligations:

[serial 2022]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2005]



[serial 2024]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2006]



[serial 2043]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = (ACTUAL_POSITION)^1 >>
S [240]->
Q [1] << 0 <= (ACTUAL_POSITION)^1 >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2014]



[serial 2044]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = (ACTUAL_POSITION)^1 >>
S [240]->
Q [243] << (ACTUAL_POSITION)^1 <= #PCS::MaxPosition >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2016]



[serial 2045]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = (ACTUAL_POSITION)^1 >>
S [240]->
Q [242] << Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2018]



[serial 2046]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = (ACTUAL_POSITION)^1 >>
S [240]->
Q [241] << (Delta + EstimatedActualPosition) = (ACTUAL_POSITION)^1 >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2020]



[serial 2047]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << ((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1 and 
(Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2039]



[serial 2048]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (EstimatedActualPosition - 1) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2040]


Done distributing ^ and @.
step:  148
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2047]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << ((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1 and 
(Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2039]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2049]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2047]

. . . done spltting timed atoms  [23.2 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [23.2 seconds ]
After "dist^" remaining 
Obligations:

[serial 2022]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2005]



[serial 2024]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2006]



[serial 2043]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = (ACTUAL_POSITION)^1 >>
S [240]->
Q [1] << 0 <= (ACTUAL_POSITION)^1 >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2014]



[serial 2044]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = (ACTUAL_POSITION)^1 >>
S [240]->
Q [243] << (ACTUAL_POSITION)^1 <= #PCS::MaxPosition >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2016]



[serial 2045]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = (ACTUAL_POSITION)^1 >>
S [240]->
Q [242] << Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2018]



[serial 2046]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = (ACTUAL_POSITION)^1 >>
S [240]->
Q [241] << (Delta + EstimatedActualPosition) = (ACTUAL_POSITION)^1 >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2020]



[serial 2048]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (EstimatedActualPosition - 1) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2040]



[serial 2049]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2047]


Done distributing ^ and @.
step:  149
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2049]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2047]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2050]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1))) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2049]

. . . done spltting timed atoms  [23.3 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [23.3 seconds ]
After "dist^" remaining 
Obligations:

[serial 2022]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2005]



[serial 2024]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2006]



[serial 2043]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = (ACTUAL_POSITION)^1 >>
S [240]->
Q [1] << 0 <= (ACTUAL_POSITION)^1 >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2014]



[serial 2044]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = (ACTUAL_POSITION)^1 >>
S [240]->
Q [243] << (ACTUAL_POSITION)^1 <= #PCS::MaxPosition >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2016]



[serial 2045]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = (ACTUAL_POSITION)^1 >>
S [240]->
Q [242] << Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2018]



[serial 2046]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = (ACTUAL_POSITION)^1 >>
S [240]->
Q [241] << (Delta + EstimatedActualPosition) = (ACTUAL_POSITION)^1 >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2020]



[serial 2048]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (EstimatedActualPosition - 1) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2040]



[serial 2050]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1))) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2049]


Done distributing ^ and @.
step:  150
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2043]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = (ACTUAL_POSITION)^1 >>
S [240]->
Q [1] << 0 <= (ACTUAL_POSITION)^1 >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2014]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2054]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [1] << 0 <= ACTUAL_POSITION^1 >>
  What for:   normalization of [serial 2043]


This Proof Obligation:

[serial 2044]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = (ACTUAL_POSITION)^1 >>
S [240]->
Q [243] << (ACTUAL_POSITION)^1 <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2016]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2056]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [243] << ACTUAL_POSITION^1 <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2044]


This Proof Obligation:

[serial 2045]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = (ACTUAL_POSITION)^1 >>
S [240]->
Q [242] << Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2018]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2058]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [242] << Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 2045]


This Proof Obligation:

[serial 2046]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = (ACTUAL_POSITION)^1 >>
S [240]->
Q [241] << (Delta + EstimatedActualPosition) = (ACTUAL_POSITION)^1 >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2020]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2060]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << ACTUAL_POSITION^1 = (Delta + EstimatedActualPosition) >>
  What for:   normalization of [serial 2046]


This Proof Obligation:

[serial 2048]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (EstimatedActualPosition - 1) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2040]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2062]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (EstimatedActualPosition - 1) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for:   normalization of [serial 2048]


This Proof Obligation:

[serial 2050]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1))) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2049]

  Normalization Axioms:

    Literal Arithmetic

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Constants are always the same
Has been normalized to get:

[serial 2064]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
  What for:   normalization of [serial 2050]

. . . done Normalizing Unsolved Proof Obligations [23.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 2022]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2005]



[serial 2024]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2006]



[serial 2054]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [1] << 0 <= ACTUAL_POSITION^1 >>
  What for:   normalization of [serial 2043]



[serial 2056]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [243] << ACTUAL_POSITION^1 <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2044]



[serial 2058]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [242] << Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 2045]



[serial 2060]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << ACTUAL_POSITION^1 = (Delta + EstimatedActualPosition) >>
  What for:   normalization of [serial 2046]



[serial 2062]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (EstimatedActualPosition - 1) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for:   normalization of [serial 2048]



[serial 2064]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
  What for:   normalization of [serial 2050]


Done Normalizing
step:  151
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2064]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2050]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2071]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2064]

. . . done spltting timed atoms  [23.3 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [23.3 seconds ]
After "dist^" remaining 
Obligations:

[serial 2022]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2005]



[serial 2024]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2006]



[serial 2054]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [1] << 0 <= ACTUAL_POSITION^1 >>
  What for:   normalization of [serial 2043]



[serial 2056]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [243] << ACTUAL_POSITION^1 <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2044]



[serial 2058]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [242] << Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 2045]



[serial 2060]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << ACTUAL_POSITION^1 = (Delta + EstimatedActualPosition) >>
  What for:   normalization of [serial 2046]



[serial 2062]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (EstimatedActualPosition - 1) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for:   normalization of [serial 2048]



[serial 2071]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2064]


Done distributing ^ and @.
step:  152
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2071]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  Identity (id):  P->P is tautology
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2064]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [23.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 2022]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2005]



[serial 2024]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2006]



[serial 2054]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [1] << 0 <= ACTUAL_POSITION^1 >>
  What for:   normalization of [serial 2043]



[serial 2056]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [243] << ACTUAL_POSITION^1 <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2044]



[serial 2058]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [242] << Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 2045]



[serial 2060]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << ACTUAL_POSITION^1 = (Delta + EstimatedActualPosition) >>
  What for:   normalization of [serial 2046]



[serial 2062]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (EstimatedActualPosition - 1) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for:   normalization of [serial 2048]


Done trying to apply axioms
step:  153
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  0 <= DESIRED_POSITION and DESIRED_POSITION <= (ACTUAL_POSITION - 1) -> 0 <= (ACTUAL_POSITION - 1)
Transitivity:  (ACTUAL_POSITION - 1) < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition -> (ACTUAL_POSITION - 1) < #PCS::MaxPosition
Transitivity:  DESIRED_POSITION <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) < ACTUAL_POSITION -> DESIRED_POSITION < ACTUAL_POSITION
Transitivity:  DESIRED_POSITION <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) < #PCS::MaxPosition -> DESIRED_POSITION < #PCS::MaxPosition
Transitivity:  0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) < ACTUAL_POSITION -> 0 < ACTUAL_POSITION
Transitivity:  0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) < #PCS::MaxPosition -> 0 < #PCS::MaxPosition

This Proof Obligation:

[serial 2022]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for:   normalization of [serial 2005]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 2072]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) < #PCS::MaxPosition and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2022]

Transitivity:  0 <= DESIRED_POSITION and DESIRED_POSITION <= (ACTUAL_POSITION - 1) -> 0 <= (ACTUAL_POSITION - 1)
Transitivity:  (ACTUAL_POSITION - 1) < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition -> (ACTUAL_POSITION - 1) < #PCS::MaxPosition
Transitivity:  DESIRED_POSITION <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) < ACTUAL_POSITION -> DESIRED_POSITION < ACTUAL_POSITION
Transitivity:  DESIRED_POSITION <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) < #PCS::MaxPosition -> DESIRED_POSITION < #PCS::MaxPosition
Transitivity:  0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) < ACTUAL_POSITION -> 0 < ACTUAL_POSITION
Transitivity:  0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) < #PCS::MaxPosition -> 0 < #PCS::MaxPosition

This Proof Obligation:

[serial 2024]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for:   normalization of [serial 2006]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 2073]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) < #PCS::MaxPosition and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2024]

Transitivity:  0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition -> 0 <= #PCS::MaxPosition

This Proof Obligation:

[serial 2054]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [1] << 0 <= ACTUAL_POSITION^1 >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for:   normalization of [serial 2043]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 2074]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition and 
0 <= #PCS::MaxPosition >>
S [240]->
Q [1] << 0 <= ACTUAL_POSITION^1 >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2054]

Transitivity:  0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition -> 0 <= #PCS::MaxPosition

This Proof Obligation:

[serial 2056]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [243] << ACTUAL_POSITION^1 <= #PCS::MaxPosition >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for:   normalization of [serial 2044]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 2075]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition and 
0 <= #PCS::MaxPosition >>
S [240]->
Q [243] << ACTUAL_POSITION^1 <= #PCS::MaxPosition >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2056]

Transitivity:  0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition -> 0 <= #PCS::MaxPosition

This Proof Obligation:

[serial 2058]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [242] << Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for:   normalization of [serial 2045]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 2076]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition and 
0 <= #PCS::MaxPosition >>
S [240]->
Q [242] << Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2058]

Transitivity:  0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition -> 0 <= #PCS::MaxPosition

This Proof Obligation:

[serial 2060]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << ACTUAL_POSITION^1 = (Delta + EstimatedActualPosition) >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for:   normalization of [serial 2046]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 2077]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition and 
0 <= #PCS::MaxPosition >>
S [240]->
Q [241] << ACTUAL_POSITION^1 = (Delta + EstimatedActualPosition) >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2060]

Transitivity:  0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition -> 0 <= #PCS::MaxPosition
Transitivity:  0 <= DESIRED_POSITION and DESIRED_POSITION <= (EstimatedActualPosition - 1) -> 0 <= (EstimatedActualPosition - 1)

This Proof Obligation:

[serial 2062]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (EstimatedActualPosition - 1) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for:   normalization of [serial 2048]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 2078]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (EstimatedActualPosition - 1) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and 0 <= #PCS::MaxPosition and 
0 <= (EstimatedActualPosition - 1) >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2062]

. . . done adding transitive terms [23.4 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 2072]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) < #PCS::MaxPosition and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2022]



[serial 2073]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) < #PCS::MaxPosition and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2024]



[serial 2074]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition and 
0 <= #PCS::MaxPosition >>
S [240]->
Q [1] << 0 <= ACTUAL_POSITION^1 >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2054]



[serial 2075]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition and 
0 <= #PCS::MaxPosition >>
S [240]->
Q [243] << ACTUAL_POSITION^1 <= #PCS::MaxPosition >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2056]



[serial 2076]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition and 
0 <= #PCS::MaxPosition >>
S [240]->
Q [242] << Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2058]



[serial 2077]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition and 
0 <= #PCS::MaxPosition >>
S [240]->
Q [241] << ACTUAL_POSITION^1 = (Delta + EstimatedActualPosition) >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2060]



[serial 2078]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (EstimatedActualPosition - 1) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and 0 <= #PCS::MaxPosition and 
0 <= (EstimatedActualPosition - 1) >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2062]


Done adding transitive relations
step:  154
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2072]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) < #PCS::MaxPosition and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Normalization
  What for: Transitivity: x<y and y<z -> x<z [serial 2022]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2080]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - 1) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
(ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2072]


This Proof Obligation:

[serial 2073]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) < #PCS::MaxPosition and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Transitivity: x<y and y<z -> x<z [serial 2024]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2082]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - 1) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
(ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2073]


This Proof Obligation:

[serial 2074]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition and 
0 <= #PCS::MaxPosition >>
S [240]->
Q [1] << 0 <= ACTUAL_POSITION^1 >>
Reason:  Normalization
  What for: Transitivity: x<y and y<z -> x<z [serial 2054]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2084]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [1] << 0 <= ACTUAL_POSITION^1 >>
  What for:   normalization of [serial 2074]


This Proof Obligation:

[serial 2075]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition and 
0 <= #PCS::MaxPosition >>
S [240]->
Q [243] << ACTUAL_POSITION^1 <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Transitivity: x<y and y<z -> x<z [serial 2056]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2086]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [243] << ACTUAL_POSITION^1 <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2075]


This Proof Obligation:

[serial 2076]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition and 
0 <= #PCS::MaxPosition >>
S [240]->
Q [242] << Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Transitivity: x<y and y<z -> x<z [serial 2058]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2088]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [242] << Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 2076]


This Proof Obligation:

[serial 2077]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition and 
0 <= #PCS::MaxPosition >>
S [240]->
Q [241] << ACTUAL_POSITION^1 = (Delta + EstimatedActualPosition) >>
Reason:  Normalization
  What for: Transitivity: x<y and y<z -> x<z [serial 2060]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2090]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << ACTUAL_POSITION^1 = (Delta + EstimatedActualPosition) >>
  What for:   normalization of [serial 2077]


This Proof Obligation:

[serial 2078]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (EstimatedActualPosition - 1) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and 0 <= #PCS::MaxPosition and 
0 <= (EstimatedActualPosition - 1) >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
Reason:  Normalization
  What for: Transitivity: x<y and y<z -> x<z [serial 2062]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2092]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= (EstimatedActualPosition - 1) and 
0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (EstimatedActualPosition - 1) and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for:   normalization of [serial 2078]

. . . done Normalizing Unsolved Proof Obligations [23.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 2080]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - 1) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
(ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2072]



[serial 2082]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - 1) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
(ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2073]



[serial 2084]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [1] << 0 <= ACTUAL_POSITION^1 >>
  What for:   normalization of [serial 2074]



[serial 2086]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [243] << ACTUAL_POSITION^1 <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2075]



[serial 2088]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [242] << Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for:   normalization of [serial 2076]



[serial 2090]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << ACTUAL_POSITION^1 = (Delta + EstimatedActualPosition) >>
  What for:   normalization of [serial 2077]



[serial 2092]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= (EstimatedActualPosition - 1) and 
0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (EstimatedActualPosition - 1) and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for:   normalization of [serial 2078]


Done Normalizing
step:  155
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION^1" . . .
equality selected for substitution:  ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta)

This Proof Obligation:

[serial 2084]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [1] << 0 <= ACTUAL_POSITION^1 >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 2074]

Has substituted 
"ACTUAL_POSITION^1" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 2100]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2084]

equality selected for substitution:  ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta)

This Proof Obligation:

[serial 2086]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [243] << ACTUAL_POSITION^1 <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 2075]

Has substituted 
"ACTUAL_POSITION^1" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 2101]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [243] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2086]

equality selected for substitution:  ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta)

This Proof Obligation:

[serial 2088]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [242] << Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 2076]

Has substituted 
"ACTUAL_POSITION^1" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 2102]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [242] << Delta = (((ACTUAL_POSITION + Delta)) - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2088]

equality selected for substitution:  ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta)

This Proof Obligation:

[serial 2090]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << ACTUAL_POSITION^1 = (Delta + EstimatedActualPosition) >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 2077]

Has substituted 
"ACTUAL_POSITION^1" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 2103]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << ((ACTUAL_POSITION + Delta)) = (Delta + EstimatedActualPosition) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2090]

. . . done guided substitution of equals  [23.4 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2080]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - 1) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
(ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2072]



[serial 2082]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - 1) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
(ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2073]



[serial 2092]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= (EstimatedActualPosition - 1) and 
0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (EstimatedActualPosition - 1) and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for:   normalization of [serial 2078]



[serial 2100]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2084]



[serial 2101]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [243] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2086]



[serial 2102]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [242] << Delta = (((ACTUAL_POSITION + Delta)) - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2088]



[serial 2103]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << ((ACTUAL_POSITION + Delta)) = (Delta + EstimatedActualPosition) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2090]


Done guided substituting an equals
step:  156
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2100]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2084]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2108]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2100]


This Proof Obligation:

[serial 2101]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [243] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2086]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2110]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [243] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2101]


This Proof Obligation:

[serial 2102]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [242] << Delta = (((ACTUAL_POSITION + Delta)) - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2088]

  Normalization Axioms:

    Subtaction of Added Value:  (a+b)-a is b

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2112]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [242] << Delta = Delta >>
  What for:   normalization of [serial 2102]


This Proof Obligation:

[serial 2103]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << ((ACTUAL_POSITION + Delta)) = (Delta + EstimatedActualPosition) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2090]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2114]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << (ACTUAL_POSITION + Delta) = (Delta + EstimatedActualPosition) >>
  What for:   normalization of [serial 2103]

. . . done Normalizing Unsolved Proof Obligations [23.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 2080]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - 1) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
(ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2072]



[serial 2082]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - 1) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
(ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2073]



[serial 2092]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= (EstimatedActualPosition - 1) and 
0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (EstimatedActualPosition - 1) and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for:   normalization of [serial 2078]



[serial 2108]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2100]



[serial 2110]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [243] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2101]



[serial 2112]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [242] << Delta = Delta >>
  What for:   normalization of [serial 2102]



[serial 2114]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << (ACTUAL_POSITION + Delta) = (Delta + EstimatedActualPosition) >>
  What for:   normalization of [serial 2103]


Done Normalizing
step:  157
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2112]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [242] << Delta = Delta >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 2102]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 2119]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [242] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 2112]

Law2.removeCommonTermFromAdd:  
^{= 
 ^{( ACTUAL_POSITION )} 
 ^{( EstimatedActualPosition )}}

This Proof Obligation:

[serial 2114]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << (ACTUAL_POSITION + Delta) = (Delta + EstimatedActualPosition) >>
Reason:  Add both sides of equality:  a=b -> x+a=x+b
  What for:   normalization of [serial 2103]

Has applied law "Add both sides of equality:  a=b -> x+a=x+b" to get:

[serial 2120]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << (ACTUAL_POSITION) = (EstimatedActualPosition) >>
  What for: Add both sides of equality:  a=b -> x+a=x+b [serial 2114]

. . . done Applying Laws [23.5 seconds ]
After "laws" remaining 
Obligations:

[serial 2080]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - 1) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
(ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2072]



[serial 2082]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - 1) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
(ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2073]



[serial 2092]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= (EstimatedActualPosition - 1) and 
0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (EstimatedActualPosition - 1) and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for:   normalization of [serial 2078]



[serial 2108]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2100]



[serial 2110]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [243] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2101]



[serial 2119]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [242] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 2112]



[serial 2120]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << (ACTUAL_POSITION) = (EstimatedActualPosition) >>
  What for: Add both sides of equality:  a=b -> x+a=x+b [serial 2114]


Done applying laws
step:  158
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2108]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 2100]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2110]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [243] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 2101]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2119]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [242] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 2112]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [23.5 seconds ]
After "axioms" remaining 
Obligations:

[serial 2080]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - 1) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
(ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2072]



[serial 2082]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - 1) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
(ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2073]



[serial 2092]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= (EstimatedActualPosition - 1) and 
0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (EstimatedActualPosition - 1) and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for:   normalization of [serial 2078]



[serial 2120]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << (ACTUAL_POSITION) = (EstimatedActualPosition) >>
  What for: Add both sides of equality:  a=b -> x+a=x+b [serial 2114]


Done trying to apply axioms
step:  159
****guided-sub-equals****
guided substitution of equals "Delta" . . .
equality selected for substitution:  -1 = Delta

This Proof Obligation:

[serial 2080]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - 1) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
(ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 2072]

Has substituted 
"Delta" with its = "-1"
 to get:

[serial 2121]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - 1) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
(ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + -1) >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 2080]

equality selected for substitution:  -1 = Delta

This Proof Obligation:

[serial 2082]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - 1) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
(ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [235]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 2073]

Has substituted 
"Delta" with its = "-1"
 to get:

[serial 2122]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - 1) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
(ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [235]->
Q [130] << (ACTUAL_POSITION + -1) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 2082]

equality selected for substitution:  -1 = Delta
. . . done guided substitution of equals  [23.5 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2092]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= (EstimatedActualPosition - 1) and 
0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (EstimatedActualPosition - 1) and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
  What for:   normalization of [serial 2078]



[serial 2120]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << (ACTUAL_POSITION) = (EstimatedActualPosition) >>
Reason:  Guided Substitution of Equals
  What for: Add both sides of equality:  a=b -> x+a=x+b [serial 2114]



[serial 2121]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - 1) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
(ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + -1) >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 2080]



[serial 2122]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - 1) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
(ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [235]->
Q [130] << (ACTUAL_POSITION + -1) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 2082]


Done guided substituting an equals
step:  160
****change subtraction to adding unary minus****
changing subtraction to adding negation . . .

This Proof Obligation:

[serial 2092]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= (EstimatedActualPosition - 1) and 
0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (EstimatedActualPosition - 1) and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
Reason:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
  What for:   normalization of [serial 2078]

Has changed subtraction to adding negation to get:

[serial 2123]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= (EstimatedActualPosition + 
 -1) and 0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (EstimatedActualPosition +  -1) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION +  -1) >>
  What for:  changing adding negation to subtraction  [serial 2092]


This Proof Obligation:

[serial 2120]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << (ACTUAL_POSITION) = (EstimatedActualPosition) >>
Reason:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
  What for: Add both sides of equality:  a=b -> x+a=x+b [serial 2114]

Has changed subtraction to adding negation to get:

[serial 2124]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and  -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << (ACTUAL_POSITION) = (EstimatedActualPosition) >>
  What for:  changing adding negation to subtraction  [serial 2120]


This Proof Obligation:

[serial 2121]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - 1) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
(ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION + -1) >>
Reason:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 2080]

Has changed subtraction to adding negation to get:

[serial 2125]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION +  -1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION +  -1) and  -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION +  -1) < ACTUAL_POSITION and 
(ACTUAL_POSITION +  -1) < #PCS::MaxPosition >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION +  -1) >>
  What for:  changing adding negation to subtraction  [serial 2121]


This Proof Obligation:

[serial 2122]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - 1) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
(ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [235]->
Q [130] << (ACTUAL_POSITION + -1) <= #PCS::MaxPosition >>
Reason:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 2082]

Has changed subtraction to adding negation to get:

[serial 2126]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION +  -1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION +  -1) and  -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION +  -1) < ACTUAL_POSITION and 
(ACTUAL_POSITION +  -1) < #PCS::MaxPosition >>
S [235]->
Q [130] << (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition >>
  What for:  changing adding negation to subtraction  [serial 2122]

. . . done substituting all equals  [23.5 seconds ]
After changing subtraction to adding unary minus remaining 
Obligations:

[serial 2123]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= (EstimatedActualPosition + 
 -1) and 0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (EstimatedActualPosition +  -1) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION +  -1) >>
  What for:  changing adding negation to subtraction  [serial 2092]



[serial 2124]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and  -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << (ACTUAL_POSITION) = (EstimatedActualPosition) >>
  What for:  changing adding negation to subtraction  [serial 2120]



[serial 2125]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION +  -1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION +  -1) and  -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION +  -1) < ACTUAL_POSITION and 
(ACTUAL_POSITION +  -1) < #PCS::MaxPosition >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION +  -1) >>
  What for:  changing adding negation to subtraction  [serial 2121]



[serial 2126]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION +  -1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION +  -1) and  -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION +  -1) < ACTUAL_POSITION and 
(ACTUAL_POSITION +  -1) < #PCS::MaxPosition >>
S [235]->
Q [130] << (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition >>
  What for:  changing adding negation to subtraction  [serial 2122]


Done changing subtraction to adding unary minus
step:  161
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2123]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= (EstimatedActualPosition + 
 -1) and 0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (EstimatedActualPosition +  -1) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION +  -1) >>
Reason:  Normalization
  What for:  changing adding negation to subtraction  [serial 2092]

  Normalization Axiom:

    Literal Arithmetic
Has been normalized to get:

[serial 2128]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= (-1 + EstimatedActualPosition) and 
0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (
-1 + EstimatedActualPosition) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (-1 + ACTUAL_POSITION) >>
  What for:   normalization of [serial 2123]


This Proof Obligation:

[serial 2124]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and  -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << (ACTUAL_POSITION) = (EstimatedActualPosition) >>
Reason:  Normalization
  What for:  changing adding negation to subtraction  [serial 2120]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Unary Minus:  -(x-y) is (y-x)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2130]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 2124]


This Proof Obligation:

[serial 2125]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION +  -1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION +  -1) and  -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION +  -1) < ACTUAL_POSITION and 
(ACTUAL_POSITION +  -1) < #PCS::MaxPosition >>
S [235]->
Q [1] << 0 <= (ACTUAL_POSITION +  -1) >>
Reason:  Normalization
  What for:  changing adding negation to subtraction  [serial 2121]

  Normalization Axioms:

    Literal Arithmetic

    Reflexivity of Equality: (a=b) = (b=a)

    Unary Minus:  -(x-y) is (y-x)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2132]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (-1 + ACTUAL_POSITION) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (-1 + ACTUAL_POSITION) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION and 
(-1 + ACTUAL_POSITION) < #PCS::MaxPosition >>
S [235]->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
  What for:   normalization of [serial 2125]


This Proof Obligation:

[serial 2126]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION +  -1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION +  -1) and  -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION +  -1) < ACTUAL_POSITION and 
(ACTUAL_POSITION +  -1) < #PCS::MaxPosition >>
S [235]->
Q [130] << (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for:  changing adding negation to subtraction  [serial 2122]

  Normalization Axioms:

    Literal Arithmetic

    Reflexivity of Equality: (a=b) = (b=a)

    Unary Minus:  -(x-y) is (y-x)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2134]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (-1 + ACTUAL_POSITION) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (-1 + ACTUAL_POSITION) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION and 
(-1 + ACTUAL_POSITION) < #PCS::MaxPosition >>
S [235]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2126]

. . . done Normalizing Unsolved Proof Obligations [23.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2128]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= (-1 + EstimatedActualPosition) and 
0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (
-1 + EstimatedActualPosition) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (-1 + ACTUAL_POSITION) >>
  What for:   normalization of [serial 2123]



[serial 2130]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 2124]



[serial 2132]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (-1 + ACTUAL_POSITION) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (-1 + ACTUAL_POSITION) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION and 
(-1 + ACTUAL_POSITION) < #PCS::MaxPosition >>
S [235]->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
  What for:   normalization of [serial 2125]



[serial 2134]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (-1 + ACTUAL_POSITION) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (-1 + ACTUAL_POSITION) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION and 
(-1 + ACTUAL_POSITION) < #PCS::MaxPosition >>
S [235]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2126]


Done Normalizing
step:  162
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2130]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240]->
Q [241] << ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 2124]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2132]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (-1 + ACTUAL_POSITION) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (-1 + ACTUAL_POSITION) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION and 
(-1 + ACTUAL_POSITION) < #PCS::MaxPosition >>
S [235]->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 2125]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [23.6 seconds ]
After "axioms" remaining 
Obligations:

[serial 2128]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= (-1 + EstimatedActualPosition) and 
0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (
-1 + EstimatedActualPosition) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (-1 + ACTUAL_POSITION) >>
  What for:   normalization of [serial 2123]



[serial 2134]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (-1 + ACTUAL_POSITION) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (-1 + ACTUAL_POSITION) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION and 
(-1 + ACTUAL_POSITION) < #PCS::MaxPosition >>
S [235]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2126]


Done trying to apply axioms
step:  163
****partial to total order****
Making partial orders into total orders . . .
Making partial orders into total orders . . .

This Proof Obligation:

[serial 2128]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= (-1 + EstimatedActualPosition) and 
0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (
-1 + EstimatedActualPosition) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION <= (-1 + ACTUAL_POSITION) >>
Reason:  Partial Order Law 3:  a <= (b-1)  is  a<b
  What for:   normalization of [serial 2123]

Has applied Partial Order Law 3:  a <= (b-1)  is  a<b (0<=(--1+EstimatedActualPosition)  is  0<EstimatedActualPosition
DESIRED_POSITION<=(--1+EstimatedActualPosition)  is  DESIRED_POSITION<EstimatedActualPosition
  DESIRED_POSITION<=(--1+ACTUAL_POSITION)  is  DESIRED_POSITION<ACTUAL_POSITION
) to get:

[serial 2139]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 < EstimatedActualPosition and 
0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION < EstimatedActualPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for: 0<=(--1+EstimatedActualPosition)  is  0<EstimatedActualPosition
DESIRED_POSITION<=(--1+EstimatedActualPosition)  is  DESIRED_POSITION<EstimatedActualPosition
  DESIRED_POSITION<=(--1+ACTUAL_POSITION)  is  DESIRED_POSITION<ACTUAL_POSITION

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2128]


This Proof Obligation:

[serial 2134]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (-1 + ACTUAL_POSITION) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (-1 + ACTUAL_POSITION) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION and 
(-1 + ACTUAL_POSITION) < #PCS::MaxPosition >>
S [235]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
Reason:  Partial Order Law 3:  a <= (b-1)  is  a<b
  What for:   normalization of [serial 2126]

Has applied Partial Order Law 3:  a <= (b-1)  is  a<b (0<=(--1+ACTUAL_POSITION)  is  0<ACTUAL_POSITION
DESIRED_POSITION<=(--1+ACTUAL_POSITION)  is  DESIRED_POSITION<ACTUAL_POSITION
(-1 + ACTUAL_POSITION)<#PCS::MaxPosition  ->  (-1 + ACTUAL_POSITION)<=#PCS::MaxPosition
  ) to get:

[serial 2140]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION < ACTUAL_POSITION and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION and 
(-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
S [235]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for: 0<=(--1+ACTUAL_POSITION)  is  0<ACTUAL_POSITION
DESIRED_POSITION<=(--1+ACTUAL_POSITION)  is  DESIRED_POSITION<ACTUAL_POSITION
(-1 + ACTUAL_POSITION)<#PCS::MaxPosition  ->  (-1 + ACTUAL_POSITION)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2134]

. . . done making partial orders into total orders [23.6 seconds ]
After making partial orders into total orders 
Obligations:

[serial 2139]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 < EstimatedActualPosition and 
0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION < EstimatedActualPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for: 0<=(--1+EstimatedActualPosition)  is  0<EstimatedActualPosition
DESIRED_POSITION<=(--1+EstimatedActualPosition)  is  DESIRED_POSITION<EstimatedActualPosition
  DESIRED_POSITION<=(--1+ACTUAL_POSITION)  is  DESIRED_POSITION<ACTUAL_POSITION

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2128]



[serial 2140]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION < ACTUAL_POSITION and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION and 
(-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
S [235]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for: 0<=(--1+ACTUAL_POSITION)  is  0<ACTUAL_POSITION
DESIRED_POSITION<=(--1+ACTUAL_POSITION)  is  DESIRED_POSITION<ACTUAL_POSITION
(-1 + ACTUAL_POSITION)<#PCS::MaxPosition  ->  (-1 + ACTUAL_POSITION)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2134]


Done making partial orders into total orders
step:  164
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2139]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 < EstimatedActualPosition and 
0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION < EstimatedActualPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION < ACTUAL_POSITION >>
Reason:  Normalization
  What for: 0<=(--1+EstimatedActualPosition)  is  0<EstimatedActualPosition
DESIRED_POSITION<=(--1+EstimatedActualPosition)  is  DESIRED_POSITION<EstimatedActualPosition
  DESIRED_POSITION<=(--1+ACTUAL_POSITION)  is  DESIRED_POSITION<ACTUAL_POSITION

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2128]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2142]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for:   normalization of [serial 2139]


This Proof Obligation:

[serial 2140]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and 0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION < ACTUAL_POSITION and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION and 
(-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
S [235]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: 0<=(--1+ACTUAL_POSITION)  is  0<ACTUAL_POSITION
DESIRED_POSITION<=(--1+ACTUAL_POSITION)  is  DESIRED_POSITION<ACTUAL_POSITION
(-1 + ACTUAL_POSITION)<#PCS::MaxPosition  ->  (-1 + ACTUAL_POSITION)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2134]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2144]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and (-1 + 
ACTUAL_POSITION) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION >>
S [235]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2140]

. . . done Normalizing Unsolved Proof Obligations [23.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2142]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for:   normalization of [serial 2139]



[serial 2144]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and (-1 + 
ACTUAL_POSITION) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION >>
S [235]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2140]


Done Normalizing
step:  165
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2144]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and (-1 + 
ACTUAL_POSITION) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION >>
S [235]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 2140]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [23.6 seconds ]
After "axioms" remaining 
Obligations:

[serial 2142]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for:   normalization of [serial 2139]


Done trying to apply axioms
step:  166
****substitute all equivalents****
substituting all equals . . .
Replacing all "ACTUAL_POSITION" with  "EstimatedActualPosition" in  "ASSERTION[228]" makes:
<< DESIRED_POSITION < EstimatedActualPosition >>

This Proof Obligation:

[serial 2142]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION < ACTUAL_POSITION >>
Reason:  Substitution in Postcondition of All Equivalents in Precondition
  What for:   normalization of [serial 2139]

Has substituted in postcondition all equivalents in precondition to get:

[serial 2147]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION < EstimatedActualPosition >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 2142]

. . . done substituting all equals  [23.6 seconds ]
After substituting all equivalents remaining 
Obligations:

[serial 2147]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION < EstimatedActualPosition >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 2142]


Done substituting all equivalents
step:  167
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2147]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition >>
S [163]->
Q [228] << DESIRED_POSITION < EstimatedActualPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 2142]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [23.6 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1016]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and ((((DESIRED_POSITION)^0 > (EstimatedActualPosition - 1))) and 
(((EstimatedActualPosition + 1) > (DESIRED_POSITION)^0)))) >>
S [246]->
Q [170] << true >>
  What for:  <<M(Decide) and x>> -> <<M(Error)>> for fraSerban:Decide-[x]->Error{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  168
#[serial 1016]  <<M(Decide) and x>> -> <<M(Error)>> for fraSerban:Decide-[x]->Error{};
step:  169
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1016]: ControlSoftware::FragilePositionControlThread.SingleStep
P [163] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and ((((DESIRED_POSITION)^0 > (EstimatedActualPosition - 1))) and 
(((EstimatedActualPosition + 1) > (DESIRED_POSITION)^0)))) >>
S [246]->
Q [170] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for:  <<M(Decide) and x>> -> <<M(Error)>> for fraSerban:Decide-[x]->Error{};

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [23.6 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1017]: ControlSoftware::FragilePositionControlThread.SingleStep
P [249] << ((E() and D() and ACTUAL_IN_RANGE()) and stop@now and not (exists u~time
  in tops,,now 
  that true ) and not (exists u~time
  in tops,,now 
  that stop@u )) >>
S [249]->
Q [165] << (E() and ACTUAL_IN_RANGE()) >>
  What for:  <<M(Run) and x>> -> <<M(ShutDown)>> for fra5stop:Run-[x]->ShutDown{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  170
#[serial 1017]  <<M(Run) and x>> -> <<M(ShutDown)>> for fra5stop:Run-[x]->ShutDown{};
step:  171
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1017]: ControlSoftware::FragilePositionControlThread.SingleStep
P [249] << ((E() and D() and ACTUAL_IN_RANGE()) and stop@now and not (exists u~time
  in tops,,now 
  that true ) and not (exists u~time
  in tops,,now 
  that stop@u )) >>
S [249]->
Q [165] << (E() and ACTUAL_IN_RANGE()) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:  <<M(Run) and x>> -> <<M(ShutDown)>> for fra5stop:Run-[x]->ShutDown{};

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2148]: ControlSoftware::FragilePositionControlThread.SingleStep
P [249] << (E() and D() and ACTUAL_IN_RANGE() and stop@now and not (exists u~time
  in tops,,now 
  that true ) and not (exists u~time
  in tops,,now 
  that stop@u )) >>
S [249]->
Q [165] << (E() and ACTUAL_IN_RANGE()) >>
  What for: Associativity: (b.c).a = a.b.c [serial 1017]


This Proof Obligation:

[serial 2148]: ControlSoftware::FragilePositionControlThread.SingleStep
P [249] << (E() and D() and ACTUAL_IN_RANGE() and stop@now and not (exists u~time
  in tops,,now 
  that true ) and not (exists u~time
  in tops,,now 
  that stop@u )) >>
S [249]->
Q [165] << (E() and ACTUAL_IN_RANGE()) >>
Reason:  Existential Quantification Introduction
  What for: Associativity: (b.c).a = a.b.c [serial 1017]

Has applied law "Existential Quantification Introduction" to get:

[serial 2149]: ControlSoftware::FragilePositionControlThread.SingleStep
P [249] << (E() and D() and ACTUAL_IN_RANGE() and stop@now and not (true) and not (exists u~time
  in tops,,now 
  that stop@u )) >>
S [249]->
Q [165] << (E() and ACTUAL_IN_RANGE()) >>
  What for: Existential Quantification Introduction [serial 2148]

. . . done Applying Laws [23.6 seconds ]
After "laws" remaining 
Obligations:

[serial 2149]: ControlSoftware::FragilePositionControlThread.SingleStep
P [249] << (E() and D() and ACTUAL_IN_RANGE() and stop@now and not (true) and not (exists u~time
  in tops,,now 
  that stop@u )) >>
S [249]->
Q [165] << (E() and ACTUAL_IN_RANGE()) >>
  What for: Existential Quantification Introduction [serial 2148]


Done applying laws
step:  172
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2149]: ControlSoftware::FragilePositionControlThread.SingleStep
P [249] << (E() and D() and ACTUAL_IN_RANGE() and stop@now and not (true) and not (exists u~time
  in tops,,now 
  that stop@u )) >>
S [249]->
Q [165] << (E() and ACTUAL_IN_RANGE()) >>
Reason:  Normalization
  What for: Existential Quantification Introduction [serial 2148]

  Normalization Axioms:

    Complement

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2151]: ControlSoftware::FragilePositionControlThread.SingleStep
P [249] << stop@now and ACTUAL_IN_RANGE() and D() and E() and false and not (exists u~time
  in tops,,now 
  that stop@u ) >>
S [249]->
Q [165] << ACTUAL_IN_RANGE() and E() >>
  What for:   normalization of [serial 2149]

. . . done Normalizing Unsolved Proof Obligations [23.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2151]: ControlSoftware::FragilePositionControlThread.SingleStep
P [249] << stop@now and ACTUAL_IN_RANGE() and D() and E() and false and not (exists u~time
  in tops,,now 
  that stop@u ) >>
S [249]->
Q [165] << ACTUAL_IN_RANGE() and E() >>
  What for:   normalization of [serial 2149]


Done Normalizing
step:  173
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2151]: ControlSoftware::FragilePositionControlThread.SingleStep
P [249] << stop@now and ACTUAL_IN_RANGE() and D() and E() and false and not (exists u~time
  in tops,,now 
  that stop@u ) >>
S [249]->
Q [165] << ACTUAL_IN_RANGE() and E() >>
Reason:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
  What for:   normalization of [serial 2149]

Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [23.6 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1018]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << (E() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition = 0))) >>
S [251]->
Q [169] << (ACTUAL_POSITION = 0) >>
  What for:  <<M(ShutDown) and x>> -> <<M(Done)>> for fra6done:ShutDown-[x]->Done{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  174
#[serial 1018]  <<M(ShutDown) and x>> -> <<M(Done)>> for fra6done:ShutDown-[x]->Done{};
step:  175
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1018]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << (E() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition = 0))) >>
S [251]->
Q [169] << (ACTUAL_POSITION = 0) >>
Reason:  Substitution of Assertion Labels
  What for:  <<M(ShutDown) and x>> -> <<M(Done)>> for fra6done:ShutDown-[x]->Done{};

Has substituted Assertions' predicates for labels to get:

[serial 2153]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << (((EstimatedActualPosition = ACTUAL_POSITION)) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = 0))) >>
S [251]->
Q [169] << (ACTUAL_POSITION = 0) >>
  What for: substituted Assertions' predicates for  labels  [serial 1018]

. . . done Substituting Assertions for Labels [23.6 seconds ]
After "substitute" remaining 
Obligations:

[serial 2153]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << (((EstimatedActualPosition = ACTUAL_POSITION)) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = 0))) >>
S [251]->
Q [169] << (ACTUAL_POSITION = 0) >>
  What for: substituted Assertions' predicates for  labels  [serial 1018]


Done substituting Assertion labels.
step:  176
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2153]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << (((EstimatedActualPosition = ACTUAL_POSITION)) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = 0))) >>
S [251]->
Q [169] << (ACTUAL_POSITION = 0) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 1018]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2155]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << 0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [251]->
Q [169] << 0 = ACTUAL_POSITION >>
  What for:   normalization of [serial 2153]

. . . done Normalizing Unsolved Proof Obligations [23.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2155]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << 0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [251]->
Q [169] << 0 = ACTUAL_POSITION >>
  What for:   normalization of [serial 2153]


Done Normalizing
step:  177
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2155]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << 0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [251]->
Q [169] << 0 = ACTUAL_POSITION >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2153]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2157]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [251]->
Q [169] << 0 = ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 2155]

. . . done Applying Laws [23.6 seconds ]
After "laws" remaining 
Obligations:

[serial 2157]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [251]->
Q [169] << 0 = ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 2155]


Done applying laws
step:  178
****substitute all equivalents****
substituting all equals . . .
Replacing all "ACTUAL_POSITION" with  "EstimatedActualPosition" in  "ASSERTION[169]" makes:
<< 0 = EstimatedActualPosition >>

This Proof Obligation:

[serial 2157]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [251]->
Q [169] << 0 = ACTUAL_POSITION >>
Reason:  Substitution in Postcondition of All Equivalents in Precondition
  What for: Associativity: (b.c).a = a.b.c [serial 2155]

Has substituted in postcondition all equivalents in precondition to get:

[serial 2158]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [251]->
Q [169] << 0 = EstimatedActualPosition >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 2157]

. . . done substituting all equals  [23.6 seconds ]
After substituting all equivalents remaining 
Obligations:

[serial 2158]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [251]->
Q [169] << 0 = EstimatedActualPosition >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 2157]


Done substituting all equivalents
step:  179
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2158]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [251]->
Q [169] << 0 = EstimatedActualPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 2157]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [23.6 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1019]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << (E() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition > 0))) >>
S [254]<< (E() and (ACTUAL_POSITION > 0) and ACTUAL_IN_RANGE()) >>
Delta := -1
<< (E() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= 0) and AXIOM_GT(ACTUAL_POSITION) and (ACTUAL_POSITION <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and ((ACTUAL_POSITION - 1) >= 0) and E() and ((ACTUAL_POSITION - 1) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition - 1)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [167] << (E() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(ShutDown) and x>> A <<M(StillClosing)>> for fra7sc:ShutDown-[x]->StillClosing{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  180
#[serial 1019]  <<M(ShutDown) and x>> A <<M(StillClosing)>> for fra7sc:ShutDown-[x]->StillClosing{A};
step:  181
****reduce****
This proof obligation:

[serial 1019]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << (E() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition > 0))) >>
S [254]<< (E() and (ACTUAL_POSITION > 0) and ACTUAL_IN_RANGE()) >>
Delta := -1
<< (E() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= 0) and AXIOM_GT(ACTUAL_POSITION) and (ACTUAL_POSITION <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and ((ACTUAL_POSITION - 1) >= 0) and E() and ((ACTUAL_POSITION - 1) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition - 1)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [167] << (E() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(ShutDown) and x>> A <<M(StillClosing)>> for fra7sc:ShutDown-[x]->StillClosing{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P2>> S2 <<Q2>>
 
was reduced to:

[serial 2159]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition > 0))) >>
S [165]->
Q [15] << (E() and (ACTUAL_POSITION > 0) and ACTUAL_IN_RANGE()) >>
  What for: P -> P1 in sequential composition for [serial 1019]


[serial 2160]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION' >= 0) and 
(ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [167]->
Q [15] << (E() and ACTUAL_IN_RANGE())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 1019]


[serial 2161]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and (ACTUAL_POSITION > 0) and ACTUAL_IN_RANGE()) >>
S [255]Delta := -1
Q [15] << (E() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= 0) and AXIOM_GT(ACTUAL_POSITION) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1019]


[serial 2162]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= 0) and AXIOM_GT(ACTUAL_POSITION) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) >>
S [259]ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and 
((ACTUAL_POSITION - 1) >= 0) and E() and ((ACTUAL_POSITION - 1) <= #PCS::MaxPosition)) >>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1019]


[serial 2163]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and 
((ACTUAL_POSITION - 1) >= 0) and E() and ((ACTUAL_POSITION - 1) <= #PCS::MaxPosition)) >>
S [263]EstimatedActualPosition' := (EstimatedActualPosition - 1)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION' >= 0) and 
(ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1019]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 2159]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition > 0))) >>
S [165]->
Q [15] << (E() and (ACTUAL_POSITION > 0) and ACTUAL_IN_RANGE()) >>
  What for: P -> P1 in sequential composition for [serial 1019]



[serial 2160]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION' >= 0) and 
(ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [167]->
Q [15] << (E() and ACTUAL_IN_RANGE())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 1019]



[serial 2161]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and (ACTUAL_POSITION > 0) and ACTUAL_IN_RANGE()) >>
S [255]Delta := -1
Q [15] << (E() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= 0) and AXIOM_GT(ACTUAL_POSITION) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1019]



[serial 2162]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= 0) and AXIOM_GT(ACTUAL_POSITION) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) >>
S [259]ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and 
((ACTUAL_POSITION - 1) >= 0) and E() and ((ACTUAL_POSITION - 1) <= #PCS::MaxPosition)) >>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1019]



[serial 2163]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and 
((ACTUAL_POSITION - 1) >= 0) and E() and ((ACTUAL_POSITION - 1) <= #PCS::MaxPosition)) >>
S [263]EstimatedActualPosition' := (EstimatedActualPosition - 1)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION' >= 0) and 
(ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1019]


done reducing composite actions
step:  182
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2159]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition > 0))) >>
S [165]->
Q [15] << (E() and (ACTUAL_POSITION > 0) and ACTUAL_IN_RANGE()) >>
Reason:  Normalization
  What for: P -> P1 in sequential composition for [serial 1019]

  Normalization Axioms:

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2165]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < EstimatedActualPosition >>
S [165]->
Q [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 2159]


This Proof Obligation:

[serial 2160]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION' >= 0) and 
(ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [167]->
Q [15] << (E() and ACTUAL_IN_RANGE())^1 >>
Reason:  Normalization
  What for: Q2 -> Q in sequential composition for [serial 1019]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2167]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [167]->
Q [15] << (ACTUAL_IN_RANGE() and E())^1 >>
  What for:   normalization of [serial 2160]


This Proof Obligation:

[serial 2161]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and (ACTUAL_POSITION > 0) and ACTUAL_IN_RANGE()) >>
S [255]Delta := -1
Q [15] << (E() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= 0) and AXIOM_GT(ACTUAL_POSITION) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1019]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2169]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]Delta := -1
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
  What for:   normalization of [serial 2161]


This Proof Obligation:

[serial 2162]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (E() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= 0) and AXIOM_GT(ACTUAL_POSITION) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) >>
S [259]ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and 
((ACTUAL_POSITION - 1) >= 0) and E() and ((ACTUAL_POSITION - 1) <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1019]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2171]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]ActuatorCommand(pc:Delta)
Q [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
  What for:   normalization of [serial 2162]


This Proof Obligation:

[serial 2163]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and 
((ACTUAL_POSITION - 1) >= 0) and E() and ((ACTUAL_POSITION - 1) <= #PCS::MaxPosition)) >>
S [263]EstimatedActualPosition' := (EstimatedActualPosition - 1)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION' >= 0) and 
(ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1019]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2173]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]EstimatedActualPosition' := (EstimatedActualPosition - 1)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
  What for:   normalization of [serial 2163]

. . . done Normalizing Unsolved Proof Obligations [23.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2165]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < EstimatedActualPosition >>
S [165]->
Q [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 2159]



[serial 2167]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [167]->
Q [15] << (ACTUAL_IN_RANGE() and E())^1 >>
  What for:   normalization of [serial 2160]



[serial 2169]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]Delta := -1
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
  What for:   normalization of [serial 2161]



[serial 2171]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]ActuatorCommand(pc:Delta)
Q [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
  What for:   normalization of [serial 2162]



[serial 2173]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]EstimatedActualPosition' := (EstimatedActualPosition - 1)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
  What for:   normalization of [serial 2163]


Done Normalizing
step:  183
****atomic****
applying atomic actions . . .
solving assignment on line 255
replacing "Delta" with "-1"
makes:  << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = -1 and AXIOM_GT(ACTUAL_POSITION) and E() >>

This Proof Obligation:

[serial 2169]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]Delta := -1
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for:   normalization of [serial 2161]

Has applied := to get:

[serial 2179]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = -1 and AXIOM_GT(ACTUAL_POSITION) and E() >>
  What for: applied wp for assignment [serial 2169]

Creating weakest-precondition predicate transfer for subprogram invocation of "ActuatorCommand".

This Proof Obligation:

[serial 2171]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]ActuatorCommand(pc:Delta)
Q [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
Reason:  Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
  What for:   normalization of [serial 2162]

Used weakest precondition predicate transformation on
+ <<P>> ActuatorCommand(X) <<Q>> to get:

[serial 2180]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and 
E() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2171]

solving assignment on line 263
replacing "EstimatedActualPosition'" with "(EstimatedActualPosition - 1)"
makes:  << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) >>

This Proof Obligation:

[serial 2173]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]EstimatedActualPosition' := (EstimatedActualPosition - 1)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for:   normalization of [serial 2163]

Has applied := to get:

[serial 2181]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) >>
  What for: applied wp for assignment [serial 2173]

. . . done applying atomic actions [23.7 seconds ]
After "atomic" remaining 
Obligations:

[serial 2165]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < EstimatedActualPosition >>
S [165]->
Q [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 2159]



[serial 2167]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [167]->
Q [15] << (ACTUAL_IN_RANGE() and E())^1 >>
  What for:   normalization of [serial 2160]



[serial 2179]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = -1 and AXIOM_GT(ACTUAL_POSITION) and E() >>
  What for: applied wp for assignment [serial 2169]



[serial 2180]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and 
E() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2171]



[serial 2181]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) >>
  What for: applied wp for assignment [serial 2173]


Done reducing atomic actions
step:  184
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2179]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = -1 and AXIOM_GT(ACTUAL_POSITION) and E() >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for: applied wp for assignment [serial 2169]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 2182]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
true and AXIOM_GT(ACTUAL_POSITION) and E() >>
  What for: Equality Law (idistr):  a=a <-> true [serial 2179]


This Proof Obligation:

[serial 2180]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and 
E() >>
Reason:  Associativity: (b.c).a = a.b.c
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2171]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2183]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and E() >>
  What for: Associativity: (b.c).a = a.b.c [serial 2180]


This Proof Obligation:

[serial 2182]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
true and AXIOM_GT(ACTUAL_POSITION) and E() >>
Reason:  Law of And-Simplification:  P and true is P
  What for: Equality Law (idistr):  a=a <-> true [serial 2179]

Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 2184]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
AXIOM_GT(ACTUAL_POSITION) and E() >>
  What for: Law of And-Simplification:  P and true is P [serial 2182]

. . . done Applying Laws [23.7 seconds ]
After "laws" remaining 
Obligations:

[serial 2165]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < EstimatedActualPosition >>
S [165]->
Q [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 2159]



[serial 2167]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [167]->
Q [15] << (ACTUAL_IN_RANGE() and E())^1 >>
  What for:   normalization of [serial 2160]



[serial 2181]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) >>
  What for: applied wp for assignment [serial 2173]



[serial 2183]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and E() >>
  What for: Associativity: (b.c).a = a.b.c [serial 2180]



[serial 2184]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
AXIOM_GT(ACTUAL_POSITION) and E() >>
  What for: Law of And-Simplification:  P and true is P [serial 2182]


Done applying laws
step:  185
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 2184]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
AXIOM_GT(ACTUAL_POSITION) and E() >>
Reason:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
  What for: Law of And-Simplification:  P and true is P [serial 2182]

has been transformed into:

[serial 2185]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
true and E() >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


by removing axioms from postconditions.

. . . done removing axioms from postconditions  [23.7 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 2165]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < EstimatedActualPosition >>
S [165]->
Q [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 2159]



[serial 2167]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [167]->
Q [15] << (ACTUAL_IN_RANGE() and E())^1 >>
  What for:   normalization of [serial 2160]



[serial 2181]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) >>
  What for: applied wp for assignment [serial 2173]



[serial 2183]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and E() >>
  What for: Associativity: (b.c).a = a.b.c [serial 2180]



[serial 2185]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
true and E() >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 



Done removing axioms from postconditions
step:  186
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2185]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
true and E() >>
Reason:  Law of And-Simplification:  P and true is P
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 2186]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
E() >>
  What for: Law of And-Simplification:  P and true is P [serial 2185]

. . . done Applying Laws [23.7 seconds ]
After "laws" remaining 
Obligations:

[serial 2165]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < EstimatedActualPosition >>
S [165]->
Q [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 2159]



[serial 2167]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [167]->
Q [15] << (ACTUAL_IN_RANGE() and E())^1 >>
  What for:   normalization of [serial 2160]



[serial 2181]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) >>
  What for: applied wp for assignment [serial 2173]



[serial 2183]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and E() >>
  What for: Associativity: (b.c).a = a.b.c [serial 2180]



[serial 2186]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
E() >>
  What for: Law of And-Simplification:  P and true is P [serial 2185]


Done applying laws
step:  187
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2181]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) >>
Reason:  Normalization
  What for: applied wp for assignment [serial 2173]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2190]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2181]


This Proof Obligation:

[serial 2183]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and E() >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 2180]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2192]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and -1 = Delta and E() >>
  What for:   normalization of [serial 2183]

. . . done Normalizing Unsolved Proof Obligations [23.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 2165]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < EstimatedActualPosition >>
S [165]->
Q [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 2159]



[serial 2167]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [167]->
Q [15] << (ACTUAL_IN_RANGE() and E())^1 >>
  What for:   normalization of [serial 2160]



[serial 2186]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
E() >>
  What for: Law of And-Simplification:  P and true is P [serial 2185]



[serial 2190]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2181]



[serial 2192]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and -1 = Delta and E() >>
  What for:   normalization of [serial 2183]


Done Normalizing
step:  188
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 2165]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < EstimatedActualPosition >>
S [165]->
Q [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 2159]

Has split postcondition to get:

[serial 2196]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < EstimatedActualPosition >>
S [165]->
Q [254] << ACTUAL_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2165]


[serial 2197]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < EstimatedActualPosition >>
S [165]->
Q [254] << E() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2165]


[serial 2198]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < EstimatedActualPosition >>
S [165]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2165]


This Proof Obligation:

[serial 2186]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
E() >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for: Law of And-Simplification:  P and true is P [serial 2185]

Has split postcondition to get:

[serial 2199]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2186]


[serial 2200]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [257] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2186]


[serial 2201]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [256] << E() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2186]


This Proof Obligation:

[serial 2190]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 2181]

Has split postcondition to get:

[serial 2202]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2190]


[serial 2203]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [265] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2190]


[serial 2204]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [264] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2190]


This Proof Obligation:

[serial 2192]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and -1 = Delta and E() >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 2183]

Has split postcondition to get:

[serial 2205]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]


[serial 2206]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]


[serial 2207]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [261] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]


[serial 2208]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]


[serial 2209]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [260] << -1 = Delta >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]


[serial 2210]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [261] << E() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]

. . . done splitting postcondition  [23.7 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 2167]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [167]->
Q [15] << (ACTUAL_IN_RANGE() and E())^1 >>
  What for:   normalization of [serial 2160]



[serial 2196]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < EstimatedActualPosition >>
S [165]->
Q [254] << ACTUAL_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2165]



[serial 2197]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < EstimatedActualPosition >>
S [165]->
Q [254] << E() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2165]



[serial 2198]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < EstimatedActualPosition >>
S [165]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2165]



[serial 2199]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2186]



[serial 2200]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [257] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2186]



[serial 2201]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [256] << E() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2186]



[serial 2202]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2190]



[serial 2203]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [265] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2190]



[serial 2204]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [264] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2190]



[serial 2205]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]



[serial 2206]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]



[serial 2207]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [261] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]



[serial 2208]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]



[serial 2209]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [260] << -1 = Delta >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]



[serial 2210]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [261] << E() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]


Done splitting postcondition
step:  189
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2196]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < EstimatedActualPosition >>
S [165]->
Q [254] << ACTUAL_IN_RANGE() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2165]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2197]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < EstimatedActualPosition >>
S [165]->
Q [254] << E() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2165]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2201]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [256] << E() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2186]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2205]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2209]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [260] << -1 = Delta >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2210]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [261] << E() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [23.7 seconds ]
After "axioms" remaining 
Obligations:

[serial 2167]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [167]->
Q [15] << (ACTUAL_IN_RANGE() and E())^1 >>
  What for:   normalization of [serial 2160]



[serial 2198]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < EstimatedActualPosition >>
S [165]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2165]



[serial 2199]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2186]



[serial 2200]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [257] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2186]



[serial 2202]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2190]



[serial 2203]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [265] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2190]



[serial 2204]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [264] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2190]



[serial 2206]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]



[serial 2207]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [261] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]



[serial 2208]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]


Done trying to apply axioms
step:  190
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  191
#ControlSoftware::FragilePositionControlThread.SingleStep
step:  192
#[serial 1685]   normalization of [serial 1678
step:  193
****make-an****
Making obligation 33
Obligations:

[serial 2167]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [167]->
Q [15] << (ACTUAL_IN_RANGE() and E())^1 >>
  What for:   normalization of [serial 2160]


Done making obligation 33
step:  194
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2167]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [167]->
Q [15] << (ACTUAL_IN_RANGE() and E())^1 >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 2160]

Has substituted Assertions' predicates for labels to get:

[serial 2211]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [167]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels  [serial 2167]

. . . done Substituting Assertions for Labels [23.7 seconds ]
After "substitute" remaining 
Obligations:

[serial 2211]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [167]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels  [serial 2167]


Done substituting Assertion labels.
step:  195
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2211]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [167]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 2167]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2213]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [167]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
  What for:   normalization of [serial 2211]

. . . done Normalizing Unsolved Proof Obligations [23.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 2213]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [167]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
  What for:   normalization of [serial 2211]


Done Normalizing
step:  196
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2213]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [167]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2211]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2215]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [167]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition)^1 >>
  What for: Associativity: (b.c).a = a.b.c [serial 2213]

. . . done Applying Laws [23.7 seconds ]
After "laws" remaining 
Obligations:

[serial 2215]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [167]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition)^1 >>
  What for: Associativity: (b.c).a = a.b.c [serial 2213]


Done applying laws
step:  197
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2215]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [167]->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition)^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Associativity: (b.c).a = a.b.c [serial 2213]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2216]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
(ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [167]->
Q [15] << ((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1 and 
(ACTUAL_POSITION = EstimatedActualPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2215]

. . . done spltting timed atoms  [23.7 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [23.7 seconds ]
After "dist^" remaining 
Obligations:

[serial 2216]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
(ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [167]->
Q [15] << ((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1 and 
(ACTUAL_POSITION = EstimatedActualPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2215]


Done distributing ^ and @.
step:  198
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2216]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
(ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [167]->
Q [15] << ((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1 and 
(ACTUAL_POSITION = EstimatedActualPosition)^1) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2215]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2217]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
(ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [167]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2216]

. . . done spltting timed atoms  [23.8 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [23.8 seconds ]
After "dist^" remaining 
Obligations:

[serial 2217]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
(ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [167]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2216]


Done distributing ^ and @.
step:  199
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2217]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
(ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [167]->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2216]

  Normalization Axioms:

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Constants are always the same
Has been normalized to get:

[serial 2219]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [167]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
  What for:   normalization of [serial 2217]

. . . done Normalizing Unsolved Proof Obligations [23.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2219]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [167]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
  What for:   normalization of [serial 2217]


Done Normalizing
step:  200
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2219]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [167]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 2217]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [23.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2198]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < EstimatedActualPosition >>
S [165]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2165]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  201
#[serial 1716] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1683]
step:  202
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2198]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < EstimatedActualPosition >>
S [165]->
Q [1] << 0 < ACTUAL_POSITION >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2165]

Has substituted Assertions' predicates for labels to get:

[serial 2221]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < EstimatedActualPosition >>
S [165]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels  [serial 2198]

. . . done Substituting Assertions for Labels [23.8 seconds ]
After "substitute" remaining 
Obligations:

[serial 2221]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < EstimatedActualPosition >>
S [165]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels  [serial 2198]


Done substituting Assertion labels.
step:  203
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2221]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < EstimatedActualPosition >>
S [165]->
Q [1] << 0 < ACTUAL_POSITION >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 2198]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2223]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and 0 < EstimatedActualPosition >>
S [165]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 2221]

. . . done Normalizing Unsolved Proof Obligations [23.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2223]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and 0 < EstimatedActualPosition >>
S [165]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 2221]


Done Normalizing
step:  204
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2223]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and 0 < EstimatedActualPosition >>
S [165]->
Q [1] << 0 < ACTUAL_POSITION >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2221]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2225]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < EstimatedActualPosition >>
S [165]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 2223]

. . . done Applying Laws [23.8 seconds ]
After "laws" remaining 
Obligations:

[serial 2225]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < EstimatedActualPosition >>
S [165]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 2223]


Done applying laws
step:  205
****substitute all equivalents****
substituting all equals . . .
Replacing all "ACTUAL_POSITION" with  "EstimatedActualPosition" in  "ASSERTION[1]" makes:
<< 0 < EstimatedActualPosition >>

This Proof Obligation:

[serial 2225]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < EstimatedActualPosition >>
S [165]->
Q [1] << 0 < ACTUAL_POSITION >>
Reason:  Substitution in Postcondition of All Equivalents in Precondition
  What for: Associativity: (b.c).a = a.b.c [serial 2223]

Has substituted in postcondition all equivalents in precondition to get:

[serial 2226]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < EstimatedActualPosition >>
S [165]->
Q [1] << 0 < EstimatedActualPosition >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 2225]

. . . done substituting all equals  [23.8 seconds ]
After substituting all equivalents remaining 
Obligations:

[serial 2226]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < EstimatedActualPosition >>
S [165]->
Q [1] << 0 < EstimatedActualPosition >>
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 2225]


Done substituting all equivalents
step:  206
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2226]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < EstimatedActualPosition >>
S [165]->
Q [1] << 0 < EstimatedActualPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 2225]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [23.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2199]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2186]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  207
#[serial 1717] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1704]
step:  208
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2199]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2186]

Has substituted Assertions' predicates for labels to get:

[serial 2227]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [255]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for: substituted Assertions' predicates for  labels  [serial 2199]

. . . done Substituting Assertions for Labels [23.8 seconds ]
After "substitute" remaining 
Obligations:

[serial 2227]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [255]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for: substituted Assertions' predicates for  labels  [serial 2199]


Done substituting Assertion labels.
step:  209
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2227]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [255]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for: substituted Assertions' predicates for  labels  [serial 2199]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2228]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [255]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2227]

. . . done Applying Laws [23.8 seconds ]
After "laws" remaining 
Obligations:

[serial 2228]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [255]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2227]


Done applying laws
step:  210
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2228]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [255]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 2227]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2230]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [255]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for:   normalization of [serial 2228]

. . . done Normalizing Unsolved Proof Obligations [23.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2230]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [255]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for:   normalization of [serial 2228]


Done Normalizing
step:  211
****partial to total order****
Making partial orders into total orders . . .
Making partial orders into total orders . . .

This Proof Obligation:

[serial 2230]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [255]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
Reason:  Partial Order Law 3:  a <= (b-1)  is  a<b
  What for:   normalization of [serial 2228]

Has applied Partial Order Law 3:  a <= (b-1)  is  a<b (  0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION
) to get:

[serial 2232]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [255]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for:   0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2230]

. . . done making partial orders into total orders [23.8 seconds ]
After making partial orders into total orders 
Obligations:

[serial 2232]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [255]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for:   0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2230]


Done making partial orders into total orders
step:  212
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2232]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [255]->
Q [1] << 0 < ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2230]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [23.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2200]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [257] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2186]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  213
#[serial 1718] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1704]
step:  214
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2200]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255]->
Q [257] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2186]

Has substituted Assertions' predicates for labels to get:

[serial 2233]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [255]->
Q [257] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels  [serial 2200]

. . . done Substituting Assertions for Labels [23.8 seconds ]
After "substitute" remaining 
Obligations:

[serial 2233]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [255]->
Q [257] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels  [serial 2200]


Done substituting Assertion labels.
step:  215
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2233]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [255]->
Q [257] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 2200]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2235]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and 0 < ACTUAL_POSITION >>
S [255]->
Q [257] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2233]

. . . done Normalizing Unsolved Proof Obligations [23.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2235]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and 0 < ACTUAL_POSITION >>
S [255]->
Q [257] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2233]


Done Normalizing
step:  216
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2235]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and 0 < ACTUAL_POSITION >>
S [255]->
Q [257] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2233]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2237]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [255]->
Q [257] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 2235]

. . . done Applying Laws [23.8 seconds ]
After "laws" remaining 
Obligations:

[serial 2237]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [255]->
Q [257] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 2235]


Done applying laws
step:  217
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2237]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [255]->
Q [257] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Associativity: (b.c).a = a.b.c [serial 2235]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [23.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2202]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2190]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  218
#[serial 1720] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1708]
step:  219
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  (ACTUAL_POSITION + Delta) = ACTUAL_POSITION'

This Proof Obligation:

[serial 2202]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [1] << 0 <= ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2190]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 2238]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2202]

. . . done guided substitution of equals  [23.8 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2238]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2202]


Done guided substituting an equals
step:  220
****guided-sub-equals****
guided substitution of equals "Delta" . . .
equality selected for substitution:  -1 = Delta

This Proof Obligation:

[serial 2238]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
Reason:  Guided Substitution of Equals
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2202]

Has substituted 
"Delta" with its = "-1"
 to get:

[serial 2239]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [1] << 0 <= ((ACTUAL_POSITION + -1)) >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 2238]

. . . done guided substitution of equals  [23.8 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2239]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [1] << 0 <= ((ACTUAL_POSITION + -1)) >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 2238]


Done guided substituting an equals
step:  221
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2239]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [1] << 0 <= ((ACTUAL_POSITION + -1)) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 2238]

  Normalization Axioms:

    Reflexivity of Addition: a+b=b+a

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2241]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
  What for:   normalization of [serial 2239]

. . . done Normalizing Unsolved Proof Obligations [23.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2241]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
  What for:   normalization of [serial 2239]


Done Normalizing
step:  222
****change subtraction to adding unary minus****
changing subtraction to adding negation . . .

This Proof Obligation:

[serial 2241]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
Reason:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
  What for:   normalization of [serial 2239]

Has changed subtraction to adding negation to get:

[serial 2243]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION +  -1) and (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition and 
 -1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [1] << 0 <= ( -1 + ACTUAL_POSITION) >>
  What for:  changing adding negation to subtraction  [serial 2241]

. . . done substituting all equals  [23.8 seconds ]
After changing subtraction to adding unary minus remaining 
Obligations:

[serial 2243]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION +  -1) and (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition and 
 -1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [1] << 0 <= ( -1 + ACTUAL_POSITION) >>
  What for:  changing adding negation to subtraction  [serial 2241]


Done changing subtraction to adding unary minus
step:  223
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2243]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION +  -1) and (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition and 
 -1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [1] << 0 <= ( -1 + ACTUAL_POSITION) >>
Reason:  Normalization
  What for:  changing adding negation to subtraction  [serial 2241]

  Normalization Axioms:

    Literal Arithmetic

    Reflexivity of Addition: a+b=b+a

    Reflexivity of Equality: (a=b) = (b=a)

    Unary Minus:  -(x-y) is (y-x)
Has been normalized to get:

[serial 2245]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (-1 + ACTUAL_POSITION) and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
  What for:   normalization of [serial 2243]

. . . done Normalizing Unsolved Proof Obligations [23.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2245]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (-1 + ACTUAL_POSITION) and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
  What for:   normalization of [serial 2243]


Done Normalizing
step:  224
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2245]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (-1 + ACTUAL_POSITION) and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 2243]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [23.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2203]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [265] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2190]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  225
#[serial 1721] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1708]
step:  226
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  (ACTUAL_POSITION + Delta) = ACTUAL_POSITION'

This Proof Obligation:

[serial 2203]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [265] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2190]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 2247]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [265] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2203]

. . . done guided substitution of equals  [23.8 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2247]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [265] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2203]


Done guided substituting an equals
step:  227
****partial to total order****
Making partial orders into total orders . . .
Making partial orders into total orders . . .

This Proof Obligation:

[serial 2247]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [265] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
Reason:  Partial Order Law 3:  a <= (b-1)  is  a<b
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2203]

Has applied Partial Order Law 3:  a <= (b-1)  is  a<b (0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION
  ) to get:

[serial 2248]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [265] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
  What for: 0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2247]

. . . done making partial orders into total orders [23.8 seconds ]
After making partial orders into total orders 
Obligations:

[serial 2248]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [265] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
  What for: 0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2247]


Done making partial orders into total orders
step:  228
****guided-sub-equals****
guided substitution of equals "Delta" . . .
equality selected for substitution:  -1 = Delta

This Proof Obligation:

[serial 2248]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [265] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for: 0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2247]

Has substituted 
"Delta" with its = "-1"
 to get:

[serial 2249]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [265] << ((ACTUAL_POSITION + -1)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 2248]

. . . done guided substitution of equals  [23.8 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2249]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [265] << ((ACTUAL_POSITION + -1)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 2248]


Done guided substituting an equals
step:  229
****change subtraction to adding unary minus****
changing subtraction to adding negation . . .

This Proof Obligation:

[serial 2249]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [265] << ((ACTUAL_POSITION + -1)) <= #PCS::MaxPosition >>
Reason:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 2248]

Has changed subtraction to adding negation to get:

[serial 2250]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 < ACTUAL_POSITION and (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition and 
 -1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [265] << ((ACTUAL_POSITION +  -1)) <= #PCS::MaxPosition >>
  What for:  changing adding negation to subtraction  [serial 2249]

. . . done substituting all equals  [23.8 seconds ]
After changing subtraction to adding unary minus remaining 
Obligations:

[serial 2250]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 < ACTUAL_POSITION and (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition and 
 -1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [265] << ((ACTUAL_POSITION +  -1)) <= #PCS::MaxPosition >>
  What for:  changing adding negation to subtraction  [serial 2249]


Done changing subtraction to adding unary minus
step:  230
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2250]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 < ACTUAL_POSITION and (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition and 
 -1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [265] << ((ACTUAL_POSITION +  -1)) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for:  changing adding negation to subtraction  [serial 2249]

  Normalization Axioms:

    Literal Arithmetic

    Reflexivity of Equality: (a=b) = (b=a)

    Unary Minus:  -(x-y) is (y-x)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2252]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and -1 = Delta and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E() and 0 < ACTUAL_POSITION >>
S [263]->
Q [265] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2250]

. . . done Normalizing Unsolved Proof Obligations [23.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2252]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and -1 = Delta and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E() and 0 < ACTUAL_POSITION >>
S [263]->
Q [265] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2250]


Done Normalizing
step:  231
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2252]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and -1 = Delta and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E() and 0 < ACTUAL_POSITION >>
S [263]->
Q [265] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 2250]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [23.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2204]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [264] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2190]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  232
#[serial 1722] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1708]
step:  233
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  (ACTUAL_POSITION + Delta) = ACTUAL_POSITION'

This Proof Obligation:

[serial 2204]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [264] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2190]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 2254]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [264] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + Delta)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2204]

. . . done guided substitution of equals  [23.8 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2254]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [264] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + Delta)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2204]


Done guided substituting an equals
step:  234
****guided-sub-equals****
guided substitution of equals "Delta" . . .
equality selected for substitution:  -1 = Delta

This Proof Obligation:

[serial 2254]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [264] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + Delta)) >>
Reason:  Guided Substitution of Equals
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2204]

Has substituted 
"Delta" with its = "-1"
 to get:

[serial 2255]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [264] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + -1)) >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 2254]

. . . done guided substitution of equals  [23.8 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2255]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [264] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + -1)) >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 2254]


Done guided substituting an equals
step:  235
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2255]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263]->
Q [264] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + -1)) >>
Reason:  Substitution of Assertion Labels
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 2254]

Has substituted Assertions' predicates for labels to get:

[serial 2256]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [263]->
Q [264] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + -1)) >>
  What for: substituted Assertions' predicates for  labels  [serial 2255]

. . . done Substituting Assertions for Labels [23.9 seconds ]
After "substitute" remaining 
Obligations:

[serial 2256]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [263]->
Q [264] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + -1)) >>
  What for: substituted Assertions' predicates for  labels  [serial 2255]


Done substituting Assertion labels.
step:  236
****change subtraction to adding unary minus****
changing subtraction to adding negation . . .

This Proof Obligation:

[serial 2256]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [263]->
Q [264] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + -1)) >>
Reason:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
  What for: substituted Assertions' predicates for  labels  [serial 2255]

Has changed subtraction to adding negation to get:

[serial 2257]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION +  -1) and (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition and 
 -1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [263]->
Q [264] << (EstimatedActualPosition +  -1) = ((ACTUAL_POSITION +  -1)) >>
  What for:  changing adding negation to subtraction  [serial 2256]

. . . done substituting all equals  [23.9 seconds ]
After changing subtraction to adding unary minus remaining 
Obligations:

[serial 2257]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION +  -1) and (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition and 
 -1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [263]->
Q [264] << (EstimatedActualPosition +  -1) = ((ACTUAL_POSITION +  -1)) >>
  What for:  changing adding negation to subtraction  [serial 2256]


Done changing subtraction to adding unary minus
step:  237
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2257]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION +  -1) and (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition and 
 -1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [263]->
Q [264] << (EstimatedActualPosition +  -1) = ((ACTUAL_POSITION +  -1)) >>
Reason:  Normalization
  What for:  changing adding negation to subtraction  [serial 2256]

  Normalization Axioms:

    Literal Arithmetic

    Reflexivity of Equality: (a=b) = (b=a)

    Unary Minus:  -(x-y) is (y-x)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2259]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (-1 + ACTUAL_POSITION) and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [263]->
Q [264] << (-1 + ACTUAL_POSITION) = (-1 + EstimatedActualPosition) >>
  What for:   normalization of [serial 2257]

. . . done Normalizing Unsolved Proof Obligations [23.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 2259]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (-1 + ACTUAL_POSITION) and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [263]->
Q [264] << (-1 + ACTUAL_POSITION) = (-1 + EstimatedActualPosition) >>
  What for:   normalization of [serial 2257]


Done Normalizing
step:  238
****change subtraction to adding unary minus****
changing subtraction to adding negation . . .

This Proof Obligation:

[serial 2259]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (-1 + ACTUAL_POSITION) and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [263]->
Q [264] << (-1 + ACTUAL_POSITION) = (-1 + EstimatedActualPosition) >>
Reason:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
  What for:   normalization of [serial 2257]

Has changed subtraction to adding negation to get:

[serial 2261]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ( -1 + ACTUAL_POSITION) and ( -1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
 -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [263]->
Q [264] << ( -1 + ACTUAL_POSITION) = ( -1 + EstimatedActualPosition) >>
  What for:  changing adding negation to subtraction  [serial 2259]

. . . done substituting all equals  [23.9 seconds ]
After changing subtraction to adding unary minus remaining 
Obligations:

[serial 2261]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ( -1 + ACTUAL_POSITION) and ( -1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
 -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [263]->
Q [264] << ( -1 + ACTUAL_POSITION) = ( -1 + EstimatedActualPosition) >>
  What for:  changing adding negation to subtraction  [serial 2259]


Done changing subtraction to adding unary minus
step:  239
****sub-equals****
substituting an equals . . .

This Proof Obligation:

[serial 2261]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ( -1 + ACTUAL_POSITION) and ( -1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
 -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [263]->
Q [264] << ( -1 + ACTUAL_POSITION) = ( -1 + EstimatedActualPosition) >>
Reason:  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
  What for:  changing adding negation to subtraction  [serial 2259]

Has substituted 
"EstimatedActualPosition"
 with its =
 "(ACTUAL_POSITION)"
 to get:

[serial 2262]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ( -1 + ACTUAL_POSITION) and ( -1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
 -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [263]->
Q [264] << (-1 + ACTUAL_POSITION) = (-1 + ACTUAL_POSITION) >>
  What for: Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
 replacing "EstimatedActualPosition"
 with its ="
 (ACTUAL_POSITION)" [serial 2261]

with score 2.
. . . done substituting an equals  [23.9 seconds ]
After substituting an equals remaining 
Obligations:

[serial 2262]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ( -1 + ACTUAL_POSITION) and ( -1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
 -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [263]->
Q [264] << (-1 + ACTUAL_POSITION) = (-1 + ACTUAL_POSITION) >>
  What for: Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
 replacing "EstimatedActualPosition"
 with its ="
 (ACTUAL_POSITION)" [serial 2261]


Done substituting an equals
step:  240
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2262]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ( -1 + ACTUAL_POSITION) and ( -1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
 -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [263]->
Q [264] << (-1 + ACTUAL_POSITION) = (-1 + ACTUAL_POSITION) >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for: Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
 replacing "EstimatedActualPosition"
 with its ="
 (ACTUAL_POSITION)" [serial 2261]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 2263]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ( -1 + ACTUAL_POSITION) and ( -1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
 -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [263]->
Q [264] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 2262]

. . . done Applying Laws [23.9 seconds ]
After "laws" remaining 
Obligations:

[serial 2263]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ( -1 + ACTUAL_POSITION) and ( -1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
 -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [263]->
Q [264] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 2262]


Done applying laws
step:  241
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2263]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= ( -1 + ACTUAL_POSITION) and ( -1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
 -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [263]->
Q [264] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 2262]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [23.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2206]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  242
#[serial 1724] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1710]
step:  243
****sub-equals****
substituting an equals . . .

This Proof Obligation:

[serial 2206]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]

Has substituted 
"Delta"
 with its =
 "(-1)"
 to get:

[serial 2264]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
  What for: Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
 replacing "Delta"
 with its ="
 (-1)" [serial 2206]

with score 1.
. . . done substituting an equals  [23.9 seconds ]
After substituting an equals remaining 
Obligations:

[serial 2264]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
  What for: Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
 replacing "Delta"
 with its ="
 (-1)" [serial 2206]


Done substituting an equals
step:  244
****change subtraction to adding unary minus****
changing subtraction to adding negation . . .

This Proof Obligation:

[serial 2264]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
Reason:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
  What for: Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
 replacing "Delta"
 with its ="
 (-1)" [serial 2206]

Has changed subtraction to adding negation to get:

[serial 2265]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION +  -1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
 -1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [1] << 0 <= ( -1 + ACTUAL_POSITION) >>
  What for:  changing adding negation to subtraction  [serial 2264]

. . . done substituting all equals  [23.9 seconds ]
After changing subtraction to adding unary minus remaining 
Obligations:

[serial 2265]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION +  -1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
 -1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [1] << 0 <= ( -1 + ACTUAL_POSITION) >>
  What for:  changing adding negation to subtraction  [serial 2264]


Done changing subtraction to adding unary minus
step:  245
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2265]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION +  -1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
 -1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [1] << 0 <= ( -1 + ACTUAL_POSITION) >>
Reason:  Normalization
  What for:  changing adding negation to subtraction  [serial 2264]

  Normalization Axioms:

    Literal Arithmetic

    Reflexivity of Addition: a+b=b+a

    Reflexivity of Equality: (a=b) = (b=a)

    Unary Minus:  -(x-y) is (y-x)
Has been normalized to get:

[serial 2267]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (-1 + ACTUAL_POSITION) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
  What for:   normalization of [serial 2265]

. . . done Normalizing Unsolved Proof Obligations [23.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 2267]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (-1 + ACTUAL_POSITION) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
  What for:   normalization of [serial 2265]


Done Normalizing
step:  246
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2267]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (-1 + ACTUAL_POSITION) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 2265]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [23.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2207]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [261] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  247
#[serial 1725] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1710]
step:  248
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2207]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [261] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]

Has substituted Assertions' predicates for labels to get:

[serial 2269]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and (((ACTUAL_POSITION - 1) < ACTUAL_POSITION)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [259]->
Q [261] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels  [serial 2207]

. . . done Substituting Assertions for Labels [23.9 seconds ]
After "substitute" remaining 
Obligations:

[serial 2269]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and (((ACTUAL_POSITION - 1) < ACTUAL_POSITION)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [259]->
Q [261] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels  [serial 2207]


Done substituting Assertion labels.
step:  249
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2269]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and (((ACTUAL_POSITION - 1) < ACTUAL_POSITION)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [259]->
Q [261] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels  [serial 2207]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2271]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [259]->
Q [261] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2269]

. . . done Normalizing Unsolved Proof Obligations [23.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 2271]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [259]->
Q [261] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2269]


Done Normalizing
step:  250
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) < ACTUAL_POSITION -> 0 < ACTUAL_POSITION
Transitivity:  (ACTUAL_POSITION - 1) < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition -> (ACTUAL_POSITION - 1) < #PCS::MaxPosition
Transitivity:  0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition -> 0 < #PCS::MaxPosition

This Proof Obligation:

[serial 2271]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [259]->
Q [261] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for:   normalization of [serial 2269]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 2273]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [259]->
Q [261] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2271]

. . . done adding transitive terms [23.9 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 2273]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [259]->
Q [261] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2271]


Done adding transitive relations
step:  251
****partial to total order****
Making partial orders into total orders . . .
Making partial orders into total orders . . .

This Proof Obligation:

[serial 2273]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [259]->
Q [261] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
Reason:  Partial Order Law 3:  a <= (b-1)  is  a<b
  What for: Transitivity: x<y and y<z -> x<z [serial 2271]

Has applied Partial Order Law 3:  a <= (b-1)  is  a<b (0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION
(ACTUAL_POSITION - 1)<#PCS::MaxPosition  ->  (ACTUAL_POSITION - 1)<=#PCS::MaxPosition
  ) to get:

[serial 2274]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and -1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [259]->
Q [261] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for: 0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION
(ACTUAL_POSITION - 1)<#PCS::MaxPosition  ->  (ACTUAL_POSITION - 1)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2273]

. . . done making partial orders into total orders [23.9 seconds ]
After making partial orders into total orders 
Obligations:

[serial 2274]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and -1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [259]->
Q [261] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for: 0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION
(ACTUAL_POSITION - 1)<#PCS::MaxPosition  ->  (ACTUAL_POSITION - 1)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2273]


Done making partial orders into total orders
step:  252
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2274]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and -1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [259]->
Q [261] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: 0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION
(ACTUAL_POSITION - 1)<#PCS::MaxPosition  ->  (ACTUAL_POSITION - 1)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2273]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [23.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2208]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  253
#[serial 1724] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1708]
step:  254
****guided-sub-equals****
guided substitution of equals "Delta" . . .
equality selected for substitution:  -1 = Delta

This Proof Obligation:

[serial 2208]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]

Has substituted 
"Delta" with its = "-1"
 to get:

[serial 2275]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [130] << (ACTUAL_POSITION + -1) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 2208]

. . . done guided substitution of equals  [23.9 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2275]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [130] << (ACTUAL_POSITION + -1) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 2208]


Done guided substituting an equals
step:  255
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2275]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259]->
Q [130] << (ACTUAL_POSITION + -1) <= #PCS::MaxPosition >>
Reason:  Substitution of Assertion Labels
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 2208]

Has substituted Assertions' predicates for labels to get:

[serial 2276]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and (((ACTUAL_POSITION - 1) < ACTUAL_POSITION)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [259]->
Q [130] << (ACTUAL_POSITION + -1) <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2275]

. . . done Substituting Assertions for Labels [23.9 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 2276]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and (((ACTUAL_POSITION - 1) < ACTUAL_POSITION)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [259]->
Q [130] << (ACTUAL_POSITION + -1) <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2275]


Done substituting Assertion labels in preconditions
step:  256
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2276]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and (((ACTUAL_POSITION - 1) < ACTUAL_POSITION)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [259]->
Q [130] << (ACTUAL_POSITION + -1) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2275]

  Normalization Axioms:

    Reflexivity of Addition: a+b=b+a

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2278]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [259]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2276]

. . . done Normalizing Unsolved Proof Obligations [23.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 2278]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [259]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2276]


Done Normalizing
step:  257
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) < ACTUAL_POSITION -> 0 < ACTUAL_POSITION
Transitivity:  (ACTUAL_POSITION - 1) < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition -> (ACTUAL_POSITION - 1) < #PCS::MaxPosition
Transitivity:  0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition -> 0 < #PCS::MaxPosition

This Proof Obligation:

[serial 2278]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [259]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for:   normalization of [serial 2276]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 2280]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [259]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2278]

. . . done adding transitive terms [23.9 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 2280]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [259]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2278]


Done adding transitive relations
step:  258
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2280]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [259]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Transitivity: x<y and y<z -> x<z [serial 2278]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2282]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION and 
0 < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and (ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [259]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2280]

. . . done Normalizing Unsolved Proof Obligations [23.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 2282]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION and 
0 < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and (ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [259]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2280]


Done Normalizing
step:  259
****change subtraction to adding unary minus****
changing subtraction to adding negation . . .

This Proof Obligation:

[serial 2282]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION and 
0 < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and (ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [259]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
Reason:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
  What for:   normalization of [serial 2280]

Has changed subtraction to adding negation to get:

[serial 2284]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION +  -1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
 -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION and 
0 < #PCS::MaxPosition and (ACTUAL_POSITION +  -1) < ACTUAL_POSITION and 
(ACTUAL_POSITION +  -1) < #PCS::MaxPosition >>
S [259]->
Q [130] << ( -1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:  changing adding negation to subtraction  [serial 2282]

. . . done substituting all equals  [23.9 seconds ]
After changing subtraction to adding unary minus remaining 
Obligations:

[serial 2284]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION +  -1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
 -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION and 
0 < #PCS::MaxPosition and (ACTUAL_POSITION +  -1) < ACTUAL_POSITION and 
(ACTUAL_POSITION +  -1) < #PCS::MaxPosition >>
S [259]->
Q [130] << ( -1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:  changing adding negation to subtraction  [serial 2282]


Done changing subtraction to adding unary minus
step:  260
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2284]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (ACTUAL_POSITION +  -1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
 -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION and 
0 < #PCS::MaxPosition and (ACTUAL_POSITION +  -1) < ACTUAL_POSITION and 
(ACTUAL_POSITION +  -1) < #PCS::MaxPosition >>
S [259]->
Q [130] << ( -1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for:  changing adding negation to subtraction  [serial 2282]

  Normalization Axioms:

    Literal Arithmetic

    Reflexivity of Addition: a+b=b+a

    Reflexivity of Equality: (a=b) = (b=a)

    Unary Minus:  -(x-y) is (y-x)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2286]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (-1 + ACTUAL_POSITION) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION and 
0 < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION and (
-1 + ACTUAL_POSITION) < #PCS::MaxPosition >>
S [259]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2284]

. . . done Normalizing Unsolved Proof Obligations [23.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 2286]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (-1 + ACTUAL_POSITION) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION and 
0 < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION and (
-1 + ACTUAL_POSITION) < #PCS::MaxPosition >>
S [259]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2284]


Done Normalizing
step:  261
****partial to total order****
Making partial orders into total orders . . .
Making partial orders into total orders . . .

This Proof Obligation:

[serial 2286]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 <= (-1 + ACTUAL_POSITION) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION and 
0 < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION and (
-1 + ACTUAL_POSITION) < #PCS::MaxPosition >>
S [259]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
Reason:  Partial Order Law 3:  a <= (b-1)  is  a<b
  What for:   normalization of [serial 2284]

Has applied Partial Order Law 3:  a <= (b-1)  is  a<b (0<=(--1+ACTUAL_POSITION)  is  0<ACTUAL_POSITION
(-1 + ACTUAL_POSITION)<#PCS::MaxPosition  ->  (-1 + ACTUAL_POSITION)<=#PCS::MaxPosition
  ) to get:

[serial 2288]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and -1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 
(-1 + ACTUAL_POSITION) < ACTUAL_POSITION and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
S [259]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for: 0<=(--1+ACTUAL_POSITION)  is  0<ACTUAL_POSITION
(-1 + ACTUAL_POSITION)<#PCS::MaxPosition  ->  (-1 + ACTUAL_POSITION)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2286]

. . . done making partial orders into total orders [24.0 seconds ]
After making partial orders into total orders 
Obligations:

[serial 2288]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and -1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 
(-1 + ACTUAL_POSITION) < ACTUAL_POSITION and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
S [259]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for: 0<=(--1+ACTUAL_POSITION)  is  0<ACTUAL_POSITION
(-1 + ACTUAL_POSITION)<#PCS::MaxPosition  ->  (-1 + ACTUAL_POSITION)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2286]


Done making partial orders into total orders
step:  262
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2288]: ControlSoftware::FragilePositionControlThread.SingleStep
P [15] << 0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and -1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 
(-1 + ACTUAL_POSITION) < ACTUAL_POSITION and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
S [259]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: 0<=(--1+ACTUAL_POSITION)  is  0<ACTUAL_POSITION
(-1 + ACTUAL_POSITION)<#PCS::MaxPosition  ->  (-1 + ACTUAL_POSITION)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2286]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [24.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1020]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << (E() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition < 0))) >>
S [268]->
Q [170] << true >>
  What for:  <<M(ShutDown) and x>> -> <<M(Error)>> for fra8er:ShutDown-[x]->Error{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  263
#[serial 1020]  <<M(ShutDown) and x>> -> <<M(Error)>> for fra8er:ShutDown-[x]->Error{};
step:  264
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1020]: ControlSoftware::FragilePositionControlThread.SingleStep
P [165] << (E() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition < 0))) >>
S [268]->
Q [170] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for:  <<M(ShutDown) and x>> -> <<M(Error)>> for fra8er:ShutDown-[x]->Error{};

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [24.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1021]: ControlSoftware::FragilePositionControlThread.SingleStep
P [167] << (E() and ACTUAL_IN_RANGE()) >>
S [269]->
Q [165] << (E() and ACTUAL_IN_RANGE()) >>
  What for:  <<M(StillClosing) and x>> -> <<M(ShutDown)>> for fra9cl:StillClosing-[x]->ShutDown{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  265
#[serial 1021]  <<M(StillClosing) and x>> -> <<M(ShutDown)>> for fra9cl:StillClosing-[x]->ShutDown{};
step:  266
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1021]: ControlSoftware::FragilePositionControlThread.SingleStep
P [167] << (E() and ACTUAL_IN_RANGE()) >>
S [269]->
Q [165] << (E() and ACTUAL_IN_RANGE()) >>
Reason:  Identity (id):  P->P is tautology
  What for:  <<M(StillClosing) and x>> -> <<M(ShutDown)>> for fra9cl:StillClosing-[x]->ShutDown{};

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [24.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1023]: ControlSoftware::FragilePositionControlThread.MultiStep
P [302] << (E_MS() and ACTUAL_IN_RANGE()) >>
S [284]->
Q [284] << (E_MS() and ACTUAL_IN_RANGE()) >>
  What for: <<M(StillClosing)>> -> <<I>> from invariant I when complete state StillClosing has Assertion <<M(StillClosing)>> in its definition.


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
Main proof script resumed.
step:  6
#multi-step thread
step:  7
****subscript****
You chose proof subscript: /Users/brianlarson/Work/BLESS-2020/Stepper/proof scripts/subscripts/FragileMultiStep.ps
step:  1
#FragileMultiStep.ps
step:  2
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  3
****sort-by-component****
sorting proof obligations for ControlSoftware::FragilePositionControlThread.MultiStep
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1023]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1024]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1025]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1026]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1027]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1028]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1029]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1030]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1031]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1032]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1033]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1034]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1035]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1036]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1037]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1038]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1039]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1040]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1041]  
ControlSoftware::FragilePositionControlThread.MultiStep  [serial 1042]  
PositionSetpoint -> c.PositionSetpoint  [serial 1059]  
After sort-by-component[ControlSoftware::FragilePositionControlThread.MultiStep], no change. 
step:  4
#ControlSoftware::FragilePositionControlThread.MultiStep
step:  5
#[serial 1023] <<M(StillClosing)>> -> <<I>> from invariant I when complete state StillClosing has Assertion <<M(StillClosing)>> in its definition
step:  6
****make-an****
Making obligation 46
Obligations:

[serial 1023]: ControlSoftware::FragilePositionControlThread.MultiStep
P [302] << (E_MS() and ACTUAL_IN_RANGE()) >>
S [284]->
Q [284] << (E_MS() and ACTUAL_IN_RANGE()) >>
  What for: <<M(StillClosing)>> -> <<I>> from invariant I when complete state StillClosing has Assertion <<M(StillClosing)>> in its definition.


Done making obligation 46
step:  7
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1023]: ControlSoftware::FragilePositionControlThread.MultiStep
P [302] << (E_MS() and ACTUAL_IN_RANGE()) >>
S [284]->
Q [284] << (E_MS() and ACTUAL_IN_RANGE()) >>
Reason:  Identity (id):  P->P is tautology
  What for: <<M(StillClosing)>> -> <<I>> from invariant I when complete state StillClosing has Assertion <<M(StillClosing)>> in its definition.

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [24.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1024]: ControlSoftware::FragilePositionControlThread.MultiStep
P [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE()) >>
S [284]->
Q [284] << (E_MS() and ACTUAL_IN_RANGE()) >>
  What for: <<M(Run)>> -> <<I>> from invariant I when complete state Run has Assertion <<M(Run)>> in its definition.


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  8
#[serial 1024] <<M(Run)>> -> <<I>> from invariant I when complete state Run has Assertion <<M(Run)>> in its definition.
step:  9
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1024]: ControlSoftware::FragilePositionControlThread.MultiStep
P [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE()) >>
S [284]->
Q [284] << (E_MS() and ACTUAL_IN_RANGE()) >>
Reason:  Normalization
  What for: <<M(Run)>> -> <<I>> from invariant I when complete state Run has Assertion <<M(Run)>> in its definition.

  Normalization Axioms:

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2290]: ControlSoftware::FragilePositionControlThread.MultiStep
P [294] << ACTUAL_IN_RANGE() and D_MS() and E_MS() >>
S [284]->
Q [284] << ACTUAL_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 1024]

. . . done Normalizing Unsolved Proof Obligations [24.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 2290]: ControlSoftware::FragilePositionControlThread.MultiStep
P [294] << ACTUAL_IN_RANGE() and D_MS() and E_MS() >>
S [284]->
Q [284] << ACTUAL_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 1024]


Done Normalizing
step:  10
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2290]: ControlSoftware::FragilePositionControlThread.MultiStep
P [294] << ACTUAL_IN_RANGE() and D_MS() and E_MS() >>
S [284]->
Q [284] << ACTUAL_IN_RANGE() and E_MS() >>
Reason:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
  What for:   normalization of [serial 1024]

Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [24.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1025]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << (E_MS() and ACTUAL_IN_RANGE()) >>
S [300]->
Q [300] << (((EstimatedActualPosition = 0)) or ((EstimatedActualPosition > 0)) or 
((EstimatedActualPosition < 0))) >>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state ShutDown, <<M(ShutDown)>> -> <<e1 or e2 or . . . en>>


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  11
#[serial 1025] Serban's Theorem:  disjunction of execute conditions leaving execution state ShutDown, <<M(ShutDown)>> -> <<e1 or e2 or . . . en>>
step:  12
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1025]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << (E_MS() and ACTUAL_IN_RANGE()) >>
S [300]->
Q [300] << (((EstimatedActualPosition = 0)) or ((EstimatedActualPosition > 0)) or 
((EstimatedActualPosition < 0))) >>
Reason:  Normalization
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state ShutDown, <<M(ShutDown)>> -> <<e1 or e2 or . . . en>>

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2293]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() >>
S [300]->
Q [300] << 0 = EstimatedActualPosition or 0 < EstimatedActualPosition or EstimatedActualPosition < 0 >>
  What for:   normalization of [serial 1025]

. . . done Normalizing Unsolved Proof Obligations [24.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 2293]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() >>
S [300]->
Q [300] << 0 = EstimatedActualPosition or 0 < EstimatedActualPosition or EstimatedActualPosition < 0 >>
  What for:   normalization of [serial 1025]


Done Normalizing
step:  13
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2293]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() >>
S [300]->
Q [300] << 0 = EstimatedActualPosition or 0 < EstimatedActualPosition or EstimatedActualPosition < 0 >>
Reason:  Less than, greater than, or equal:  |-a<b or b<a or a=b
  What for:   normalization of [serial 1025]

Has applied law "Less than, greater than, or equal:  |-a<b or b<a or a=b" to get:

[serial 2295]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() >>
S [300]->
Q [300] << true >>
  What for: Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 2293]

. . . done Applying Laws [24.0 seconds ]
After "laws" remaining 
Obligations:

[serial 2295]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() >>
S [300]->
Q [300] << true >>
  What for: Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 2293]


Done applying laws
step:  14
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2295]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() >>
S [300]->
Q [300] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 2293]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [24.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1026]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << (E_MS() and ACTUAL_IN_RANGE()) >>
S [296]->
Q [296] << (((((DESIRED_POSITION)^0 >= 0)) and (((DESIRED_POSITION)^0 <= #PCS::MaxPosition))) or 
(((((DESIRED_POSITION)^0 < 0))) or ((((DESIRED_POSITION)^0 > #PCS::MaxPosition))))) >>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state Check, <<M(Check)>> -> <<e1 or e2 or . . . en>>


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  15
#[serial 1026] Serban's Theorem:  disjunction of execute conditions leaving execution state Check, <<M(Check)>> -> <<e1 or e2 or . . . en>>
step:  16
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1026]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << (E_MS() and ACTUAL_IN_RANGE()) >>
S [296]->
Q [296] << (((((DESIRED_POSITION)^0 >= 0)) and (((DESIRED_POSITION)^0 <= #PCS::MaxPosition))) or 
(((((DESIRED_POSITION)^0 < 0))) or ((((DESIRED_POSITION)^0 > #PCS::MaxPosition))))) >>
Reason:  Normalization
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state Check, <<M(Check)>> -> <<e1 or e2 or . . . en>>

  Normalization Axioms:

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2297]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296]->
Q [296] << (0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition) or 
(DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0) >>
  What for:   normalization of [serial 1026]

. . . done Normalizing Unsolved Proof Obligations [24.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 2297]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296]->
Q [296] << (0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition) or 
(DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0) >>
  What for:   normalization of [serial 1026]


Done Normalizing
step:  17
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 2297]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296]->
Q [296] << (0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition) or 
(DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0) >>
Reason:  At Most Is Not Less Than: (a<=b) = not(b<a)
  What for:   normalization of [serial 1026]

Has applied At Most Is Not Less Than: (a<=b) = not(b<a) to get:

[serial 2299]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296]->
Q [296] << ((not (DESIRED_POSITION^0 < 0)) and (not (#PCS::MaxPosition < DESIRED_POSITION^0))) or 
(DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0) >>
  What for: At Most Is Not Less Than: (a<=b) = not(b<a) [serial 2297]

. . . Substituting <= with not < [24.0 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 2299]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296]->
Q [296] << ((not (DESIRED_POSITION^0 < 0)) and (not (#PCS::MaxPosition < DESIRED_POSITION^0))) or 
(DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0) >>
  What for: At Most Is Not Less Than: (a<=b) = not(b<a) [serial 2297]


Done replacing a<=b with (not b<a)
step:  18
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2299]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296]->
Q [296] << ((not (DESIRED_POSITION^0 < 0)) and (not (#PCS::MaxPosition < DESIRED_POSITION^0))) or 
(DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0) >>
Reason:  Normalization
  What for: At Most Is Not Less Than: (a<=b) = not(b<a) [serial 2297]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2301]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296]->
Q [296] << (not DESIRED_POSITION^0 < 0 and not #PCS::MaxPosition < DESIRED_POSITION^0) or 
(DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0) >>
  What for:   normalization of [serial 2299]

. . . done Normalizing Unsolved Proof Obligations [24.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 2301]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296]->
Q [296] << (not DESIRED_POSITION^0 < 0 and not #PCS::MaxPosition < DESIRED_POSITION^0) or 
(DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0) >>
  What for:   normalization of [serial 2299]


Done Normalizing
step:  19
****conjunctive-normal-form****
Transforming into Conjunctive Normal Form . . .
Replacing A->B with not A or B
Substituting A->B with not A or B
done Substituting A->B with not A or B [24.0 seconds ]
Applying DeMorgan's Law . . .
. . . done applying DeMorgan's Law  [24.0 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [24.0 seconds ]

This Proof Obligation:

[serial 2301]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296]->
Q [296] << (not DESIRED_POSITION^0 < 0 and not #PCS::MaxPosition < DESIRED_POSITION^0) or 
(DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0) >>
Reason:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
  What for:   normalization of [serial 2299]

Has applied Distribution of preconditions, and over or, and distribution of postcondtitions, or over and while transforming into conjunctive normal form to get:

[serial 2304]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296]->
Q [296] << (not DESIRED_POSITION^0 < 0 or (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0)) and 
(not #PCS::MaxPosition < DESIRED_POSITION^0 or (DESIRED_POSITION^0 < 0 or 
#PCS::MaxPosition < DESIRED_POSITION^0)) >>
  What for: Distribution of preconditions, and over or, and distribution of postcondtitions, or over and while transforming into
  conjunctive normal form [serial 2301]

. . . done putting into conjunctive normal form [24.0 seconds ]
After "conjunctive normal form" remaining 
Obligations:

[serial 2304]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296]->
Q [296] << (not DESIRED_POSITION^0 < 0 or (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0)) and 
(not #PCS::MaxPosition < DESIRED_POSITION^0 or (DESIRED_POSITION^0 < 0 or 
#PCS::MaxPosition < DESIRED_POSITION^0)) >>
  What for: Distribution of preconditions, and over or, and distribution of postcondtitions, or over and while transforming into
  conjunctive normal form [serial 2301]


Done making conjunctive normal forms.
step:  20
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2304]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296]->
Q [296] << (not DESIRED_POSITION^0 < 0 or (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0)) and 
(not #PCS::MaxPosition < DESIRED_POSITION^0 or (DESIRED_POSITION^0 < 0 or 
#PCS::MaxPosition < DESIRED_POSITION^0)) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for: Distribution of preconditions, and over or, and distribution of postcondtitions, or over and while transforming into
  conjunctive normal form [serial 2301]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2305]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296]->
Q [296] << (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0 or 
not DESIRED_POSITION^0 < 0) and (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0 or 
not #PCS::MaxPosition < DESIRED_POSITION^0) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2304]


This Proof Obligation:

[serial 2305]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296]->
Q [296] << (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0 or 
not DESIRED_POSITION^0 < 0) and (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0 or 
not #PCS::MaxPosition < DESIRED_POSITION^0) >>
Reason:  Law of Excluded Middle: P or not P is tautology
  What for: Associativity: (b.c).a = a.b.c [serial 2304]

Has applied law "Law of Excluded Middle: P or not P is tautology" to get:

[serial 2306]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296]->
Q [296] << (true) and (true) >>
  What for: Law of Excluded Middle: P or not P is tautology [serial 2305]


This Proof Obligation:

[serial 2306]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296]->
Q [296] << (true) and (true) >>
Reason:  Law of And-Simplification:  P and P is P
  What for: Law of Excluded Middle: P or not P is tautology [serial 2305]

Has applied law "Law of And-Simplification:  P and P is P" to get:

[serial 2307]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296]->
Q [296] << (true) >>
  What for: Law of And-Simplification:  P and P is P [serial 2306]

. . . done Applying Laws [24.0 seconds ]
After "laws" remaining 
Obligations:

[serial 2307]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296]->
Q [296] << (true) >>
  What for: Law of And-Simplification:  P and P is P [serial 2306]


Done applying laws
step:  21
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2307]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296]->
Q [296] << (true) >>
Reason:  Normalization
  What for: Law of And-Simplification:  P and P is P [serial 2306]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2309]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296]->
Q [296] << true >>
  What for:   normalization of [serial 2307]

. . . done Normalizing Unsolved Proof Obligations [24.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 2309]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296]->
Q [296] << true >>
  What for:   normalization of [serial 2307]


Done Normalizing
step:  22
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2309]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296]->
Q [296] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for:   normalization of [serial 2307]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [24.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1027]: ControlSoftware::FragilePositionControlThread.MultiStep
P [292] << (ACTUAL_POSITION = 0) >>
S [292]->
Q [292] << true >>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state PowerOn, <<M(PowerOn)>> -> <<e1 or e2 or . . . en>>


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  23
#[serial 1027] Serban's Theorem:  disjunction of execute conditions leaving execution state PowerOn, <<M(PowerOn)>> -> <<e1 or e2 or . . . en>>
step:  24
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1027]: ControlSoftware::FragilePositionControlThread.MultiStep
P [292] << (ACTUAL_POSITION = 0) >>
S [292]->
Q [292] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state PowerOn, <<M(PowerOn)>> -> <<e1 or e2 or . . . en>>

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [24.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1028]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
S [298]->
Q [298] << ((((DESIRED_POSITION)^0 = EstimatedActualPosition)) or (((EstimatedActualPosition + 
#PCS::MaxStepsUp) <= (DESIRED_POSITION)^0)) or (((DESIRED_POSITION)^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp))) or 
(((EstimatedActualPosition < (DESIRED_POSITION)^0)) and (((EstimatedActualPosition + 
#PCS::MaxStepsUp) > (DESIRED_POSITION)^0))) or (((EstimatedActualPosition > (DESIRED_POSITION)^0)) and 
(((EstimatedActualPosition - #PCS::MaxStepsUp) < (DESIRED_POSITION)^0)))) >>
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state Decide, <<M(Decide)>> -> <<e1 or e2 or . . . en>>


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  25
#[serial 1028] Serban's Theorem:  disjunction of execute conditions leaving execution state Decide, <<M(Decide)>> -> <<e1 or e2 or . . . en>>
step:  26
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1028]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
S [298]->
Q [298] << ((((DESIRED_POSITION)^0 = EstimatedActualPosition)) or (((EstimatedActualPosition + 
#PCS::MaxStepsUp) <= (DESIRED_POSITION)^0)) or (((DESIRED_POSITION)^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp))) or 
(((EstimatedActualPosition < (DESIRED_POSITION)^0)) and (((EstimatedActualPosition + 
#PCS::MaxStepsUp) > (DESIRED_POSITION)^0))) or (((EstimatedActualPosition > (DESIRED_POSITION)^0)) and 
(((EstimatedActualPosition - #PCS::MaxStepsUp) < (DESIRED_POSITION)^0)))) >>
Reason:  Normalization
  What for: Serban's Theorem:  disjunction of execute conditions leaving execution state Decide, <<M(Decide)>> -> <<e1 or e2 or . . . en>>

  Normalization Axioms:

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2312]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) or 
(EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 or DESIRED_POSITION^0 = EstimatedActualPosition or 
(DESIRED_POSITION^0 < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) or 
(DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0) >>
  What for:   normalization of [serial 1028]

. . . done Normalizing Unsolved Proof Obligations [24.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 2312]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) or 
(EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 or DESIRED_POSITION^0 = EstimatedActualPosition or 
(DESIRED_POSITION^0 < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) or 
(DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0) >>
  What for:   normalization of [serial 1028]


Done Normalizing
step:  27
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 2312]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) or 
(EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 or DESIRED_POSITION^0 = EstimatedActualPosition or 
(DESIRED_POSITION^0 < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) or 
(DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0) >>
Reason:  At Most Is Not Less Than: (a<=b) = not(b<a)
  What for:   normalization of [serial 1028]

Has applied At Most Is Not Less Than: (a<=b) = not(b<a) to get:

[serial 2314]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << (not ((EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0)) or 
(not (DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp))) or 
DESIRED_POSITION^0 = EstimatedActualPosition or (DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) or (DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0) >>
  What for: At Most Is Not Less Than: (a<=b) = not(b<a) [serial 2312]

. . . Substituting <= with not < [24.0 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 2314]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << (not ((EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0)) or 
(not (DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp))) or 
DESIRED_POSITION^0 = EstimatedActualPosition or (DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) or (DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0) >>
  What for: At Most Is Not Less Than: (a<=b) = not(b<a) [serial 2312]


Done replacing a<=b with (not b<a)
step:  28
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2314]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << (not ((EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0)) or 
(not (DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp))) or 
DESIRED_POSITION^0 = EstimatedActualPosition or (DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) or (DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0) >>
Reason:  Normalization
  What for: At Most Is Not Less Than: (a<=b) = not(b<a) [serial 2312]

  Normalization Axioms:

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 2316]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << DESIRED_POSITION^0 = EstimatedActualPosition or not DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) or not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 or 
(DESIRED_POSITION^0 < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) or 
(DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0) >>
  What for:   normalization of [serial 2314]

. . . done Normalizing Unsolved Proof Obligations [24.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 2316]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << DESIRED_POSITION^0 = EstimatedActualPosition or not DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) or not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 or 
(DESIRED_POSITION^0 < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) or 
(DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0) >>
  What for:   normalization of [serial 2314]


Done Normalizing
step:  29
****conjunctive-normal-form****
Transforming into Conjunctive Normal Form . . .
Replacing A->B with not A or B
Substituting A->B with not A or B
done Substituting A->B with not A or B [24.0 seconds ]
Applying DeMorgan's Law . . .
. . . done applying DeMorgan's Law  [24.0 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [24.0 seconds ]

This Proof Obligation:

[serial 2316]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << DESIRED_POSITION^0 = EstimatedActualPosition or not DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) or not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 or 
(DESIRED_POSITION^0 < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) or 
(DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0) >>
Reason:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
  What for:   normalization of [serial 2314]

Has applied Distribution of preconditions, and over or, and distribution of postcondtitions, or over and while transforming into conjunctive normal form to get:

[serial 2319]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << (DESIRED_POSITION^0 < EstimatedActualPosition or DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) or DESIRED_POSITION^0 = EstimatedActualPosition or 
not DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp) or 
not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) and 
((EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 or DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) or DESIRED_POSITION^0 = EstimatedActualPosition or 
not DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp) or 
not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) and 
(DESIRED_POSITION^0 < EstimatedActualPosition or EstimatedActualPosition < DESIRED_POSITION^0 or 
DESIRED_POSITION^0 = EstimatedActualPosition or not DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) or not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) and 
((EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 or EstimatedActualPosition < DESIRED_POSITION^0 or 
DESIRED_POSITION^0 = EstimatedActualPosition or not DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) or not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) >>
  What for: Distribution of preconditions, and over or, and distribution of postcondtitions, or over and while transforming into
  conjunctive normal form [serial 2316]

. . . done putting into conjunctive normal form [24.0 seconds ]
After "conjunctive normal form" remaining 
Obligations:

[serial 2319]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << (DESIRED_POSITION^0 < EstimatedActualPosition or DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) or DESIRED_POSITION^0 = EstimatedActualPosition or 
not DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp) or 
not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) and 
((EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 or DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) or DESIRED_POSITION^0 = EstimatedActualPosition or 
not DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp) or 
not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) and 
(DESIRED_POSITION^0 < EstimatedActualPosition or EstimatedActualPosition < DESIRED_POSITION^0 or 
DESIRED_POSITION^0 = EstimatedActualPosition or not DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) or not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) and 
((EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 or EstimatedActualPosition < DESIRED_POSITION^0 or 
DESIRED_POSITION^0 = EstimatedActualPosition or not DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) or not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) >>
  What for: Distribution of preconditions, and over or, and distribution of postcondtitions, or over and while transforming into
  conjunctive normal form [serial 2316]


Done making conjunctive normal forms.
step:  30
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2319]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << (DESIRED_POSITION^0 < EstimatedActualPosition or DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) or DESIRED_POSITION^0 = EstimatedActualPosition or 
not DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp) or 
not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) and 
((EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 or DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) or DESIRED_POSITION^0 = EstimatedActualPosition or 
not DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp) or 
not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) and 
(DESIRED_POSITION^0 < EstimatedActualPosition or EstimatedActualPosition < DESIRED_POSITION^0 or 
DESIRED_POSITION^0 = EstimatedActualPosition or not DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) or not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) and 
((EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 or EstimatedActualPosition < DESIRED_POSITION^0 or 
DESIRED_POSITION^0 = EstimatedActualPosition or not DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) or not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) >>
Reason:  Law of Excluded Middle: P or not P is tautology
  What for: Distribution of preconditions, and over or, and distribution of postcondtitions, or over and while transforming into
  conjunctive normal form [serial 2316]

Has applied law "Law of Excluded Middle: P or not P is tautology" to get:

[serial 2320]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << (true) and (true) and (DESIRED_POSITION^0 < EstimatedActualPosition or 
EstimatedActualPosition < DESIRED_POSITION^0 or DESIRED_POSITION^0 = EstimatedActualPosition or 
not DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp) or 
not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) and 
(true) >>
  What for: Law of Excluded Middle: P or not P is tautology [serial 2319]


This Proof Obligation:

[serial 2320]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << (true) and (true) and (DESIRED_POSITION^0 < EstimatedActualPosition or 
EstimatedActualPosition < DESIRED_POSITION^0 or DESIRED_POSITION^0 = EstimatedActualPosition or 
not DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp) or 
not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) and 
(true) >>
Reason:  Law of And-Simplification:  P and P is P
  What for: Law of Excluded Middle: P or not P is tautology [serial 2319]

Has applied law "Law of And-Simplification:  P and P is P" to get:

[serial 2321]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << (true) and (DESIRED_POSITION^0 < EstimatedActualPosition or EstimatedActualPosition < DESIRED_POSITION^0 or 
DESIRED_POSITION^0 = EstimatedActualPosition or not DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) or not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) and 
(true) >>
  What for: Law of And-Simplification:  P and P is P [serial 2320]


This Proof Obligation:

[serial 2321]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << (true) and (DESIRED_POSITION^0 < EstimatedActualPosition or EstimatedActualPosition < DESIRED_POSITION^0 or 
DESIRED_POSITION^0 = EstimatedActualPosition or not DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) or not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) and 
(true) >>
Reason:  Less than, greater than, or equal:  |-a<b or b<a or a=b
  What for: Law of And-Simplification:  P and P is P [serial 2320]

Has applied law "Less than, greater than, or equal:  |-a<b or b<a or a=b" to get:

[serial 2322]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << (true) and (true) and (true) >>
  What for: Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 2321]


This Proof Obligation:

[serial 2322]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << (true) and (true) and (true) >>
Reason:  Law of And-Simplification:  P and P is P
  What for: Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 2321]

Has applied law "Law of And-Simplification:  P and P is P" to get:

[serial 2323]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << (true) and (true) >>
  What for: Law of And-Simplification:  P and P is P [serial 2322]


This Proof Obligation:

[serial 2323]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << (true) and (true) >>
Reason:  Law of And-Simplification:  P and P is P
  What for: Law of And-Simplification:  P and P is P [serial 2322]

Has applied law "Law of And-Simplification:  P and P is P" to get:

[serial 2324]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << (true) >>
  What for: Law of And-Simplification:  P and P is P [serial 2323]

. . . done Applying Laws [24.1 seconds ]
After "laws" remaining 
Obligations:

[serial 2324]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << (true) >>
  What for: Law of And-Simplification:  P and P is P [serial 2323]


Done applying laws
step:  31
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2324]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << (true) >>
Reason:  Normalization
  What for: Law of And-Simplification:  P and P is P [serial 2323]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2326]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << true >>
  What for:   normalization of [serial 2324]

. . . done Normalizing Unsolved Proof Obligations [24.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 2326]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << true >>
  What for:   normalization of [serial 2324]


Done Normalizing
step:  32
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2326]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [298] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for:   normalization of [serial 2324]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [24.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1029]: ControlSoftware::FragilePositionControlThread.MultiStep
P [292] << (ACTUAL_POSITION = 0) >>
S [308]<< (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
ActuatorCommand(pc:0)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
;
Delta := 0
<< ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
;
EstimatedActualPosition' := 0
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(PowerOn)>> A <<M(Run)>> for ms0po:PowerOn-[ ]->Run{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  33
#[serial 1029]  <<M(PowerOn)>> A <<M(Run)>> for ms0po:PowerOn-[ ]->Run{A};
step:  34
****reduce****
This proof obligation:

[serial 1029]: ControlSoftware::FragilePositionControlThread.MultiStep
P [292] << (ACTUAL_POSITION = 0) >>
S [308]<< (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
ActuatorCommand(pc:0)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
;
Delta := 0
<< ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
;
EstimatedActualPosition' := 0
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(PowerOn)>> A <<M(Run)>> for ms0po:PowerOn-[ ]->Run{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P2>> S2 <<Q2>>
 
was reduced to:

[serial 2328]: ControlSoftware::FragilePositionControlThread.MultiStep
P [292] << (ACTUAL_POSITION = 0) >>
S [292]->
Q [15] << (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
  What for: P -> P1 in sequential composition for [serial 1029]


[serial 2329]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [294]->
Q [15] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 1029]


[serial 2330]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
S [309]ActuatorCommand(pc:0)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1029]


[serial 2331]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
S [312]Delta := 0
Q [15] << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1029]


[serial 2332]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
S [316]EstimatedActualPosition' := 0
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1029]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 2328]: ControlSoftware::FragilePositionControlThread.MultiStep
P [292] << (ACTUAL_POSITION = 0) >>
S [292]->
Q [15] << (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
  What for: P -> P1 in sequential composition for [serial 1029]



[serial 2329]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [294]->
Q [15] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 1029]



[serial 2330]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
S [309]ActuatorCommand(pc:0)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1029]



[serial 2331]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
S [312]Delta := 0
Q [15] << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1029]



[serial 2332]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
S [316]EstimatedActualPosition' := 0
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1029]


done reducing composite actions
step:  35
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2328]: ControlSoftware::FragilePositionControlThread.MultiStep
P [292] << (ACTUAL_POSITION = 0) >>
S [292]->
Q [15] << (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
Reason:  Normalization
  What for: P -> P1 in sequential composition for [serial 1029]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2334]: ControlSoftware::FragilePositionControlThread.MultiStep
P [292] << 0 = ACTUAL_POSITION >>
S [292]->
Q [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
  What for:   normalization of [serial 2328]


This Proof Obligation:

[serial 2329]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [294]->
Q [15] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
Reason:  Normalization
  What for: Q2 -> Q in sequential composition for [serial 1029]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2336]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2329]


This Proof Obligation:

[serial 2330]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
S [309]ActuatorCommand(pc:0)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
Reason:  Normalization
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1029]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2338]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]ActuatorCommand(pc:0)
Q [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2330]


This Proof Obligation:

[serial 2331]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
S [312]Delta := 0
Q [15] << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
Reason:  Normalization
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1029]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2340]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]Delta := 0
Q [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
  What for:   normalization of [serial 2331]


This Proof Obligation:

[serial 2332]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
S [316]EstimatedActualPosition' := 0
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1029]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2342]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [316]EstimatedActualPosition' := 0
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
  What for:   normalization of [serial 2332]

. . . done Normalizing Unsolved Proof Obligations [24.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 2334]: ControlSoftware::FragilePositionControlThread.MultiStep
P [292] << 0 = ACTUAL_POSITION >>
S [292]->
Q [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
  What for:   normalization of [serial 2328]



[serial 2336]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2329]



[serial 2338]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]ActuatorCommand(pc:0)
Q [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2330]



[serial 2340]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]Delta := 0
Q [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
  What for:   normalization of [serial 2331]



[serial 2342]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [316]EstimatedActualPosition' := 0
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
  What for:   normalization of [serial 2332]


Done Normalizing
step:  36
****atomic****
applying atomic actions . . .
Creating weakest-precondition predicate transfer for subprogram invocation of "ActuatorCommand".

This Proof Obligation:

[serial 2338]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]ActuatorCommand(pc:0)
Q [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
Reason:  Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
  What for:   normalization of [serial 2330]

Used weakest precondition predicate transformation on
+ <<P>> ActuatorCommand(X) <<Q>> to get:

[serial 2348]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]->
Q [15] << 0 = ACTUAL_POSITION and (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2338]

solving assignment on line 312
replacing "Delta" with "0"
makes:  << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>

This Proof Obligation:

[serial 2340]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]Delta := 0
Q [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for:   normalization of [serial 2331]

Has applied := to get:

[serial 2349]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
  What for: applied wp for assignment [serial 2340]

solving assignment on line 316
replacing "EstimatedActualPosition'" with "0"
makes:  << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = 0 >>

This Proof Obligation:

[serial 2342]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [316]EstimatedActualPosition' := 0
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for:   normalization of [serial 2332]

Has applied := to get:

[serial 2350]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [316]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = 0 >>
  What for: applied wp for assignment [serial 2342]

. . . done applying atomic actions [24.1 seconds ]
After "atomic" remaining 
Obligations:

[serial 2334]: ControlSoftware::FragilePositionControlThread.MultiStep
P [292] << 0 = ACTUAL_POSITION >>
S [292]->
Q [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
  What for:   normalization of [serial 2328]



[serial 2336]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2329]



[serial 2348]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]->
Q [15] << 0 = ACTUAL_POSITION and (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2338]



[serial 2349]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
  What for: applied wp for assignment [serial 2340]



[serial 2350]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [316]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = 0 >>
  What for: applied wp for assignment [serial 2342]


Done reducing atomic actions
step:  37
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2349]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
Reason:  Normalization
  What for: applied wp for assignment [serial 2340]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2355]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' and AXIOM_MPGT0() >>
  What for:   normalization of [serial 2349]


This Proof Obligation:

[serial 2350]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [316]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = 0 >>
Reason:  Normalization
  What for: applied wp for assignment [serial 2342]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2357]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [316]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 2350]

. . . done Normalizing Unsolved Proof Obligations [24.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 2334]: ControlSoftware::FragilePositionControlThread.MultiStep
P [292] << 0 = ACTUAL_POSITION >>
S [292]->
Q [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
  What for:   normalization of [serial 2328]



[serial 2336]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2329]



[serial 2348]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]->
Q [15] << 0 = ACTUAL_POSITION and (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2338]



[serial 2355]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' and AXIOM_MPGT0() >>
  What for:   normalization of [serial 2349]



[serial 2357]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [316]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 2350]


Done Normalizing
step:  38
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2348]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]->
Q [15] << 0 = ACTUAL_POSITION and (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2338]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2360]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 2348]

. . . done Applying Laws [24.1 seconds ]
After "laws" remaining 
Obligations:

[serial 2334]: ControlSoftware::FragilePositionControlThread.MultiStep
P [292] << 0 = ACTUAL_POSITION >>
S [292]->
Q [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
  What for:   normalization of [serial 2328]



[serial 2336]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2329]



[serial 2355]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' and AXIOM_MPGT0() >>
  What for:   normalization of [serial 2349]



[serial 2357]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [316]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 2350]



[serial 2360]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 2348]


Done applying laws
step:  39
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 2334]: ControlSoftware::FragilePositionControlThread.MultiStep
P [292] << 0 = ACTUAL_POSITION >>
S [292]->
Q [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
Reason:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
  What for:   normalization of [serial 2328]

has been transformed into:

[serial 2361]: ControlSoftware::FragilePositionControlThread.MultiStep
P [292] << 0 = ACTUAL_POSITION >>
S [292]->
Q [15] << 0 = ACTUAL_POSITION and true >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


by removing axioms from postconditions.

This proof obligation:

[serial 2355]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' and AXIOM_MPGT0() >>
Reason:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
  What for:   normalization of [serial 2349]

has been transformed into:

[serial 2362]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' and true >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


by removing axioms from postconditions.

. . . done removing axioms from postconditions  [24.1 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 2336]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2329]



[serial 2357]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [316]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 2350]



[serial 2360]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 2348]



[serial 2361]: ControlSoftware::FragilePositionControlThread.MultiStep
P [292] << 0 = ACTUAL_POSITION >>
S [292]->
Q [15] << 0 = ACTUAL_POSITION and true >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 




[serial 2362]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' and true >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 



Done removing axioms from postconditions
step:  40
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2361]: ControlSoftware::FragilePositionControlThread.MultiStep
P [292] << 0 = ACTUAL_POSITION >>
S [292]->
Q [15] << 0 = ACTUAL_POSITION and true >>
Reason:  Law of And-Simplification:  P and true is P
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 2363]: ControlSoftware::FragilePositionControlThread.MultiStep
P [292] << 0 = ACTUAL_POSITION >>
S [292]->
Q [15] << (0 = ACTUAL_POSITION) >>
  What for: Law of And-Simplification:  P and true is P [serial 2361]


This Proof Obligation:

[serial 2362]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' and true >>
Reason:  Law of And-Simplification:  P and true is P
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 2364]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for: Law of And-Simplification:  P and true is P [serial 2362]

. . . done Applying Laws [24.1 seconds ]
After "laws" remaining 
Obligations:

[serial 2336]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2329]



[serial 2357]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [316]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 2350]



[serial 2360]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 2348]



[serial 2363]: ControlSoftware::FragilePositionControlThread.MultiStep
P [292] << 0 = ACTUAL_POSITION >>
S [292]->
Q [15] << (0 = ACTUAL_POSITION) >>
  What for: Law of And-Simplification:  P and true is P [serial 2361]



[serial 2364]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for: Law of And-Simplification:  P and true is P [serial 2362]


Done applying laws
step:  41
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2363]: ControlSoftware::FragilePositionControlThread.MultiStep
P [292] << 0 = ACTUAL_POSITION >>
S [292]->
Q [15] << (0 = ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Law of And-Simplification:  P and true is P [serial 2361]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2369]: ControlSoftware::FragilePositionControlThread.MultiStep
P [292] << 0 = ACTUAL_POSITION >>
S [292]->
Q [15] << 0 = ACTUAL_POSITION >>
  What for:   normalization of [serial 2363]

. . . done Normalizing Unsolved Proof Obligations [24.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 2336]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2329]



[serial 2357]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [316]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 2350]



[serial 2360]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 2348]



[serial 2364]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for: Law of And-Simplification:  P and true is P [serial 2362]



[serial 2369]: ControlSoftware::FragilePositionControlThread.MultiStep
P [292] << 0 = ACTUAL_POSITION >>
S [292]->
Q [15] << 0 = ACTUAL_POSITION >>
  What for:   normalization of [serial 2363]


Done Normalizing
step:  42
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2369]: ControlSoftware::FragilePositionControlThread.MultiStep
P [292] << 0 = ACTUAL_POSITION >>
S [292]->
Q [15] << 0 = ACTUAL_POSITION >>
Reason:  Identity (id):  P->P is tautology
  What for:   normalization of [serial 2363]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [24.1 seconds ]
After "axioms" remaining 
Obligations:

[serial 2336]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2329]



[serial 2357]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [316]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 2350]



[serial 2360]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 2348]



[serial 2364]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for: Law of And-Simplification:  P and true is P [serial 2362]


Done trying to apply axioms
step:  43
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  44
#ControlSoftware::FragilePositionControlThread.MultiStep
step:  45
#[serial 1107]   normalization of [serial 1100
step:  46
****make-an****
Making obligation 53
Obligations:

[serial 2336]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2329]


Done making obligation 53
step:  47
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2336]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 2329]

Has substituted Assertions' predicates for labels to get:

[serial 2372]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels in postconditions [serial 2336]

. . . done Substituting Assertions for Labels [24.2 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 2372]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels in postconditions [serial 2336]


Done substituting Assertion labels in postconditions.
step:  48
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2372]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in postconditions [serial 2336]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2374]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
  What for:   normalization of [serial 2372]

. . . done Normalizing Unsolved Proof Obligations [24.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 2374]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
  What for:   normalization of [serial 2372]


Done Normalizing
step:  49
****distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2374]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2372]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2376]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [294]->
Q [15] << ((Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2374]

. . . done spltting timed atoms  [24.2 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [24.2 seconds ]
After "dist^" remaining 
Obligations:

[serial 2376]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [294]->
Q [15] << ((Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2374]


Done distributing ^ and @.
step:  50
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2376]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [294]->
Q [15] << ((Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2374]

  Normalization Axioms:

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2378]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
  What for:   normalization of [serial 2376]

. . . done Normalizing Unsolved Proof Obligations [24.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 2378]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
  What for:   normalization of [serial 2376]


Done Normalizing
step:  51
****completely distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2378]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2376]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2380]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2378]

. . . done spltting timed atoms  [24.2 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [24.2 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2380]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2378]

  Normalization Axioms:

    Literal Arithmetic

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2382]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for:   normalization of [serial 2380]

. . . done Normalizing Unsolved Proof Obligations [24.2 seconds ]
After "completely distribute ^ and @" round 0 remaining 
Obligations:

[serial 2382]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for:   normalization of [serial 2380]


Done completely distributing ^ and @, round 0.
Distributing carets . .

This Proof Obligation:

[serial 2382]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2380]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2384]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) and 
(((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2382]

. . . done spltting timed atoms  [24.2 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [24.2 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2384]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) and 
(((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1)) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2382]

  Normalization Axioms:

    Literal Arithmetic

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Constants are always the same
Has been normalized to get:

[serial 2386]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 2384]

. . . done Normalizing Unsolved Proof Obligations [24.2 seconds ]
After "completely distribute ^ and @" round 1 remaining 
Obligations:

[serial 2386]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 2384]


Done completely distributing ^ and @, round 1.
Distributing carets . .

This Proof Obligation:

[serial 2386]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2384]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2388]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2386]

. . . done spltting timed atoms  [24.2 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [24.2 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [24.2 seconds ]
After "completely distribute ^ and @" round 2 remaining 
Obligations:

[serial 2388]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2386]


Done completely distributing ^ and @, round 2.
Distributing carets . .
. . . done spltting timed atoms  [24.2 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [24.2 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [24.2 seconds ]
step:  52
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2388]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2386]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2391]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2388]

. . . done Applying Laws [24.2 seconds ]
After "laws" remaining 
Obligations:

[serial 2391]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2388]


Done applying laws
step:  53
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2391]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  Identity (id):  P->P is tautology
  What for: Associativity: (b.c).a = a.b.c [serial 2388]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [24.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2357]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [316]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 2350]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  54
#[serial 1128]   normalization of [serial 1121]
step:  55
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2357]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [316]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 2350]

Has substituted Assertions' predicates for labels to get:

[serial 2392]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((0 <= #PCS::MaxPosition)) >>
S [316]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2357]

. . . done Substituting Assertions for Labels [24.2 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 2392]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((0 <= #PCS::MaxPosition)) >>
S [316]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2357]


Done substituting Assertion labels in preconditions
step:  56
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2392]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((0 <= #PCS::MaxPosition)) >>
S [316]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2357]

  Normalization Axioms:

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2394]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 2392]

. . . done Normalizing Unsolved Proof Obligations [24.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 2394]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 2392]


Done Normalizing
step:  57
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 2394]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 2392]

Has split postcondition to get:

[serial 2396]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2394]


[serial 2397]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [319] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2394]


[serial 2398]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [317] << 0 = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2394]


[serial 2399]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [318] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2394]

. . . done splitting postcondition  [24.3 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 2396]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2394]



[serial 2397]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [319] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2394]



[serial 2398]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [317] << 0 = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2394]



[serial 2399]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [318] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2394]


Done splitting postcondition
step:  58
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2399]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [318] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2394]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [24.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 2396]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2394]



[serial 2397]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [319] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2394]



[serial 2398]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [317] << 0 = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2394]


Done trying to apply axioms
step:  59
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  ACTUAL_POSITION = ACTUAL_POSITION'

This Proof Obligation:

[serial 2396]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [1] << 0 <= ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2394]

Has substituted 
"ACTUAL_POSITION'" with its = "ACTUAL_POSITION"
 to get:

[serial 2400]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2396]

equality selected for substitution:  ACTUAL_POSITION = ACTUAL_POSITION'

This Proof Obligation:

[serial 2397]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [319] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2394]

Has substituted 
"ACTUAL_POSITION'" with its = "ACTUAL_POSITION"
 to get:

[serial 2401]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [319] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2397]

equality selected for substitution:  ACTUAL_POSITION = ACTUAL_POSITION'

This Proof Obligation:

[serial 2398]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [317] << 0 = ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2394]

Has substituted 
"ACTUAL_POSITION'" with its = "ACTUAL_POSITION"
 to get:

[serial 2402]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [317] << 0 = ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2398]

. . . done guided substitution of equals  [24.3 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2400]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2396]



[serial 2401]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [319] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2397]



[serial 2402]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [317] << 0 = ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2398]


Done guided substituting an equals
step:  60
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2402]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [317] << 0 = ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2398]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [24.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 2400]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2396]



[serial 2401]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [319] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2397]


Done trying to apply axioms
step:  61
****guided-sub-equals****
guided substitution of equals "0" . . .
equality selected for substitution:  0 = ACTUAL_POSITION

This Proof Obligation:

[serial 2400]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  Guided Substitution of Equals
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2396]

Has substituted 
"0" with its = "ACTUAL_POSITION"
 to get:

[serial 2403]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [1] << ACTUAL_POSITION <= ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "0" with its = "ACTUAL_POSITION" in its postcondition [serial 2400]

equality selected for substitution:  0 = ACTUAL_POSITION
. . . done guided substitution of equals  [24.3 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2401]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [319] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2397]



[serial 2403]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [1] << ACTUAL_POSITION <= ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "0" with its = "ACTUAL_POSITION" in its postcondition [serial 2400]


Done guided substituting an equals
step:  62
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2403]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [1] << ACTUAL_POSITION <= ACTUAL_POSITION >>
Reason:  Partial Order Law 1:  a<=a by definition
  What for: Guided Substitution of Equals
 replacing "0" with its = "ACTUAL_POSITION" in its postcondition [serial 2400]

Has applied law "Partial Order Law 1:  a<=a by definition" to get:

[serial 2404]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [1] << true >>
  What for: Partial Order Law 1:  a<=a by definition [serial 2403]

. . . done Applying Laws [24.3 seconds ]
After "laws" remaining 
Obligations:

[serial 2401]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [319] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2397]



[serial 2404]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [1] << true >>
  What for: Partial Order Law 1:  a<=a by definition [serial 2403]


Done applying laws
step:  63
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2404]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [1] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Partial Order Law 1:  a<=a by definition [serial 2403]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [24.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 2401]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [319] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2397]


Done trying to apply axioms
step:  64
****equivalent****
Adding equivalent terms to conjunctions having an equality term . . .
Adding equivalent terms to conjunction . . .
Add Equivalent Term:  0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION -> ACTUAL_POSITION <= #PCS::MaxPosition
Add Equivalent Term:  ACTUAL_POSITION = ACTUAL_POSITION' and 0 = ACTUAL_POSITION -> 0 = ACTUAL_POSITION'
Add Equivalent Term:  0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' -> ACTUAL_POSITION' = 0

This Proof Obligation:

[serial 2401]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [319] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  Remove Equivalent Term: P(a) and P(b) and a=b is P(a) and a=b
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2397]

Has applied Remove Equivalent Term: P(a) and P(b) and a=b is P(a) and a=b to get:

[serial 2405]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and 
0 = ACTUAL_POSITION' and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [319] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Remove Equivalent Term: P(a) and P(b) and a=b is P(a) and a=b [serial 2401]

. . . done adding equivalent terms [24.3 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 2405]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and 
0 = ACTUAL_POSITION' and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [319] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Remove Equivalent Term: P(a) and P(b) and a=b is P(a) and a=b [serial 2401]


Done adding equivalent terms
step:  65
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2405]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and 
0 = ACTUAL_POSITION' and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316]->
Q [319] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Remove Equivalent Term: P(a) and P(b) and a=b is P(a) and a=b [serial 2401]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [24.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2360]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 2348]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  66
#[serial 1131] Associativity: (b.c).a = a.b.c [serial 1119]
step:  67
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION" . . .
equality selected for substitution:  0 = ACTUAL_POSITION

This Proof Obligation:

[serial 2360]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
Reason:  Guided Substitution of Equals
  What for: Associativity: (b.c).a = a.b.c [serial 2348]

Has substituted 
"ACTUAL_POSITION" with its = "0"
 to get:

[serial 2406]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]->
Q [15] << 0 <= 0 and 0 <= #PCS::MaxPosition and 0 = 0 >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "0" in its postcondition [serial 2360]

. . . done guided substitution of equals  [24.3 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2406]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]->
Q [15] << 0 <= 0 and 0 <= #PCS::MaxPosition and 0 = 0 >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "0" in its postcondition [serial 2360]


Done guided substituting an equals
step:  68
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2406]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]->
Q [15] << 0 <= 0 and 0 <= #PCS::MaxPosition and 0 = 0 >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "0" in its postcondition [serial 2360]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 2407]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]->
Q [15] << true and 0 <= #PCS::MaxPosition and true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 2406]


This Proof Obligation:

[serial 2407]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]->
Q [15] << true and 0 <= #PCS::MaxPosition and true >>
Reason:  Law of And-Simplification:  P and true is P
  What for: Equality Law (idistr):  a=a <-> true [serial 2406]

Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 2408]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]->
Q [15] << (0 <= #PCS::MaxPosition) >>
  What for: Law of And-Simplification:  P and true is P [serial 2407]

. . . done Applying Laws [24.3 seconds ]
After "laws" remaining 
Obligations:

[serial 2408]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]->
Q [15] << (0 <= #PCS::MaxPosition) >>
  What for: Law of And-Simplification:  P and true is P [serial 2407]


Done applying laws
step:  69
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2408]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]->
Q [15] << (0 <= #PCS::MaxPosition) >>
Reason:  Normalization
  What for: Law of And-Simplification:  P and true is P [serial 2407]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2410]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]->
Q [15] << 0 <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2408]

. . . done Normalizing Unsolved Proof Obligations [24.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 2410]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]->
Q [15] << 0 <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2408]


Done Normalizing
step:  70
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2410]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309]->
Q [15] << 0 <= #PCS::MaxPosition >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 2408]

Has substituted Assertions' predicates for labels to get:

[serial 2412]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ((0 <= #PCS::MaxPosition)) >>
S [309]->
Q [15] << 0 <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2410]

. . . done Substituting Assertions for Labels [24.3 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 2412]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ((0 <= #PCS::MaxPosition)) >>
S [309]->
Q [15] << 0 <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2410]


Done substituting Assertion labels in preconditions
step:  71
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2412]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ((0 <= #PCS::MaxPosition)) >>
S [309]->
Q [15] << 0 <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2410]

  Normalization Axioms:

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2414]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [309]->
Q [15] << 0 <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2412]

. . . done Normalizing Unsolved Proof Obligations [24.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 2414]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [309]->
Q [15] << 0 <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2412]


Done Normalizing
step:  72
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2414]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [309]->
Q [15] << 0 <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 2412]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [24.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2364]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for: Law of And-Simplification:  P and true is P [serial 2362]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  73
#[serial 1135] Law of And-Simplification:  P and true is P [serial 1133]
step:  74
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 2364]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for: Law of And-Simplification:  P and true is P [serial 2362]

Has split postcondition to get:

[serial 2416]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [313] << 0 = ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2364]


[serial 2417]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [314] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2364]


[serial 2418]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [313] << ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2364]

. . . done splitting postcondition  [24.3 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 2416]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [313] << 0 = ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2364]



[serial 2417]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [314] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2364]



[serial 2418]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [313] << ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2364]


Done splitting postcondition
step:  75
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2416]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [313] << 0 = ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2364]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2418]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [313] << ACTUAL_POSITION = ACTUAL_POSITION' >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2364]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [24.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 2417]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [314] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2364]


Done trying to apply axioms
step:  76
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  ACTUAL_POSITION = ACTUAL_POSITION'

This Proof Obligation:

[serial 2417]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [314] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2364]

Has substituted 
"ACTUAL_POSITION'" with its = "ACTUAL_POSITION"
 to get:

[serial 2419]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [314] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2417]

. . . done guided substitution of equals  [24.3 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2419]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [314] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2417]


Done guided substituting an equals
step:  77
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2419]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [314] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2417]

  Normalization Axioms:

    Subtraction of Same:  a-a is 0

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2421]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [314] << 0 = 0 >>
  What for:   normalization of [serial 2419]

. . . done Normalizing Unsolved Proof Obligations [24.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 2421]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [314] << 0 = 0 >>
  What for:   normalization of [serial 2419]


Done Normalizing
step:  78
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2421]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [314] << 0 = 0 >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 2419]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 2423]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [314] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 2421]

. . . done Applying Laws [24.3 seconds ]
After "laws" remaining 
Obligations:

[serial 2423]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [314] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 2421]


Done applying laws
step:  79
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2423]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312]->
Q [314] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 2421]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [24.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1030]: ControlSoftware::FragilePositionControlThread.MultiStep
P [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE()) >>
S [321]->
Q [296] << (E_MS() and ACTUAL_IN_RANGE()) >>
  What for:  <<M(Run) and x>> -> <<M(Check)>> for ms1run:Run-[x]->Check{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  80
#[serial 1030]  <<M(Run) and x>> -> <<M(Check)>> for ms1run:Run-[x]->Check{};
step:  81
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1030]: ControlSoftware::FragilePositionControlThread.MultiStep
P [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE()) >>
S [321]->
Q [296] << (E_MS() and ACTUAL_IN_RANGE()) >>
Reason:  Normalization
  What for:  <<M(Run) and x>> -> <<M(Check)>> for ms1run:Run-[x]->Check{};

  Normalization Axioms:

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2425]: ControlSoftware::FragilePositionControlThread.MultiStep
P [294] << ACTUAL_IN_RANGE() and D_MS() and E_MS() >>
S [321]->
Q [296] << ACTUAL_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 1030]

. . . done Normalizing Unsolved Proof Obligations [24.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 2425]: ControlSoftware::FragilePositionControlThread.MultiStep
P [294] << ACTUAL_IN_RANGE() and D_MS() and E_MS() >>
S [321]->
Q [296] << ACTUAL_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 1030]


Done Normalizing
step:  82
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2425]: ControlSoftware::FragilePositionControlThread.MultiStep
P [294] << ACTUAL_IN_RANGE() and D_MS() and E_MS() >>
S [321]->
Q [296] << ACTUAL_IN_RANGE() and E_MS() >>
Reason:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
  What for:   normalization of [serial 1030]

Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [24.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1031]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << (E_MS() and ACTUAL_IN_RANGE() and ((((DESIRED_POSITION)^0 >= 0)) and 
(((DESIRED_POSITION)^0 <= #PCS::MaxPosition)))) >>
S [323]->
Q [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
  What for:  <<M(Check) and x>> -> <<M(Decide)>> for ms1ok:Check-[x]->Decide{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  83
#[serial 1031]  <<M(Check) and x>> -> <<M(Decide)>> for ms1ok:Check-[x]->Decide{};
step:  84
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1031]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << (E_MS() and ACTUAL_IN_RANGE() and ((((DESIRED_POSITION)^0 >= 0)) and 
(((DESIRED_POSITION)^0 <= #PCS::MaxPosition)))) >>
S [323]->
Q [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Reason:  Normalization
  What for:  <<M(Check) and x>> -> <<M(Decide)>> for ms1ok:Check-[x]->Decide{};

  Normalization Axioms:

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2428]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() and (0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition) >>
S [323]->
Q [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 1031]

. . . done Normalizing Unsolved Proof Obligations [24.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 2428]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() and (0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition) >>
S [323]->
Q [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 1031]


Done Normalizing
step:  85
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2428]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << ACTUAL_IN_RANGE() and E_MS() and (0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition) >>
S [323]->
Q [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1031]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2430]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323]->
Q [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
  What for: Associativity: (b.c).a = a.b.c [serial 2428]

. . . done Applying Laws [24.3 seconds ]
After "laws" remaining 
Obligations:

[serial 2430]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323]->
Q [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
  What for: Associativity: (b.c).a = a.b.c [serial 2428]


Done applying laws
step:  86
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 2430]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323]->
Q [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for: Associativity: (b.c).a = a.b.c [serial 2428]

Has split postcondition to get:

[serial 2431]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323]->
Q [298] << ACTUAL_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2430]


[serial 2432]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323]->
Q [298] << DESIRED_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2430]


[serial 2433]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323]->
Q [298] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2430]

. . . done splitting postcondition  [24.3 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 2431]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323]->
Q [298] << ACTUAL_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2430]



[serial 2432]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323]->
Q [298] << DESIRED_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2430]



[serial 2433]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323]->
Q [298] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2430]


Done splitting postcondition
step:  87
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2431]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323]->
Q [298] << ACTUAL_IN_RANGE() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2430]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2433]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323]->
Q [298] << E_MS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2430]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [24.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 2432]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323]->
Q [298] << DESIRED_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2430]


Done trying to apply axioms
step:  88
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2432]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323]->
Q [298] << DESIRED_IN_RANGE() >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2430]

Has substituted Assertions' predicates for labels to get:

[serial 2434]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323]->
Q [298] << ((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) >>
  What for: substituted Assertions' predicates for  labels in postconditions [serial 2432]

. . . done Substituting Assertions for Labels [24.3 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 2434]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323]->
Q [298] << ((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) >>
  What for: substituted Assertions' predicates for  labels in postconditions [serial 2432]


Done substituting Assertion labels in postconditions.
step:  89
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2434]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323]->
Q [298] << ((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in postconditions [serial 2432]

  Normalization Axioms:

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2436]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323]->
Q [298] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2434]

. . . done Normalizing Unsolved Proof Obligations [24.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 2436]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323]->
Q [298] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2434]


Done Normalizing
step:  90
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 2436]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323]->
Q [298] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition >>
Reason:  Assume Present:  P = P@now = P^0 
  What for:   normalization of [serial 2434]

Has applied Assume Present:  P = P@now = P^0  to get:

[serial 2438]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_IN_RANGE() and 
E_MS() >>
S [323]->
Q [298] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: Assume Present:  P = P@now = P^0  [serial 2436]

. . . done replacing P@now and P^0 with P  [24.3 seconds ]
After assuming present remaining 
Obligations:

[serial 2438]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_IN_RANGE() and 
E_MS() >>
S [323]->
Q [298] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: Assume Present:  P = P@now = P^0  [serial 2436]


Done assuming present.
step:  91
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2438]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_IN_RANGE() and 
E_MS() >>
S [323]->
Q [298] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
  What for: Assume Present:  P = P@now = P^0  [serial 2436]

Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [24.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1032]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << (E_MS() and ACTUAL_IN_RANGE() and (((((DESIRED_POSITION)^0 < 0))) or 
((((DESIRED_POSITION)^0 > #PCS::MaxPosition))))) >>
S [325]->
Q [305] << true >>
  What for:  <<M(Check) and x>> -> <<M(Error)>> for ms1er:Check-[x]->Error{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  92
#[serial 1032]  <<M(Check) and x>> -> <<M(Error)>> for ms1er:Check-[x]->Error{};
step:  93
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1032]: ControlSoftware::FragilePositionControlThread.MultiStep
P [296] << (E_MS() and ACTUAL_IN_RANGE() and (((((DESIRED_POSITION)^0 < 0))) or 
((((DESIRED_POSITION)^0 > #PCS::MaxPosition))))) >>
S [325]->
Q [305] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for:  <<M(Check) and x>> -> <<M(Error)>> for ms1er:Check-[x]->Error{};

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [24.4 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1033]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 = EstimatedActualPosition))) >>
S [330]<< (E_MS() and (DESIRED_POSITION = ACTUAL_POSITION) and ACTUAL_IN_RANGE()) >>
ActuatorCommand(pc:0)
<< (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E_MS() and ACTUAL_IN_RANGE()) >>
;
Delta := 0
<< (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E_MS() and ACTUAL_IN_RANGE() and ((Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
;
EstimatedActualPosition' := EstimatedActualPosition
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for ms2eq:Decide-[x]->Run{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  94
#[serial 1033]  <<M(Decide) and x>> A <<M(Run)>> for ms2eq:Decide-[x]->Run{A};
step:  95
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1033]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 = EstimatedActualPosition))) >>
S [330]<< (E_MS() and (DESIRED_POSITION = ACTUAL_POSITION) and ACTUAL_IN_RANGE()) >>
ActuatorCommand(pc:0)
<< (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E_MS() and ACTUAL_IN_RANGE()) >>
;
Delta := 0
<< (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E_MS() and ACTUAL_IN_RANGE() and ((Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
;
EstimatedActualPosition' := EstimatedActualPosition
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
Reason:  Normalization
  What for:  <<M(Decide) and x>> A <<M(Run)>> for ms2eq:Decide-[x]->Run{A};

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2440]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [330]<< ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
ActuatorCommand(pc:0)
<< ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
;
Delta := 0
<< ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_IN_RANGE() and E_MS() >>
;
EstimatedActualPosition' := EstimatedActualPosition
<< 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION' = EstimatedActualPosition' >>
Q [294] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 1033]

. . . done Normalizing Unsolved Proof Obligations [24.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 2440]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [330]<< ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
ActuatorCommand(pc:0)
<< ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
;
Delta := 0
<< ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_IN_RANGE() and E_MS() >>
;
EstimatedActualPosition' := EstimatedActualPosition
<< 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION' = EstimatedActualPosition' >>
Q [294] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 1033]


Done Normalizing
step:  96
****reduce****
This proof obligation:

[serial 2440]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [330]<< ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
ActuatorCommand(pc:0)
<< ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
;
Delta := 0
<< ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_IN_RANGE() and E_MS() >>
;
EstimatedActualPosition' := EstimatedActualPosition
<< 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION' = EstimatedActualPosition' >>
Q [294] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 1033]

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P2>> S2 <<Q2>>
 
was reduced to:

[serial 2442]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
  What for: P -> P1 in sequential composition for [serial 2440]


[serial 2443]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 2440]


[serial 2444]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]ActuatorCommand(pc:0)
Q [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 2440]


[serial 2445]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334]Delta := 0
Q [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 2440]


[serial 2446]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]EstimatedActualPosition' := EstimatedActualPosition
Q [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 2440]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 2442]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
  What for: P -> P1 in sequential composition for [serial 2440]



[serial 2443]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 2440]



[serial 2444]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]ActuatorCommand(pc:0)
Q [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 2440]



[serial 2445]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334]Delta := 0
Q [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 2440]



[serial 2446]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]EstimatedActualPosition' := EstimatedActualPosition
Q [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 2440]


done reducing composite actions
step:  97
****atomic****
applying atomic actions . . .
Creating weakest-precondition predicate transfer for subprogram invocation of "ActuatorCommand".

This Proof Obligation:

[serial 2444]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]ActuatorCommand(pc:0)
Q [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
Reason:  Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 2440]

Used weakest precondition predicate transformation on
+ <<P>> ActuatorCommand(X) <<Q>> to get:

[serial 2447]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]->
Q [332] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and ACTUAL_IN_RANGE() and 
E_MS() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2444]

solving assignment on line 334
replacing "Delta" with "0"
makes:  << ACTUAL_POSITION = ACTUAL_POSITION' and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>

This Proof Obligation:

[serial 2445]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334]Delta := 0
Q [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 2440]

Has applied := to get:

[serial 2448]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334]->
Q [335] << ACTUAL_POSITION = ACTUAL_POSITION' and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
  What for: applied wp for assignment [serial 2445]

solving assignment on line 338
replacing "EstimatedActualPosition'" with "EstimatedActualPosition"
makes:  << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition >>

This Proof Obligation:

[serial 2446]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]EstimatedActualPosition' := EstimatedActualPosition
Q [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 2440]

Has applied := to get:

[serial 2449]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]->
Q [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition >>
  What for: applied wp for assignment [serial 2446]

. . . done applying atomic actions [24.4 seconds ]
After "atomic" remaining 
Obligations:

[serial 2442]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
  What for: P -> P1 in sequential composition for [serial 2440]



[serial 2443]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 2440]



[serial 2447]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]->
Q [332] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and ACTUAL_IN_RANGE() and 
E_MS() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2444]



[serial 2448]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334]->
Q [335] << ACTUAL_POSITION = ACTUAL_POSITION' and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
  What for: applied wp for assignment [serial 2445]



[serial 2449]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]->
Q [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition >>
  What for: applied wp for assignment [serial 2446]


Done reducing atomic actions
step:  98
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2447]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]->
Q [332] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and ACTUAL_IN_RANGE() and 
E_MS() >>
Reason:  Normalization
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2444]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2453]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]->
Q [332] << ACTUAL_IN_RANGE() and E_MS() and (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 2447]


This Proof Obligation:

[serial 2448]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334]->
Q [335] << ACTUAL_POSITION = ACTUAL_POSITION' and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
Reason:  Normalization
  What for: applied wp for assignment [serial 2445]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2455]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334]->
Q [335] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION = ACTUAL_POSITION' and 
ACTUAL_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 2448]


This Proof Obligation:

[serial 2449]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]->
Q [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition >>
Reason:  Normalization
  What for: applied wp for assignment [serial 2446]

  Normalization Axiom:

    Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 2457]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]->
Q [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2449]

. . . done Normalizing Unsolved Proof Obligations [24.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 2442]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
  What for: P -> P1 in sequential composition for [serial 2440]



[serial 2443]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 2440]



[serial 2453]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]->
Q [332] << ACTUAL_IN_RANGE() and E_MS() and (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 2447]



[serial 2455]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334]->
Q [335] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION = ACTUAL_POSITION' and 
ACTUAL_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 2448]



[serial 2457]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]->
Q [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2449]


Done Normalizing
step:  99
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2453]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]->
Q [332] << ACTUAL_IN_RANGE() and E_MS() and (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2447]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2461]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]->
Q [332] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_IN_RANGE() and 
E_MS() >>
  What for: Associativity: (b.c).a = a.b.c [serial 2453]

. . . done Applying Laws [24.4 seconds ]
After "laws" remaining 
Obligations:

[serial 2442]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
  What for: P -> P1 in sequential composition for [serial 2440]



[serial 2443]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 2440]



[serial 2455]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334]->
Q [335] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION = ACTUAL_POSITION' and 
ACTUAL_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 2448]



[serial 2457]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]->
Q [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2449]



[serial 2461]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]->
Q [332] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_IN_RANGE() and 
E_MS() >>
  What for: Associativity: (b.c).a = a.b.c [serial 2453]


Done applying laws
step:  100
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 2442]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for: P -> P1 in sequential composition for [serial 2440]

Has split postcondition to get:

[serial 2462]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2442]


[serial 2463]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [330] << ACTUAL_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2442]


[serial 2464]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [330] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2442]


This Proof Obligation:

[serial 2455]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334]->
Q [335] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION = ACTUAL_POSITION' and 
ACTUAL_IN_RANGE() and E_MS() >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 2448]

Has split postcondition to get:

[serial 2465]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334]->
Q [336] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2455]


[serial 2466]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334]->
Q [335] << ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2455]


[serial 2467]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334]->
Q [335] << ACTUAL_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2455]


[serial 2468]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334]->
Q [335] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2455]


This Proof Obligation:

[serial 2457]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]->
Q [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 2449]

Has split postcondition to get:

[serial 2469]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2457]


[serial 2470]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]->
Q [341] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2457]


[serial 2471]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]->
Q [340] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2457]


[serial 2472]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]->
Q [339] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2457]


This Proof Obligation:

[serial 2461]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]->
Q [332] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_IN_RANGE() and 
E_MS() >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for: Associativity: (b.c).a = a.b.c [serial 2453]

Has split postcondition to get:

[serial 2473]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2461]


[serial 2474]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2461]


[serial 2475]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]->
Q [332] << ACTUAL_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2461]


[serial 2476]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]->
Q [332] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2461]

. . . done splitting postcondition  [24.4 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 2443]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 2440]



[serial 2462]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2442]



[serial 2463]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [330] << ACTUAL_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2442]



[serial 2464]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [330] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2442]



[serial 2465]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334]->
Q [336] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2455]



[serial 2466]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334]->
Q [335] << ACTUAL_POSITION = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2455]



[serial 2467]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334]->
Q [335] << ACTUAL_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2455]



[serial 2468]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334]->
Q [335] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2455]



[serial 2469]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2457]



[serial 2470]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]->
Q [341] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2457]



[serial 2471]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]->
Q [340] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2457]



[serial 2472]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]->
Q [339] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2457]



[serial 2473]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2461]



[serial 2474]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2461]



[serial 2475]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]->
Q [332] << ACTUAL_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2461]



[serial 2476]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]->
Q [332] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2461]


Done splitting postcondition
step:  101
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2463]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [330] << ACTUAL_IN_RANGE() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2442]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2464]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [330] << E_MS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2442]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2466]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334]->
Q [335] << ACTUAL_POSITION = ACTUAL_POSITION' >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2455]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2467]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334]->
Q [335] << ACTUAL_IN_RANGE() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2455]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2468]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334]->
Q [335] << E_MS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2455]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2471]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]->
Q [340] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2457]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2475]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]->
Q [332] << ACTUAL_IN_RANGE() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2461]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2476]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]->
Q [332] << E_MS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2461]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [24.4 seconds ]
After "axioms" remaining 
Obligations:

[serial 2443]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 2440]



[serial 2462]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2442]



[serial 2465]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334]->
Q [336] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2455]



[serial 2469]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2457]



[serial 2470]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]->
Q [341] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2457]



[serial 2472]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]->
Q [339] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2457]



[serial 2473]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2461]



[serial 2474]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2461]


Done trying to apply axioms
step:  102
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2462]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2442]

Has substituted Assertions' predicates for labels to get:

[serial 2477]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2462]


This Proof Obligation:

[serial 2465]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334]->
Q [336] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2455]

Has substituted Assertions' predicates for labels to get:

[serial 2478]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [334]->
Q [336] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2465]


This Proof Obligation:

[serial 2469]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]->
Q [1] << 0 <= ACTUAL_POSITION' >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2457]

Has substituted Assertions' predicates for labels to get:

[serial 2479]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [338]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2469]


This Proof Obligation:

[serial 2470]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]->
Q [341] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2457]

Has substituted Assertions' predicates for labels to get:

[serial 2480]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [338]->
Q [341] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2470]


This Proof Obligation:

[serial 2472]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338]->
Q [339] << EstimatedActualPosition = ACTUAL_POSITION' >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2457]

Has substituted Assertions' predicates for labels to get:

[serial 2481]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [338]->
Q [339] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2472]


This Proof Obligation:

[serial 2473]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2461]

Has substituted Assertions' predicates for labels to get:

[serial 2482]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [331]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2473]


This Proof Obligation:

[serial 2474]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2461]

Has substituted Assertions' predicates for labels to get:

[serial 2483]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [331]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2474]

. . . done Substituting Assertions for Labels [24.5 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 2443]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 2440]



[serial 2477]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2462]



[serial 2478]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [334]->
Q [336] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2465]



[serial 2479]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [338]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2469]



[serial 2480]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [338]->
Q [341] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2470]



[serial 2481]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [338]->
Q [339] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2472]



[serial 2482]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [331]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2473]



[serial 2483]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [331]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2474]


Done substituting Assertion labels in preconditions
step:  103
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2477]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2462]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2486]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 2477]


This Proof Obligation:

[serial 2478]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [334]->
Q [336] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2465]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2488]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [334]->
Q [336] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 2478]


This Proof Obligation:

[serial 2479]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [338]->
Q [1] << 0 <= ACTUAL_POSITION' >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2469]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2490]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [338]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for:   normalization of [serial 2479]


This Proof Obligation:

[serial 2480]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [338]->
Q [341] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2470]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2492]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [338]->
Q [341] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2480]


This Proof Obligation:

[serial 2481]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [338]->
Q [339] << EstimatedActualPosition = ACTUAL_POSITION' >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2472]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2494]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [338]->
Q [339] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2481]


This Proof Obligation:

[serial 2482]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [331]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2473]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2496]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [331]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for:   normalization of [serial 2482]


This Proof Obligation:

[serial 2483]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [331]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2474]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2498]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [331]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2483]

. . . done Normalizing Unsolved Proof Obligations [24.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 2443]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 2440]



[serial 2486]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 2477]



[serial 2488]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [334]->
Q [336] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for:   normalization of [serial 2478]



[serial 2490]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [338]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for:   normalization of [serial 2479]



[serial 2492]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [338]->
Q [341] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2480]



[serial 2494]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [338]->
Q [339] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2481]



[serial 2496]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [331]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for:   normalization of [serial 2482]



[serial 2498]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [331]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2483]


Done Normalizing
step:  104
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2486]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2477]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2506]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 2486]


This Proof Obligation:

[serial 2488]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [334]->
Q [336] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2478]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2507]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [334]->
Q [336] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2488]


This Proof Obligation:

[serial 2490]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [338]->
Q [1] << 0 <= ACTUAL_POSITION' >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2479]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2508]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Associativity: (b.c).a = a.b.c [serial 2490]


This Proof Obligation:

[serial 2492]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [338]->
Q [341] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2480]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2509]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [341] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 2492]


This Proof Obligation:

[serial 2494]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [338]->
Q [339] << EstimatedActualPosition = ACTUAL_POSITION' >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2481]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2510]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [339] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for: Associativity: (b.c).a = a.b.c [serial 2494]


This Proof Obligation:

[serial 2496]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [331]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2482]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2511]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [331]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 2496]


This Proof Obligation:

[serial 2498]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [331]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2483]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2512]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [331]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 2498]

. . . done Applying Laws [24.5 seconds ]
After "laws" remaining 
Obligations:

[serial 2443]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 2440]



[serial 2506]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 2486]



[serial 2507]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [334]->
Q [336] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2488]



[serial 2508]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Associativity: (b.c).a = a.b.c [serial 2490]



[serial 2509]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [341] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 2492]



[serial 2510]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [339] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for: Associativity: (b.c).a = a.b.c [serial 2494]



[serial 2511]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [331]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 2496]



[serial 2512]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [331]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 2498]


Done applying laws
step:  105
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2511]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [331]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Associativity: (b.c).a = a.b.c [serial 2496]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2512]: ControlSoftware::FragilePositionControlThread.MultiStep
P [330] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [331]->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Associativity: (b.c).a = a.b.c [serial 2498]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [24.5 seconds ]
After "axioms" remaining 
Obligations:

[serial 2443]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 2440]



[serial 2506]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 2486]



[serial 2507]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [334]->
Q [336] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2488]



[serial 2508]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Associativity: (b.c).a = a.b.c [serial 2490]



[serial 2509]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [341] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 2492]



[serial 2510]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [339] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for: Associativity: (b.c).a = a.b.c [serial 2494]


Done trying to apply axioms
step:  106
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2506]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 2486]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2515]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 2506]

. . . done Normalizing Unsolved Proof Obligations [24.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 2443]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 2440]



[serial 2507]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [334]->
Q [336] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2488]



[serial 2508]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Associativity: (b.c).a = a.b.c [serial 2490]



[serial 2509]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [341] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 2492]



[serial 2510]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [339] << EstimatedActualPosition = ACTUAL_POSITION' >>
  What for: Associativity: (b.c).a = a.b.c [serial 2494]



[serial 2515]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 2506]


Done Normalizing
step:  107
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  ACTUAL_POSITION' = EstimatedActualPosition'
equality selected for substitution:  ACTUAL_POSITION = ACTUAL_POSITION'

This Proof Obligation:

[serial 2507]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [334]->
Q [336] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Guided Substitution of Equals
  What for: Associativity: (b.c).a = a.b.c [serial 2488]

Has substituted 
"ACTUAL_POSITION'" with its = "ACTUAL_POSITION"
 to get:

[serial 2521]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [334]->
Q [336] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2507]

equality selected for substitution:  ACTUAL_POSITION = ACTUAL_POSITION'

This Proof Obligation:

[serial 2508]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [1] << 0 <= ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for: Associativity: (b.c).a = a.b.c [serial 2490]

Has substituted 
"ACTUAL_POSITION'" with its = "ACTUAL_POSITION"
 to get:

[serial 2522]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2508]

equality selected for substitution:  ACTUAL_POSITION = ACTUAL_POSITION'

This Proof Obligation:

[serial 2509]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [341] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for: Associativity: (b.c).a = a.b.c [serial 2492]

Has substituted 
"ACTUAL_POSITION'" with its = "ACTUAL_POSITION"
 to get:

[serial 2523]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [341] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2509]

equality selected for substitution:  ACTUAL_POSITION = ACTUAL_POSITION'

This Proof Obligation:

[serial 2510]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [339] << EstimatedActualPosition = ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for: Associativity: (b.c).a = a.b.c [serial 2494]

Has substituted 
"ACTUAL_POSITION'" with its = "ACTUAL_POSITION"
 to get:

[serial 2524]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [339] << EstimatedActualPosition = ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2510]

. . . done guided substitution of equals  [24.6 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2443]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
Reason:  Guided Substitution of Equals
  What for: Q2 -> Q in sequential composition for [serial 2440]



[serial 2515]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 2506]



[serial 2521]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [334]->
Q [336] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2507]



[serial 2522]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2508]



[serial 2523]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [341] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2509]



[serial 2524]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [339] << EstimatedActualPosition = ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2510]


Done guided substituting an equals
step:  108
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2521]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [334]->
Q [336] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2507]

  Normalization Axioms:

    Subtraction of Same:  a-a is 0

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2528]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [334]->
Q [336] << 0 = 0 >>
  What for:   normalization of [serial 2521]


This Proof Obligation:

[serial 2524]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [339] << EstimatedActualPosition = ACTUAL_POSITION >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2510]

  Normalization Axiom:

    Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 2532]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [339] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 2524]

. . . done Normalizing Unsolved Proof Obligations [24.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2443]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
Reason:  Guided Substitution of Equals
  What for: Q2 -> Q in sequential composition for [serial 2440]



[serial 2515]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 2506]



[serial 2522]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2508]



[serial 2523]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [341] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2509]



[serial 2528]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [334]->
Q [336] << 0 = 0 >>
  What for:   normalization of [serial 2521]



[serial 2532]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [339] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 2524]


Done Normalizing
step:  109
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2522]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2508]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2523]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [341] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2509]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2532]: ControlSoftware::FragilePositionControlThread.MultiStep
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338]->
Q [339] << ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 2524]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [24.6 seconds ]
After "axioms" remaining 
Obligations:

[serial 2443]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
Reason:  Guided Substitution of Equals
  What for: Q2 -> Q in sequential composition for [serial 2440]



[serial 2515]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 2506]



[serial 2528]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [334]->
Q [336] << 0 = 0 >>
  What for:   normalization of [serial 2521]


Done trying to apply axioms
step:  110
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2528]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [334]->
Q [336] << 0 = 0 >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 2521]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 2535]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [334]->
Q [336] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 2528]

. . . done Applying Laws [24.6 seconds ]
After "laws" remaining 
Obligations:

[serial 2443]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
Reason:  Guided Substitution of Equals
  What for: Q2 -> Q in sequential composition for [serial 2440]



[serial 2515]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 2506]



[serial 2535]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [334]->
Q [336] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 2528]


Done applying laws
step:  111
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2535]: ControlSoftware::FragilePositionControlThread.MultiStep
P [332] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [334]->
Q [336] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 2528]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [24.6 seconds ]
After "axioms" remaining 
Obligations:

[serial 2443]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
Reason:  Guided Substitution of Equals
  What for: Q2 -> Q in sequential composition for [serial 2440]



[serial 2515]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 2506]


Done trying to apply axioms
step:  112
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 2515]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
Reason:  Assume Present:  P = P@now = P^0 
  What for:   normalization of [serial 2506]

Has applied Assume Present:  P = P@now = P^0  to get:

[serial 2536]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: Assume Present:  P = P@now = P^0  [serial 2515]

. . . done replacing P@now and P^0 with P  [24.6 seconds ]
After assuming present remaining 
Obligations:

[serial 2443]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
Reason:  Guided Substitution of Equals
  What for: Q2 -> Q in sequential composition for [serial 2440]



[serial 2536]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
  What for: Assume Present:  P = P@now = P^0  [serial 2515]


Done assuming present.
step:  113
****guided-sub-equals****
guided substitution of equals "DESIRED_POSITION" . . .
equality selected for substitution:  DESIRED_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 2536]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [298]->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
Reason:  Guided Substitution of Equals
  What for: Assume Present:  P = P@now = P^0  [serial 2515]

Has substituted 
"DESIRED_POSITION" with its = "EstimatedActualPosition"
 to get:

[serial 2537]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [298]->
Q [330] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Guided Substitution of Equals
 replacing "DESIRED_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 2536]

. . . done guided substitution of equals  [24.6 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2443]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
Reason:  Guided Substitution of Equals
  What for: Q2 -> Q in sequential composition for [serial 2440]



[serial 2537]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [298]->
Q [330] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for: Guided Substitution of Equals
 replacing "DESIRED_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 2536]


Done guided substituting an equals
step:  114
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2537]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [298]->
Q [330] << ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Guided Substitution of Equals
 replacing "DESIRED_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 2536]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [24.6 seconds ]
After "axioms" remaining 
Obligations:

[serial 2443]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
Reason:  Guided Substitution of Equals
  What for: Q2 -> Q in sequential composition for [serial 2440]


Done trying to apply axioms
step:  115
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2443]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
Reason:  Substitution of Assertion Labels
  What for: Q2 -> Q in sequential composition for [serial 2440]

Has substituted Assertions' predicates for labels to get:

[serial 2538]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels in postconditions [serial 2443]

. . . done Substituting Assertions for Labels [24.6 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 2538]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels in postconditions [serial 2443]


Done substituting Assertion labels in postconditions.
step:  116
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2538]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in postconditions [serial 2443]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2540]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
  What for:   normalization of [serial 2538]

. . . done Normalizing Unsolved Proof Obligations [24.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2540]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
  What for:   normalization of [serial 2538]


Done Normalizing
step:  117
****completely distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2540]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2538]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2542]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [294]->
Q [15] << ((Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2540]

. . . done spltting timed atoms  [24.6 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [24.6 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2542]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [294]->
Q [15] << ((Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2540]

  Normalization Axioms:

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2544]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
  What for:   normalization of [serial 2542]

. . . done Normalizing Unsolved Proof Obligations [24.6 seconds ]
After "completely distribute ^ and @" round 0 remaining 
Obligations:

[serial 2544]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
  What for:   normalization of [serial 2542]


Done completely distributing ^ and @, round 0.
Distributing carets . .

This Proof Obligation:

[serial 2544]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2542]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2546]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2544]

. . . done spltting timed atoms  [24.7 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [24.7 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2546]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2544]

  Normalization Axioms:

    Literal Arithmetic

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2548]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for:   normalization of [serial 2546]

. . . done Normalizing Unsolved Proof Obligations [24.7 seconds ]
After "completely distribute ^ and @" round 1 remaining 
Obligations:

[serial 2548]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for:   normalization of [serial 2546]


Done completely distributing ^ and @, round 1.
Distributing carets . .

This Proof Obligation:

[serial 2548]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2546]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2550]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) and 
(((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2548]

. . . done spltting timed atoms  [24.7 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [24.7 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2550]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) and 
(((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1)) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2548]

  Normalization Axioms:

    Literal Arithmetic

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Constants are always the same
Has been normalized to get:

[serial 2552]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 2550]

. . . done Normalizing Unsolved Proof Obligations [24.7 seconds ]
After "completely distribute ^ and @" round 2 remaining 
Obligations:

[serial 2552]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 2550]


Done completely distributing ^ and @, round 2.
Distributing carets . .

This Proof Obligation:

[serial 2552]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2550]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2554]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2552]

. . . done spltting timed atoms  [24.7 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [24.7 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [24.7 seconds ]
After "completely distribute ^ and @" round 3 remaining 
Obligations:

[serial 2554]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2552]


Done completely distributing ^ and @, round 3.
Distributing carets . .
. . . done spltting timed atoms  [24.7 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [24.7 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [24.7 seconds ]
step:  118
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2554]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2552]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2557]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2554]

. . . done Applying Laws [24.7 seconds ]
After "laws" remaining 
Obligations:

[serial 2557]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2554]


Done applying laws
step:  119
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2557]: ControlSoftware::FragilePositionControlThread.MultiStep
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  Identity (id):  P->P is tautology
  What for: Associativity: (b.c).a = a.b.c [serial 2554]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [24.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1034]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition + 
#PCS::MaxStepsUp) <= (DESIRED_POSITION)^0))) >>
S [346]<< (((ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION) and E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Delta := #PCS::MaxStepsUp
<< (E_MS() and (DESIRED_POSITION >= (ACTUAL_POSITION + #PCS::MaxStepsUp)) and (Delta = #PCS::MaxStepsUp) and (ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and ((ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and (Delta = #PCS::MaxStepsUp) and (ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition + Delta)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for ms3om:Decide-[x]->Run{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  120
#[serial 1034]  <<M(Decide) and x>> A <<M(Run)>> for ms3om:Decide-[x]->Run{A};
step:  121
****reduce****
This proof obligation:

[serial 1034]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition + 
#PCS::MaxStepsUp) <= (DESIRED_POSITION)^0))) >>
S [346]<< (((ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION) and E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Delta := #PCS::MaxStepsUp
<< (E_MS() and (DESIRED_POSITION >= (ACTUAL_POSITION + #PCS::MaxStepsUp)) and (Delta = #PCS::MaxStepsUp) and (ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and ((ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and (Delta = #PCS::MaxStepsUp) and (ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition + Delta)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for ms3om:Decide-[x]->Run{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P2>> S2 <<Q2>>
 
was reduced to:

[serial 2558]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition + 
#PCS::MaxStepsUp) <= (DESIRED_POSITION)^0))) >>
S [298]->
Q [15] << (((ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION) and E_MS() and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
  What for: P -> P1 in sequential composition for [serial 1034]


[serial 2559]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [294]->
Q [15] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 1034]


[serial 2560]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (((ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION) and E_MS() and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
S [348]Delta := #PCS::MaxStepsUp
Q [15] << (E_MS() and (DESIRED_POSITION >= (ACTUAL_POSITION + #PCS::MaxStepsUp)) and 
(Delta = #PCS::MaxStepsUp) and (ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and ((ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= #PCS::MaxPosition)) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1034]


[serial 2561]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (E_MS() and (DESIRED_POSITION >= (ACTUAL_POSITION + #PCS::MaxStepsUp)) and 
(Delta = #PCS::MaxStepsUp) and (ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and ((ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= #PCS::MaxPosition)) >>
S [354]ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and (Delta = #PCS::MaxStepsUp) and 
(ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1034]


[serial 2562]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and (Delta = #PCS::MaxStepsUp) and 
(ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
S [359]EstimatedActualPosition' := (EstimatedActualPosition + Delta)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1034]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 2558]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition + 
#PCS::MaxStepsUp) <= (DESIRED_POSITION)^0))) >>
S [298]->
Q [15] << (((ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION) and E_MS() and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
  What for: P -> P1 in sequential composition for [serial 1034]



[serial 2559]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [294]->
Q [15] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 1034]



[serial 2560]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (((ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION) and E_MS() and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
S [348]Delta := #PCS::MaxStepsUp
Q [15] << (E_MS() and (DESIRED_POSITION >= (ACTUAL_POSITION + #PCS::MaxStepsUp)) and 
(Delta = #PCS::MaxStepsUp) and (ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and ((ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= #PCS::MaxPosition)) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1034]



[serial 2561]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (E_MS() and (DESIRED_POSITION >= (ACTUAL_POSITION + #PCS::MaxStepsUp)) and 
(Delta = #PCS::MaxStepsUp) and (ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and ((ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= #PCS::MaxPosition)) >>
S [354]ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and (Delta = #PCS::MaxStepsUp) and 
(ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1034]



[serial 2562]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and (Delta = #PCS::MaxStepsUp) and 
(ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
S [359]EstimatedActualPosition' := (EstimatedActualPosition + Delta)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1034]


done reducing composite actions
step:  122
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2558]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition + 
#PCS::MaxStepsUp) <= (DESIRED_POSITION)^0))) >>
S [298]->
Q [15] << (((ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION) and E_MS() and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Reason:  Normalization
  What for: P -> P1 in sequential composition for [serial 1034]

  Normalization Axioms:

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2564]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 2558]


This Proof Obligation:

[serial 2559]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [294]->
Q [15] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
Reason:  Normalization
  What for: Q2 -> Q in sequential composition for [serial 1034]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2566]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2559]


This Proof Obligation:

[serial 2560]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (((ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION) and E_MS() and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
S [348]Delta := #PCS::MaxStepsUp
Q [15] << (E_MS() and (DESIRED_POSITION >= (ACTUAL_POSITION + #PCS::MaxStepsUp)) and 
(Delta = #PCS::MaxStepsUp) and (ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and ((ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1034]

  Normalization Axioms:

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2568]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]Delta := #PCS::MaxStepsUp
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
  What for:   normalization of [serial 2560]


This Proof Obligation:

[serial 2561]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (E_MS() and (DESIRED_POSITION >= (ACTUAL_POSITION + #PCS::MaxStepsUp)) and 
(Delta = #PCS::MaxStepsUp) and (ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and ((ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= #PCS::MaxPosition)) >>
S [354]ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and (Delta = #PCS::MaxStepsUp) and 
(ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1034]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2570]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]ActuatorCommand(pc:Delta)
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
  What for:   normalization of [serial 2561]


This Proof Obligation:

[serial 2562]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and (Delta = #PCS::MaxStepsUp) and 
(ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
S [359]EstimatedActualPosition' := (EstimatedActualPosition + Delta)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1034]

  Normalization Axioms:

    Reflexivity of Addition: a+b=b+a

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2572]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]EstimatedActualPosition' := (Delta + EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
  What for:   normalization of [serial 2562]

. . . done Normalizing Unsolved Proof Obligations [24.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2564]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 2558]



[serial 2566]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2559]



[serial 2568]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]Delta := #PCS::MaxStepsUp
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
  What for:   normalization of [serial 2560]



[serial 2570]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]ActuatorCommand(pc:Delta)
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
  What for:   normalization of [serial 2561]



[serial 2572]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]EstimatedActualPosition' := (Delta + EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
  What for:   normalization of [serial 2562]


Done Normalizing
step:  123
****atomic****
applying atomic actions . . .
solving assignment on line 348
replacing "Delta" with "#PCS::MaxStepsUp"
makes:  << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
(#PCS::MaxStepsUp) = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>

This Proof Obligation:

[serial 2568]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]Delta := #PCS::MaxStepsUp
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for:   normalization of [serial 2560]

Has applied := to get:

[serial 2578]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
(#PCS::MaxStepsUp) = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
  What for: applied wp for assignment [serial 2568]

Creating weakest-precondition predicate transfer for subprogram invocation of "ActuatorCommand".

This Proof Obligation:

[serial 2570]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]ActuatorCommand(pc:Delta)
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
Reason:  Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
  What for:   normalization of [serial 2561]

Used weakest precondition predicate transformation on
+ <<P>> ActuatorCommand(X) <<Q>> to get:

[serial 2579]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (0 <= (ACTUAL_POSITION + 
Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and E_MS() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2570]

solving assignment on line 359
replacing "EstimatedActualPosition'" with "(Delta + EstimatedActualPosition)"
makes:  << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>

This Proof Obligation:

[serial 2572]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]EstimatedActualPosition' := (Delta + EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for:   normalization of [serial 2562]

Has applied := to get:

[serial 2580]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
  What for: applied wp for assignment [serial 2572]

. . . done applying atomic actions [24.8 seconds ]
After "atomic" remaining 
Obligations:

[serial 2564]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 2558]



[serial 2566]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2559]



[serial 2578]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
(#PCS::MaxStepsUp) = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
  What for: applied wp for assignment [serial 2568]



[serial 2579]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (0 <= (ACTUAL_POSITION + 
Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and E_MS() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2570]



[serial 2580]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
  What for: applied wp for assignment [serial 2572]


Done reducing atomic actions
step:  124
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2578]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
(#PCS::MaxStepsUp) = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
Reason:  Normalization
  What for: applied wp for assignment [serial 2568]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2584]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
#PCS::MaxStepsUp = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
  What for:   normalization of [serial 2578]


This Proof Obligation:

[serial 2579]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (0 <= (ACTUAL_POSITION + 
Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and E_MS() >>
Reason:  Normalization
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2570]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2586]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and E_MS() and 
(0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 2579]


This Proof Obligation:

[serial 2580]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
Reason:  Normalization
  What for: applied wp for assignment [serial 2572]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2588]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2580]

. . . done Normalizing Unsolved Proof Obligations [24.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2564]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 2558]



[serial 2566]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2559]



[serial 2584]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
#PCS::MaxStepsUp = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
  What for:   normalization of [serial 2578]



[serial 2586]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and E_MS() and 
(0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 2579]



[serial 2588]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2580]


Done Normalizing
step:  125
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2584]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
#PCS::MaxStepsUp = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 2578]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 2592]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
true and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and E_MS() >>
  What for: Equality Law (idistr):  a=a <-> true [serial 2584]


This Proof Obligation:

[serial 2586]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and E_MS() and 
(0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2579]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2593]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and E_MS() >>
  What for: Associativity: (b.c).a = a.b.c [serial 2586]


This Proof Obligation:

[serial 2592]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
true and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and E_MS() >>
Reason:  Law of And-Simplification:  P and true is P
  What for: Equality Law (idistr):  a=a <-> true [serial 2584]

Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 2594]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and E_MS() >>
  What for: Law of And-Simplification:  P and true is P [serial 2592]

. . . done Applying Laws [24.8 seconds ]
After "laws" remaining 
Obligations:

[serial 2564]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 2558]



[serial 2566]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2559]



[serial 2588]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2580]



[serial 2593]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and E_MS() >>
  What for: Associativity: (b.c).a = a.b.c [serial 2586]



[serial 2594]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and E_MS() >>
  What for: Law of And-Simplification:  P and true is P [serial 2592]


Done applying laws
step:  126
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2593]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and E_MS() >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 2586]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2599]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + 
Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and E_MS() >>
  What for:   normalization of [serial 2593]

. . . done Normalizing Unsolved Proof Obligations [24.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2564]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 2558]



[serial 2566]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2559]



[serial 2588]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2580]



[serial 2594]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and E_MS() >>
  What for: Law of And-Simplification:  P and true is P [serial 2592]



[serial 2599]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + 
Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and E_MS() >>
  What for:   normalization of [serial 2593]


Done Normalizing
step:  127
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 2564]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 2558]

Has split postcondition to get:

[serial 2602]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2564]


[serial 2603]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [347] << ACTUAL_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2564]


[serial 2604]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [347] << DESIRED_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2564]


[serial 2605]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [347] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2564]


This Proof Obligation:

[serial 2588]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 2580]

Has split postcondition to get:

[serial 2606]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2588]


[serial 2607]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [362] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2588]


[serial 2608]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [361] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2588]


[serial 2609]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [360] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2588]


This Proof Obligation:

[serial 2594]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and E_MS() >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for: Law of And-Simplification:  P and true is P [serial 2592]

Has split postcondition to get:

[serial 2610]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]


[serial 2611]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [350] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]


[serial 2612]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [1] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]


[serial 2613]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]


[serial 2614]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [351] << AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]


[serial 2615]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [349] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]


This Proof Obligation:

[serial 2599]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + 
Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and E_MS() >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 2593]

Has split postcondition to get:

[serial 2616]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]


[serial 2617]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]


[serial 2618]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]


[serial 2619]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]


[serial 2620]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [357] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]


[serial 2621]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [356] << Delta = #PCS::MaxStepsUp >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]


[serial 2622]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [355] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]

. . . done splitting postcondition  [24.8 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 2566]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2559]



[serial 2602]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2564]



[serial 2603]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [347] << ACTUAL_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2564]



[serial 2604]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [347] << DESIRED_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2564]



[serial 2605]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [347] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2564]



[serial 2606]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2588]



[serial 2607]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [362] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2588]



[serial 2608]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [361] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2588]



[serial 2609]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [360] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2588]



[serial 2610]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]



[serial 2611]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [350] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]



[serial 2612]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [1] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]



[serial 2613]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]



[serial 2614]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [351] << AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]



[serial 2615]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [349] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]



[serial 2616]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]



[serial 2617]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]



[serial 2618]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]



[serial 2619]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]



[serial 2620]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [357] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]



[serial 2621]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [356] << Delta = #PCS::MaxStepsUp >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]



[serial 2622]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [355] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]


Done splitting postcondition
step:  128
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2603]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [347] << ACTUAL_IN_RANGE() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2564]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2604]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [347] << DESIRED_IN_RANGE() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2564]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2605]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [347] << E_MS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2564]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2612]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [1] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2615]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [349] << E_MS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2616]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2621]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [356] << Delta = #PCS::MaxStepsUp >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2622]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [355] << E_MS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [24.9 seconds ]
After "axioms" remaining 
Obligations:

[serial 2566]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2559]



[serial 2602]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2564]



[serial 2606]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2588]



[serial 2607]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [362] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2588]



[serial 2608]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [361] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2588]



[serial 2609]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [360] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2588]



[serial 2610]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]



[serial 2611]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [350] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]



[serial 2613]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]



[serial 2614]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [351] << AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]



[serial 2617]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]



[serial 2618]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]



[serial 2619]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]



[serial 2620]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [357] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]


Done trying to apply axioms
step:  129
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  130
****make-an****
Making obligation 62
Obligations:

[serial 2566]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2559]


Done making obligation 62
step:  131
#ControlSoftware::FragilePositionControlThread.MultiStep
step:  132
#[serial 1342]   normalization of [serial 1335]
step:  133
" "   (does nothing)
step:  134
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2566]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 2559]

Has substituted Assertions' predicates for labels to get:

[serial 2623]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels in postconditions [serial 2566]

. . . done Substituting Assertions for Labels [24.9 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 2623]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels in postconditions [serial 2566]


Done substituting Assertion labels in postconditions.
step:  135
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2623]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in postconditions [serial 2566]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2625]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
  What for:   normalization of [serial 2623]

. . . done Normalizing Unsolved Proof Obligations [24.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 2625]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
  What for:   normalization of [serial 2623]


Done Normalizing
step:  136
****completely distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2625]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2623]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2627]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [294]->
Q [15] << ((Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2625]

. . . done spltting timed atoms  [24.9 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [24.9 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2627]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [294]->
Q [15] << ((Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2625]

  Normalization Axioms:

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2629]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
  What for:   normalization of [serial 2627]

. . . done Normalizing Unsolved Proof Obligations [24.9 seconds ]
After "completely distribute ^ and @" round 0 remaining 
Obligations:

[serial 2629]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
  What for:   normalization of [serial 2627]


Done completely distributing ^ and @, round 0.
Distributing carets . .

This Proof Obligation:

[serial 2629]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2627]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2631]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2629]

. . . done spltting timed atoms  [24.9 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [24.9 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2631]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2629]

  Normalization Axioms:

    Literal Arithmetic

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2633]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for:   normalization of [serial 2631]

. . . done Normalizing Unsolved Proof Obligations [24.9 seconds ]
After "completely distribute ^ and @" round 1 remaining 
Obligations:

[serial 2633]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for:   normalization of [serial 2631]


Done completely distributing ^ and @, round 1.
Distributing carets . .

This Proof Obligation:

[serial 2633]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2631]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2635]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) and 
(((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2633]

. . . done spltting timed atoms  [24.9 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [24.9 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2635]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) and 
(((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1)) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2633]

  Normalization Axioms:

    Literal Arithmetic

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Constants are always the same
Has been normalized to get:

[serial 2637]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 2635]

. . . done Normalizing Unsolved Proof Obligations [24.9 seconds ]
After "completely distribute ^ and @" round 2 remaining 
Obligations:

[serial 2637]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 2635]


Done completely distributing ^ and @, round 2.
Distributing carets . .

This Proof Obligation:

[serial 2637]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2635]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2639]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2637]

. . . done spltting timed atoms  [24.9 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [24.9 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [24.9 seconds ]
After "completely distribute ^ and @" round 3 remaining 
Obligations:

[serial 2639]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2637]


Done completely distributing ^ and @, round 3.
Distributing carets . .
. . . done spltting timed atoms  [24.9 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [24.9 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [24.9 seconds ]
step:  137
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2639]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2637]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2642]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2639]

. . . done Applying Laws [24.9 seconds ]
After "laws" remaining 
Obligations:

[serial 2642]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2639]


Done applying laws
step:  138
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2642]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  Identity (id):  P->P is tautology
  What for: Associativity: (b.c).a = a.b.c [serial 2639]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [24.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2602]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2564]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  139
#[serial 1378] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1340]
step:  140
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2602]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2564]

Has substituted Assertions' predicates for labels to get:

[serial 2643]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [298]->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2602]

. . . done Substituting Assertions for Labels [24.9 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 2643]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [298]->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2602]


Done substituting Assertion labels in preconditions
step:  141
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2643]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [298]->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2602]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2645]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) >>
S [298]->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
  What for:   normalization of [serial 2643]

. . . done Normalizing Unsolved Proof Obligations [25.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 2645]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) >>
S [298]->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
  What for:   normalization of [serial 2643]


Done Normalizing
step:  142
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2645]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) >>
S [298]->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2643]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2647]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 2645]

. . . done Applying Laws [25.0 seconds ]
After "laws" remaining 
Obligations:

[serial 2647]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 2645]


Done applying laws
step:  143
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2647]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 2645]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2649]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
  What for:   normalization of [serial 2647]

. . . done Normalizing Unsolved Proof Obligations [25.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 2649]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
  What for:   normalization of [serial 2647]


Done Normalizing
step:  144
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 2649]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
Reason:  Assume Present:  P = P@now = P^0 
  What for:   normalization of [serial 2647]

Has applied Assume Present:  P = P@now = P^0  to get:

[serial 2651]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
  What for: Assume Present:  P = P@now = P^0  [serial 2649]

. . . done replacing P@now and P^0 with P  [25.0 seconds ]
After assuming present remaining 
Obligations:

[serial 2651]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
  What for: Assume Present:  P = P@now = P^0  [serial 2649]


Done assuming present.
step:  145
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION" . . .
equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 2651]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
Reason:  Guided Substitution of Equals
  What for: Assume Present:  P = P@now = P^0  [serial 2649]

Has substituted 
"ACTUAL_POSITION" with its = "EstimatedActualPosition"
 to get:

[serial 2652]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [346] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 2651]

. . . done guided substitution of equals  [25.0 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2652]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [346] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 2651]


Done guided substituting an equals
step:  146
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2652]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [346] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 2651]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [25.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2606]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2588]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  147
#[serial 1382] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1364]
step:  148
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  (ACTUAL_POSITION + Delta) = ACTUAL_POSITION'

This Proof Obligation:

[serial 2606]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [1] << 0 <= ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2588]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 2653]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2606]

. . . done guided substitution of equals  [25.0 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2653]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2606]


Done guided substituting an equals
step:  149
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2653]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2606]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2655]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2653]

. . . done Normalizing Unsolved Proof Obligations [25.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 2655]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2653]


Done Normalizing
step:  150
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2655]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 2653]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [25.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2607]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [362] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2588]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  151
#[serial 1383] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1364]
step:  152
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  (ACTUAL_POSITION + Delta) = ACTUAL_POSITION'

This Proof Obligation:

[serial 2607]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [362] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2588]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 2657]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [362] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2607]

. . . done guided substitution of equals  [25.0 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2657]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [362] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2607]


Done guided substituting an equals
step:  153
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2657]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [362] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2607]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2659]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [362] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2657]

. . . done Normalizing Unsolved Proof Obligations [25.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 2659]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [362] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2657]


Done Normalizing
step:  154
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2659]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [362] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 2657]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [25.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2608]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [361] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2588]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  155
#[serial 1384] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1364]
step:  156
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  (ACTUAL_POSITION + Delta) = ACTUAL_POSITION'

This Proof Obligation:

[serial 2608]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [361] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2588]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 2661]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [361] << Delta = (((ACTUAL_POSITION + Delta)) - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2608]

. . . done guided substitution of equals  [25.0 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2661]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [361] << Delta = (((ACTUAL_POSITION + Delta)) - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2608]


Done guided substituting an equals
step:  157
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2661]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [361] << Delta = (((ACTUAL_POSITION + Delta)) - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2608]

  Normalization Axioms:

    Subtaction of Added Value:  (a+b)-a is b

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2663]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [361] << Delta = Delta >>
  What for:   normalization of [serial 2661]

. . . done Normalizing Unsolved Proof Obligations [25.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 2663]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [361] << Delta = Delta >>
  What for:   normalization of [serial 2661]


Done Normalizing
step:  158
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2663]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [361] << Delta = Delta >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 2661]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 2665]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [361] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 2663]

. . . done Applying Laws [25.0 seconds ]
After "laws" remaining 
Obligations:

[serial 2665]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [361] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 2663]


Done applying laws
step:  159
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2665]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [361] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 2663]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [25.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2609]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [360] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2588]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  160
#[serial 1385] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1364]
step:  161
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2609]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359]->
Q [360] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2588]

Has substituted Assertions' predicates for labels to get:

[serial 2666]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [359]->
Q [360] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2609]

. . . done Substituting Assertions for Labels [25.0 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 2666]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [359]->
Q [360] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2609]


Done substituting Assertion labels in preconditions
step:  162
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2666]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [359]->
Q [360] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2609]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2668]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [359]->
Q [360] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2666]

. . . done Normalizing Unsolved Proof Obligations [25.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 2668]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [359]->
Q [360] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2666]


Done Normalizing
step:  163
****guided-sub-equals****
guided substitution of equals "EstimatedActualPosition" . . .
equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 2668]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [359]->
Q [360] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 2666]

Has substituted 
"EstimatedActualPosition" with its = "ACTUAL_POSITION"
 to get:

[serial 2670]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [359]->
Q [360] << (Delta + ACTUAL_POSITION) = ACTUAL_POSITION' >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 2668]

. . . done guided substitution of equals  [25.0 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2670]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [359]->
Q [360] << (Delta + ACTUAL_POSITION) = ACTUAL_POSITION' >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 2668]


Done guided substituting an equals
step:  164
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2670]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [359]->
Q [360] << (Delta + ACTUAL_POSITION) = ACTUAL_POSITION' >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 2668]

  Normalization Axiom:

    Reflexivity of Addition: a+b=b+a
Has been normalized to get:

[serial 2672]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [359]->
Q [360] << (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2670]

. . . done Normalizing Unsolved Proof Obligations [25.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 2672]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [359]->
Q [360] << (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2670]


Done Normalizing
step:  165
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2672]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [359]->
Q [360] << (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 2670]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [25.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2610]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  166
#[serial 1386] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1370]
step:  167
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2610]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]

Has substituted Assertions' predicates for labels to get:

[serial 2674]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [348]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2610]

. . . done Substituting Assertions for Labels [25.0 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 2674]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [348]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2610]


Done substituting Assertion labels in preconditions
step:  168
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2674]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [348]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2610]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2676]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [348]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for:   normalization of [serial 2674]

. . . done Normalizing Unsolved Proof Obligations [25.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 2676]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [348]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for:   normalization of [serial 2674]


Done Normalizing
step:  169
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2676]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [348]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2674]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2678]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [348]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 2676]

. . . done Applying Laws [25.0 seconds ]
After "laws" remaining 
Obligations:

[serial 2678]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [348]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 2676]


Done applying laws
step:  170
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2678]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [348]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Associativity: (b.c).a = a.b.c [serial 2676]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [25.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2611]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [350] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  171
#[serial 1387] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1370]
step:  172
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2611]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [350] << DESIRED_POSITION <= #PCS::MaxPosition >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]

Has substituted Assertions' predicates for labels to get:

[serial 2679]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [348]->
Q [350] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2611]

. . . done Substituting Assertions for Labels [25.0 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 2679]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [348]->
Q [350] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2611]


Done substituting Assertion labels in preconditions
step:  173
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2679]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [348]->
Q [350] << DESIRED_POSITION <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2611]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2681]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [348]->
Q [350] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2679]

. . . done Normalizing Unsolved Proof Obligations [25.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 2681]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [348]->
Q [350] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2679]


Done Normalizing
step:  174
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2681]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [348]->
Q [350] << DESIRED_POSITION <= #PCS::MaxPosition >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2679]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2683]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [348]->
Q [350] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 2681]

. . . done Applying Laws [25.0 seconds ]
After "laws" remaining 
Obligations:

[serial 2683]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [348]->
Q [350] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 2681]


Done applying laws
step:  175
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2683]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [348]->
Q [350] << DESIRED_POSITION <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Associativity: (b.c).a = a.b.c [serial 2681]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [25.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2613]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  176
#[serial 1389] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1370]
step:  177
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2613]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]

Has substituted Assertions' predicates for labels to get:

[serial 2684]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [348]->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2613]

. . . done Substituting Assertions for Labels [25.1 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 2684]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [348]->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2613]


Done substituting Assertion labels in preconditions
step:  178
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2684]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [348]->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2613]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2686]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [348]->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2684]

. . . done Normalizing Unsolved Proof Obligations [25.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 2686]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [348]->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2684]


Done Normalizing
step:  179
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2686]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [348]->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2684]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2688]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [348]->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 2686]

. . . done Applying Laws [25.1 seconds ]
After "laws" remaining 
Obligations:

[serial 2688]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [348]->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 2686]


Done applying laws
step:  180
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2688]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [348]->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 2686]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2690]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [348]->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2688]

. . . done Normalizing Unsolved Proof Obligations [25.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 2690]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [348]->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2688]


Done Normalizing
step:  181
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition -> 0 <= #PCS::MaxPosition
Transitivity:  (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition -> (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition

This Proof Obligation:

[serial 2690]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [348]->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for:   normalization of [serial 2688]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 2692]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and 0 <= #PCS::MaxPosition and 
(ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
S [348]->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2690]

. . . done adding transitive terms [25.1 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 2692]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and 0 <= #PCS::MaxPosition and 
(ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
S [348]->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2690]


Done adding transitive relations
step:  182
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2692]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and 0 <= #PCS::MaxPosition and 
(ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
S [348]->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Transitivity: x<y and y<z -> x<z [serial 2690]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [25.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2614]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [351] << AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  183
#[serial 1390] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1370]
step:  184
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 2614]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [351] << AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) >>
Reason:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]

has been transformed into:

[serial 2693]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [351] << true >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


by removing axioms from postconditions.

. . . done removing axioms from postconditions  [25.1 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 2693]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [351] << true >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 



Done removing axioms from postconditions
step:  185
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2693]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348]->
Q [351] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [25.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2617]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  186
#[serial 1393] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1375]
step:  187
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2617]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]

Has substituted Assertions' predicates for labels to get:

[serial 2694]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and ((ACTUAL_POSITION < (ACTUAL_POSITION + (#PCS::MaxStepsUp))) and 
((#PCS::MaxStepsUp) > 0)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2617]

. . . done Substituting Assertions for Labels [25.1 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 2694]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and ((ACTUAL_POSITION < (ACTUAL_POSITION + (#PCS::MaxStepsUp))) and 
((#PCS::MaxStepsUp) > 0)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2617]


Done substituting Assertion labels in preconditions
step:  188
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2694]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and ((ACTUAL_POSITION < (ACTUAL_POSITION + (#PCS::MaxStepsUp))) and 
((#PCS::MaxStepsUp) > 0)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2617]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2696]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
(0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp)) >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2694]

. . . done Normalizing Unsolved Proof Obligations [25.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 2696]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
(0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp)) >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2694]


Done Normalizing
step:  189
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2696]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
(0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp)) >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2694]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2698]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) and 
0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2696]

. . . done Applying Laws [25.1 seconds ]
After "laws" remaining 
Obligations:

[serial 2698]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) and 
0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2696]


Done applying laws
step:  190
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2698]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) and 
0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 2696]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2700]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2698]

. . . done Normalizing Unsolved Proof Obligations [25.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 2700]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2698]


Done Normalizing
step:  191
****guided-sub-equals****
guided substitution of equals "Delta" . . .
equality selected for substitution:  Delta = #PCS::MaxStepsUp

This Proof Obligation:

[serial 2700]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 2698]

Has substituted 
"Delta" with its = "(#PCS::MaxStepsUp)"
 to get:

[serial 2702]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + (#PCS::MaxStepsUp)) >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "(#PCS::MaxStepsUp)" in its postcondition [serial 2700]

. . . done guided substitution of equals  [25.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2702]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + (#PCS::MaxStepsUp)) >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "(#PCS::MaxStepsUp)" in its postcondition [serial 2700]


Done guided substituting an equals
step:  192
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2702]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + (#PCS::MaxStepsUp)) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "(#PCS::MaxStepsUp)" in its postcondition [serial 2700]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2704]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2702]

. . . done Normalizing Unsolved Proof Obligations [25.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 2704]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2702]


Done Normalizing
step:  193
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  0 <= ACTUAL_POSITION and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) -> 0 < (ACTUAL_POSITION + #PCS::MaxStepsUp)
Transitivity:  ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION -> ACTUAL_POSITION < DESIRED_POSITION
Transitivity:  0 < (ACTUAL_POSITION + #PCS::MaxStepsUp) and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION -> 0 < DESIRED_POSITION
Transitivity:  ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition -> ACTUAL_POSITION < #PCS::MaxPosition
Transitivity:  0 < (ACTUAL_POSITION + #PCS::MaxStepsUp) and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition -> 0 < #PCS::MaxPosition

This Proof Obligation:

[serial 2704]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for:   normalization of [serial 2702]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 2706]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) and 
0 < (ACTUAL_POSITION + #PCS::MaxStepsUp) and ACTUAL_POSITION < DESIRED_POSITION and 
0 < DESIRED_POSITION and ACTUAL_POSITION < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2704]

. . . done adding transitive terms [25.1 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 2706]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) and 
0 < (ACTUAL_POSITION + #PCS::MaxStepsUp) and ACTUAL_POSITION < DESIRED_POSITION and 
0 < DESIRED_POSITION and ACTUAL_POSITION < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2704]


Done adding transitive relations
step:  194
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2706]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) and 
0 < (ACTUAL_POSITION + #PCS::MaxStepsUp) and ACTUAL_POSITION < DESIRED_POSITION and 
0 < DESIRED_POSITION and ACTUAL_POSITION < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
Reason:  Normalization
  What for: Transitivity: x<y and y<z -> x<z [serial 2704]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2708]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < DESIRED_POSITION and 0 < (ACTUAL_POSITION + #PCS::MaxStepsUp) and 0 < #PCS::MaxPosition and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (
ACTUAL_POSITION + #PCS::MaxStepsUp) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2706]

. . . done Normalizing Unsolved Proof Obligations [25.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 2708]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < DESIRED_POSITION and 0 < (ACTUAL_POSITION + #PCS::MaxStepsUp) and 0 < #PCS::MaxPosition and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (
ACTUAL_POSITION + #PCS::MaxStepsUp) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2706]


Done Normalizing
step:  195
****partial to total order****
Making partial orders into total orders . . .
Making partial orders into total orders . . .

This Proof Obligation:

[serial 2708]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < DESIRED_POSITION and 0 < (ACTUAL_POSITION + #PCS::MaxStepsUp) and 0 < #PCS::MaxPosition and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (
ACTUAL_POSITION + #PCS::MaxStepsUp) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
Reason:  Partial Order Law 3:  a <= (b-1)  is  a<b
  What for:   normalization of [serial 2706]

Has applied Partial Order Law 3:  a <= (b-1)  is  a<b (0<(ACTUAL_POSITION + #PCS::MaxStepsUp)  ->  0<=(ACTUAL_POSITION + #PCS::MaxStepsUp)
 null <=(- null + null)  is   null < null
   null <=(- null + null)  is   null < null
) to get:

[serial 2710]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < DESIRED_POSITION and 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) and 0 < #PCS::MaxPosition and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (
ACTUAL_POSITION + #PCS::MaxStepsUp) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for: 0<(ACTUAL_POSITION + #PCS::MaxStepsUp)  ->  0<=(ACTUAL_POSITION + #PCS::MaxStepsUp)
 null <=(- null + null)  is   null < null
   null <=(- null + null)  is   null < null

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2708]

. . . done making partial orders into total orders [25.1 seconds ]
After making partial orders into total orders 
Obligations:

[serial 2710]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < DESIRED_POSITION and 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) and 0 < #PCS::MaxPosition and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (
ACTUAL_POSITION + #PCS::MaxStepsUp) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for: 0<(ACTUAL_POSITION + #PCS::MaxStepsUp)  ->  0<=(ACTUAL_POSITION + #PCS::MaxStepsUp)
 null <=(- null + null)  is   null < null
   null <=(- null + null)  is   null < null

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2708]


Done making partial orders into total orders
step:  196
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2710]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < DESIRED_POSITION and 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) and 0 < #PCS::MaxPosition and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (
ACTUAL_POSITION + #PCS::MaxStepsUp) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: 0<(ACTUAL_POSITION + #PCS::MaxStepsUp)  ->  0<=(ACTUAL_POSITION + #PCS::MaxStepsUp)
 null <=(- null + null)  is   null < null
   null <=(- null + null)  is   null < null

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2708]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [25.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2618]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  197
#[serial 1394] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1375]
step:  198
****guided-sub-equals****
guided substitution of equals "Delta" . . .
equality selected for substitution:  Delta = #PCS::MaxStepsUp

This Proof Obligation:

[serial 2618]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]

Has substituted 
"Delta" with its = "(#PCS::MaxStepsUp)"
 to get:

[serial 2711]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + (#PCS::MaxStepsUp)) >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "(#PCS::MaxStepsUp)" in its postcondition [serial 2618]

. . . done guided substitution of equals  [25.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2711]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + (#PCS::MaxStepsUp)) >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "(#PCS::MaxStepsUp)" in its postcondition [serial 2618]


Done guided substituting an equals
step:  199
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2711]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + (#PCS::MaxStepsUp)) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "(#PCS::MaxStepsUp)" in its postcondition [serial 2618]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2713]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2711]

. . . done Normalizing Unsolved Proof Obligations [25.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 2713]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2711]


Done Normalizing
step:  200
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2713]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 2711]

Has substituted Assertions' predicates for labels to get:

[serial 2715]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and ((ACTUAL_POSITION < (ACTUAL_POSITION + (#PCS::MaxStepsUp))) and 
((#PCS::MaxStepsUp) > 0)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2713]

. . . done Substituting Assertions for Labels [25.1 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 2715]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and ((ACTUAL_POSITION < (ACTUAL_POSITION + (#PCS::MaxStepsUp))) and 
((#PCS::MaxStepsUp) > 0)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2713]


Done substituting Assertion labels in preconditions
step:  201
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2715]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and ((ACTUAL_POSITION < (ACTUAL_POSITION + (#PCS::MaxStepsUp))) and 
((#PCS::MaxStepsUp) > 0)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2713]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2717]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
(0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp)) >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2715]

. . . done Normalizing Unsolved Proof Obligations [25.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 2717]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
(0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp)) >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2715]


Done Normalizing
step:  202
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2717]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
(0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp)) >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2715]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2719]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) and 
0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2717]

. . . done Applying Laws [25.2 seconds ]
After "laws" remaining 
Obligations:

[serial 2719]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) and 
0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2717]


Done applying laws
step:  203
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2719]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) and 
0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 2717]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2721]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2719]

. . . done Normalizing Unsolved Proof Obligations [25.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 2721]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2719]


Done Normalizing
step:  204
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  0 <= ACTUAL_POSITION and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) -> 0 < (ACTUAL_POSITION + #PCS::MaxStepsUp)
Transitivity:  ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION -> ACTUAL_POSITION < DESIRED_POSITION
Transitivity:  0 < (ACTUAL_POSITION + #PCS::MaxStepsUp) and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION -> 0 < DESIRED_POSITION
Transitivity:  ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition -> ACTUAL_POSITION < #PCS::MaxPosition
Transitivity:  0 < (ACTUAL_POSITION + #PCS::MaxStepsUp) and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition -> 0 < #PCS::MaxPosition

This Proof Obligation:

[serial 2721]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for:   normalization of [serial 2719]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 2723]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) and 
0 < (ACTUAL_POSITION + #PCS::MaxStepsUp) and ACTUAL_POSITION < DESIRED_POSITION and 
0 < DESIRED_POSITION and ACTUAL_POSITION < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2721]

. . . done adding transitive terms [25.2 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 2723]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) and 
0 < (ACTUAL_POSITION + #PCS::MaxStepsUp) and ACTUAL_POSITION < DESIRED_POSITION and 
0 < DESIRED_POSITION and ACTUAL_POSITION < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2721]


Done adding transitive relations
step:  205
****partial to total order****
Making partial orders into total orders . . .
Making partial orders into total orders . . .

This Proof Obligation:

[serial 2723]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) and 
0 < (ACTUAL_POSITION + #PCS::MaxStepsUp) and ACTUAL_POSITION < DESIRED_POSITION and 
0 < DESIRED_POSITION and ACTUAL_POSITION < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
Reason:  Partial Order Law 3:  a <= (b-1)  is  a<b
  What for: Transitivity: x<y and y<z -> x<z [serial 2721]

Has applied Partial Order Law 3:  a <= (b-1)  is  a<b (0<(ACTUAL_POSITION + #PCS::MaxStepsUp)  ->  0<=(ACTUAL_POSITION + #PCS::MaxStepsUp)
 null <=(- null + null)  is   null < null
   null <=(- null + null)  is   null < null
) to get:

[serial 2724]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) and 
0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) and ACTUAL_POSITION < DESIRED_POSITION and 
0 < DESIRED_POSITION and ACTUAL_POSITION < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for: 0<(ACTUAL_POSITION + #PCS::MaxStepsUp)  ->  0<=(ACTUAL_POSITION + #PCS::MaxStepsUp)
 null <=(- null + null)  is   null < null
   null <=(- null + null)  is   null < null

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2723]

. . . done making partial orders into total orders [25.2 seconds ]
After making partial orders into total orders 
Obligations:

[serial 2724]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) and 
0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) and ACTUAL_POSITION < DESIRED_POSITION and 
0 < DESIRED_POSITION and ACTUAL_POSITION < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for: 0<(ACTUAL_POSITION + #PCS::MaxStepsUp)  ->  0<=(ACTUAL_POSITION + #PCS::MaxStepsUp)
 null <=(- null + null)  is   null < null
   null <=(- null + null)  is   null < null

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2723]


Done making partial orders into total orders
step:  206
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2724]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) and 
0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) and ACTUAL_POSITION < DESIRED_POSITION and 
0 < DESIRED_POSITION and ACTUAL_POSITION < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [354]->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: 0<(ACTUAL_POSITION + #PCS::MaxStepsUp)  ->  0<=(ACTUAL_POSITION + #PCS::MaxStepsUp)
 null <=(- null + null)  is   null < null
   null <=(- null + null)  is   null < null

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2723]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [25.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2619]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  207
#[serial 1395] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1375]
step:  208
****guided-sub-equals****
guided substitution of equals "Delta" . . .
equality selected for substitution:  Delta = #PCS::MaxStepsUp

This Proof Obligation:

[serial 2619]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]

Has substituted 
"Delta" with its = "(#PCS::MaxStepsUp)"
 to get:

[serial 2725]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [130] << (ACTUAL_POSITION + (#PCS::MaxStepsUp)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "(#PCS::MaxStepsUp)" in its postcondition [serial 2619]

. . . done guided substitution of equals  [25.2 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2725]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [130] << (ACTUAL_POSITION + (#PCS::MaxStepsUp)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "(#PCS::MaxStepsUp)" in its postcondition [serial 2619]


Done guided substituting an equals
step:  209
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2725]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [130] << (ACTUAL_POSITION + (#PCS::MaxStepsUp)) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "(#PCS::MaxStepsUp)" in its postcondition [serial 2619]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2727]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [130] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2725]

. . . done Normalizing Unsolved Proof Obligations [25.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 2727]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [130] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2725]


Done Normalizing
step:  210
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2727]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [130] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 2725]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [25.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2620]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [357] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  211
#[serial 1396] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1375]
step:  212
****guided-sub-equals****
guided substitution of equals "Delta" . . .
equality selected for substitution:  Delta = #PCS::MaxStepsUp

This Proof Obligation:

[serial 2620]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [357] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]

Has substituted 
"Delta" with its = "(#PCS::MaxStepsUp)"
 to get:

[serial 2729]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [357] << (ACTUAL_POSITION + (#PCS::MaxStepsUp)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "(#PCS::MaxStepsUp)" in its postcondition [serial 2620]

. . . done guided substitution of equals  [25.2 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2729]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [357] << (ACTUAL_POSITION + (#PCS::MaxStepsUp)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "(#PCS::MaxStepsUp)" in its postcondition [serial 2620]


Done guided substituting an equals
step:  213
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2729]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [357] << (ACTUAL_POSITION + (#PCS::MaxStepsUp)) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "(#PCS::MaxStepsUp)" in its postcondition [serial 2620]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2731]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [357] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2729]

. . . done Normalizing Unsolved Proof Obligations [25.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 2731]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [357] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2729]


Done Normalizing
step:  214
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2731]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354]->
Q [357] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 2729]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [25.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1035]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp)))) >>
S [367]<< ((DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp)) and E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Delta := -#PCS::MaxStepsUp
<< (E_MS() and (Delta =  -#PCS::MaxStepsUp) and ((ACTUAL_POSITION - #PCS::MaxStepsUp) >= DESIRED_POSITION) and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and (DESIRED_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta =  -#PCS::MaxStepsUp) and ((ACTUAL_POSITION + Delta) >= 0) and E_MS() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition + Delta)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for ms4cm:Decide-[x]->Run{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  215
#[serial 1035]  <<M(Decide) and x>> A <<M(Run)>> for ms4cm:Decide-[x]->Run{A};
step:  216
****reduce****
This proof obligation:

[serial 1035]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp)))) >>
S [367]<< ((DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp)) and E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Delta := -#PCS::MaxStepsUp
<< (E_MS() and (Delta =  -#PCS::MaxStepsUp) and ((ACTUAL_POSITION - #PCS::MaxStepsUp) >= DESIRED_POSITION) and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and (DESIRED_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta =  -#PCS::MaxStepsUp) and ((ACTUAL_POSITION + Delta) >= 0) and E_MS() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition + Delta)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for ms4cm:Decide-[x]->Run{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P2>> S2 <<Q2>>
 
was reduced to:

[serial 2733]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp)))) >>
S [298]->
Q [15] << ((DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp)) and E_MS() and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
  What for: P -> P1 in sequential composition for [serial 1035]


[serial 2734]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [294]->
Q [15] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 1035]


[serial 2735]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp)) and E_MS() and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
S [369]Delta := -#PCS::MaxStepsUp
Q [15] << (E_MS() and (Delta =  -#PCS::MaxStepsUp) and ((ACTUAL_POSITION - #PCS::MaxStepsUp) >= DESIRED_POSITION) and 
AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and (DESIRED_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1035]


[serial 2736]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (E_MS() and (Delta =  -#PCS::MaxStepsUp) and ((ACTUAL_POSITION - #PCS::MaxStepsUp) >= DESIRED_POSITION) and 
AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and (DESIRED_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) >>
S [374]ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta =  -#PCS::MaxStepsUp) and 
((ACTUAL_POSITION + Delta) >= 0) and E_MS() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1035]


[serial 2737]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta =  -#PCS::MaxStepsUp) and 
((ACTUAL_POSITION + Delta) >= 0) and E_MS() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
S [379]EstimatedActualPosition' := (EstimatedActualPosition + Delta)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1035]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 2733]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp)))) >>
S [298]->
Q [15] << ((DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp)) and E_MS() and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
  What for: P -> P1 in sequential composition for [serial 1035]



[serial 2734]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [294]->
Q [15] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 1035]



[serial 2735]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp)) and E_MS() and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
S [369]Delta := -#PCS::MaxStepsUp
Q [15] << (E_MS() and (Delta =  -#PCS::MaxStepsUp) and ((ACTUAL_POSITION - #PCS::MaxStepsUp) >= DESIRED_POSITION) and 
AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and (DESIRED_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1035]



[serial 2736]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (E_MS() and (Delta =  -#PCS::MaxStepsUp) and ((ACTUAL_POSITION - #PCS::MaxStepsUp) >= DESIRED_POSITION) and 
AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and (DESIRED_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) >>
S [374]ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta =  -#PCS::MaxStepsUp) and 
((ACTUAL_POSITION + Delta) >= 0) and E_MS() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1035]



[serial 2737]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta =  -#PCS::MaxStepsUp) and 
((ACTUAL_POSITION + Delta) >= 0) and E_MS() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
S [379]EstimatedActualPosition' := (EstimatedActualPosition + Delta)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1035]


done reducing composite actions
step:  217
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2733]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp)))) >>
S [298]->
Q [15] << ((DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp)) and E_MS() and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Reason:  Normalization
  What for: P -> P1 in sequential composition for [serial 1035]

  Normalization Axioms:

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2739]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 2733]


This Proof Obligation:

[serial 2734]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [294]->
Q [15] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
Reason:  Normalization
  What for: Q2 -> Q in sequential composition for [serial 1035]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2741]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2734]


This Proof Obligation:

[serial 2735]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp)) and E_MS() and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
S [369]Delta := -#PCS::MaxStepsUp
Q [15] << (E_MS() and (Delta =  -#PCS::MaxStepsUp) and ((ACTUAL_POSITION - #PCS::MaxStepsUp) >= DESIRED_POSITION) and 
AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and (DESIRED_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1035]

  Normalization Axioms:

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2743]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]Delta := -#PCS::MaxStepsUp
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
  What for:   normalization of [serial 2735]


This Proof Obligation:

[serial 2736]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (E_MS() and (Delta =  -#PCS::MaxStepsUp) and ((ACTUAL_POSITION - #PCS::MaxStepsUp) >= DESIRED_POSITION) and 
AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and (DESIRED_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) >>
S [374]ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta =  -#PCS::MaxStepsUp) and 
((ACTUAL_POSITION + Delta) >= 0) and E_MS() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1035]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2745]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]ActuatorCommand(pc:Delta)
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
  What for:   normalization of [serial 2736]


This Proof Obligation:

[serial 2737]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta =  -#PCS::MaxStepsUp) and 
((ACTUAL_POSITION + Delta) >= 0) and E_MS() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
S [379]EstimatedActualPosition' := (EstimatedActualPosition + Delta)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1035]

  Normalization Axioms:

    Reflexivity of Addition: a+b=b+a

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2747]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]EstimatedActualPosition' := (Delta + EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
  What for:   normalization of [serial 2737]

. . . done Normalizing Unsolved Proof Obligations [25.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 2739]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 2733]



[serial 2741]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2734]



[serial 2743]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]Delta := -#PCS::MaxStepsUp
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
  What for:   normalization of [serial 2735]



[serial 2745]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]ActuatorCommand(pc:Delta)
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
  What for:   normalization of [serial 2736]



[serial 2747]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]EstimatedActualPosition' := (Delta + EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
  What for:   normalization of [serial 2737]


Done Normalizing
step:  218
****atomic****
applying atomic actions . . .
solving assignment on line 369
replacing "Delta" with "- #PCS::MaxStepsUp"
makes:  << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
( -#PCS::MaxStepsUp) =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,
k:#PCS::MaxStepsUp) and E_MS() >>

This Proof Obligation:

[serial 2743]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]Delta := -#PCS::MaxStepsUp
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for:   normalization of [serial 2735]

Has applied := to get:

[serial 2753]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
( -#PCS::MaxStepsUp) =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,
k:#PCS::MaxStepsUp) and E_MS() >>
  What for: applied wp for assignment [serial 2743]

Creating weakest-precondition predicate transfer for subprogram invocation of "ActuatorCommand".

This Proof Obligation:

[serial 2745]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]ActuatorCommand(pc:Delta)
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
Reason:  Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
  What for:   normalization of [serial 2736]

Used weakest precondition predicate transformation on
+ <<P>> ActuatorCommand(X) <<Q>> to get:

[serial 2754]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition) and E_MS() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2745]

solving assignment on line 379
replacing "EstimatedActualPosition'" with "(Delta + EstimatedActualPosition)"
makes:  << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>

This Proof Obligation:

[serial 2747]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]EstimatedActualPosition' := (Delta + EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for:   normalization of [serial 2737]

Has applied := to get:

[serial 2755]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
  What for: applied wp for assignment [serial 2747]

. . . done applying atomic actions [25.3 seconds ]
After "atomic" remaining 
Obligations:

[serial 2739]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 2733]



[serial 2741]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2734]



[serial 2753]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
( -#PCS::MaxStepsUp) =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,
k:#PCS::MaxStepsUp) and E_MS() >>
  What for: applied wp for assignment [serial 2743]



[serial 2754]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition) and E_MS() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2745]



[serial 2755]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
  What for: applied wp for assignment [serial 2747]


Done reducing atomic actions
step:  219
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2754]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition) and E_MS() >>
Reason:  Normalization
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2745]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2760]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and E_MS() and (0 <= (ACTUAL_POSITION + Delta) and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 2754]


This Proof Obligation:

[serial 2755]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
Reason:  Normalization
  What for: applied wp for assignment [serial 2747]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2762]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2755]

. . . done Normalizing Unsolved Proof Obligations [25.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 2739]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 2733]



[serial 2741]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2734]



[serial 2753]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
( -#PCS::MaxStepsUp) =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,
k:#PCS::MaxStepsUp) and E_MS() >>
  What for: applied wp for assignment [serial 2743]



[serial 2760]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and E_MS() and (0 <= (ACTUAL_POSITION + Delta) and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 2754]



[serial 2762]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2755]


Done Normalizing
step:  220
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2753]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
( -#PCS::MaxStepsUp) =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,
k:#PCS::MaxStepsUp) and E_MS() >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for: applied wp for assignment [serial 2743]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 2765]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
true and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and E_MS() >>
  What for: Equality Law (idistr):  a=a <-> true [serial 2753]


This Proof Obligation:

[serial 2760]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and E_MS() and (0 <= (ACTUAL_POSITION + Delta) and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2754]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2766]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and E_MS() >>
  What for: Associativity: (b.c).a = a.b.c [serial 2760]


This Proof Obligation:

[serial 2765]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
true and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and E_MS() >>
Reason:  Law of And-Simplification:  P and true is P
  What for: Equality Law (idistr):  a=a <-> true [serial 2753]

Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 2767]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and E_MS() >>
  What for: Law of And-Simplification:  P and true is P [serial 2765]

. . . done Applying Laws [25.3 seconds ]
After "laws" remaining 
Obligations:

[serial 2739]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 2733]



[serial 2741]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2734]



[serial 2762]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2755]



[serial 2766]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and E_MS() >>
  What for: Associativity: (b.c).a = a.b.c [serial 2760]



[serial 2767]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and E_MS() >>
  What for: Law of And-Simplification:  P and true is P [serial 2765]


Done applying laws
step:  221
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2766]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and E_MS() >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 2760]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2772]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + Delta) and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and E_MS() >>
  What for:   normalization of [serial 2766]

. . . done Normalizing Unsolved Proof Obligations [25.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 2739]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 2733]



[serial 2741]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2734]



[serial 2762]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2755]



[serial 2767]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and E_MS() >>
  What for: Law of And-Simplification:  P and true is P [serial 2765]



[serial 2772]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + Delta) and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and E_MS() >>
  What for:   normalization of [serial 2766]


Done Normalizing
step:  222
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 2739]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 2733]

Has split postcondition to get:

[serial 2775]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [367] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2739]


[serial 2776]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [368] << ACTUAL_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2739]


[serial 2777]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [368] << DESIRED_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2739]


[serial 2778]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [368] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2739]


This Proof Obligation:

[serial 2762]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 2755]

Has split postcondition to get:

[serial 2779]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2762]


[serial 2780]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [382] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2762]


[serial 2781]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [381] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2762]


[serial 2782]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [380] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2762]


This Proof Obligation:

[serial 2767]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and E_MS() >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for: Law of And-Simplification:  P and true is P [serial 2765]

Has split postcondition to get:

[serial 2783]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [1] << 0 <= DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]


[serial 2784]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [372] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]


[serial 2785]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [1] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]


[serial 2786]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [371] << AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]


[serial 2787]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [370] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]


This Proof Obligation:

[serial 2772]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + Delta) and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and E_MS() >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 2766]

Has split postcondition to get:

[serial 2788]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]


[serial 2789]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]


[serial 2790]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]


[serial 2791]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [377] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]


[serial 2792]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [375] << Delta =  -#PCS::MaxStepsUp >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]


[serial 2793]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [376] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]

. . . done splitting postcondition  [25.3 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 2741]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2734]



[serial 2775]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [367] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2739]



[serial 2776]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [368] << ACTUAL_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2739]



[serial 2777]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [368] << DESIRED_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2739]



[serial 2778]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [368] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2739]



[serial 2779]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2762]



[serial 2780]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [382] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2762]



[serial 2781]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [381] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2762]



[serial 2782]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [380] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2762]



[serial 2783]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [1] << 0 <= DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]



[serial 2784]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [372] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]



[serial 2785]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [1] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]



[serial 2786]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [371] << AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]



[serial 2787]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [370] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]



[serial 2788]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]



[serial 2789]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]



[serial 2790]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]



[serial 2791]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [377] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]



[serial 2792]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [375] << Delta =  -#PCS::MaxStepsUp >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]



[serial 2793]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [376] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]


Done splitting postcondition
step:  223
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2776]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [368] << ACTUAL_IN_RANGE() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2739]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2777]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [368] << DESIRED_IN_RANGE() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2739]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2778]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [368] << E_MS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2739]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2785]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [1] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2787]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [370] << E_MS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2792]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [375] << Delta =  -#PCS::MaxStepsUp >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2793]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [376] << E_MS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [25.4 seconds ]
After "axioms" remaining 
Obligations:

[serial 2741]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2734]



[serial 2775]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [367] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2739]



[serial 2779]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2762]



[serial 2780]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [382] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2762]



[serial 2781]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [381] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2762]



[serial 2782]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [380] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2762]



[serial 2783]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [1] << 0 <= DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]



[serial 2784]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [372] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]



[serial 2786]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [371] << AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]



[serial 2788]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]



[serial 2789]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]



[serial 2790]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]



[serial 2791]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [377] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]


Done trying to apply axioms
step:  224
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  225
****make-an****
Making obligation 77
Obligations:

[serial 2741]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2734]


Done making obligation 77
step:  226
#[serial 1512]   normalization of [serial 1505]
step:  227
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2741]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 2734]

Has substituted Assertions' predicates for labels to get:

[serial 2794]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels in postconditions [serial 2741]

. . . done Substituting Assertions for Labels [25.4 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 2794]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels in postconditions [serial 2741]


Done substituting Assertion labels in postconditions.
step:  228
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2794]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in postconditions [serial 2741]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2796]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
  What for:   normalization of [serial 2794]

. . . done Normalizing Unsolved Proof Obligations [25.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 2796]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
  What for:   normalization of [serial 2794]


Done Normalizing
step:  229
****completely distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2796]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2794]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2798]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [294]->
Q [15] << ((Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2796]

. . . done spltting timed atoms  [25.4 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [25.4 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2798]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [294]->
Q [15] << ((Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2796]

  Normalization Axioms:

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2800]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
  What for:   normalization of [serial 2798]

. . . done Normalizing Unsolved Proof Obligations [25.4 seconds ]
After "completely distribute ^ and @" round 0 remaining 
Obligations:

[serial 2800]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
  What for:   normalization of [serial 2798]


Done completely distributing ^ and @, round 0.
Distributing carets . .

This Proof Obligation:

[serial 2800]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2798]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2802]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2800]

. . . done spltting timed atoms  [25.4 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [25.4 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2802]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2800]

  Normalization Axioms:

    Literal Arithmetic

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2804]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for:   normalization of [serial 2802]

. . . done Normalizing Unsolved Proof Obligations [25.4 seconds ]
After "completely distribute ^ and @" round 1 remaining 
Obligations:

[serial 2804]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for:   normalization of [serial 2802]


Done completely distributing ^ and @, round 1.
Distributing carets . .

This Proof Obligation:

[serial 2804]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2802]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2806]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) and 
(((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2804]

. . . done spltting timed atoms  [25.4 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [25.4 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2806]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) and 
(((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1)) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2804]

  Normalization Axioms:

    Literal Arithmetic

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Constants are always the same
Has been normalized to get:

[serial 2808]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 2806]

. . . done Normalizing Unsolved Proof Obligations [25.4 seconds ]
After "completely distribute ^ and @" round 2 remaining 
Obligations:

[serial 2808]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 2806]


Done completely distributing ^ and @, round 2.
Distributing carets . .

This Proof Obligation:

[serial 2808]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2806]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2810]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2808]

. . . done spltting timed atoms  [25.4 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [25.4 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [25.4 seconds ]
After "completely distribute ^ and @" round 3 remaining 
Obligations:

[serial 2810]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2808]


Done completely distributing ^ and @, round 3.
Distributing carets . .
. . . done spltting timed atoms  [25.4 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [25.4 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [25.4 seconds ]
step:  230
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2810]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2808]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2813]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2810]

. . . done Applying Laws [25.4 seconds ]
After "laws" remaining 
Obligations:

[serial 2813]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2810]


Done applying laws
step:  231
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2813]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  Identity (id):  P->P is tautology
  What for: Associativity: (b.c).a = a.b.c [serial 2810]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [25.4 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2775]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [367] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2739]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  232
#[serial 1546] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1510]
step:  233
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2775]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [367] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2739]

Has substituted Assertions' predicates for labels to get:

[serial 2814]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [298]->
Q [367] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2775]

. . . done Substituting Assertions for Labels [25.4 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 2814]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [298]->
Q [367] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2775]


Done substituting Assertion labels in preconditions
step:  234
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2814]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [298]->
Q [367] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2775]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2816]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) >>
S [298]->
Q [367] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2814]

. . . done Normalizing Unsolved Proof Obligations [25.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 2816]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) >>
S [298]->
Q [367] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2814]


Done Normalizing
step:  235
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2816]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) >>
S [298]->
Q [367] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2814]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2818]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [367] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2816]

. . . done Applying Laws [25.5 seconds ]
After "laws" remaining 
Obligations:

[serial 2818]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [367] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2816]


Done applying laws
step:  236
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2818]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [367] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 2816]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2820]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [367] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2818]

. . . done Normalizing Unsolved Proof Obligations [25.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 2820]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [367] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2818]


Done Normalizing
step:  237
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION" . . .
equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 2820]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [367] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 2818]

Has substituted 
"ACTUAL_POSITION" with its = "EstimatedActualPosition"
 to get:

[serial 2822]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [367] << DESIRED_POSITION <= (EstimatedActualPosition - #PCS::MaxStepsUp) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 2820]

. . . done guided substitution of equals  [25.5 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2822]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [367] << DESIRED_POSITION <= (EstimatedActualPosition - #PCS::MaxStepsUp) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 2820]


Done guided substituting an equals
step:  238
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 2822]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [367] << DESIRED_POSITION <= (EstimatedActualPosition - #PCS::MaxStepsUp) >>
Reason:  Assume Present:  P = P@now = P^0 
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 2820]

Has applied Assume Present:  P = P@now = P^0  to get:

[serial 2823]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (EstimatedActualPosition - #PCS::MaxStepsUp) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [367] << DESIRED_POSITION <= (EstimatedActualPosition - #PCS::MaxStepsUp) >>
  What for: Assume Present:  P = P@now = P^0  [serial 2822]

. . . done replacing P@now and P^0 with P  [25.5 seconds ]
After assuming present remaining 
Obligations:

[serial 2823]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (EstimatedActualPosition - #PCS::MaxStepsUp) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [367] << DESIRED_POSITION <= (EstimatedActualPosition - #PCS::MaxStepsUp) >>
  What for: Assume Present:  P = P@now = P^0  [serial 2822]


Done assuming present.
step:  239
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2823]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (EstimatedActualPosition - #PCS::MaxStepsUp) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298]->
Q [367] << DESIRED_POSITION <= (EstimatedActualPosition - #PCS::MaxStepsUp) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Assume Present:  P = P@now = P^0  [serial 2822]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [25.5 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2779]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2762]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  240
#[serial 1550] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1533]
step:  241
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  (ACTUAL_POSITION + Delta) = ACTUAL_POSITION'

This Proof Obligation:

[serial 2779]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [1] << 0 <= ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2762]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 2824]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2779]

. . . done guided substitution of equals  [25.5 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2824]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2779]


Done guided substituting an equals
step:  242
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2824]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2779]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2826]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2824]

. . . done Normalizing Unsolved Proof Obligations [25.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 2826]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2824]


Done Normalizing
step:  243
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2826]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 2824]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [25.5 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2780]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [382] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2762]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  244
#[serial 1551] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1533]
step:  245
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  (ACTUAL_POSITION + Delta) = ACTUAL_POSITION'

This Proof Obligation:

[serial 2780]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [382] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2762]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 2828]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [382] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2780]

. . . done guided substitution of equals  [25.5 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2828]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [382] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2780]


Done guided substituting an equals
step:  246
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2828]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [382] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2780]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2830]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [382] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2828]

. . . done Normalizing Unsolved Proof Obligations [25.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 2830]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [382] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2828]


Done Normalizing
step:  247
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2830]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [382] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 2828]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [25.5 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2781]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [381] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2762]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  248
#[serial 1552] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1533]
step:  249
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  (ACTUAL_POSITION + Delta) = ACTUAL_POSITION'

This Proof Obligation:

[serial 2781]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [381] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2762]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 2832]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [381] << Delta = (((ACTUAL_POSITION + Delta)) - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2781]

. . . done guided substitution of equals  [25.5 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2832]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [381] << Delta = (((ACTUAL_POSITION + Delta)) - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2781]


Done guided substituting an equals
step:  250
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2832]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [381] << Delta = (((ACTUAL_POSITION + Delta)) - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2781]

  Normalization Axioms:

    Subtaction of Added Value:  (a+b)-a is b

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2834]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [381] << Delta = Delta >>
  What for:   normalization of [serial 2832]

. . . done Normalizing Unsolved Proof Obligations [25.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 2834]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [381] << Delta = Delta >>
  What for:   normalization of [serial 2832]


Done Normalizing
step:  251
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2834]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [381] << Delta = Delta >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 2832]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 2836]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [381] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 2834]

. . . done Applying Laws [25.5 seconds ]
After "laws" remaining 
Obligations:

[serial 2836]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [381] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 2834]


Done applying laws
step:  252
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2836]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [381] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 2834]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [25.5 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2782]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [380] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2762]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  253
#[serial 1553] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1533]
step:  254
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2782]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379]->
Q [380] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2762]

Has substituted Assertions' predicates for labels to get:

[serial 2837]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [379]->
Q [380] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2782]

. . . done Substituting Assertions for Labels [25.5 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 2837]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [379]->
Q [380] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2782]


Done substituting Assertion labels in preconditions
step:  255
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2837]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [379]->
Q [380] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2782]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2839]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [379]->
Q [380] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2837]

. . . done Normalizing Unsolved Proof Obligations [25.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 2839]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [379]->
Q [380] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2837]


Done Normalizing
step:  256
****guided-sub-equals****
guided substitution of equals "EstimatedActualPosition" . . .
equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 2839]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [379]->
Q [380] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 2837]

Has substituted 
"EstimatedActualPosition" with its = "ACTUAL_POSITION"
 to get:

[serial 2841]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [379]->
Q [380] << (Delta + ACTUAL_POSITION) = ACTUAL_POSITION' >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 2839]

. . . done guided substitution of equals  [25.5 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2841]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [379]->
Q [380] << (Delta + ACTUAL_POSITION) = ACTUAL_POSITION' >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 2839]


Done guided substituting an equals
step:  257
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2841]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [379]->
Q [380] << (Delta + ACTUAL_POSITION) = ACTUAL_POSITION' >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 2839]

  Normalization Axiom:

    Reflexivity of Addition: a+b=b+a
Has been normalized to get:

[serial 2843]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [379]->
Q [380] << (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2841]

. . . done Normalizing Unsolved Proof Obligations [25.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 2843]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [379]->
Q [380] << (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2841]


Done Normalizing
step:  258
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2843]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [379]->
Q [380] << (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 2841]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [25.5 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2783]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [1] << 0 <= DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  259
#[serial 1554] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1538]
step:  260
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2783]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [1] << 0 <= DESIRED_POSITION >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]

Has substituted Assertions' predicates for labels to get:

[serial 2845]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [369]->
Q [1] << 0 <= DESIRED_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2783]

. . . done Substituting Assertions for Labels [25.5 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 2845]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [369]->
Q [1] << 0 <= DESIRED_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2783]


Done substituting Assertion labels in preconditions
step:  261
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2845]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [369]->
Q [1] << 0 <= DESIRED_POSITION >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2783]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2847]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [369]->
Q [1] << 0 <= DESIRED_POSITION >>
  What for:   normalization of [serial 2845]

. . . done Normalizing Unsolved Proof Obligations [25.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 2847]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [369]->
Q [1] << 0 <= DESIRED_POSITION >>
  What for:   normalization of [serial 2845]


Done Normalizing
step:  262
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2847]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [369]->
Q [1] << 0 <= DESIRED_POSITION >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2845]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2849]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [369]->
Q [1] << 0 <= DESIRED_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 2847]

. . . done Applying Laws [25.5 seconds ]
After "laws" remaining 
Obligations:

[serial 2849]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [369]->
Q [1] << 0 <= DESIRED_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 2847]


Done applying laws
step:  263
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2849]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [369]->
Q [1] << 0 <= DESIRED_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Associativity: (b.c).a = a.b.c [serial 2847]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [25.5 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2784]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [372] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  264
#[serial 1555] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1538]
step:  265
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2784]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [372] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]

Has substituted Assertions' predicates for labels to get:

[serial 2850]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [369]->
Q [372] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2784]

. . . done Substituting Assertions for Labels [25.5 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 2850]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [369]->
Q [372] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2784]


Done substituting Assertion labels in preconditions
step:  266
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2850]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [369]->
Q [372] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2784]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2852]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [369]->
Q [372] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2850]

. . . done Normalizing Unsolved Proof Obligations [25.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2852]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [369]->
Q [372] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2850]


Done Normalizing
step:  267
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2852]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [369]->
Q [372] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2850]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2854]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [369]->
Q [372] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 2852]

. . . done Applying Laws [25.6 seconds ]
After "laws" remaining 
Obligations:

[serial 2854]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [369]->
Q [372] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 2852]


Done applying laws
step:  268
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2854]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [369]->
Q [372] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 2852]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2856]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [369]->
Q [372] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2854]

. . . done Normalizing Unsolved Proof Obligations [25.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2856]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [369]->
Q [372] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2854]


Done Normalizing
step:  269
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2856]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [369]->
Q [372] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 2854]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [25.6 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2786]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [371] << AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  270
#[serial 1557] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1538]
step:  271
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 2786]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [371] << AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) >>
Reason:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]

has been transformed into:

[serial 2858]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [371] << true >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


by removing axioms from postconditions.

. . . done removing axioms from postconditions  [25.6 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 2858]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [371] << true >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 



Done removing axioms from postconditions
step:  272
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2858]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369]->
Q [371] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [25.6 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2788]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  273
#[serial 1559] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1543]
step:  274
****guided-sub-equals****
guided substitution of equals "Delta" . . .
equality selected for substitution:  Delta =  -#PCS::MaxStepsUp

This Proof Obligation:

[serial 2788]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]

Has substituted 
"Delta" with its = "(-#PCS::MaxStepsUp)"
 to get:

[serial 2859]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + ( -#PCS::MaxStepsUp)) >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "(-#PCS::MaxStepsUp)" in its postcondition [serial 2788]

. . . done guided substitution of equals  [25.6 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2859]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + ( -#PCS::MaxStepsUp)) >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "(-#PCS::MaxStepsUp)" in its postcondition [serial 2788]


Done guided substituting an equals
step:  275
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  0 <= DESIRED_POSITION and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) -> 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp)

This Proof Obligation:

[serial 2859]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + ( -#PCS::MaxStepsUp)) >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "(-#PCS::MaxStepsUp)" in its postcondition [serial 2788]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 2860]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + ( -#PCS::MaxStepsUp)) >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2859]

. . . done adding transitive terms [25.6 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 2860]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + ( -#PCS::MaxStepsUp)) >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2859]


Done adding transitive relations
step:  276
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2860]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + ( -#PCS::MaxStepsUp)) >>
Reason:  Normalization
  What for: Transitivity: x<y and y<z -> x<z [serial 2859]

  Normalization Axioms:

    Reflexivity of Conjunction: (m and k) = (k and m)

    Associativity: (b.c).a = a.b.c
Has been normalized to get:

[serial 2862]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2860]

. . . done Normalizing Unsolved Proof Obligations [25.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2862]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2860]


Done Normalizing
step:  277
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2862]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 2860]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [25.6 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2789]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  278
#[serial 1560] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1543]
step:  279
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2789]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]

Has substituted Assertions' predicates for labels to get:

[serial 2864]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and ((ACTUAL_POSITION > (ACTUAL_POSITION - (#PCS::MaxStepsUp))) and 
((#PCS::MaxStepsUp) > 0)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2789]

. . . done Substituting Assertions for Labels [25.6 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 2864]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and ((ACTUAL_POSITION > (ACTUAL_POSITION - (#PCS::MaxStepsUp))) and 
((#PCS::MaxStepsUp) > 0)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2789]


Done substituting Assertion labels in preconditions
step:  280
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2864]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and ((ACTUAL_POSITION > (ACTUAL_POSITION - (#PCS::MaxStepsUp))) and 
((#PCS::MaxStepsUp) > 0)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2789]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2866]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
(0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION) >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2864]

. . . done Normalizing Unsolved Proof Obligations [25.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2866]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
(0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION) >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2864]


Done Normalizing
step:  281
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2866]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
(0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION) >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2864]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2868]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and 
0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2866]

. . . done Applying Laws [25.6 seconds ]
After "laws" remaining 
Obligations:

[serial 2868]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and 
0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2866]


Done applying laws
step:  282
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2868]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and 
0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 2866]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2870]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2868]

. . . done Normalizing Unsolved Proof Obligations [25.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2870]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 2868]


Done Normalizing
step:  283
****guided-sub-equals****
guided substitution of equals "Delta" . . .
equality selected for substitution:  Delta =  -#PCS::MaxStepsUp

This Proof Obligation:

[serial 2870]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 2868]

Has substituted 
"Delta" with its = "(-#PCS::MaxStepsUp)"
 to get:

[serial 2872]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + ( -#PCS::MaxStepsUp)) >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "(-#PCS::MaxStepsUp)" in its postcondition [serial 2870]

. . . done guided substitution of equals  [25.6 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2872]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + ( -#PCS::MaxStepsUp)) >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "(-#PCS::MaxStepsUp)" in its postcondition [serial 2870]


Done guided substituting an equals
step:  284
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2872]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION + ( -#PCS::MaxStepsUp)) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "(-#PCS::MaxStepsUp)" in its postcondition [serial 2870]

  Normalization Axiom:

    Associativity: (b.c).a = a.b.c
Has been normalized to get:

[serial 2874]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2872]

. . . done Normalizing Unsolved Proof Obligations [25.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2874]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2872]


Done Normalizing
step:  285
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  0 <= DESIRED_POSITION and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) -> 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp)
Transitivity:  (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition -> (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition
Transitivity:  DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION -> DESIRED_POSITION < ACTUAL_POSITION
Transitivity:  DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition -> DESIRED_POSITION < #PCS::MaxPosition
Transitivity:  0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION -> 0 < ACTUAL_POSITION
Transitivity:  0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition -> 0 < #PCS::MaxPosition

This Proof Obligation:

[serial 2874]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for:   normalization of [serial 2872]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 2876]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and 
0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2874]

. . . done adding transitive terms [25.6 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 2876]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and 
0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2874]


Done adding transitive relations
step:  286
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2876]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and 
0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition >>
S [374]->
Q [1] << 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Transitivity: x<y and y<z -> x<z [serial 2874]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [25.6 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2790]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  287
#[serial 1561] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1543]
step:  288
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2790]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]

Has substituted Assertions' predicates for labels to get:

[serial 2877]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and ((ACTUAL_POSITION > (ACTUAL_POSITION - (#PCS::MaxStepsUp))) and 
((#PCS::MaxStepsUp) > 0)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [374]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2790]

. . . done Substituting Assertions for Labels [25.6 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 2877]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and ((ACTUAL_POSITION > (ACTUAL_POSITION - (#PCS::MaxStepsUp))) and 
((#PCS::MaxStepsUp) > 0)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [374]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2790]


Done substituting Assertion labels in preconditions
step:  289
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2877]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and ((ACTUAL_POSITION > (ACTUAL_POSITION - (#PCS::MaxStepsUp))) and 
((#PCS::MaxStepsUp) > 0)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [374]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2790]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2879]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
(0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION) >>
S [374]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2877]

. . . done Normalizing Unsolved Proof Obligations [25.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2879]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
(0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION) >>
S [374]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2877]


Done Normalizing
step:  290
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2879]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
(0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION) >>
S [374]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2877]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2881]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and 
0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp >>
S [374]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 2879]

. . . done Applying Laws [25.6 seconds ]
After "laws" remaining 
Obligations:

[serial 2881]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and 
0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp >>
S [374]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 2879]


Done applying laws
step:  291
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2881]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and 
0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp >>
S [374]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 2879]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2883]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2881]

. . . done Normalizing Unsolved Proof Obligations [25.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2883]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2881]


Done Normalizing
step:  292
****guided-sub-equals****
guided substitution of equals "Delta" . . .
equality selected for substitution:  Delta =  -#PCS::MaxStepsUp

This Proof Obligation:

[serial 2883]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 2881]

Has substituted 
"Delta" with its = "(-#PCS::MaxStepsUp)"
 to get:

[serial 2885]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374]->
Q [130] << (ACTUAL_POSITION + ( -#PCS::MaxStepsUp)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "(-#PCS::MaxStepsUp)" in its postcondition [serial 2883]

. . . done guided substitution of equals  [25.6 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2885]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374]->
Q [130] << (ACTUAL_POSITION + ( -#PCS::MaxStepsUp)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "(-#PCS::MaxStepsUp)" in its postcondition [serial 2883]


Done guided substituting an equals
step:  293
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2885]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374]->
Q [130] << (ACTUAL_POSITION + ( -#PCS::MaxStepsUp)) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "(-#PCS::MaxStepsUp)" in its postcondition [serial 2883]

  Normalization Axiom:

    Associativity: (b.c).a = a.b.c
Has been normalized to get:

[serial 2887]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374]->
Q [130] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2885]

. . . done Normalizing Unsolved Proof Obligations [25.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 2887]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374]->
Q [130] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2885]


Done Normalizing
step:  294
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  0 <= DESIRED_POSITION and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) -> 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp)
Transitivity:  (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition -> (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition
Transitivity:  DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION -> DESIRED_POSITION < ACTUAL_POSITION
Transitivity:  DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition -> DESIRED_POSITION < #PCS::MaxPosition
Transitivity:  0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION -> 0 < ACTUAL_POSITION
Transitivity:  0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition -> 0 < #PCS::MaxPosition

This Proof Obligation:

[serial 2887]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374]->
Q [130] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for:   normalization of [serial 2885]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 2889]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and 
0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition >>
S [374]->
Q [130] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2887]

. . . done adding transitive terms [25.6 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 2889]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and 
0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition >>
S [374]->
Q [130] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2887]


Done adding transitive relations
step:  295
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2889]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and 
0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition >>
S [374]->
Q [130] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Transitivity: x<y and y<z -> x<z [serial 2887]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2891]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 0 < #PCS::MaxStepsUp and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition >>
S [374]->
Q [130] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2889]

. . . done Normalizing Unsolved Proof Obligations [25.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 2891]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 0 < #PCS::MaxStepsUp and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition >>
S [374]->
Q [130] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2889]


Done Normalizing
step:  296
****partial to total order****
Making partial orders into total orders . . .
Making partial orders into total orders . . .

This Proof Obligation:

[serial 2891]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 0 < #PCS::MaxStepsUp and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition >>
S [374]->
Q [130] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
Reason:  Partial Order Law 3:  a <= (b-1)  is  a<b
  What for:   normalization of [serial 2889]

Has applied Partial Order Law 3:  a <= (b-1)  is  a<b ((ACTUAL_POSITION - #PCS::MaxStepsUp)<#PCS::MaxPosition  ->  (ACTUAL_POSITION - #PCS::MaxStepsUp)<=#PCS::MaxPosition
  ) to get:

[serial 2893]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 0 < #PCS::MaxStepsUp and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
S [374]->
Q [130] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for: (ACTUAL_POSITION - #PCS::MaxStepsUp)<#PCS::MaxPosition  ->  (ACTUAL_POSITION - #PCS::MaxStepsUp)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2891]

. . . done making partial orders into total orders [25.7 seconds ]
After making partial orders into total orders 
Obligations:

[serial 2893]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 0 < #PCS::MaxStepsUp and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
S [374]->
Q [130] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for: (ACTUAL_POSITION - #PCS::MaxStepsUp)<#PCS::MaxPosition  ->  (ACTUAL_POSITION - #PCS::MaxStepsUp)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2891]


Done making partial orders into total orders
step:  297
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2893]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 0 < #PCS::MaxStepsUp and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
S [374]->
Q [130] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: (ACTUAL_POSITION - #PCS::MaxStepsUp)<#PCS::MaxPosition  ->  (ACTUAL_POSITION - #PCS::MaxStepsUp)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2891]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [25.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2791]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [377] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  298
#[serial 1562] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1543]
step:  299
****guided-sub-equals****
guided substitution of equals "Delta" . . .
equality selected for substitution:  Delta =  -#PCS::MaxStepsUp

This Proof Obligation:

[serial 2791]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [377] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]

Has substituted 
"Delta" with its = "(-#PCS::MaxStepsUp)"
 to get:

[serial 2894]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [377] << (ACTUAL_POSITION + ( -#PCS::MaxStepsUp)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "(-#PCS::MaxStepsUp)" in its postcondition [serial 2791]

. . . done guided substitution of equals  [25.7 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 2894]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [377] << (ACTUAL_POSITION + ( -#PCS::MaxStepsUp)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "(-#PCS::MaxStepsUp)" in its postcondition [serial 2791]


Done guided substituting an equals
step:  300
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2894]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [377] << (ACTUAL_POSITION + ( -#PCS::MaxStepsUp)) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "(-#PCS::MaxStepsUp)" in its postcondition [serial 2791]

  Normalization Axiom:

    Associativity: (b.c).a = a.b.c
Has been normalized to get:

[serial 2896]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2894]

. . . done Normalizing Unsolved Proof Obligations [25.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 2896]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2894]


Done Normalizing
step:  301
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  0 <= DESIRED_POSITION and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) -> 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp)

This Proof Obligation:

[serial 2896]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for:   normalization of [serial 2894]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 2898]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2896]

. . . done adding transitive terms [25.7 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 2898]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2896]


Done adding transitive relations
step:  302
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2898]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Transitivity: x<y and y<z -> x<z [serial 2896]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2900]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2898]

. . . done Normalizing Unsolved Proof Obligations [25.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 2900]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2898]


Done Normalizing
step:  303
****partial to total order****
Making partial orders into total orders . . .
Making partial orders into total orders . . .
. . . done making partial orders into total orders [25.7 seconds ]
After making partial orders into total orders, no change. 
step:  304
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2900]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 2898]

Has substituted Assertions' predicates for labels to get:

[serial 2902]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and ((ACTUAL_POSITION > (ACTUAL_POSITION - (#PCS::MaxStepsUp))) and 
((#PCS::MaxStepsUp) > 0)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2900]

. . . done Substituting Assertions for Labels [25.7 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 2902]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and ((ACTUAL_POSITION > (ACTUAL_POSITION - (#PCS::MaxStepsUp))) and 
((#PCS::MaxStepsUp) > 0)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2900]


Done substituting Assertion labels in preconditions
step:  305
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2902]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and ((ACTUAL_POSITION > (ACTUAL_POSITION - (#PCS::MaxStepsUp))) and 
((#PCS::MaxStepsUp) > 0)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2900]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2904]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
(0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION) >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2902]

. . . done Normalizing Unsolved Proof Obligations [25.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 2904]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
(0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION) >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2902]


Done Normalizing
step:  306
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2904]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
(0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION) >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2902]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2906]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and 
0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 2904]

. . . done Applying Laws [25.7 seconds ]
After "laws" remaining 
Obligations:

[serial 2906]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and 
0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 2904]


Done applying laws
step:  307
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2906]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and 
0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 2904]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2908]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2906]

. . . done Normalizing Unsolved Proof Obligations [25.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 2908]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2906]


Done Normalizing
step:  308
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION -> 0 < ACTUAL_POSITION
Transitivity:  (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition -> (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition
Transitivity:  0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition -> 0 < #PCS::MaxPosition
Transitivity:  DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION -> DESIRED_POSITION < ACTUAL_POSITION
Transitivity:  DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition -> DESIRED_POSITION < #PCS::MaxPosition

This Proof Obligation:

[serial 2908]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for:   normalization of [serial 2906]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 2910]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition and 
0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2908]

. . . done adding transitive terms [25.7 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 2910]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition and 
0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for: Transitivity: x<y and y<z -> x<z [serial 2908]


Done adding transitive relations
step:  309
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2910]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition and 
0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Transitivity: x<y and y<z -> x<z [serial 2908]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2912]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 0 < #PCS::MaxStepsUp and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2910]

. . . done Normalizing Unsolved Proof Obligations [25.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 2912]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 0 < #PCS::MaxStepsUp and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 2910]


Done Normalizing
step:  310
****partial to total order****
Making partial orders into total orders . . .
Making partial orders into total orders . . .

This Proof Obligation:

[serial 2912]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 0 < #PCS::MaxStepsUp and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
Reason:  Partial Order Law 3:  a <= (b-1)  is  a<b
  What for:   normalization of [serial 2910]

Has applied Partial Order Law 3:  a <= (b-1)  is  a<b ((ACTUAL_POSITION - #PCS::MaxStepsUp)<#PCS::MaxPosition  ->  (ACTUAL_POSITION - #PCS::MaxStepsUp)<=#PCS::MaxPosition
  ) to get:

[serial 2914]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 0 < #PCS::MaxStepsUp and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for: (ACTUAL_POSITION - #PCS::MaxStepsUp)<#PCS::MaxPosition  ->  (ACTUAL_POSITION - #PCS::MaxStepsUp)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2912]

. . . done making partial orders into total orders [25.7 seconds ]
After making partial orders into total orders 
Obligations:

[serial 2914]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 0 < #PCS::MaxStepsUp and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
  What for: (ACTUAL_POSITION - #PCS::MaxStepsUp)<#PCS::MaxPosition  ->  (ACTUAL_POSITION - #PCS::MaxStepsUp)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2912]


Done making partial orders into total orders
step:  311
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2914]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 0 < #PCS::MaxStepsUp and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
S [374]->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: (ACTUAL_POSITION - #PCS::MaxStepsUp)<#PCS::MaxPosition  ->  (ACTUAL_POSITION - #PCS::MaxStepsUp)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2912]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [25.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1036]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition < (DESIRED_POSITION)^0)) and 
(((EstimatedActualPosition + #PCS::MaxStepsUp) > (DESIRED_POSITION)^0)))) >>
S [387]<< (((ACTUAL_POSITION + #PCS::MaxStepsUp) > DESIRED_POSITION) and (ACTUAL_POSITION < DESIRED_POSITION) and E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Delta := (DesiredPosition? - EstimatedActualPosition)
<< (E_MS() and (DESIRED_POSITION = (ACTUAL_POSITION + Delta)) and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and (ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(z:ACTUAL_POSITION,k:Delta) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and (ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition + Delta)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for ms5od:Decide-[x]->Run{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  312
#[serial 1036]  <<M(Decide) and x>> A <<M(Run)>> for ms5od:Decide-[x]->Run{A};
step:  313
****reduce****
This proof obligation:

[serial 1036]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition < (DESIRED_POSITION)^0)) and 
(((EstimatedActualPosition + #PCS::MaxStepsUp) > (DESIRED_POSITION)^0)))) >>
S [387]<< (((ACTUAL_POSITION + #PCS::MaxStepsUp) > DESIRED_POSITION) and (ACTUAL_POSITION < DESIRED_POSITION) and E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Delta := (DesiredPosition? - EstimatedActualPosition)
<< (E_MS() and (DESIRED_POSITION = (ACTUAL_POSITION + Delta)) and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and (ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(z:ACTUAL_POSITION,k:Delta) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and (ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition + Delta)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for ms5od:Decide-[x]->Run{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P2>> S2 <<Q2>>
 
was reduced to:

[serial 2915]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition < (DESIRED_POSITION)^0)) and 
(((EstimatedActualPosition + #PCS::MaxStepsUp) > (DESIRED_POSITION)^0)))) >>
S [298]->
Q [15] << (((ACTUAL_POSITION + #PCS::MaxStepsUp) > DESIRED_POSITION) and (ACTUAL_POSITION < DESIRED_POSITION) and 
E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
  What for: P -> P1 in sequential composition for [serial 1036]


[serial 2916]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [294]->
Q [15] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 1036]


[serial 2917]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (((ACTUAL_POSITION + #PCS::MaxStepsUp) > DESIRED_POSITION) and (ACTUAL_POSITION < DESIRED_POSITION) and 
E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
S [390]Delta := (DesiredPosition? - EstimatedActualPosition)
Q [15] << (E_MS() and (DESIRED_POSITION = (ACTUAL_POSITION + Delta)) and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and 
(ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(
z:ACTUAL_POSITION,k:Delta) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1036]


[serial 2918]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (E_MS() and (DESIRED_POSITION = (ACTUAL_POSITION + Delta)) and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and 
(ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(
z:ACTUAL_POSITION,k:Delta) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
S [397]ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and 
(ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1036]


[serial 2919]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and 
(ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
S [402]EstimatedActualPosition' := (EstimatedActualPosition + Delta)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1036]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 2915]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition < (DESIRED_POSITION)^0)) and 
(((EstimatedActualPosition + #PCS::MaxStepsUp) > (DESIRED_POSITION)^0)))) >>
S [298]->
Q [15] << (((ACTUAL_POSITION + #PCS::MaxStepsUp) > DESIRED_POSITION) and (ACTUAL_POSITION < DESIRED_POSITION) and 
E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
  What for: P -> P1 in sequential composition for [serial 1036]



[serial 2916]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [294]->
Q [15] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 1036]



[serial 2917]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (((ACTUAL_POSITION + #PCS::MaxStepsUp) > DESIRED_POSITION) and (ACTUAL_POSITION < DESIRED_POSITION) and 
E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
S [390]Delta := (DesiredPosition? - EstimatedActualPosition)
Q [15] << (E_MS() and (DESIRED_POSITION = (ACTUAL_POSITION + Delta)) and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and 
(ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(
z:ACTUAL_POSITION,k:Delta) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1036]



[serial 2918]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (E_MS() and (DESIRED_POSITION = (ACTUAL_POSITION + Delta)) and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and 
(ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(
z:ACTUAL_POSITION,k:Delta) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
S [397]ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and 
(ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1036]



[serial 2919]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and 
(ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
S [402]EstimatedActualPosition' := (EstimatedActualPosition + Delta)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1036]


done reducing composite actions
step:  314
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2915]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition < (DESIRED_POSITION)^0)) and 
(((EstimatedActualPosition + #PCS::MaxStepsUp) > (DESIRED_POSITION)^0)))) >>
S [298]->
Q [15] << (((ACTUAL_POSITION + #PCS::MaxStepsUp) > DESIRED_POSITION) and (ACTUAL_POSITION < DESIRED_POSITION) and 
E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Reason:  Normalization
  What for: P -> P1 in sequential composition for [serial 1036]

  Normalization Axioms:

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2921]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and (DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0) >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2915]


This Proof Obligation:

[serial 2916]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [294]->
Q [15] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
Reason:  Normalization
  What for: Q2 -> Q in sequential composition for [serial 1036]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2923]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2916]


This Proof Obligation:

[serial 2917]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (((ACTUAL_POSITION + #PCS::MaxStepsUp) > DESIRED_POSITION) and (ACTUAL_POSITION < DESIRED_POSITION) and 
E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
S [390]Delta := (DesiredPosition? - EstimatedActualPosition)
Q [15] << (E_MS() and (DESIRED_POSITION = (ACTUAL_POSITION + Delta)) and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and 
(ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(
z:ACTUAL_POSITION,k:Delta) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1036]

  Normalization Axioms:

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2925]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]Delta := (DesiredPosition? - EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
  What for:   normalization of [serial 2917]


This Proof Obligation:

[serial 2918]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (E_MS() and (DESIRED_POSITION = (ACTUAL_POSITION + Delta)) and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and 
(ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(
z:ACTUAL_POSITION,k:Delta) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
S [397]ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and 
(ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1036]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2927]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]ActuatorCommand(pc:Delta)
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
  What for:   normalization of [serial 2918]


This Proof Obligation:

[serial 2919]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and 
(ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
S [402]EstimatedActualPosition' := (EstimatedActualPosition + Delta)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1036]

  Normalization Axioms:

    Reflexivity of Addition: a+b=b+a

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2929]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]EstimatedActualPosition' := (Delta + EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
  What for:   normalization of [serial 2919]

. . . done Normalizing Unsolved Proof Obligations [25.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2921]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and (DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0) >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2915]



[serial 2923]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2916]



[serial 2925]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]Delta := (DesiredPosition? - EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
  What for:   normalization of [serial 2917]



[serial 2927]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]ActuatorCommand(pc:Delta)
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
  What for:   normalization of [serial 2918]



[serial 2929]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]EstimatedActualPosition' := (Delta + EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
  What for:   normalization of [serial 2919]


Done Normalizing
step:  315
****atomic****
applying atomic actions . . .
solving assignment on line 390
replacing "Delta" with "((DESIRED_POSITION)^0 - EstimatedActualPosition)"
makes:  << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
(((DESIRED_POSITION)^0 - EstimatedActualPosition))) <= #PCS::MaxPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + (((DESIRED_POSITION)^0 - EstimatedActualPosition))) and 
(((DESIRED_POSITION)^0 - EstimatedActualPosition)) = (DESIRED_POSITION - ACTUAL_POSITION) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:(((DESIRED_POSITION)^0 - EstimatedActualPosition))) and 
E_MS() >>

This Proof Obligation:

[serial 2925]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]Delta := (DesiredPosition? - EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for:   normalization of [serial 2917]

Has applied := to get:

[serial 2935]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
(((DESIRED_POSITION)^0 - EstimatedActualPosition))) <= #PCS::MaxPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + (((DESIRED_POSITION)^0 - EstimatedActualPosition))) and 
(((DESIRED_POSITION)^0 - EstimatedActualPosition)) = (DESIRED_POSITION - ACTUAL_POSITION) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:(((DESIRED_POSITION)^0 - EstimatedActualPosition))) and 
E_MS() >>
  What for: applied wp for assignment [serial 2925]

Creating weakest-precondition predicate transfer for subprogram invocation of "ActuatorCommand".

This Proof Obligation:

[serial 2927]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]ActuatorCommand(pc:Delta)
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
Reason:  Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
  What for:   normalization of [serial 2918]

Used weakest precondition predicate transformation on
+ <<P>> ActuatorCommand(X) <<Q>> to get:

[serial 2936]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and 
E_MS() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2927]

solving assignment on line 402
replacing "EstimatedActualPosition'" with "(Delta + EstimatedActualPosition)"
makes:  << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>

This Proof Obligation:

[serial 2929]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]EstimatedActualPosition' := (Delta + EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for:   normalization of [serial 2919]

Has applied := to get:

[serial 2937]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
  What for: applied wp for assignment [serial 2929]

. . . done applying atomic actions [25.8 seconds ]
After "atomic" remaining 
Obligations:

[serial 2921]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and (DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0) >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2915]



[serial 2923]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2916]



[serial 2935]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
(((DESIRED_POSITION)^0 - EstimatedActualPosition))) <= #PCS::MaxPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + (((DESIRED_POSITION)^0 - EstimatedActualPosition))) and 
(((DESIRED_POSITION)^0 - EstimatedActualPosition)) = (DESIRED_POSITION - ACTUAL_POSITION) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:(((DESIRED_POSITION)^0 - EstimatedActualPosition))) and 
E_MS() >>
  What for: applied wp for assignment [serial 2925]



[serial 2936]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and 
E_MS() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2927]



[serial 2937]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
  What for: applied wp for assignment [serial 2929]


Done reducing atomic actions
step:  316
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2935]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
(((DESIRED_POSITION)^0 - EstimatedActualPosition))) <= #PCS::MaxPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + (((DESIRED_POSITION)^0 - EstimatedActualPosition))) and 
(((DESIRED_POSITION)^0 - EstimatedActualPosition)) = (DESIRED_POSITION - ACTUAL_POSITION) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:(((DESIRED_POSITION)^0 - EstimatedActualPosition))) and 
E_MS() >>
Reason:  Normalization
  What for: applied wp for assignment [serial 2925]

  Normalization Axioms:

    Reflexivity of Addition: a+b=b+a

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Associativity: (b.c).a = a.b.c
Has been normalized to get:

[serial 2941]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ((
DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition and 
DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) and 
(DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:(DESIRED_POSITION^0 - EstimatedActualPosition)) and 
E_MS() >>
  What for:   normalization of [serial 2935]


This Proof Obligation:

[serial 2936]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and 
E_MS() >>
Reason:  Normalization
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2927]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2943]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
E_MS() and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 2936]


This Proof Obligation:

[serial 2937]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
Reason:  Normalization
  What for: applied wp for assignment [serial 2929]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 2945]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2937]

. . . done Normalizing Unsolved Proof Obligations [25.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 2921]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and (DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0) >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2915]



[serial 2923]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2916]



[serial 2941]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ((
DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition and 
DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) and 
(DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:(DESIRED_POSITION^0 - EstimatedActualPosition)) and 
E_MS() >>
  What for:   normalization of [serial 2935]



[serial 2943]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
E_MS() and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 2936]



[serial 2945]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2937]


Done Normalizing
step:  317
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2921]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and (DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0) >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2915]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2949]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp) and 
EstimatedActualPosition < DESIRED_POSITION^0 and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E_MS() >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2921]


This Proof Obligation:

[serial 2943]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
E_MS() and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 2936]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 2950]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
E_MS() >>
  What for: Associativity: (b.c).a = a.b.c [serial 2943]

. . . done Applying Laws [25.9 seconds ]
After "laws" remaining 
Obligations:

[serial 2923]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2916]



[serial 2941]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ((
DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition and 
DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) and 
(DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:(DESIRED_POSITION^0 - EstimatedActualPosition)) and 
E_MS() >>
  What for:   normalization of [serial 2935]



[serial 2945]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2937]



[serial 2949]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp) and 
EstimatedActualPosition < DESIRED_POSITION^0 and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E_MS() >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2921]



[serial 2950]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
E_MS() >>
  What for: Associativity: (b.c).a = a.b.c [serial 2943]


Done applying laws
step:  318
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2949]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp) and 
EstimatedActualPosition < DESIRED_POSITION^0 and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E_MS() >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 2921]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2955]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2949]


This Proof Obligation:

[serial 2950]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
E_MS() >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 2943]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2957]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + 
Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
E_MS() >>
  What for:   normalization of [serial 2950]

. . . done Normalizing Unsolved Proof Obligations [25.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 2923]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2916]



[serial 2941]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ((
DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition and 
DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) and 
(DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:(DESIRED_POSITION^0 - EstimatedActualPosition)) and 
E_MS() >>
  What for:   normalization of [serial 2935]



[serial 2945]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2937]



[serial 2955]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2949]



[serial 2957]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + 
Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
E_MS() >>
  What for:   normalization of [serial 2950]


Done Normalizing
step:  319
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 2941]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ((
DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition and 
DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) and 
(DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:(DESIRED_POSITION^0 - EstimatedActualPosition)) and 
E_MS() >>
Reason:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
  What for:   normalization of [serial 2935]

has been transformed into:

[serial 2960]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ((
DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition and 
DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) and 
(DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) and 
true and E_MS() >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


by removing axioms from postconditions.

. . . done removing axioms from postconditions  [25.9 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 2923]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2916]



[serial 2945]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2937]



[serial 2955]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2949]



[serial 2957]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + 
Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
E_MS() >>
  What for:   normalization of [serial 2950]



[serial 2960]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ((
DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition and 
DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) and 
(DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) and 
true and E_MS() >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 



Done removing axioms from postconditions
step:  320
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2957]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + 
Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
E_MS() >>
Reason:  Law of And-Simplification:  P and P is P
  What for:   normalization of [serial 2950]

Has applied law "Law of And-Simplification:  P and P is P" to get:

[serial 2961]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
E_MS() >>
  What for: Law of And-Simplification:  P and P is P [serial 2957]


This Proof Obligation:

[serial 2960]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ((
DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition and 
DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) and 
(DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) and 
true and E_MS() >>
Reason:  Law of And-Simplification:  P and true is P
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 2962]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ((
DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition and 
DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) and 
(DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) and 
E_MS() >>
  What for: Law of And-Simplification:  P and true is P [serial 2960]

. . . done Applying Laws [25.9 seconds ]
After "laws" remaining 
Obligations:

[serial 2923]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2916]



[serial 2945]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 2937]



[serial 2955]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 2949]



[serial 2961]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
E_MS() >>
  What for: Law of And-Simplification:  P and P is P [serial 2957]



[serial 2962]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ((
DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition and 
DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) and 
(DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) and 
E_MS() >>
  What for: Law of And-Simplification:  P and true is P [serial 2960]


Done applying laws
step:  321
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 2945]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 2937]

Has split postcondition to get:

[serial 2963]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2945]


[serial 2964]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [405] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2945]


[serial 2965]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [404] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2945]


[serial 2966]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [403] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2945]


This Proof Obligation:

[serial 2955]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 2949]

Has split postcondition to get:

[serial 2967]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [389] << ACTUAL_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2955]


[serial 2968]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [389] << DESIRED_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2955]


[serial 2969]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [389] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2955]


[serial 2970]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [388] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2955]


[serial 2971]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [1] << DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2955]


This Proof Obligation:

[serial 2961]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
E_MS() >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for: Law of And-Simplification:  P and P is P [serial 2957]

Has split postcondition to get:

[serial 2972]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2961]


[serial 2973]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2961]


[serial 2974]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2961]


[serial 2975]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [399] << Delta = (DESIRED_POSITION - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2961]


[serial 2976]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [398] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2961]


This Proof Obligation:

[serial 2962]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ((
DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition and 
DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) and 
(DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) and 
E_MS() >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for: Law of And-Simplification:  P and true is P [serial 2960]

Has split postcondition to get:

[serial 2977]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]


[serial 2978]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]


[serial 2979]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [395] << ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]


[serial 2980]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]


[serial 2981]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [392] << (DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]


[serial 2982]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [391] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]

. . . done splitting postcondition  [25.9 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 2923]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2916]



[serial 2963]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2945]



[serial 2964]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [405] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2945]



[serial 2965]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [404] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2945]



[serial 2966]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [403] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2945]



[serial 2967]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [389] << ACTUAL_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2955]



[serial 2968]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [389] << DESIRED_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2955]



[serial 2969]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [389] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2955]



[serial 2970]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [388] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2955]



[serial 2971]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [1] << DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2955]



[serial 2972]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2961]



[serial 2973]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2961]



[serial 2974]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2961]



[serial 2975]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [399] << Delta = (DESIRED_POSITION - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2961]



[serial 2976]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [398] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2961]



[serial 2977]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]



[serial 2978]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]



[serial 2979]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [395] << ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]



[serial 2980]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]



[serial 2981]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [392] << (DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]



[serial 2982]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [391] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]


Done splitting postcondition
step:  322
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 2967]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [389] << ACTUAL_IN_RANGE() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2955]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2968]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [389] << DESIRED_IN_RANGE() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2955]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2969]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [389] << E_MS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2955]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2972]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2961]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2974]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2961]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2975]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [399] << Delta = (DESIRED_POSITION - ACTUAL_POSITION) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2961]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2976]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [398] << E_MS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2961]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 2982]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [391] << E_MS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [26.0 seconds ]
After "axioms" remaining 
Obligations:

[serial 2923]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2916]



[serial 2963]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2945]



[serial 2964]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [405] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2945]



[serial 2965]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [404] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2945]



[serial 2966]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [403] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2945]



[serial 2970]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [388] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2955]



[serial 2971]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [1] << DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2955]



[serial 2973]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2961]



[serial 2977]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]



[serial 2978]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]



[serial 2979]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [395] << ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]



[serial 2980]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]



[serial 2981]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [392] << (DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]


Done trying to apply axioms
step:  323
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  324
****make-an****
Making obligation 91
Obligations:

[serial 2923]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 2916]


Done making obligation 91
step:  325
#[serial 1694]   normalization of [serial 1687]
step:  326
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2923]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 2916]

Has substituted Assertions' predicates for labels to get:

[serial 2983]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels in postconditions [serial 2923]

. . . done Substituting Assertions for Labels [26.0 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 2983]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels in postconditions [serial 2923]


Done substituting Assertion labels in postconditions.
step:  327
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2983]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in postconditions [serial 2923]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2985]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
  What for:   normalization of [serial 2983]

. . . done Normalizing Unsolved Proof Obligations [26.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 2985]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
  What for:   normalization of [serial 2983]


Done Normalizing
step:  328
****completely distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 2985]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2983]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2987]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [294]->
Q [15] << ((Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2985]

. . . done spltting timed atoms  [26.0 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [26.0 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2987]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [294]->
Q [15] << ((Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2985]

  Normalization Axioms:

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2989]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
  What for:   normalization of [serial 2987]

. . . done Normalizing Unsolved Proof Obligations [26.0 seconds ]
After "completely distribute ^ and @" round 0 remaining 
Obligations:

[serial 2989]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
  What for:   normalization of [serial 2987]


Done completely distributing ^ and @, round 0.
Distributing carets . .

This Proof Obligation:

[serial 2989]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2987]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2991]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2989]

. . . done spltting timed atoms  [26.0 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [26.0 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2991]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2989]

  Normalization Axioms:

    Literal Arithmetic

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 2993]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for:   normalization of [serial 2991]

. . . done Normalizing Unsolved Proof Obligations [26.0 seconds ]
After "completely distribute ^ and @" round 1 remaining 
Obligations:

[serial 2993]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for:   normalization of [serial 2991]


Done completely distributing ^ and @, round 1.
Distributing carets . .

This Proof Obligation:

[serial 2993]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2991]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2995]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) and 
(((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2993]

. . . done spltting timed atoms  [26.0 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [26.0 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 2995]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) and 
(((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1)) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2993]

  Normalization Axioms:

    Literal Arithmetic

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Constants are always the same
Has been normalized to get:

[serial 2997]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 2995]

. . . done Normalizing Unsolved Proof Obligations [26.0 seconds ]
After "completely distribute ^ and @" round 2 remaining 
Obligations:

[serial 2997]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 2995]


Done completely distributing ^ and @, round 2.
Distributing carets . .

This Proof Obligation:

[serial 2997]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 2995]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 2999]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2997]

. . . done spltting timed atoms  [26.0 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [26.0 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [26.0 seconds ]
After "completely distribute ^ and @" round 3 remaining 
Obligations:

[serial 2999]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2997]


Done completely distributing ^ and @, round 3.
Distributing carets . .
. . . done spltting timed atoms  [26.0 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [26.0 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [26.0 seconds ]
step:  329
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 2999]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2997]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3002]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2999]

. . . done Applying Laws [26.0 seconds ]
After "laws" remaining 
Obligations:

[serial 3002]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Associativity: (b.c).a = a.b.c [serial 2999]


Done applying laws
step:  330
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3002]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  Identity (id):  P->P is tautology
  What for: Associativity: (b.c).a = a.b.c [serial 2999]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [26.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2963]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2945]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  331
#[serial 1739] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1716]
step:  332
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  (ACTUAL_POSITION + Delta) = ACTUAL_POSITION'

This Proof Obligation:

[serial 2963]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [1] << 0 <= ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2945]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 3003]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2963]

. . . done guided substitution of equals  [26.0 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3003]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2963]


Done guided substituting an equals
step:  333
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3003]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2963]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 3005]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 3003]

. . . done Normalizing Unsolved Proof Obligations [26.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 3005]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 3003]


Done Normalizing
step:  334
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3005]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 3003]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [26.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2964]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [405] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2945]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  335
#[serial 1740] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1716]
step:  336
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  (ACTUAL_POSITION + Delta) = ACTUAL_POSITION'

This Proof Obligation:

[serial 2964]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [405] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2945]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 3007]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [405] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2964]

. . . done guided substitution of equals  [26.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3007]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [405] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2964]


Done guided substituting an equals
step:  337
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3007]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [405] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2964]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 3009]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [405] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3007]

. . . done Normalizing Unsolved Proof Obligations [26.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 3009]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [405] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3007]


Done Normalizing
step:  338
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3009]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [405] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 3007]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [26.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2965]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [404] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2945]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  339
#[serial 1741] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1716]
step:  340
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  (ACTUAL_POSITION + Delta) = ACTUAL_POSITION'

This Proof Obligation:

[serial 2965]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [404] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2945]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 3011]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [404] << Delta = (((ACTUAL_POSITION + Delta)) - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2965]

. . . done guided substitution of equals  [26.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3011]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [404] << Delta = (((ACTUAL_POSITION + Delta)) - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2965]


Done guided substituting an equals
step:  341
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3011]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [404] << Delta = (((ACTUAL_POSITION + Delta)) - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2965]

  Normalization Axioms:

    Subtaction of Added Value:  (a+b)-a is b

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 3013]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [404] << Delta = Delta >>
  What for:   normalization of [serial 3011]

. . . done Normalizing Unsolved Proof Obligations [26.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 3013]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [404] << Delta = Delta >>
  What for:   normalization of [serial 3011]


Done Normalizing
step:  342
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3013]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [404] << Delta = Delta >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 3011]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 3015]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [404] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 3013]

. . . done Applying Laws [26.1 seconds ]
After "laws" remaining 
Obligations:

[serial 3015]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [404] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 3013]


Done applying laws
step:  343
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3015]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [404] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 3013]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [26.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2966]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [403] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2945]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  344
#[serial 1742] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1716]
step:  345
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2966]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402]->
Q [403] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2945]

Has substituted Assertions' predicates for labels to get:

[serial 3016]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [402]->
Q [403] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2966]

. . . done Substituting Assertions for Labels [26.1 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3016]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [402]->
Q [403] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2966]


Done substituting Assertion labels in preconditions
step:  346
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3016]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [402]->
Q [403] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2966]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3018]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [402]->
Q [403] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 3016]

. . . done Normalizing Unsolved Proof Obligations [26.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 3018]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [402]->
Q [403] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 3016]


Done Normalizing
step:  347
****guided-sub-equals****
guided substitution of equals "EstimatedActualPosition" . . .
equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 3018]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [402]->
Q [403] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 3016]

Has substituted 
"EstimatedActualPosition" with its = "ACTUAL_POSITION"
 to get:

[serial 3020]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [402]->
Q [403] << (Delta + ACTUAL_POSITION) = ACTUAL_POSITION' >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3018]

. . . done guided substitution of equals  [26.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3020]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [402]->
Q [403] << (Delta + ACTUAL_POSITION) = ACTUAL_POSITION' >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3018]


Done guided substituting an equals
step:  348
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3020]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [402]->
Q [403] << (Delta + ACTUAL_POSITION) = ACTUAL_POSITION' >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3018]

  Normalization Axiom:

    Reflexivity of Addition: a+b=b+a
Has been normalized to get:

[serial 3022]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [402]->
Q [403] << (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 3020]

. . . done Normalizing Unsolved Proof Obligations [26.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 3022]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [402]->
Q [403] << (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 3020]


Done Normalizing
step:  349
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3022]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [402]->
Q [403] << (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 3020]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [26.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2970]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [388] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2955]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  350
#[serial 1746] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1726]
step:  351
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2970]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [388] << ACTUAL_POSITION < DESIRED_POSITION >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2955]

Has substituted Assertions' predicates for labels to get:

[serial 3024]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [388] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2970]

. . . done Substituting Assertions for Labels [26.1 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3024]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [388] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2970]


Done substituting Assertion labels in preconditions
step:  352
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 3024]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [388] << ACTUAL_POSITION < DESIRED_POSITION >>
Reason:  Assume Present:  P = P@now = P^0 
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2970]

Has applied Assume Present:  P = P@now = P^0  to get:

[serial 3025]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298]->
Q [388] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Assume Present:  P = P@now = P^0  [serial 3024]

. . . done replacing P@now and P^0 with P  [26.1 seconds ]
After assuming present remaining 
Obligations:

[serial 3025]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298]->
Q [388] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Assume Present:  P = P@now = P^0  [serial 3024]


Done assuming present.
step:  353
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3025]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298]->
Q [388] << ACTUAL_POSITION < DESIRED_POSITION >>
Reason:  Associativity: (b.c).a = a.b.c
  What for: Assume Present:  P = P@now = P^0  [serial 3024]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3026]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298]->
Q [388] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 3025]

. . . done Applying Laws [26.1 seconds ]
After "laws" remaining 
Obligations:

[serial 3026]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298]->
Q [388] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 3025]


Done applying laws
step:  354
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3026]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298]->
Q [388] << ACTUAL_POSITION < DESIRED_POSITION >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 3025]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3028]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298]->
Q [388] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for:   normalization of [serial 3026]

. . . done Normalizing Unsolved Proof Obligations [26.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 3028]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298]->
Q [388] << ACTUAL_POSITION < DESIRED_POSITION >>
  What for:   normalization of [serial 3026]


Done Normalizing
step:  355
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION" . . .
equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 3028]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298]->
Q [388] << ACTUAL_POSITION < DESIRED_POSITION >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 3026]

Has substituted 
"ACTUAL_POSITION" with its = "EstimatedActualPosition"
 to get:

[serial 3030]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298]->
Q [388] << EstimatedActualPosition < DESIRED_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 3028]

. . . done guided substitution of equals  [26.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3030]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298]->
Q [388] << EstimatedActualPosition < DESIRED_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 3028]


Done guided substituting an equals
step:  356
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3030]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298]->
Q [388] << EstimatedActualPosition < DESIRED_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 3028]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [26.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2971]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [1] << DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2955]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  357
#[serial 1747] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1726]
step:  358
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2971]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [1] << DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2955]

Has substituted Assertions' predicates for labels to get:

[serial 3031]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [1] << DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2971]

. . . done Substituting Assertions for Labels [26.1 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3031]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [1] << DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2971]


Done substituting Assertion labels in preconditions
step:  359
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 3031]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298]->
Q [1] << DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
Reason:  Assume Present:  P = P@now = P^0 
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2971]

Has applied Assume Present:  P = P@now = P^0  to get:

[serial 3032]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for: Assume Present:  P = P@now = P^0  [serial 3031]

. . . done replacing P@now and P^0 with P  [26.1 seconds ]
After assuming present remaining 
Obligations:

[serial 3032]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for: Assume Present:  P = P@now = P^0  [serial 3031]


Done assuming present.
step:  360
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3032]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for: Assume Present:  P = P@now = P^0  [serial 3031]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3033]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for: Associativity: (b.c).a = a.b.c [serial 3032]

. . . done Applying Laws [26.1 seconds ]
After "laws" remaining 
Obligations:

[serial 3033]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for: Associativity: (b.c).a = a.b.c [serial 3032]


Done applying laws
step:  361
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3033]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 3032]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3035]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 3033]

. . . done Normalizing Unsolved Proof Obligations [26.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 3035]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
  What for:   normalization of [serial 3033]


Done Normalizing
step:  362
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION" . . .
equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 3035]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 3033]

Has substituted 
"ACTUAL_POSITION" with its = "EstimatedActualPosition"
 to get:

[serial 3037]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 3035]

. . . done guided substitution of equals  [26.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3037]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 3035]


Done guided substituting an equals
step:  363
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3037]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 3035]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [26.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2973]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2961]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  364
#[serial 1749] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1732]
step:  365
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2973]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2961]

Has substituted Assertions' predicates for labels to get:

[serial 3038]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and ((ACTUAL_POSITION < (ACTUAL_POSITION + 
Delta)) and (Delta > 0)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [397]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2973]

. . . done Substituting Assertions for Labels [26.2 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3038]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and ((ACTUAL_POSITION < (ACTUAL_POSITION + 
Delta)) and (Delta > 0)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [397]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2973]


Done substituting Assertion labels in preconditions
step:  366
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3038]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and ((ACTUAL_POSITION < (ACTUAL_POSITION + 
Delta)) and (Delta > 0)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [397]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2973]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3040]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(0 < Delta and ACTUAL_POSITION < (ACTUAL_POSITION + Delta)) >>
S [397]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 3038]

. . . done Normalizing Unsolved Proof Obligations [26.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 3040]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(0 < Delta and ACTUAL_POSITION < (ACTUAL_POSITION + Delta)) >>
S [397]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 3038]


Done Normalizing
step:  367
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3040]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(0 < Delta and ACTUAL_POSITION < (ACTUAL_POSITION + Delta)) >>
S [397]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 3038]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3042]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 < Delta and ACTUAL_POSITION < (ACTUAL_POSITION + Delta) and 0 <= ACTUAL_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = (ACTUAL_POSITION + 
Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) >>
S [397]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Associativity: (b.c).a = a.b.c [serial 3040]

. . . done Applying Laws [26.2 seconds ]
After "laws" remaining 
Obligations:

[serial 3042]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 < Delta and ACTUAL_POSITION < (ACTUAL_POSITION + Delta) and 0 <= ACTUAL_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = (ACTUAL_POSITION + 
Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) >>
S [397]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Associativity: (b.c).a = a.b.c [serial 3040]


Done applying laws
step:  368
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3042]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 < Delta and ACTUAL_POSITION < (ACTUAL_POSITION + Delta) and 0 <= ACTUAL_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = (ACTUAL_POSITION + 
Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) >>
S [397]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 3040]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3044]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
0 < Delta and ACTUAL_POSITION < (ACTUAL_POSITION + Delta) >>
S [397]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 3042]

. . . done Normalizing Unsolved Proof Obligations [26.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 3044]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
0 < Delta and ACTUAL_POSITION < (ACTUAL_POSITION + Delta) >>
S [397]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 3042]


Done Normalizing
step:  369
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  0 <= ACTUAL_POSITION and ACTUAL_POSITION < (ACTUAL_POSITION + Delta) -> 0 < (ACTUAL_POSITION + Delta)
Transitivity:  ACTUAL_POSITION < (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition -> ACTUAL_POSITION < #PCS::MaxPosition
Transitivity:  0 < (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition -> 0 < #PCS::MaxPosition

This Proof Obligation:

[serial 3044]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
0 < Delta and ACTUAL_POSITION < (ACTUAL_POSITION + Delta) >>
S [397]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for:   normalization of [serial 3042]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 3046]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
0 < Delta and ACTUAL_POSITION < (ACTUAL_POSITION + Delta) and 0 < (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [397]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Transitivity: x<y and y<z -> x<z [serial 3044]

. . . done adding transitive terms [26.2 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 3046]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
0 < Delta and ACTUAL_POSITION < (ACTUAL_POSITION + Delta) and 0 < (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [397]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Transitivity: x<y and y<z -> x<z [serial 3044]


Done adding transitive relations
step:  370
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3046]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
0 < Delta and ACTUAL_POSITION < (ACTUAL_POSITION + Delta) and 0 < (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [397]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Normalization
  What for: Transitivity: x<y and y<z -> x<z [serial 3044]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3048]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
0 < Delta and 0 < (ACTUAL_POSITION + Delta) and 0 < #PCS::MaxPosition and 
ACTUAL_POSITION < (ACTUAL_POSITION + Delta) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [397]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 3046]

. . . done Normalizing Unsolved Proof Obligations [26.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 3048]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
0 < Delta and 0 < (ACTUAL_POSITION + Delta) and 0 < #PCS::MaxPosition and 
ACTUAL_POSITION < (ACTUAL_POSITION + Delta) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [397]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 3046]


Done Normalizing
step:  371
****partial to total order****
Making partial orders into total orders . . .
Making partial orders into total orders . . .

This Proof Obligation:

[serial 3048]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
0 < Delta and 0 < (ACTUAL_POSITION + Delta) and 0 < #PCS::MaxPosition and 
ACTUAL_POSITION < (ACTUAL_POSITION + Delta) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [397]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Partial Order Law 3:  a <= (b-1)  is  a<b
  What for:   normalization of [serial 3046]

Has applied Partial Order Law 3:  a <= (b-1)  is  a<b (0<(ACTUAL_POSITION + Delta)  ->  0<=(ACTUAL_POSITION + Delta)
0<=(-ACTUAL_POSITION+Delta)  is  0<Delta
  0<=(-ACTUAL_POSITION+Delta)  is  0<Delta
) to get:

[serial 3050]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
0 < Delta and 0 < Delta and 0 < #PCS::MaxPosition and ACTUAL_POSITION < (
ACTUAL_POSITION + Delta) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [397]->
Q [1] << 0 < Delta >>
  What for: 0<(ACTUAL_POSITION + Delta)  ->  0<=(ACTUAL_POSITION + Delta)
0<=(-ACTUAL_POSITION+Delta)  is  0<Delta
  0<=(-ACTUAL_POSITION+Delta)  is  0<Delta

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 3048]

. . . done making partial orders into total orders [26.2 seconds ]
After making partial orders into total orders 
Obligations:

[serial 3050]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
0 < Delta and 0 < Delta and 0 < #PCS::MaxPosition and ACTUAL_POSITION < (
ACTUAL_POSITION + Delta) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [397]->
Q [1] << 0 < Delta >>
  What for: 0<(ACTUAL_POSITION + Delta)  ->  0<=(ACTUAL_POSITION + Delta)
0<=(-ACTUAL_POSITION+Delta)  is  0<Delta
  0<=(-ACTUAL_POSITION+Delta)  is  0<Delta

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 3048]


Done making partial orders into total orders
step:  372
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3050]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
0 < Delta and 0 < Delta and 0 < #PCS::MaxPosition and ACTUAL_POSITION < (
ACTUAL_POSITION + Delta) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [397]->
Q [1] << 0 < Delta >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: 0<(ACTUAL_POSITION + Delta)  ->  0<=(ACTUAL_POSITION + Delta)
0<=(-ACTUAL_POSITION+Delta)  is  0<Delta
  0<=(-ACTUAL_POSITION+Delta)  is  0<Delta

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 3048]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [26.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2977]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  373
#[serial 1753] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]
step:  374
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2977]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]

Has substituted Assertions' predicates for labels to get:

[serial 3051]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2977]

. . . done Substituting Assertions for Labels [26.2 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3051]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2977]


Done substituting Assertion labels in preconditions
step:  375
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3051]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2977]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3053]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for:   normalization of [serial 3051]

. . . done Normalizing Unsolved Proof Obligations [26.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 3053]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for:   normalization of [serial 3051]


Done Normalizing
step:  376
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3053]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 3051]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3055]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 3053]

. . . done Applying Laws [26.2 seconds ]
After "laws" remaining 
Obligations:

[serial 3055]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 3053]


Done applying laws
step:  377
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3055]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Associativity: (b.c).a = a.b.c [serial 3053]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [26.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2978]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  378
#[serial 1754] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]
step:  379
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 2978]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]

Has substituted Assertions' predicates for labels to get:

[serial 3056]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2978]

. . . done Substituting Assertions for Labels [26.2 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3056]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2978]


Done substituting Assertion labels in preconditions
step:  380
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3056]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 2978]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3058]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3056]

. . . done Normalizing Unsolved Proof Obligations [26.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 3058]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3056]


Done Normalizing
step:  381
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3058]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 3056]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3060]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 3058]

. . . done Applying Laws [26.2 seconds ]
After "laws" remaining 
Obligations:

[serial 3060]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 3058]


Done applying laws
step:  382
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3060]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 3058]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3062]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3060]

. . . done Normalizing Unsolved Proof Obligations [26.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 3062]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3060]


Done Normalizing
step:  383
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3062]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 3060]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [26.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2979]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [395] << ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  384
#[serial 1755] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]
step:  385
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 2979]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [395] << ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
Reason:  Assume Present:  P = P@now = P^0 
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]

Has applied Assume Present:  P = P@now = P^0  to get:

[serial 3064]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for: Assume Present:  P = P@now = P^0  [serial 2979]

. . . done replacing P@now and P^0 with P  [26.2 seconds ]
After assuming present remaining 
Obligations:

[serial 3064]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for: Assume Present:  P = P@now = P^0  [serial 2979]


Done assuming present.
step:  386
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 3064]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
Reason:  Substitution of Assertion Labels
  What for: Assume Present:  P = P@now = P^0  [serial 2979]

Has substituted Assertions' predicates for labels to get:

[serial 3065]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3064]

. . . done Substituting Assertions for Labels [26.2 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3065]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3064]


Done substituting Assertion labels in preconditions
step:  387
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3065]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3064]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3067]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3065]

. . . done Normalizing Unsolved Proof Obligations [26.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 3067]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3065]


Done Normalizing
step:  388
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3067]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 3065]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3069]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 3067]

. . . done Applying Laws [26.2 seconds ]
After "laws" remaining 
Obligations:

[serial 3069]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 3067]


Done applying laws
step:  389
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3069]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 3067]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3071]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3069]

. . . done Normalizing Unsolved Proof Obligations [26.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 3071]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3069]


Done Normalizing
step:  390
****guided-sub-equals****
guided substitution of equals "EstimatedActualPosition" . . .
equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 3071]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 3069]

Has substituted 
"EstimatedActualPosition" with its = "ACTUAL_POSITION"
 to get:

[serial 3073]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3071]

. . . done guided substitution of equals  [26.2 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3073]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3071]


Done guided substituting an equals
step:  391
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3073]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - ACTUAL_POSITION) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3071]

  Normalization Axioms:

    Subtaction of Added Value:  (a+b)-a is b

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 3075]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [395] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3073]

. . . done Normalizing Unsolved Proof Obligations [26.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 3075]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [395] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3073]


Done Normalizing
step:  392
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3075]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [395] << DESIRED_POSITION <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 3073]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [26.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2980]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  393
#[serial 1756] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]
step:  394
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 2980]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) >>
Reason:  Assume Present:  P = P@now = P^0 
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]

Has applied Assume Present:  P = P@now = P^0  to get:

[serial 3077]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
  What for: Assume Present:  P = P@now = P^0  [serial 2980]

. . . done replacing P@now and P^0 with P  [26.3 seconds ]
After assuming present remaining 
Obligations:

[serial 3077]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
  What for: Assume Present:  P = P@now = P^0  [serial 2980]


Done assuming present.
step:  395
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 3077]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
Reason:  Substitution of Assertion Labels
  What for: Assume Present:  P = P@now = P^0  [serial 2980]

Has substituted Assertions' predicates for labels to get:

[serial 3078]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3077]

. . . done Substituting Assertions for Labels [26.3 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3078]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3077]


Done substituting Assertion labels in preconditions
step:  396
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3078]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3077]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3080]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
  What for:   normalization of [serial 3078]

. . . done Normalizing Unsolved Proof Obligations [26.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 3080]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
  What for:   normalization of [serial 3078]


Done Normalizing
step:  397
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3080]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 3078]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3082]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
  What for: Associativity: (b.c).a = a.b.c [serial 3080]

. . . done Applying Laws [26.3 seconds ]
After "laws" remaining 
Obligations:

[serial 3082]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
  What for: Associativity: (b.c).a = a.b.c [serial 3080]


Done applying laws
step:  398
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3082]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 3080]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3084]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
  What for:   normalization of [serial 3082]

. . . done Normalizing Unsolved Proof Obligations [26.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 3084]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
  What for:   normalization of [serial 3082]


Done Normalizing
step:  399
****guided-sub-equals****
guided substitution of equals "EstimatedActualPosition" . . .
equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 3084]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 3082]

Has substituted 
"EstimatedActualPosition" with its = "ACTUAL_POSITION"
 to get:

[serial 3086]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3084]

. . . done guided substitution of equals  [26.3 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3086]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3084]


Done guided substituting an equals
step:  400
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3086]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3084]

  Normalization Axioms:

    Subtaction of Added Value:  (a+b)-a is b

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 3088]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 3086]

. . . done Normalizing Unsolved Proof Obligations [26.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 3088]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 3086]


Done Normalizing
step:  401
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3088]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [391] << DESIRED_POSITION = DESIRED_POSITION >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 3086]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 3090]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [391] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 3088]

. . . done Applying Laws [26.3 seconds ]
After "laws" remaining 
Obligations:

[serial 3090]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [391] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 3088]


Done applying laws
step:  402
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3090]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [391] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 3088]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [26.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 2981]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [392] << (DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  403
#[serial 1757] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]
step:  404
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 2981]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [392] << (DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) >>
Reason:  Assume Present:  P = P@now = P^0 
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]

Has applied Assume Present:  P = P@now = P^0  to get:

[serial 3091]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
  What for: Assume Present:  P = P@now = P^0  [serial 2981]

. . . done replacing P@now and P^0 with P  [26.3 seconds ]
After assuming present remaining 
Obligations:

[serial 3091]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
  What for: Assume Present:  P = P@now = P^0  [serial 2981]


Done assuming present.
step:  405
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 3091]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
Reason:  Substitution of Assertion Labels
  What for: Assume Present:  P = P@now = P^0  [serial 2981]

Has substituted Assertions' predicates for labels to get:

[serial 3092]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3091]

. . . done Substituting Assertions for Labels [26.3 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3092]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3091]


Done substituting Assertion labels in preconditions
step:  406
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3092]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390]->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3091]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3094]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
  What for:   normalization of [serial 3092]

. . . done Normalizing Unsolved Proof Obligations [26.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 3094]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
  What for:   normalization of [serial 3092]


Done Normalizing
step:  407
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3094]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 3092]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3096]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
  What for: Associativity: (b.c).a = a.b.c [serial 3094]

. . . done Applying Laws [26.3 seconds ]
After "laws" remaining 
Obligations:

[serial 3096]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
  What for: Associativity: (b.c).a = a.b.c [serial 3094]


Done applying laws
step:  408
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3096]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 3094]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3098]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
  What for:   normalization of [serial 3096]

. . . done Normalizing Unsolved Proof Obligations [26.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 3098]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
  What for:   normalization of [serial 3096]


Done Normalizing
step:  409
****guided-sub-equals****
guided substitution of equals "EstimatedActualPosition" . . .
equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 3098]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 3096]

Has substituted 
"EstimatedActualPosition" with its = "ACTUAL_POSITION"
 to get:

[serial 3100]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3098]

. . . done guided substitution of equals  [26.3 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3100]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3098]


Done guided substituting an equals
step:  410
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3100]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - ACTUAL_POSITION) >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3098]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 3101]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [392] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 3100]

. . . done Applying Laws [26.3 seconds ]
After "laws" remaining 
Obligations:

[serial 3101]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [392] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 3100]


Done applying laws
step:  411
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3101]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390]->
Q [392] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 3100]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [26.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1037]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition > (DESIRED_POSITION)^0)) and 
(((EstimatedActualPosition - #PCS::MaxStepsUp) < (DESIRED_POSITION)^0)))) >>
S [410]<< (((ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION) and (ACTUAL_POSITION > DESIRED_POSITION) and E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Delta := (DesiredPosition? - EstimatedActualPosition)
<< (E_MS() and (DESIRED_POSITION = (ACTUAL_POSITION + Delta)) and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and (ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(z:ACTUAL_POSITION,k: -Delta) and DESIRED_IN_RANGE() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and DESIRED_IN_RANGE() and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and (ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition + Delta)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for ms6cd:Decide-[x]->Run{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  412
#[serial 1037]  <<M(Decide) and x>> A <<M(Run)>> for ms6cd:Decide-[x]->Run{A};
step:  413
****reduce****
This proof obligation:

[serial 1037]: ControlSoftware::FragilePositionControlThread.MultiStep
P [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition > (DESIRED_POSITION)^0)) and 
(((EstimatedActualPosition - #PCS::MaxStepsUp) < (DESIRED_POSITION)^0)))) >>
S [410]<< (((ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION) and (ACTUAL_POSITION > DESIRED_POSITION) and E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Delta := (DesiredPosition? - EstimatedActualPosition)
<< (E_MS() and (DESIRED_POSITION = (ACTUAL_POSITION + Delta)) and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and (ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(z:ACTUAL_POSITION,k: -Delta) and DESIRED_IN_RANGE() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and DESIRED_IN_RANGE() and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and (ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition + Delta)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(Decide) and x>> A <<M(Run)>> for ms6cd:Decide-[x]->Run{A};

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P2>> S2 <<Q2>>
 
was reduced to:

[serial 3102]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition > (DESIRED_POSITION)^0)) and 
(((EstimatedActualPosition - #PCS::MaxStepsUp) < (DESIRED_POSITION)^0)))) >>
S [298]->
Q [15] << (((ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION) and (ACTUAL_POSITION > DESIRED_POSITION) and 
E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
  What for: P -> P1 in sequential composition for [serial 1037]


[serial 3103]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [294]->
Q [15] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 1037]


[serial 3104]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (((ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION) and (ACTUAL_POSITION > DESIRED_POSITION) and 
E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
S [413]Delta := (DesiredPosition? - EstimatedActualPosition)
Q [15] << (E_MS() and (DESIRED_POSITION = (ACTUAL_POSITION + Delta)) and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and 
(ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(
z:ACTUAL_POSITION,k: -Delta) and DESIRED_IN_RANGE() and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1037]


[serial 3105]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (E_MS() and (DESIRED_POSITION = (ACTUAL_POSITION + Delta)) and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and 
(ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(
z:ACTUAL_POSITION,k: -Delta) and DESIRED_IN_RANGE() and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
S [420]ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and DESIRED_IN_RANGE() and 
(Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and (ACTUAL_POSITION >= 0) and 
((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1037]


[serial 3106]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and DESIRED_IN_RANGE() and 
(Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and (ACTUAL_POSITION >= 0) and 
((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
S [425]EstimatedActualPosition' := (EstimatedActualPosition + Delta)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1037]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 3102]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition > (DESIRED_POSITION)^0)) and 
(((EstimatedActualPosition - #PCS::MaxStepsUp) < (DESIRED_POSITION)^0)))) >>
S [298]->
Q [15] << (((ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION) and (ACTUAL_POSITION > DESIRED_POSITION) and 
E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
  What for: P -> P1 in sequential composition for [serial 1037]



[serial 3103]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [294]->
Q [15] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 1037]



[serial 3104]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (((ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION) and (ACTUAL_POSITION > DESIRED_POSITION) and 
E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
S [413]Delta := (DesiredPosition? - EstimatedActualPosition)
Q [15] << (E_MS() and (DESIRED_POSITION = (ACTUAL_POSITION + Delta)) and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and 
(ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(
z:ACTUAL_POSITION,k: -Delta) and DESIRED_IN_RANGE() and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1037]



[serial 3105]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (E_MS() and (DESIRED_POSITION = (ACTUAL_POSITION + Delta)) and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and 
(ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(
z:ACTUAL_POSITION,k: -Delta) and DESIRED_IN_RANGE() and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
S [420]ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and DESIRED_IN_RANGE() and 
(Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and (ACTUAL_POSITION >= 0) and 
((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1037]



[serial 3106]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and DESIRED_IN_RANGE() and 
(Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and (ACTUAL_POSITION >= 0) and 
((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
S [425]EstimatedActualPosition' := (EstimatedActualPosition + Delta)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1037]


done reducing composite actions
step:  414
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3102]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition > (DESIRED_POSITION)^0)) and 
(((EstimatedActualPosition - #PCS::MaxStepsUp) < (DESIRED_POSITION)^0)))) >>
S [298]->
Q [15] << (((ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION) and (ACTUAL_POSITION > DESIRED_POSITION) and 
E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Reason:  Normalization
  What for: P -> P1 in sequential composition for [serial 1037]

  Normalization Axioms:

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3108]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and (DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for:   normalization of [serial 3102]


This Proof Obligation:

[serial 3103]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [294]->
Q [15] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
Reason:  Normalization
  What for: Q2 -> Q in sequential composition for [serial 1037]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3110]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 3103]


This Proof Obligation:

[serial 3104]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (((ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION) and (ACTUAL_POSITION > DESIRED_POSITION) and 
E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
S [413]Delta := (DesiredPosition? - EstimatedActualPosition)
Q [15] << (E_MS() and (DESIRED_POSITION = (ACTUAL_POSITION + Delta)) and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and 
(ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(
z:ACTUAL_POSITION,k: -Delta) and DESIRED_IN_RANGE() and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1037]

  Normalization Axioms:

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3112]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]Delta := (DesiredPosition? - EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 3104]


This Proof Obligation:

[serial 3105]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << (E_MS() and (DESIRED_POSITION = (ACTUAL_POSITION + Delta)) and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and 
(ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(
z:ACTUAL_POSITION,k: -Delta) and DESIRED_IN_RANGE() and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
S [420]ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and DESIRED_IN_RANGE() and 
(Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and (ACTUAL_POSITION >= 0) and 
((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1037]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3114]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]ActuatorCommand(pc:Delta)
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
  What for:   normalization of [serial 3105]


This Proof Obligation:

[serial 3106]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and DESIRED_IN_RANGE() and 
(Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and (ACTUAL_POSITION >= 0) and 
((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
S [425]EstimatedActualPosition' := (EstimatedActualPosition + Delta)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Reason:  Normalization
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1037]

  Normalization Axioms:

    Reflexivity of Addition: a+b=b+a

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3116]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]EstimatedActualPosition' := (Delta + EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
  What for:   normalization of [serial 3106]

. . . done Normalizing Unsolved Proof Obligations [26.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 3108]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and (DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for:   normalization of [serial 3102]



[serial 3110]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 3103]



[serial 3112]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]Delta := (DesiredPosition? - EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 3104]



[serial 3114]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]ActuatorCommand(pc:Delta)
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
  What for:   normalization of [serial 3105]



[serial 3116]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]EstimatedActualPosition' := (Delta + EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
  What for:   normalization of [serial 3106]


Done Normalizing
step:  415
****atomic****
applying atomic actions . . .
solving assignment on line 413
replacing "Delta" with "((DESIRED_POSITION)^0 - EstimatedActualPosition)"
makes:  << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
(((DESIRED_POSITION)^0 - EstimatedActualPosition))) <= #PCS::MaxPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + (((DESIRED_POSITION)^0 - EstimatedActualPosition))) and 
(((DESIRED_POSITION)^0 - EstimatedActualPosition)) = (DESIRED_POSITION - ACTUAL_POSITION) and 
AXIOM_LTK(z:ACTUAL_POSITION,k: -(((DESIRED_POSITION)^0 - EstimatedActualPosition))) and 
DESIRED_IN_RANGE() and E_MS() >>

This Proof Obligation:

[serial 3112]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]Delta := (DesiredPosition? - EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for:   normalization of [serial 3104]

Has applied := to get:

[serial 3122]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
(((DESIRED_POSITION)^0 - EstimatedActualPosition))) <= #PCS::MaxPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + (((DESIRED_POSITION)^0 - EstimatedActualPosition))) and 
(((DESIRED_POSITION)^0 - EstimatedActualPosition)) = (DESIRED_POSITION - ACTUAL_POSITION) and 
AXIOM_LTK(z:ACTUAL_POSITION,k: -(((DESIRED_POSITION)^0 - EstimatedActualPosition))) and 
DESIRED_IN_RANGE() and E_MS() >>
  What for: applied wp for assignment [serial 3112]

Creating weakest-precondition predicate transfer for subprogram invocation of "ActuatorCommand".

This Proof Obligation:

[serial 3114]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]ActuatorCommand(pc:Delta)
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
Reason:  Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
  What for:   normalization of [serial 3105]

Used weakest precondition predicate transformation on
+ <<P>> ActuatorCommand(X) <<Q>> to get:

[serial 3123]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and 
DESIRED_IN_RANGE() and E_MS() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 3114]

solving assignment on line 425
replacing "EstimatedActualPosition'" with "(Delta + EstimatedActualPosition)"
makes:  << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>

This Proof Obligation:

[serial 3116]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]EstimatedActualPosition' := (Delta + EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for:   normalization of [serial 3106]

Has applied := to get:

[serial 3124]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
  What for: applied wp for assignment [serial 3116]

. . . done applying atomic actions [26.4 seconds ]
After "atomic" remaining 
Obligations:

[serial 3108]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and (DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for:   normalization of [serial 3102]



[serial 3110]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 3103]



[serial 3122]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
(((DESIRED_POSITION)^0 - EstimatedActualPosition))) <= #PCS::MaxPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + (((DESIRED_POSITION)^0 - EstimatedActualPosition))) and 
(((DESIRED_POSITION)^0 - EstimatedActualPosition)) = (DESIRED_POSITION - ACTUAL_POSITION) and 
AXIOM_LTK(z:ACTUAL_POSITION,k: -(((DESIRED_POSITION)^0 - EstimatedActualPosition))) and 
DESIRED_IN_RANGE() and E_MS() >>
  What for: applied wp for assignment [serial 3112]



[serial 3123]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and 
DESIRED_IN_RANGE() and E_MS() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 3114]



[serial 3124]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
  What for: applied wp for assignment [serial 3116]


Done reducing atomic actions
step:  416
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3122]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
(((DESIRED_POSITION)^0 - EstimatedActualPosition))) <= #PCS::MaxPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + (((DESIRED_POSITION)^0 - EstimatedActualPosition))) and 
(((DESIRED_POSITION)^0 - EstimatedActualPosition)) = (DESIRED_POSITION - ACTUAL_POSITION) and 
AXIOM_LTK(z:ACTUAL_POSITION,k: -(((DESIRED_POSITION)^0 - EstimatedActualPosition))) and 
DESIRED_IN_RANGE() and E_MS() >>
Reason:  Normalization
  What for: applied wp for assignment [serial 3112]

  Normalization Axioms:

    Reflexivity of Addition: a+b=b+a

    Unary Minus:  -(x-y) is (y-x)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Associativity: (b.c).a = a.b.c
Has been normalized to get:

[serial 3128]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ((
DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition and 
DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) and 
(DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:(EstimatedActualPosition - DESIRED_POSITION^0)) and 
DESIRED_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 3122]


This Proof Obligation:

[serial 3123]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and 
DESIRED_IN_RANGE() and E_MS() >>
Reason:  Normalization
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 3114]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3130]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
DESIRED_IN_RANGE() and E_MS() and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 3123]


This Proof Obligation:

[serial 3124]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
Reason:  Normalization
  What for: applied wp for assignment [serial 3116]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 3132]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 3124]

. . . done Normalizing Unsolved Proof Obligations [26.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 3108]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and (DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for:   normalization of [serial 3102]



[serial 3110]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 3103]



[serial 3128]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ((
DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition and 
DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) and 
(DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:(EstimatedActualPosition - DESIRED_POSITION^0)) and 
DESIRED_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 3122]



[serial 3130]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
DESIRED_IN_RANGE() and E_MS() and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 3123]



[serial 3132]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 3124]


Done Normalizing
step:  417
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3108]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and (DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 3102]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3136]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 3108]


This Proof Obligation:

[serial 3130]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
DESIRED_IN_RANGE() and E_MS() and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 3123]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3137]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
DESIRED_IN_RANGE() and E_MS() >>
  What for: Associativity: (b.c).a = a.b.c [serial 3130]

. . . done Applying Laws [26.5 seconds ]
After "laws" remaining 
Obligations:

[serial 3110]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 3103]



[serial 3128]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ((
DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition and 
DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) and 
(DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:(EstimatedActualPosition - DESIRED_POSITION^0)) and 
DESIRED_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 3122]



[serial 3132]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 3124]



[serial 3136]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 3108]



[serial 3137]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
DESIRED_IN_RANGE() and E_MS() >>
  What for: Associativity: (b.c).a = a.b.c [serial 3130]


Done applying laws
step:  418
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3136]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << DESIRED_POSITION^0 < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 3108]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3142]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for:   normalization of [serial 3136]


This Proof Obligation:

[serial 3137]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
DESIRED_IN_RANGE() and E_MS() >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 3130]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3144]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + 
Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
DESIRED_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 3137]

. . . done Normalizing Unsolved Proof Obligations [26.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 3110]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 3103]



[serial 3128]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ((
DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition and 
DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) and 
(DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:(EstimatedActualPosition - DESIRED_POSITION^0)) and 
DESIRED_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 3122]



[serial 3132]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 3124]



[serial 3142]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for:   normalization of [serial 3136]



[serial 3144]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + 
Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
DESIRED_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 3137]


Done Normalizing
step:  419
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3144]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + 
Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
DESIRED_IN_RANGE() and E_MS() >>
Reason:  Law of And-Simplification:  P and P is P
  What for:   normalization of [serial 3137]

Has applied law "Law of And-Simplification:  P and P is P" to get:

[serial 3147]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
DESIRED_IN_RANGE() and E_MS() >>
  What for: Law of And-Simplification:  P and P is P [serial 3144]

. . . done Applying Laws [26.5 seconds ]
After "laws" remaining 
Obligations:

[serial 3110]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 3103]



[serial 3128]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ((
DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition and 
DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) and 
(DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:(EstimatedActualPosition - DESIRED_POSITION^0)) and 
DESIRED_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 3122]



[serial 3132]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 3124]



[serial 3142]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for:   normalization of [serial 3136]



[serial 3147]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
DESIRED_IN_RANGE() and E_MS() >>
  What for: Law of And-Simplification:  P and P is P [serial 3144]


Done applying laws
step:  420
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 3128]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ((
DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition and 
DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) and 
(DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:(EstimatedActualPosition - DESIRED_POSITION^0)) and 
DESIRED_IN_RANGE() and E_MS() >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 3122]

Has split postcondition to get:

[serial 3148]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]


[serial 3149]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [416] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]


[serial 3150]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]


[serial 3151]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]


[serial 3152]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << (DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]


[serial 3153]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [417] << AXIOM_LTK(z:ACTUAL_POSITION,k:(EstimatedActualPosition - DESIRED_POSITION^0)) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]


[serial 3154]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [417] << DESIRED_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]


[serial 3155]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]


This Proof Obligation:

[serial 3132]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 3124]

Has split postcondition to get:

[serial 3156]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3132]


[serial 3157]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [428] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3132]


[serial 3158]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [427] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3132]


[serial 3159]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [426] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3132]


This Proof Obligation:

[serial 3142]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298]->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 3136]

Has split postcondition to get:

[serial 3160]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298]->
Q [412] << ACTUAL_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3142]


[serial 3161]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298]->
Q [412] << DESIRED_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3142]


[serial 3162]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298]->
Q [412] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3142]


[serial 3163]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298]->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3142]


[serial 3164]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298]->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3142]


This Proof Obligation:

[serial 3147]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
DESIRED_IN_RANGE() and E_MS() >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for: Law of And-Simplification:  P and P is P [serial 3144]

Has split postcondition to get:

[serial 3165]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]


[serial 3166]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]


[serial 3167]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]


[serial 3168]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [422] << Delta = (DESIRED_POSITION - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]


[serial 3169]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [421] << DESIRED_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]


[serial 3170]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [421] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]

. . . done splitting postcondition  [26.5 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 3110]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 3103]



[serial 3148]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]



[serial 3149]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [416] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]



[serial 3150]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]



[serial 3151]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]



[serial 3152]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << (DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]



[serial 3153]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [417] << AXIOM_LTK(z:ACTUAL_POSITION,k:(EstimatedActualPosition - DESIRED_POSITION^0)) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]



[serial 3154]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [417] << DESIRED_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]



[serial 3155]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]



[serial 3156]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3132]



[serial 3157]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [428] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3132]



[serial 3158]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [427] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3132]



[serial 3159]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [426] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3132]



[serial 3160]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298]->
Q [412] << ACTUAL_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3142]



[serial 3161]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298]->
Q [412] << DESIRED_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3142]



[serial 3162]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298]->
Q [412] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3142]



[serial 3163]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298]->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3142]



[serial 3164]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298]->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3142]



[serial 3165]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]



[serial 3166]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]



[serial 3167]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]



[serial 3168]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [422] << Delta = (DESIRED_POSITION - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]



[serial 3169]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [421] << DESIRED_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]



[serial 3170]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [421] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]


Done splitting postcondition
step:  421
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3154]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [417] << DESIRED_IN_RANGE() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 3155]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << E_MS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 3160]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298]->
Q [412] << ACTUAL_IN_RANGE() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3142]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 3161]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298]->
Q [412] << DESIRED_IN_RANGE() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3142]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 3162]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298]->
Q [412] << E_MS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3142]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 3165]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 3167]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 3168]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [422] << Delta = (DESIRED_POSITION - ACTUAL_POSITION) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 3169]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [421] << DESIRED_IN_RANGE() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 3170]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [421] << E_MS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [26.6 seconds ]
After "axioms" remaining 
Obligations:

[serial 3110]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 3103]



[serial 3148]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]



[serial 3149]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [416] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]



[serial 3150]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]



[serial 3151]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]



[serial 3152]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << (DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]



[serial 3153]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [417] << AXIOM_LTK(z:ACTUAL_POSITION,k:(EstimatedActualPosition - DESIRED_POSITION^0)) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]



[serial 3156]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3132]



[serial 3157]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [428] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3132]



[serial 3158]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [427] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3132]



[serial 3159]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [426] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3132]



[serial 3163]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298]->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3142]



[serial 3164]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298]->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3142]



[serial 3166]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]


Done trying to apply axioms
step:  422
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  423
****make-an****
Making obligation 105
Obligations:

[serial 3110]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
  What for:   normalization of [serial 3103]


Done making obligation 105
step:  424
#[serial 1881]   normalization of [serial 1874]
step:  425
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 3110]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 3103]

Has substituted Assertions' predicates for labels to get:

[serial 3171]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels in postconditions [serial 3110]

. . . done Substituting Assertions for Labels [26.6 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 3171]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels in postconditions [serial 3110]


Done substituting Assertion labels in postconditions.
step:  426
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3171]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in postconditions [serial 3110]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3173]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
  What for:   normalization of [serial 3171]

. . . done Normalizing Unsolved Proof Obligations [26.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 3173]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
  What for:   normalization of [serial 3171]


Done Normalizing
step:  427
****completely distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 3173]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 3171]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 3175]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [294]->
Q [15] << ((Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3173]

. . . done spltting timed atoms  [26.6 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [26.6 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3175]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [294]->
Q [15] << ((Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3173]

  Normalization Axioms:

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3177]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
  What for:   normalization of [serial 3175]

. . . done Normalizing Unsolved Proof Obligations [26.6 seconds ]
After "completely distribute ^ and @" round 0 remaining 
Obligations:

[serial 3177]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
  What for:   normalization of [serial 3175]


Done completely distributing ^ and @, round 0.
Distributing carets . .

This Proof Obligation:

[serial 3177]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 3175]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 3179]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3177]

. . . done spltting timed atoms  [26.6 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [26.6 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3179]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << (Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3177]

  Normalization Axioms:

    Literal Arithmetic

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3181]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for:   normalization of [serial 3179]

. . . done Normalizing Unsolved Proof Obligations [26.6 seconds ]
After "completely distribute ^ and @" round 1 remaining 
Obligations:

[serial 3181]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for:   normalization of [serial 3179]


Done completely distributing ^ and @, round 1.
Distributing carets . .

This Proof Obligation:

[serial 3181]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 3179]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 3183]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) and 
(((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3181]

. . . done spltting timed atoms  [26.6 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [26.6 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3183]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) and 
(((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1)) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3181]

  Normalization Axioms:

    Literal Arithmetic

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Constants are always the same
Has been normalized to get:

[serial 3185]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 3183]

. . . done Normalizing Unsolved Proof Obligations [26.6 seconds ]
After "completely distribute ^ and @" round 2 remaining 
Obligations:

[serial 3185]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 3183]


Done completely distributing ^ and @, round 2.
Distributing carets . .

This Proof Obligation:

[serial 3185]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 3183]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 3187]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3185]

. . . done spltting timed atoms  [26.6 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [26.6 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [26.6 seconds ]
After "completely distribute ^ and @" round 3 remaining 
Obligations:

[serial 3187]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3185]


Done completely distributing ^ and @, round 3.
Distributing carets . .
. . . done spltting timed atoms  [26.6 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [26.6 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [26.6 seconds ]
step:  428
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3187]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3185]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3190]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Associativity: (b.c).a = a.b.c [serial 3187]

. . . done Applying Laws [26.6 seconds ]
After "laws" remaining 
Obligations:

[serial 3190]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
  What for: Associativity: (b.c).a = a.b.c [serial 3187]


Done applying laws
step:  429
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3190]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
Reason:  Identity (id):  P->P is tautology
  What for: Associativity: (b.c).a = a.b.c [serial 3187]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [26.6 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 3148]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  430
#[serial 1924] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1899]
step:  431
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 3148]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]

Has substituted Assertions' predicates for labels to get:

[serial 3191]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3148]

. . . done Substituting Assertions for Labels [26.6 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3191]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3148]


Done substituting Assertion labels in preconditions
step:  432
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3191]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3148]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3193]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for:   normalization of [serial 3191]

. . . done Normalizing Unsolved Proof Obligations [26.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 3193]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for:   normalization of [serial 3191]


Done Normalizing
step:  433
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3193]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 3191]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3195]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 3193]

. . . done Applying Laws [26.7 seconds ]
After "laws" remaining 
Obligations:

[serial 3195]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [1] << 0 <= ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 3193]


Done applying laws
step:  434
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3195]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [1] << 0 <= ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Associativity: (b.c).a = a.b.c [serial 3193]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [26.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 3149]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [416] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  435
#[serial 1925] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1899]
step:  436
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 3149]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [416] << DESIRED_POSITION <= #PCS::MaxPosition >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]

Has substituted Assertions' predicates for labels to get:

[serial 3196]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [416] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3149]

. . . done Substituting Assertions for Labels [26.7 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3196]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [416] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3149]


Done substituting Assertion labels in preconditions
step:  437
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3196]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [416] << DESIRED_POSITION <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3149]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3198]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [416] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3196]

. . . done Normalizing Unsolved Proof Obligations [26.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 3198]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [416] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3196]


Done Normalizing
step:  438
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3198]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [416] << DESIRED_POSITION <= #PCS::MaxPosition >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 3196]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3200]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [416] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 3198]

. . . done Applying Laws [26.7 seconds ]
After "laws" remaining 
Obligations:

[serial 3200]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [416] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 3198]


Done applying laws
step:  439
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3200]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [416] << DESIRED_POSITION <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Associativity: (b.c).a = a.b.c [serial 3198]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [26.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 3150]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  440
#[serial 1926] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1899]
step:  441
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 3150]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
Reason:  Assume Present:  P = P@now = P^0 
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]

Has applied Assume Present:  P = P@now = P^0  to get:

[serial 3201]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for: Assume Present:  P = P@now = P^0  [serial 3150]

. . . done replacing P@now and P^0 with P  [26.7 seconds ]
After assuming present remaining 
Obligations:

[serial 3201]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for: Assume Present:  P = P@now = P^0  [serial 3150]


Done assuming present.
step:  442
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 3201]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
Reason:  Substitution of Assertion Labels
  What for: Assume Present:  P = P@now = P^0  [serial 3150]

Has substituted Assertions' predicates for labels to get:

[serial 3202]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3201]

. . . done Substituting Assertions for Labels [26.7 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3202]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3201]


Done substituting Assertion labels in preconditions
step:  443
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3202]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3201]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3204]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3202]

. . . done Normalizing Unsolved Proof Obligations [26.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 3204]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3202]


Done Normalizing
step:  444
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3204]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 3202]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3206]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 3204]

. . . done Applying Laws [26.7 seconds ]
After "laws" remaining 
Obligations:

[serial 3206]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 3204]


Done applying laws
step:  445
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3206]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 3204]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3208]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3206]

. . . done Normalizing Unsolved Proof Obligations [26.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 3208]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3206]


Done Normalizing
step:  446
****guided-sub-equals****
guided substitution of equals "EstimatedActualPosition" . . .
equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 3208]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 3206]

Has substituted 
"EstimatedActualPosition" with its = "ACTUAL_POSITION"
 to get:

[serial 3210]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << ((ACTUAL_POSITION + DESIRED_POSITION) - ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3208]

. . . done guided substitution of equals  [26.7 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3210]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << ((ACTUAL_POSITION + DESIRED_POSITION) - ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3208]


Done guided substituting an equals
step:  447
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3210]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << ((ACTUAL_POSITION + DESIRED_POSITION) - ACTUAL_POSITION) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3208]

  Normalization Axioms:

    Subtaction of Added Value:  (a+b)-a is b

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 3212]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3210]

. . . done Normalizing Unsolved Proof Obligations [26.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 3212]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << DESIRED_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3210]


Done Normalizing
step:  448
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3212]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [418] << DESIRED_POSITION <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 3210]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [26.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 3151]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  449
#[serial 1927] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1899]
step:  450
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 3151]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) >>
Reason:  Assume Present:  P = P@now = P^0 
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]

Has applied Assume Present:  P = P@now = P^0  to get:

[serial 3214]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
  What for: Assume Present:  P = P@now = P^0  [serial 3151]

. . . done replacing P@now and P^0 with P  [26.7 seconds ]
After assuming present remaining 
Obligations:

[serial 3214]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
  What for: Assume Present:  P = P@now = P^0  [serial 3151]


Done assuming present.
step:  451
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 3214]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
Reason:  Substitution of Assertion Labels
  What for: Assume Present:  P = P@now = P^0  [serial 3151]

Has substituted Assertions' predicates for labels to get:

[serial 3215]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3214]

. . . done Substituting Assertions for Labels [26.7 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3215]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3214]


Done substituting Assertion labels in preconditions
step:  452
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3215]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3214]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3217]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
  What for:   normalization of [serial 3215]

. . . done Normalizing Unsolved Proof Obligations [26.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 3217]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
  What for:   normalization of [serial 3215]


Done Normalizing
step:  453
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3217]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 3215]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3219]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
  What for: Associativity: (b.c).a = a.b.c [serial 3217]

. . . done Applying Laws [26.7 seconds ]
After "laws" remaining 
Obligations:

[serial 3219]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
  What for: Associativity: (b.c).a = a.b.c [serial 3217]


Done applying laws
step:  454
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3219]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 3217]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3221]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
  What for:   normalization of [serial 3219]

. . . done Normalizing Unsolved Proof Obligations [26.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 3221]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
  What for:   normalization of [serial 3219]


Done Normalizing
step:  455
****guided-sub-equals****
guided substitution of equals "EstimatedActualPosition" . . .
equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 3221]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 3219]

Has substituted 
"EstimatedActualPosition" with its = "ACTUAL_POSITION"
 to get:

[serial 3223]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3221]

. . . done guided substitution of equals  [26.7 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3223]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3221]


Done guided substituting an equals
step:  456
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3223]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3221]

  Normalization Axioms:

    Subtaction of Added Value:  (a+b)-a is b

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 3225]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 3223]

. . . done Normalizing Unsolved Proof Obligations [26.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 3225]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = DESIRED_POSITION >>
  What for:   normalization of [serial 3223]


Done Normalizing
step:  457
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3225]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << DESIRED_POSITION = DESIRED_POSITION >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 3223]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 3227]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 3225]

. . . done Applying Laws [26.7 seconds ]
After "laws" remaining 
Obligations:

[serial 3227]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 3225]


Done applying laws
step:  458
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3227]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [414] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 3225]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [26.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 3152]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << (DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  459
#[serial 1928] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1899]
step:  460
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 3152]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << (DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) >>
Reason:  Assume Present:  P = P@now = P^0 
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]

Has applied Assume Present:  P = P@now = P^0  to get:

[serial 3228]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
  What for: Assume Present:  P = P@now = P^0  [serial 3152]

. . . done replacing P@now and P^0 with P  [26.7 seconds ]
After assuming present remaining 
Obligations:

[serial 3228]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
  What for: Assume Present:  P = P@now = P^0  [serial 3152]


Done assuming present.
step:  461
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 3228]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
Reason:  Substitution of Assertion Labels
  What for: Assume Present:  P = P@now = P^0  [serial 3152]

Has substituted Assertions' predicates for labels to get:

[serial 3229]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3228]

. . . done Substituting Assertions for Labels [26.7 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3229]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3228]


Done substituting Assertion labels in preconditions
step:  462
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3229]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3228]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3231]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
  What for:   normalization of [serial 3229]

. . . done Normalizing Unsolved Proof Obligations [26.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 3231]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
  What for:   normalization of [serial 3229]


Done Normalizing
step:  463
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3231]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 3229]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3233]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
  What for: Associativity: (b.c).a = a.b.c [serial 3231]

. . . done Applying Laws [26.7 seconds ]
After "laws" remaining 
Obligations:

[serial 3233]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
  What for: Associativity: (b.c).a = a.b.c [serial 3231]


Done applying laws
step:  464
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3233]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 3231]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3235]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
  What for:   normalization of [serial 3233]

. . . done Normalizing Unsolved Proof Obligations [26.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 3235]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
  What for:   normalization of [serial 3233]


Done Normalizing
step:  465
****guided-sub-equals****
guided substitution of equals "EstimatedActualPosition" . . .
equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 3235]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 3233]

Has substituted 
"EstimatedActualPosition" with its = "ACTUAL_POSITION"
 to get:

[serial 3237]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3235]

. . . done guided substitution of equals  [26.8 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3237]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3235]


Done guided substituting an equals
step:  466
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3237]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - ACTUAL_POSITION) >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3235]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 3238]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 3237]

. . . done Applying Laws [26.8 seconds ]
After "laws" remaining 
Obligations:

[serial 3238]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 3237]


Done applying laws
step:  467
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3238]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [415] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 3237]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [26.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 3153]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [417] << AXIOM_LTK(z:ACTUAL_POSITION,k:(EstimatedActualPosition - DESIRED_POSITION^0)) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  468
#[serial 1929] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1899]
step:  469
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 3153]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [417] << AXIOM_LTK(z:ACTUAL_POSITION,k:(EstimatedActualPosition - DESIRED_POSITION^0)) >>
Reason:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]

has been transformed into:

[serial 3239]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [417] << true >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


by removing axioms from postconditions.

. . . done removing axioms from postconditions  [26.8 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 3239]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [417] << true >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 



Done removing axioms from postconditions
step:  470
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3239]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413]->
Q [417] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [26.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 3156]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3132]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  471
#[serial 1932] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1903]
step:  472
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  (ACTUAL_POSITION + Delta) = ACTUAL_POSITION'

This Proof Obligation:

[serial 3156]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [1] << 0 <= ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3132]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 3240]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3156]

. . . done guided substitution of equals  [26.8 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3240]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3156]


Done guided substituting an equals
step:  473
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3240]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3156]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 3242]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 3240]

. . . done Normalizing Unsolved Proof Obligations [26.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 3242]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 3240]


Done Normalizing
step:  474
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3242]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 3240]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [26.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 3157]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [428] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3132]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  475
#[serial 1933] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1903]
step:  476
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  (ACTUAL_POSITION + Delta) = ACTUAL_POSITION'

This Proof Obligation:

[serial 3157]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [428] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3132]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 3244]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [428] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3157]

. . . done guided substitution of equals  [26.8 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3244]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [428] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3157]


Done guided substituting an equals
step:  477
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3244]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [428] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3157]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 3246]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [428] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3244]

. . . done Normalizing Unsolved Proof Obligations [26.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 3246]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [428] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3244]


Done Normalizing
step:  478
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3246]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [428] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 3244]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [26.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 3158]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [427] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3132]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  479
#[serial 1934] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1903]
step:  480
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  (ACTUAL_POSITION + Delta) = ACTUAL_POSITION'

This Proof Obligation:

[serial 3158]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [427] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3132]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 3248]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [427] << Delta = (((ACTUAL_POSITION + Delta)) - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3158]

. . . done guided substitution of equals  [26.8 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3248]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [427] << Delta = (((ACTUAL_POSITION + Delta)) - ACTUAL_POSITION) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3158]


Done guided substituting an equals
step:  481
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3248]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [427] << Delta = (((ACTUAL_POSITION + Delta)) - ACTUAL_POSITION) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3158]

  Normalization Axioms:

    Subtaction of Added Value:  (a+b)-a is b

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 3250]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [427] << Delta = Delta >>
  What for:   normalization of [serial 3248]

. . . done Normalizing Unsolved Proof Obligations [26.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 3250]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [427] << Delta = Delta >>
  What for:   normalization of [serial 3248]


Done Normalizing
step:  482
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3250]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [427] << Delta = Delta >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 3248]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 3252]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [427] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 3250]

. . . done Applying Laws [26.8 seconds ]
After "laws" remaining 
Obligations:

[serial 3252]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [427] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 3250]


Done applying laws
step:  483
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3252]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [427] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 3250]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [26.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 3159]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [426] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3132]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  484
#[serial 1935] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1903]
step:  485
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  (ACTUAL_POSITION + Delta) = ACTUAL_POSITION'

This Proof Obligation:

[serial 3159]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [426] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3132]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 3253]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [426] << (Delta + EstimatedActualPosition) = ((ACTUAL_POSITION + Delta)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3159]

. . . done guided substitution of equals  [26.8 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3253]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [426] << (Delta + EstimatedActualPosition) = ((ACTUAL_POSITION + Delta)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3159]


Done guided substituting an equals
step:  486
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 3253]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425]->
Q [426] << (Delta + EstimatedActualPosition) = ((ACTUAL_POSITION + Delta)) >>
Reason:  Substitution of Assertion Labels
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3159]

Has substituted Assertions' predicates for labels to get:

[serial 3254]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [425]->
Q [426] << (Delta + EstimatedActualPosition) = ((ACTUAL_POSITION + Delta)) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3253]

. . . done Substituting Assertions for Labels [26.8 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3254]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [425]->
Q [426] << (Delta + EstimatedActualPosition) = ((ACTUAL_POSITION + Delta)) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3253]


Done substituting Assertion labels in preconditions
step:  487
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3254]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [425]->
Q [426] << (Delta + EstimatedActualPosition) = ((ACTUAL_POSITION + Delta)) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3253]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3256]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
(0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) >>
S [425]->
Q [426] << (ACTUAL_POSITION + Delta) = (Delta + EstimatedActualPosition) >>
  What for:   normalization of [serial 3254]

. . . done Normalizing Unsolved Proof Obligations [26.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 3256]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
(0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) >>
S [425]->
Q [426] << (ACTUAL_POSITION + Delta) = (Delta + EstimatedActualPosition) >>
  What for:   normalization of [serial 3254]


Done Normalizing
step:  488
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3256]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
(0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) >>
S [425]->
Q [426] << (ACTUAL_POSITION + Delta) = (Delta + EstimatedActualPosition) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 3254]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3258]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 0 <= ACTUAL_POSITION and 
0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [425]->
Q [426] << (ACTUAL_POSITION + Delta) = (Delta + EstimatedActualPosition) >>
  What for: Associativity: (b.c).a = a.b.c [serial 3256]

Law2.removeCommonTermFromAdd:  
^{= 
 ^{( ACTUAL_POSITION )} 
 ^{( EstimatedActualPosition )}}

This Proof Obligation:

[serial 3258]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 0 <= ACTUAL_POSITION and 
0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [425]->
Q [426] << (ACTUAL_POSITION + Delta) = (Delta + EstimatedActualPosition) >>
Reason:  Add both sides of equality:  a=b -> x+a=x+b
  What for: Associativity: (b.c).a = a.b.c [serial 3256]

Has applied law "Add both sides of equality:  a=b -> x+a=x+b" to get:

[serial 3259]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 0 <= ACTUAL_POSITION and 
0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [425]->
Q [426] << (ACTUAL_POSITION) = (EstimatedActualPosition) >>
  What for: Add both sides of equality:  a=b -> x+a=x+b [serial 3258]

. . . done Applying Laws [26.8 seconds ]
After "laws" remaining 
Obligations:

[serial 3259]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 0 <= ACTUAL_POSITION and 
0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [425]->
Q [426] << (ACTUAL_POSITION) = (EstimatedActualPosition) >>
  What for: Add both sides of equality:  a=b -> x+a=x+b [serial 3258]


Done applying laws
step:  489
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3259]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 0 <= ACTUAL_POSITION and 
0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [425]->
Q [426] << (ACTUAL_POSITION) = (EstimatedActualPosition) >>
Reason:  Normalization
  What for: Add both sides of equality:  a=b -> x+a=x+b [serial 3258]

  Normalization Axioms:

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3261]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION + 
Delta) and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [425]->
Q [426] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 3259]

. . . done Normalizing Unsolved Proof Obligations [26.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 3261]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION + 
Delta) and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [425]->
Q [426] << ACTUAL_POSITION = EstimatedActualPosition >>
  What for:   normalization of [serial 3259]


Done Normalizing
step:  490
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3261]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION + 
Delta) and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [425]->
Q [426] << ACTUAL_POSITION = EstimatedActualPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 3259]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [26.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 3163]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298]->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3142]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  491
#[serial 1939] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1913]
step:  492
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 3163]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298]->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
Reason:  Assume Present:  P = P@now = P^0 
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3142]

Has applied Assume Present:  P = P@now = P^0  to get:

[serial 3263]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for: Assume Present:  P = P@now = P^0  [serial 3163]

. . . done replacing P@now and P^0 with P  [26.8 seconds ]
After assuming present remaining 
Obligations:

[serial 3263]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for: Assume Present:  P = P@now = P^0  [serial 3163]


Done assuming present.
step:  493
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 3263]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
Reason:  Substitution of Assertion Labels
  What for: Assume Present:  P = P@now = P^0  [serial 3163]

Has substituted Assertions' predicates for labels to get:

[serial 3264]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3263]

. . . done Substituting Assertions for Labels [26.8 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3264]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3263]


Done substituting Assertion labels in preconditions
step:  494
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3264]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3263]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3266]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for:   normalization of [serial 3264]

. . . done Normalizing Unsolved Proof Obligations [26.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 3266]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for:   normalization of [serial 3264]


Done Normalizing
step:  495
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3266]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 3264]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3268]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 3266]

. . . done Applying Laws [26.9 seconds ]
After "laws" remaining 
Obligations:

[serial 3268]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 3266]


Done applying laws
step:  496
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3268]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 3266]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3270]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for:   normalization of [serial 3268]

. . . done Normalizing Unsolved Proof Obligations [26.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 3270]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
  What for:   normalization of [serial 3268]


Done Normalizing
step:  497
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION" . . .
equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 3270]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 3268]

Has substituted 
"ACTUAL_POSITION" with its = "EstimatedActualPosition"
 to get:

[serial 3272]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < EstimatedActualPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 3270]

. . . done guided substitution of equals  [26.9 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3272]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < EstimatedActualPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 3270]


Done guided substituting an equals
step:  498
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3272]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [1] << DESIRED_POSITION < EstimatedActualPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 3270]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [26.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 3164]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298]->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3142]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  499
#[serial 1940] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1913]
step:  500
****assume present****
Assume Present P=P^0=P@now

This Proof Obligation:

[serial 3164]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298]->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
Reason:  Assume Present:  P = P@now = P^0 
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3142]

Has applied Assume Present:  P = P@now = P^0  to get:

[serial 3273]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for: Assume Present:  P = P@now = P^0  [serial 3164]

. . . done replacing P@now and P^0 with P  [26.9 seconds ]
After assuming present remaining 
Obligations:

[serial 3273]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for: Assume Present:  P = P@now = P^0  [serial 3164]


Done assuming present.
step:  501
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 3273]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
Reason:  Substitution of Assertion Labels
  What for: Assume Present:  P = P@now = P^0  [serial 3164]

Has substituted Assertions' predicates for labels to get:

[serial 3274]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3273]

. . . done Substituting Assertions for Labels [26.9 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3274]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3273]


Done substituting Assertion labels in preconditions
step:  502
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3274]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3273]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3276]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for:   normalization of [serial 3274]

. . . done Normalizing Unsolved Proof Obligations [26.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 3276]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for:   normalization of [serial 3274]


Done Normalizing
step:  503
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3276]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 3274]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3278]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 3276]

. . . done Applying Laws [26.9 seconds ]
After "laws" remaining 
Obligations:

[serial 3278]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 3276]


Done applying laws
step:  504
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3278]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 3276]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3280]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for:   normalization of [serial 3278]

. . . done Normalizing Unsolved Proof Obligations [26.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 3280]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for:   normalization of [serial 3278]


Done Normalizing
step:  505
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION" . . .
equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 3280]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 3278]

Has substituted 
"ACTUAL_POSITION" with its = "EstimatedActualPosition"
 to get:

[serial 3282]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [410] << (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 3280]

. . . done guided substitution of equals  [26.9 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3282]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [410] << (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 3280]


Done guided substituting an equals
step:  506
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3282]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298]->
Q [410] << (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 3280]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [26.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 3166]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  507
#[serial 1942] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1918]
step:  508
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 3166]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]

Has substituted Assertions' predicates for labels to get:

[serial 3283]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and ((ACTUAL_POSITION < (ACTUAL_POSITION + 
( -Delta))) and (( -Delta) > 0)) and ((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [420]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3166]

. . . done Substituting Assertions for Labels [26.9 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3283]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and ((ACTUAL_POSITION < (ACTUAL_POSITION + 
( -Delta))) and (( -Delta) > 0)) and ((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [420]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3166]


Done substituting Assertion labels in preconditions
step:  509
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3283]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and ((ACTUAL_POSITION < (ACTUAL_POSITION + 
( -Delta))) and (( -Delta) > 0)) and ((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [420]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3166]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)

    Associativity: (b.c).a = a.b.c
Has been normalized to get:

[serial 3285]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and (0 < ( -Delta) and 
ACTUAL_POSITION < (ACTUAL_POSITION - Delta)) >>
S [420]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 3283]

. . . done Normalizing Unsolved Proof Obligations [26.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 3285]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and (0 < ( -Delta) and 
ACTUAL_POSITION < (ACTUAL_POSITION - Delta)) >>
S [420]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 3283]


Done Normalizing
step:  510
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3285]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and (0 < ( -Delta) and 
ACTUAL_POSITION < (ACTUAL_POSITION - Delta)) >>
S [420]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 3283]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3287]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 0 < ( -Delta) and 
ACTUAL_POSITION < (ACTUAL_POSITION - Delta) and 0 <= ACTUAL_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = (ACTUAL_POSITION + 
Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) >>
S [420]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Associativity: (b.c).a = a.b.c [serial 3285]

. . . done Applying Laws [26.9 seconds ]
After "laws" remaining 
Obligations:

[serial 3287]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 0 < ( -Delta) and 
ACTUAL_POSITION < (ACTUAL_POSITION - Delta) and 0 <= ACTUAL_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = (ACTUAL_POSITION + 
Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) >>
S [420]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Associativity: (b.c).a = a.b.c [serial 3285]


Done applying laws
step:  511
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3287]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 0 < ( -Delta) and 
ACTUAL_POSITION < (ACTUAL_POSITION - Delta) and 0 <= ACTUAL_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = (ACTUAL_POSITION + 
Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) >>
S [420]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 3285]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3289]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = (ACTUAL_POSITION + 
Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 0 < ( -Delta) and 
ACTUAL_POSITION < (ACTUAL_POSITION - Delta) >>
S [420]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 3287]

. . . done Normalizing Unsolved Proof Obligations [26.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 3289]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = (ACTUAL_POSITION + 
Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 0 < ( -Delta) and 
ACTUAL_POSITION < (ACTUAL_POSITION - Delta) >>
S [420]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for:   normalization of [serial 3287]


Done Normalizing
step:  512
****guided-sub-equals****
guided substitution of equals "(ACTUAL_POSITION + Delta)" . . .
equality selected for substitution:  DESIRED_POSITION = (ACTUAL_POSITION + Delta)

This Proof Obligation:

[serial 3289]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = (ACTUAL_POSITION + 
Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 0 < ( -Delta) and 
ACTUAL_POSITION < (ACTUAL_POSITION - Delta) >>
S [420]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 3287]

Has substituted 
"(ACTUAL_POSITION + Delta)" with its = "DESIRED_POSITION"
 to get:

[serial 3291]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = (ACTUAL_POSITION + 
Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 0 < ( -Delta) and 
ACTUAL_POSITION < (ACTUAL_POSITION - Delta) >>
S [420]->
Q [1] << 0 <= DESIRED_POSITION >>
  What for: Guided Substitution of Equals
 replacing "(ACTUAL_POSITION + Delta)" with its = "DESIRED_POSITION" in its postcondition [serial 3289]

. . . done guided substitution of equals  [26.9 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3291]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = (ACTUAL_POSITION + 
Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 0 < ( -Delta) and 
ACTUAL_POSITION < (ACTUAL_POSITION - Delta) >>
S [420]->
Q [1] << 0 <= DESIRED_POSITION >>
  What for: Guided Substitution of Equals
 replacing "(ACTUAL_POSITION + Delta)" with its = "DESIRED_POSITION" in its postcondition [serial 3289]


Done guided substituting an equals
step:  513
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3291]: ControlSoftware::FragilePositionControlThread.MultiStep
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = (ACTUAL_POSITION + 
Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 0 < ( -Delta) and 
ACTUAL_POSITION < (ACTUAL_POSITION - Delta) >>
S [420]->
Q [1] << 0 <= DESIRED_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Guided Substitution of Equals
 replacing "(ACTUAL_POSITION + Delta)" with its = "DESIRED_POSITION" in its postcondition [serial 3289]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [26.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1038]: ControlSoftware::FragilePositionControlThread.MultiStep
P [431] << ((E_MS() and D_MS() and ACTUAL_IN_RANGE()) and stop@now and not (exists u~time
  in tops,,now 
  that true ) and not (exists u~time
  in tops,,now 
  that stop@u )) >>
S [430]->
Q [300] << (E_MS() and ACTUAL_IN_RANGE()) >>
  What for:  <<M(Run) and x>> -> <<M(ShutDown)>> for ms7stop:Run-[x]->ShutDown{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  514
#[serial 1038]  <<M(Run) and x>> -> <<M(ShutDown)>> for ms7stop:Run-[x]->ShutDown{};
step:  515
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1038]: ControlSoftware::FragilePositionControlThread.MultiStep
P [431] << ((E_MS() and D_MS() and ACTUAL_IN_RANGE()) and stop@now and not (exists u~time
  in tops,,now 
  that true ) and not (exists u~time
  in tops,,now 
  that stop@u )) >>
S [430]->
Q [300] << (E_MS() and ACTUAL_IN_RANGE()) >>
Reason:  Normalization
  What for:  <<M(Run) and x>> -> <<M(ShutDown)>> for ms7stop:Run-[x]->ShutDown{};

  Normalization Axioms:

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3293]: ControlSoftware::FragilePositionControlThread.MultiStep
P [431] << stop@now and not (exists u~time
  in tops,,now 
  that stop@u ) and not (exists u~time
  in tops,,now 
  that true ) and (ACTUAL_IN_RANGE() and D_MS() and E_MS()) >>
S [430]->
Q [300] << ACTUAL_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 1038]

. . . done Normalizing Unsolved Proof Obligations [26.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 3293]: ControlSoftware::FragilePositionControlThread.MultiStep
P [431] << stop@now and not (exists u~time
  in tops,,now 
  that stop@u ) and not (exists u~time
  in tops,,now 
  that true ) and (ACTUAL_IN_RANGE() and D_MS() and E_MS()) >>
S [430]->
Q [300] << ACTUAL_IN_RANGE() and E_MS() >>
  What for:   normalization of [serial 1038]


Done Normalizing
step:  516
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3293]: ControlSoftware::FragilePositionControlThread.MultiStep
P [431] << stop@now and not (exists u~time
  in tops,,now 
  that stop@u ) and not (exists u~time
  in tops,,now 
  that true ) and (ACTUAL_IN_RANGE() and D_MS() and E_MS()) >>
S [430]->
Q [300] << ACTUAL_IN_RANGE() and E_MS() >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 1038]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3295]: ControlSoftware::FragilePositionControlThread.MultiStep
P [431] << ACTUAL_IN_RANGE() and D_MS() and E_MS() and stop@now and not (exists u~time
  in tops,,now 
  that stop@u ) and not (exists u~time
  in tops,,now 
  that true ) >>
S [430]->
Q [300] << ACTUAL_IN_RANGE() and E_MS() >>
  What for: Associativity: (b.c).a = a.b.c [serial 3293]


This Proof Obligation:

[serial 3295]: ControlSoftware::FragilePositionControlThread.MultiStep
P [431] << ACTUAL_IN_RANGE() and D_MS() and E_MS() and stop@now and not (exists u~time
  in tops,,now 
  that stop@u ) and not (exists u~time
  in tops,,now 
  that true ) >>
S [430]->
Q [300] << ACTUAL_IN_RANGE() and E_MS() >>
Reason:  Existential Quantification Introduction
  What for: Associativity: (b.c).a = a.b.c [serial 3293]

Has applied law "Existential Quantification Introduction" to get:

[serial 3296]: ControlSoftware::FragilePositionControlThread.MultiStep
P [431] << ACTUAL_IN_RANGE() and D_MS() and E_MS() and stop@now and not (exists u~time
  in tops,,now 
  that stop@u ) and not (true) >>
S [430]->
Q [300] << ACTUAL_IN_RANGE() and E_MS() >>
  What for: Existential Quantification Introduction [serial 3295]

. . . done Applying Laws [27.0 seconds ]
After "laws" remaining 
Obligations:

[serial 3296]: ControlSoftware::FragilePositionControlThread.MultiStep
P [431] << ACTUAL_IN_RANGE() and D_MS() and E_MS() and stop@now and not (exists u~time
  in tops,,now 
  that stop@u ) and not (true) >>
S [430]->
Q [300] << ACTUAL_IN_RANGE() and E_MS() >>
  What for: Existential Quantification Introduction [serial 3295]


Done applying laws
step:  517
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3296]: ControlSoftware::FragilePositionControlThread.MultiStep
P [431] << ACTUAL_IN_RANGE() and D_MS() and E_MS() and stop@now and not (exists u~time
  in tops,,now 
  that stop@u ) and not (true) >>
S [430]->
Q [300] << ACTUAL_IN_RANGE() and E_MS() >>
Reason:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
  What for: Existential Quantification Introduction [serial 3295]

Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [27.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1039]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << (E_MS() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition = 0))) >>
S [432]->
Q [304] << (ACTUAL_POSITION = 0) >>
  What for:  <<M(ShutDown) and x>> -> <<M(Done)>> for ms8done:ShutDown-[x]->Done{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  518
#[serial 1039]  <<M(ShutDown) and x>> -> <<M(Done)>> for ms8done:ShutDown-[x]->Done{};
step:  519
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1039]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << (E_MS() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition = 0))) >>
S [432]->
Q [304] << (ACTUAL_POSITION = 0) >>
Reason:  Normalization
  What for:  <<M(ShutDown) and x>> -> <<M(Done)>> for ms8done:ShutDown-[x]->Done{};

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3298]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << 0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and E_MS() >>
S [432]->
Q [304] << 0 = ACTUAL_POSITION >>
  What for:   normalization of [serial 1039]

. . . done Normalizing Unsolved Proof Obligations [27.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 3298]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << 0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and E_MS() >>
S [432]->
Q [304] << 0 = ACTUAL_POSITION >>
  What for:   normalization of [serial 1039]


Done Normalizing
step:  520
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 3298]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << 0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and E_MS() >>
S [432]->
Q [304] << 0 = ACTUAL_POSITION >>
Reason:  Substitution of Assertion Labels
  What for:   normalization of [serial 1039]

Has substituted Assertions' predicates for labels to get:

[serial 3300]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << 0 = EstimatedActualPosition and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [432]->
Q [304] << 0 = ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3298]

. . . done Substituting Assertions for Labels [27.0 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3300]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << 0 = EstimatedActualPosition and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [432]->
Q [304] << 0 = ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3298]


Done substituting Assertion labels in preconditions
step:  521
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3300]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << 0 = EstimatedActualPosition and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [432]->
Q [304] << 0 = ACTUAL_POSITION >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3298]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3302]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << 0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [432]->
Q [304] << 0 = ACTUAL_POSITION >>
  What for:   normalization of [serial 3300]

. . . done Normalizing Unsolved Proof Obligations [27.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 3302]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << 0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [432]->
Q [304] << 0 = ACTUAL_POSITION >>
  What for:   normalization of [serial 3300]


Done Normalizing
step:  522
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3302]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << 0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [432]->
Q [304] << 0 = ACTUAL_POSITION >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 3300]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3304]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [432]->
Q [304] << 0 = ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 3302]

. . . done Applying Laws [27.0 seconds ]
After "laws" remaining 
Obligations:

[serial 3304]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [432]->
Q [304] << 0 = ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 3302]


Done applying laws
step:  523
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION" . . .
equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 3304]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [432]->
Q [304] << 0 = ACTUAL_POSITION >>
Reason:  Guided Substitution of Equals
  What for: Associativity: (b.c).a = a.b.c [serial 3302]

Has substituted 
"ACTUAL_POSITION" with its = "EstimatedActualPosition"
 to get:

[serial 3305]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [432]->
Q [304] << 0 = EstimatedActualPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 3304]

. . . done guided substitution of equals  [27.0 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3305]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [432]->
Q [304] << 0 = EstimatedActualPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 3304]


Done guided substituting an equals
step:  524
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3305]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [432]->
Q [304] << 0 = EstimatedActualPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 3304]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [27.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1040]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << (E_MS() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition > 0))) >>
S [436]<< (E_MS() and (ACTUAL_POSITION > 0) and ACTUAL_IN_RANGE()) >>
Delta := -1
<< (E_MS() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= 0) and AXIOM_GT(ACTUAL_POSITION) and (ACTUAL_POSITION <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and ((ACTUAL_POSITION - 1) >= 0) and E_MS() and ((ACTUAL_POSITION - 1) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition - 1)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [302] << (E_MS() and ACTUAL_IN_RANGE())^1 >>
  What for:  <<M(ShutDown) and x>> A <<M(StillClosing)>> for ms9sc:ShutDown-[x]->StillClosing{A};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  525
#[serial 1040]  <<M(ShutDown) and x>> A <<M(StillClosing)>> for ms9sc:ShutDown-[x]->StillClosing{A};
step:  526
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1040]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << (E_MS() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition > 0))) >>
S [436]<< (E_MS() and (ACTUAL_POSITION > 0) and ACTUAL_IN_RANGE()) >>
Delta := -1
<< (E_MS() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= 0) and AXIOM_GT(ACTUAL_POSITION) and (ACTUAL_POSITION <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and ((ACTUAL_POSITION - 1) >= 0) and E_MS() and ((ACTUAL_POSITION - 1) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition - 1)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [302] << (E_MS() and ACTUAL_IN_RANGE())^1 >>
Reason:  Normalization
  What for:  <<M(ShutDown) and x>> A <<M(StillClosing)>> for ms9sc:ShutDown-[x]->StillClosing{A};

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of Greater Than: (a>b) = (b<a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3307]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [436]<< ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
Delta := -1
<< 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and -1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
;
ActuatorCommand(pc:Delta)
<< 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and -1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
;
EstimatedActualPosition' := (EstimatedActualPosition - 1)
<< 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
Q [302] << (ACTUAL_IN_RANGE() and E_MS())^1 >>
  What for:   normalization of [serial 1040]

. . . done Normalizing Unsolved Proof Obligations [27.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 3307]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [436]<< ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
Delta := -1
<< 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and -1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
;
ActuatorCommand(pc:Delta)
<< 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and -1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
;
EstimatedActualPosition' := (EstimatedActualPosition - 1)
<< 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
Q [302] << (ACTUAL_IN_RANGE() and E_MS())^1 >>
  What for:   normalization of [serial 1040]


Done Normalizing
step:  527
****reduce****
This proof obligation:

[serial 3307]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [436]<< ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
Delta := -1
<< 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and -1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
;
ActuatorCommand(pc:Delta)
<< 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and -1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
;
EstimatedActualPosition' := (EstimatedActualPosition - 1)
<< 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
Q [302] << (ACTUAL_IN_RANGE() and E_MS())^1 >>
  What for:   normalization of [serial 1040]

 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P2>> S2 <<Q2>>
 
was reduced to:

[serial 3309]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [300]->
Q [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
  What for: P -> P1 in sequential composition for [serial 3307]


[serial 3310]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [302]->
Q [15] << (ACTUAL_IN_RANGE() and E_MS())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 3307]


[serial 3311]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]Delta := -1
Q [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 3307]


[serial 3312]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]ActuatorCommand(pc:Delta)
Q [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 3307]


[serial 3313]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]EstimatedActualPosition' := (EstimatedActualPosition - 1)
Q [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 3307]

After "reduce composite" remaining proof obligations: 

Obligations:

[serial 3309]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [300]->
Q [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
  What for: P -> P1 in sequential composition for [serial 3307]



[serial 3310]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [302]->
Q [15] << (ACTUAL_IN_RANGE() and E_MS())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 3307]



[serial 3311]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]Delta := -1
Q [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 3307]



[serial 3312]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]ActuatorCommand(pc:Delta)
Q [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 3307]



[serial 3313]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]EstimatedActualPosition' := (EstimatedActualPosition - 1)
Q [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 3307]


done reducing composite actions
step:  528
****atomic****
applying atomic actions . . .
solving assignment on line 437
replacing "Delta" with "-1"
makes:  << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = -1 and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>

This Proof Obligation:

[serial 3311]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]Delta := -1
Q [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for: <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 3307]

Has applied := to get:

[serial 3314]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = -1 and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
  What for: applied wp for assignment [serial 3311]

Creating weakest-precondition predicate transfer for subprogram invocation of "ActuatorCommand".

This Proof Obligation:

[serial 3312]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]ActuatorCommand(pc:Delta)
Q [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
Reason:  Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
  What for: <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 3307]

Used weakest precondition predicate transformation on
+ <<P>> ActuatorCommand(X) <<Q>> to get:

[serial 3315]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and 
E_MS() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 3312]

solving assignment on line 445
replacing "EstimatedActualPosition'" with "(EstimatedActualPosition - 1)"
makes:  << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) >>

This Proof Obligation:

[serial 3313]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]EstimatedActualPosition' := (EstimatedActualPosition - 1)
Q [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
Reason:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
  What for: <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 3307]

Has applied := to get:

[serial 3316]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) >>
  What for: applied wp for assignment [serial 3313]

. . . done applying atomic actions [27.0 seconds ]
After "atomic" remaining 
Obligations:

[serial 3309]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [300]->
Q [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
  What for: P -> P1 in sequential composition for [serial 3307]



[serial 3310]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [302]->
Q [15] << (ACTUAL_IN_RANGE() and E_MS())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 3307]



[serial 3314]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = -1 and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
  What for: applied wp for assignment [serial 3311]



[serial 3315]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and 
E_MS() >>
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 3312]



[serial 3316]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) >>
  What for: applied wp for assignment [serial 3313]


Done reducing atomic actions
step:  529
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3315]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and 
E_MS() >>
Reason:  Normalization
  What for: applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 3312]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3321]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and E_MS() and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 3315]


This Proof Obligation:

[serial 3316]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) >>
Reason:  Normalization
  What for: applied wp for assignment [serial 3313]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 3323]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 3316]

. . . done Normalizing Unsolved Proof Obligations [27.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 3309]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [300]->
Q [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
  What for: P -> P1 in sequential composition for [serial 3307]



[serial 3310]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [302]->
Q [15] << (ACTUAL_IN_RANGE() and E_MS())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 3307]



[serial 3314]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = -1 and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
  What for: applied wp for assignment [serial 3311]



[serial 3321]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and E_MS() and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 3315]



[serial 3323]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 3316]


Done Normalizing
step:  530
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3314]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = -1 and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for: applied wp for assignment [serial 3311]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 3326]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
true and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
  What for: Equality Law (idistr):  a=a <-> true [serial 3314]


This Proof Obligation:

[serial 3321]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and E_MS() and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 3315]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3327]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [442] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and E_MS() >>
  What for: Associativity: (b.c).a = a.b.c [serial 3321]


This Proof Obligation:

[serial 3326]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
true and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
Reason:  Law of And-Simplification:  P and true is P
  What for: Equality Law (idistr):  a=a <-> true [serial 3314]

Has applied law "Law of And-Simplification:  P and true is P" to get:

[serial 3328]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
  What for: Law of And-Simplification:  P and true is P [serial 3326]

. . . done Applying Laws [27.0 seconds ]
After "laws" remaining 
Obligations:

[serial 3309]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [300]->
Q [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
  What for: P -> P1 in sequential composition for [serial 3307]



[serial 3310]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [302]->
Q [15] << (ACTUAL_IN_RANGE() and E_MS())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 3307]



[serial 3323]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 3316]



[serial 3327]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [442] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and E_MS() >>
  What for: Associativity: (b.c).a = a.b.c [serial 3321]



[serial 3328]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
  What for: Law of And-Simplification:  P and true is P [serial 3326]


Done applying laws
step:  531
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3327]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [442] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and E_MS() >>
Reason:  Normalization
  What for: Associativity: (b.c).a = a.b.c [serial 3321]

  Normalization Axiom:

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3333]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [442] << 0 <= (ACTUAL_POSITION - 1) and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and -1 = Delta and E_MS() >>
  What for:   normalization of [serial 3327]

. . . done Normalizing Unsolved Proof Obligations [27.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 3309]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [300]->
Q [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
  What for: P -> P1 in sequential composition for [serial 3307]



[serial 3310]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [302]->
Q [15] << (ACTUAL_IN_RANGE() and E_MS())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 3307]



[serial 3323]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 3316]



[serial 3328]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
  What for: Law of And-Simplification:  P and true is P [serial 3326]



[serial 3333]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [442] << 0 <= (ACTUAL_POSITION - 1) and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and -1 = Delta and E_MS() >>
  What for:   normalization of [serial 3327]


Done Normalizing
step:  532
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 3309]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [300]->
Q [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for: P -> P1 in sequential composition for [serial 3307]

Has split postcondition to get:

[serial 3336]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [300]->
Q [436] << ACTUAL_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3309]


[serial 3337]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [300]->
Q [436] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3309]


[serial 3338]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [300]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3309]


This Proof Obligation:

[serial 3323]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 3316]

Has split postcondition to get:

[serial 3339]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3323]


[serial 3340]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [447] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3323]


[serial 3341]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [446] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3323]


This Proof Obligation:

[serial 3328]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for: Law of And-Simplification:  P and true is P [serial 3326]

Has split postcondition to get:

[serial 3342]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]


[serial 3343]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [439] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]


[serial 3344]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [438] << AXIOM_GT(ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]


[serial 3345]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [438] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]


This Proof Obligation:

[serial 3333]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [442] << 0 <= (ACTUAL_POSITION - 1) and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and -1 = Delta and E_MS() >>
Reason:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
  What for:   normalization of [serial 3327]

Has split postcondition to get:

[serial 3346]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]


[serial 3347]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]


[serial 3348]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [443] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]


[serial 3349]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]


[serial 3350]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [442] << -1 = Delta >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]


[serial 3351]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [443] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]

. . . done splitting postcondition  [27.0 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 3310]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [302]->
Q [15] << (ACTUAL_IN_RANGE() and E_MS())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 3307]



[serial 3336]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [300]->
Q [436] << ACTUAL_IN_RANGE() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3309]



[serial 3337]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [300]->
Q [436] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3309]



[serial 3338]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [300]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3309]



[serial 3339]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3323]



[serial 3340]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [447] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3323]



[serial 3341]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [446] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3323]



[serial 3342]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]



[serial 3343]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [439] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]



[serial 3344]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [438] << AXIOM_GT(ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]



[serial 3345]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [438] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]



[serial 3346]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]



[serial 3347]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]



[serial 3348]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [443] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]



[serial 3349]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]



[serial 3350]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [442] << -1 = Delta >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]



[serial 3351]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [443] << E_MS() >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]


Done splitting postcondition
step:  533
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3336]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [300]->
Q [436] << ACTUAL_IN_RANGE() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3309]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 3337]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [300]->
Q [436] << E_MS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3309]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 3345]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [438] << E_MS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 3346]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 3350]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [442] << -1 = Delta >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 3351]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [443] << E_MS() >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [27.1 seconds ]
After "axioms" remaining 
Obligations:

[serial 3310]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [302]->
Q [15] << (ACTUAL_IN_RANGE() and E_MS())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 3307]



[serial 3338]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [300]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3309]



[serial 3339]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3323]



[serial 3340]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [447] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3323]



[serial 3341]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [446] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3323]



[serial 3342]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]



[serial 3343]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [439] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]



[serial 3344]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [438] << AXIOM_GT(ACTUAL_POSITION) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]



[serial 3347]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]



[serial 3348]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [443] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]



[serial 3349]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]


Done trying to apply axioms
step:  534
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 3344]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [438] << AXIOM_GT(ACTUAL_POSITION) >>
Reason:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]

has been transformed into:

[serial 3352]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [438] << true >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


by removing axioms from postconditions.

. . . done removing axioms from postconditions  [27.1 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 3310]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [302]->
Q [15] << (ACTUAL_IN_RANGE() and E_MS())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 3307]



[serial 3338]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [300]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3309]



[serial 3339]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3323]



[serial 3340]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [447] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3323]



[serial 3341]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [446] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3323]



[serial 3342]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]



[serial 3343]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [439] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]



[serial 3347]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]



[serial 3348]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [443] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]



[serial 3349]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]



[serial 3352]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [438] << true >>
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 



Done removing axioms from postconditions
step:  535
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3352]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [438] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for:  add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 


Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [27.1 seconds ]
After "axioms" remaining 
Obligations:

[serial 3310]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [302]->
Q [15] << (ACTUAL_IN_RANGE() and E_MS())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 3307]



[serial 3338]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [300]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3309]



[serial 3339]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3323]



[serial 3340]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [447] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3323]



[serial 3341]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [446] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3323]



[serial 3342]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]



[serial 3343]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [439] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]



[serial 3347]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]



[serial 3348]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [443] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]



[serial 3349]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]


Done trying to apply axioms
step:  536
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  537
****make-an****
Making obligation 122
Obligations:

[serial 3310]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [302]->
Q [15] << (ACTUAL_IN_RANGE() and E_MS())^1 >>
  What for: Q2 -> Q in sequential composition for [serial 3307]


Done making obligation 122
step:  538
#[serial 2081] Q2 -> Q in sequential composition for [serial 2078]
step:  539
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 3310]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [302]->
Q [15] << (ACTUAL_IN_RANGE() and E_MS())^1 >>
Reason:  Substitution of Assertion Labels
  What for: Q2 -> Q in sequential composition for [serial 3307]

Has substituted Assertions' predicates for labels to get:

[serial 3353]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [302]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels in postconditions [serial 3310]

. . . done Substituting Assertions for Labels [27.1 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 3353]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [302]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
  What for: substituted Assertions' predicates for  labels in postconditions [serial 3310]


Done substituting Assertion labels in postconditions.
step:  540
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3353]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [302]->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in postconditions [serial 3310]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3355]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [302]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
  What for:   normalization of [serial 3353]

. . . done Normalizing Unsolved Proof Obligations [27.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 3355]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [302]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
  What for:   normalization of [serial 3353]


Done Normalizing
step:  541
****completely distribute ^ and @****
Distributing carets . .

This Proof Obligation:

[serial 3355]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [302]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 3353]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 3357]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
(ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [302]->
Q [15] << ((ACTUAL_POSITION = EstimatedActualPosition)^1 and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3355]

. . . done spltting timed atoms  [27.1 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [27.1 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3357]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
(ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [302]->
Q [15] << ((ACTUAL_POSITION = EstimatedActualPosition)^1 and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3355]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 3359]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [302]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
  What for:   normalization of [serial 3357]

. . . done Normalizing Unsolved Proof Obligations [27.1 seconds ]
After "completely distribute ^ and @" round 0 remaining 
Obligations:

[serial 3359]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [302]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
  What for:   normalization of [serial 3357]


Done completely distributing ^ and @, round 0.
Distributing carets . .

This Proof Obligation:

[serial 3359]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [302]->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 3357]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 3361]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [302]->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((0 <= ACTUAL_POSITION)^1 and 
(ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3359]

. . . done spltting timed atoms  [27.1 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [27.1 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3361]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [302]->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((0 <= ACTUAL_POSITION)^1 and 
(ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3359]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 3363]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [302]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and ((0 <= ACTUAL_POSITION)^1 and 
(ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for:   normalization of [serial 3361]

. . . done Normalizing Unsolved Proof Obligations [27.1 seconds ]
After "completely distribute ^ and @" round 1 remaining 
Obligations:

[serial 3363]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [302]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and ((0 <= ACTUAL_POSITION)^1 and 
(ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
  What for:   normalization of [serial 3361]


Done completely distributing ^ and @, round 1.
Distributing carets . .

This Proof Obligation:

[serial 3363]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [302]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and ((0 <= ACTUAL_POSITION)^1 and 
(ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
Reason:  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
  What for:   normalization of [serial 3361]

Has applied Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k to get:

[serial 3365]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [302]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and (((0)^1 <= (ACTUAL_POSITION)^1) and 
((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1)) >>
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3363]

. . . done spltting timed atoms  [27.1 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [27.1 seconds ]
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3365]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [302]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and (((0)^1 <= (ACTUAL_POSITION)^1) and 
((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1)) >>
Reason:  Normalization
  What for: Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3363]

  Normalization Axioms:

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Constants are always the same
Has been normalized to get:

[serial 3367]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [302]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and (0 <= ACTUAL_POSITION^1 and 
ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 3365]

. . . done Normalizing Unsolved Proof Obligations [27.1 seconds ]
After "completely distribute ^ and @" round 2 remaining 
Obligations:

[serial 3367]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [302]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and (0 <= ACTUAL_POSITION^1 and 
ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
  What for:   normalization of [serial 3365]


Done completely distributing ^ and @, round 2.
Distributing carets . .
. . . done spltting timed atoms  [27.1 seconds ]
Distributing @ . .
. . . done spltting timed atoms  [27.1 seconds ]
Normalizing Unsolved Proof Obligations . . .
. . . done Normalizing Unsolved Proof Obligations [27.1 seconds ]
step:  542
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3367]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [302]->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and (0 <= ACTUAL_POSITION^1 and 
ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 3365]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3370]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [302]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
  What for: Associativity: (b.c).a = a.b.c [serial 3367]

. . . done Applying Laws [27.1 seconds ]
After "laws" remaining 
Obligations:

[serial 3370]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [302]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
  What for: Associativity: (b.c).a = a.b.c [serial 3367]


Done applying laws
step:  543
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3370]: ControlSoftware::FragilePositionControlThread.MultiStep
P [446] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [302]->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
Reason:  Identity (id):  P->P is tautology
  What for: Associativity: (b.c).a = a.b.c [serial 3367]

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [27.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 3338]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [300]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3309]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  544
#[serial 2109] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2080]
step:  545
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 3338]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [300]->
Q [1] << 0 < ACTUAL_POSITION >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3309]

Has substituted Assertions' predicates for labels to get:

[serial 3371]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < EstimatedActualPosition >>
S [300]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3338]

. . . done Substituting Assertions for Labels [27.1 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3371]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < EstimatedActualPosition >>
S [300]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3338]


Done substituting Assertion labels in preconditions
step:  546
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3371]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < EstimatedActualPosition >>
S [300]->
Q [1] << 0 < ACTUAL_POSITION >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3338]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3373]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and 0 < EstimatedActualPosition >>
S [300]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 3371]

. . . done Normalizing Unsolved Proof Obligations [27.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 3373]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and 0 < EstimatedActualPosition >>
S [300]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for:   normalization of [serial 3371]


Done Normalizing
step:  547
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3373]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and 0 < EstimatedActualPosition >>
S [300]->
Q [1] << 0 < ACTUAL_POSITION >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 3371]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3375]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < EstimatedActualPosition >>
S [300]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 3373]

. . . done Applying Laws [27.1 seconds ]
After "laws" remaining 
Obligations:

[serial 3375]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < EstimatedActualPosition >>
S [300]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for: Associativity: (b.c).a = a.b.c [serial 3373]


Done applying laws
step:  548
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION" . . .
equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 3375]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < EstimatedActualPosition >>
S [300]->
Q [1] << 0 < ACTUAL_POSITION >>
Reason:  Guided Substitution of Equals
  What for: Associativity: (b.c).a = a.b.c [serial 3373]

Has substituted 
"ACTUAL_POSITION" with its = "EstimatedActualPosition"
 to get:

[serial 3376]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < EstimatedActualPosition >>
S [300]->
Q [1] << 0 < EstimatedActualPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 3375]

. . . done guided substitution of equals  [27.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3376]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < EstimatedActualPosition >>
S [300]->
Q [1] << 0 < EstimatedActualPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 3375]


Done guided substituting an equals
step:  549
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3376]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < EstimatedActualPosition >>
S [300]->
Q [1] << 0 < EstimatedActualPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 3375]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [27.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 3339]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [1] << 0 <= ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3323]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  550
#[serial 2110] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2094]
step:  551
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  (ACTUAL_POSITION + Delta) = ACTUAL_POSITION'

This Proof Obligation:

[serial 3339]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [1] << 0 <= ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3323]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 3377]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3339]

. . . done guided substitution of equals  [27.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3377]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3339]


Done guided substituting an equals
step:  552
****guided-sub-equals****
guided substitution of equals "Delta" . . .
equality selected for substitution:  -1 = Delta

This Proof Obligation:

[serial 3377]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
Reason:  Guided Substitution of Equals
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3339]

Has substituted 
"Delta" with its = "-1"
 to get:

[serial 3378]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [1] << 0 <= ((ACTUAL_POSITION + -1)) >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 3377]

. . . done guided substitution of equals  [27.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3378]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [1] << 0 <= ((ACTUAL_POSITION + -1)) >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 3377]


Done guided substituting an equals
step:  553
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3378]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [1] << 0 <= ((ACTUAL_POSITION + -1)) >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 3377]

  Normalization Axioms:

    Reflexivity of Addition: a+b=b+a

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 3380]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
  What for:   normalization of [serial 3378]

. . . done Normalizing Unsolved Proof Obligations [27.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 3380]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
  What for:   normalization of [serial 3378]


Done Normalizing
step:  554
****change subtraction to adding unary minus****
changing subtraction to adding negation . . .

This Proof Obligation:

[serial 3380]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
Reason:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
  What for:   normalization of [serial 3378]

Has changed subtraction to adding negation to get:

[serial 3382]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION +  -1) and (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition and 
 -1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [1] << 0 <= ( -1 + ACTUAL_POSITION) >>
  What for:  changing adding negation to subtraction  [serial 3380]

. . . done substituting all equals  [27.1 seconds ]
After changing subtraction to adding unary minus remaining 
Obligations:

[serial 3382]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION +  -1) and (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition and 
 -1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [1] << 0 <= ( -1 + ACTUAL_POSITION) >>
  What for:  changing adding negation to subtraction  [serial 3380]


Done changing subtraction to adding unary minus
step:  555
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3382]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION +  -1) and (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition and 
 -1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [1] << 0 <= ( -1 + ACTUAL_POSITION) >>
Reason:  Normalization
  What for:  changing adding negation to subtraction  [serial 3380]

  Normalization Axioms:

    Literal Arithmetic

    Reflexivity of Addition: a+b=b+a

    Reflexivity of Equality: (a=b) = (b=a)

    Unary Minus:  -(x-y) is (y-x)
Has been normalized to get:

[serial 3384]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (-1 + ACTUAL_POSITION) and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
  What for:   normalization of [serial 3382]

. . . done Normalizing Unsolved Proof Obligations [27.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 3384]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (-1 + ACTUAL_POSITION) and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
  What for:   normalization of [serial 3382]


Done Normalizing
step:  556
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3384]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (-1 + ACTUAL_POSITION) and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 3382]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [27.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 3340]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [447] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3323]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  557
#[serial 2111] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2094]
step:  558
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  (ACTUAL_POSITION + Delta) = ACTUAL_POSITION'

This Proof Obligation:

[serial 3340]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [447] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3323]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 3386]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [447] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3340]

. . . done guided substitution of equals  [27.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3386]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [447] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3340]


Done guided substituting an equals
step:  559
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3386]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [447] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3340]

  Normalization Axiom:

    Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 3388]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [447] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3386]

. . . done Normalizing Unsolved Proof Obligations [27.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 3388]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [447] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3386]


Done Normalizing
step:  560
****guided-sub-equals****
guided substitution of equals "Delta" . . .
equality selected for substitution:  -1 = Delta

This Proof Obligation:

[serial 3388]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [447] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 3386]

Has substituted 
"Delta" with its = "-1"
 to get:

[serial 3390]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [447] << (ACTUAL_POSITION + -1) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 3388]

. . . done guided substitution of equals  [27.2 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3390]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [447] << (ACTUAL_POSITION + -1) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 3388]


Done guided substituting an equals
step:  561
****change subtraction to adding unary minus****
changing subtraction to adding negation . . .

This Proof Obligation:

[serial 3390]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [447] << (ACTUAL_POSITION + -1) <= #PCS::MaxPosition >>
Reason:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 3388]

Has changed subtraction to adding negation to get:

[serial 3391]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION +  -1) and (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition and 
 -1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [447] << (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition >>
  What for:  changing adding negation to subtraction  [serial 3390]

. . . done substituting all equals  [27.2 seconds ]
After changing subtraction to adding unary minus remaining 
Obligations:

[serial 3391]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION +  -1) and (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition and 
 -1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [447] << (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition >>
  What for:  changing adding negation to subtraction  [serial 3390]


Done changing subtraction to adding unary minus
step:  562
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3391]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION +  -1) and (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition and 
 -1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [447] << (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for:  changing adding negation to subtraction  [serial 3390]

  Normalization Axioms:

    Literal Arithmetic

    Reflexivity of Equality: (a=b) = (b=a)

    Unary Minus:  -(x-y) is (y-x)
Has been normalized to get:

[serial 3393]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (-1 + ACTUAL_POSITION) and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [447] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3391]

. . . done Normalizing Unsolved Proof Obligations [27.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 3393]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (-1 + ACTUAL_POSITION) and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [447] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3391]


Done Normalizing
step:  563
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3393]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (-1 + ACTUAL_POSITION) and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [447] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   normalization of [serial 3391]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [27.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 3341]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [446] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3323]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  564
#[serial 2112] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2094]
step:  565
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 3341]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445]->
Q [446] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3323]

Has substituted Assertions' predicates for labels to get:

[serial 3395]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [445]->
Q [446] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3341]

. . . done Substituting Assertions for Labels [27.2 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3395]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [445]->
Q [446] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3341]


Done substituting Assertion labels in preconditions
step:  566
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3395]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [445]->
Q [446] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3341]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3397]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445]->
Q [446] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 3395]

. . . done Normalizing Unsolved Proof Obligations [27.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 3397]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445]->
Q [446] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
  What for:   normalization of [serial 3395]


Done Normalizing
step:  567
****guided-sub-equals****
guided substitution of equals "ACTUAL_POSITION'" . . .
equality selected for substitution:  (ACTUAL_POSITION + Delta) = ACTUAL_POSITION'

This Proof Obligation:

[serial 3397]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445]->
Q [446] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 3395]

Has substituted 
"ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))"
 to get:

[serial 3399]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445]->
Q [446] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + Delta)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3397]

. . . done guided substitution of equals  [27.2 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3399]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445]->
Q [446] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + Delta)) >>
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3397]


Done guided substituting an equals
step:  568
****guided-sub-equals****
guided substitution of equals "Delta" . . .
equality selected for substitution:  -1 = Delta

This Proof Obligation:

[serial 3399]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445]->
Q [446] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + Delta)) >>
Reason:  Guided Substitution of Equals
  What for: Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3397]

Has substituted 
"Delta" with its = "-1"
 to get:

[serial 3400]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445]->
Q [446] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + -1)) >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 3399]

. . . done guided substitution of equals  [27.2 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3400]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445]->
Q [446] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + -1)) >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 3399]


Done guided substituting an equals
step:  569
****guided-sub-equals****
guided substitution of equals "EstimatedActualPosition" . . .
equality selected for substitution:  ACTUAL_POSITION = EstimatedActualPosition

This Proof Obligation:

[serial 3400]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445]->
Q [446] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + -1)) >>
Reason:  Guided Substitution of Equals
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 3399]

Has substituted 
"EstimatedActualPosition" with its = "ACTUAL_POSITION"
 to get:

[serial 3401]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445]->
Q [446] << (ACTUAL_POSITION - 1) = ((ACTUAL_POSITION + -1)) >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3400]

. . . done guided substitution of equals  [27.2 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3401]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445]->
Q [446] << (ACTUAL_POSITION - 1) = ((ACTUAL_POSITION + -1)) >>
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3400]


Done guided substituting an equals
step:  570
****change subtraction to adding unary minus****
changing subtraction to adding negation . . .

This Proof Obligation:

[serial 3401]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445]->
Q [446] << (ACTUAL_POSITION - 1) = ((ACTUAL_POSITION + -1)) >>
Reason:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
  What for: Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3400]

Has changed subtraction to adding negation to get:

[serial 3402]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION +  -1) and (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition and 
 -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445]->
Q [446] << (ACTUAL_POSITION +  -1) = ((ACTUAL_POSITION +  -1)) >>
  What for:  changing adding negation to subtraction  [serial 3401]

. . . done substituting all equals  [27.2 seconds ]
After changing subtraction to adding unary minus remaining 
Obligations:

[serial 3402]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION +  -1) and (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition and 
 -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445]->
Q [446] << (ACTUAL_POSITION +  -1) = ((ACTUAL_POSITION +  -1)) >>
  What for:  changing adding negation to subtraction  [serial 3401]


Done changing subtraction to adding unary minus
step:  571
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3402]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (ACTUAL_POSITION +  -1) and (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition and 
 -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445]->
Q [446] << (ACTUAL_POSITION +  -1) = ((ACTUAL_POSITION +  -1)) >>
Reason:  Normalization
  What for:  changing adding negation to subtraction  [serial 3401]

  Normalization Axioms:

    Literal Arithmetic

    Reflexivity of Equality: (a=b) = (b=a)

    Unary Minus:  -(x-y) is (y-x)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3404]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (-1 + ACTUAL_POSITION) and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445]->
Q [446] << (-1 + ACTUAL_POSITION) = (-1 + ACTUAL_POSITION) >>
  What for:   normalization of [serial 3402]

. . . done Normalizing Unsolved Proof Obligations [27.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 3404]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (-1 + ACTUAL_POSITION) and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445]->
Q [446] << (-1 + ACTUAL_POSITION) = (-1 + ACTUAL_POSITION) >>
  What for:   normalization of [serial 3402]


Done Normalizing
step:  572
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3404]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (-1 + ACTUAL_POSITION) and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445]->
Q [446] << (-1 + ACTUAL_POSITION) = (-1 + ACTUAL_POSITION) >>
Reason:  Equality Law (idistr):  a=a <-> true
  What for:   normalization of [serial 3402]

Has applied law "Equality Law (idistr):  a=a <-> true" to get:

[serial 3406]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (-1 + ACTUAL_POSITION) and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445]->
Q [446] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 3404]

. . . done Applying Laws [27.2 seconds ]
After "laws" remaining 
Obligations:

[serial 3406]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (-1 + ACTUAL_POSITION) and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445]->
Q [446] << true >>
  What for: Equality Law (idistr):  a=a <-> true [serial 3404]


Done applying laws
step:  573
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3406]: ControlSoftware::FragilePositionControlThread.MultiStep
P [442] << 0 <= (-1 + ACTUAL_POSITION) and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445]->
Q [446] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for: Equality Law (idistr):  a=a <-> true [serial 3404]

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [27.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 3342]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  574
#[serial 2113] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2099]
step:  575
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 3342]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]

Has substituted Assertions' predicates for labels to get:

[serial 3407]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [437]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3342]

. . . done Substituting Assertions for Labels [27.2 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3407]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [437]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3342]


Done substituting Assertion labels in preconditions
step:  576
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3407]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [437]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3342]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3409]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and 0 < ACTUAL_POSITION >>
S [437]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for:   normalization of [serial 3407]

. . . done Normalizing Unsolved Proof Obligations [27.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 3409]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and 0 < ACTUAL_POSITION >>
S [437]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for:   normalization of [serial 3407]


Done Normalizing
step:  577
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3409]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and 0 < ACTUAL_POSITION >>
S [437]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 3407]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3411]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [437]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for: Associativity: (b.c).a = a.b.c [serial 3409]

. . . done Applying Laws [27.2 seconds ]
After "laws" remaining 
Obligations:

[serial 3411]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [437]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
  What for: Associativity: (b.c).a = a.b.c [serial 3409]


Done applying laws
step:  578
****partial to total order****
Making partial orders into total orders . . .
Making partial orders into total orders . . .

This Proof Obligation:

[serial 3411]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [437]->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
Reason:  Partial Order Law 3:  a <= (b-1)  is  a<b
  What for: Associativity: (b.c).a = a.b.c [serial 3409]

Has applied Partial Order Law 3:  a <= (b-1)  is  a<b (  0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION
) to get:

[serial 3412]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [437]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for:   0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 3411]

. . . done making partial orders into total orders [27.2 seconds ]
After making partial orders into total orders 
Obligations:

[serial 3412]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [437]->
Q [1] << 0 < ACTUAL_POSITION >>
  What for:   0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 3411]


Done making partial orders into total orders
step:  579
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3412]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [437]->
Q [1] << 0 < ACTUAL_POSITION >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:   0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 3411]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [27.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 3343]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [439] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  580
#[serial 2114] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2099]
step:  581
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 3343]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437]->
Q [439] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]

Has substituted Assertions' predicates for labels to get:

[serial 3413]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [437]->
Q [439] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3343]

. . . done Substituting Assertions for Labels [27.2 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3413]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [437]->
Q [439] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3343]


Done substituting Assertion labels in preconditions
step:  582
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3413]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [437]->
Q [439] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3343]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Irreflexivity of At Least: (a>=b) = (b<=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3415]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and 0 < ACTUAL_POSITION >>
S [437]->
Q [439] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3413]

. . . done Normalizing Unsolved Proof Obligations [27.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 3415]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and 0 < ACTUAL_POSITION >>
S [437]->
Q [439] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3413]


Done Normalizing
step:  583
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 3415]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and 0 < ACTUAL_POSITION >>
S [437]->
Q [439] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  Associativity: (b.c).a = a.b.c
  What for:   normalization of [serial 3413]

Has applied law "Associativity: (b.c).a = a.b.c" to get:

[serial 3417]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [437]->
Q [439] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 3415]

. . . done Applying Laws [27.2 seconds ]
After "laws" remaining 
Obligations:

[serial 3417]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [437]->
Q [439] << ACTUAL_POSITION <= #PCS::MaxPosition >>
  What for: Associativity: (b.c).a = a.b.c [serial 3415]


Done applying laws
step:  584
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3417]: ControlSoftware::FragilePositionControlThread.MultiStep
P [436] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [437]->
Q [439] << ACTUAL_POSITION <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: Associativity: (b.c).a = a.b.c [serial 3415]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [27.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 3347]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  585
#[serial 2118] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2104]
step:  586
****guided-sub-equals****
guided substitution of equals "Delta" . . .
equality selected for substitution:  -1 = Delta

This Proof Obligation:

[serial 3347]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
Reason:  Guided Substitution of Equals
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]

Has substituted 
"Delta" with its = "-1"
 to get:

[serial 3418]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [1] << 0 <= (ACTUAL_POSITION + -1) >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 3347]

. . . done guided substitution of equals  [27.2 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3418]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [1] << 0 <= (ACTUAL_POSITION + -1) >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 3347]


Done guided substituting an equals
step:  587
****change subtraction to adding unary minus****
changing subtraction to adding negation . . .

This Proof Obligation:

[serial 3418]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [1] << 0 <= (ACTUAL_POSITION + -1) >>
Reason:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 3347]

Has changed subtraction to adding negation to get:

[serial 3419]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION +  -1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
 -1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [1] << 0 <= (ACTUAL_POSITION +  -1) >>
  What for:  changing adding negation to subtraction  [serial 3418]

. . . done substituting all equals  [27.2 seconds ]
After changing subtraction to adding unary minus remaining 
Obligations:

[serial 3419]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION +  -1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
 -1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [1] << 0 <= (ACTUAL_POSITION +  -1) >>
  What for:  changing adding negation to subtraction  [serial 3418]


Done changing subtraction to adding unary minus
step:  588
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3419]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION +  -1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
 -1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [1] << 0 <= (ACTUAL_POSITION +  -1) >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for:  changing adding negation to subtraction  [serial 3418]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [27.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 3348]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [443] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  589
#[serial 2119] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2104]
step:  590
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 3348]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [443] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]

Has substituted Assertions' predicates for labels to get:

[serial 3420]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and (((ACTUAL_POSITION - 1) < ACTUAL_POSITION)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [441]->
Q [443] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3348]

. . . done Substituting Assertions for Labels [27.2 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3420]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and (((ACTUAL_POSITION - 1) < ACTUAL_POSITION)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [441]->
Q [443] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3348]


Done substituting Assertion labels in preconditions
step:  591
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3420]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and (((ACTUAL_POSITION - 1) < ACTUAL_POSITION)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [441]->
Q [443] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3348]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3422]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [441]->
Q [443] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3420]

. . . done Normalizing Unsolved Proof Obligations [27.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 3422]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [441]->
Q [443] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3420]


Done Normalizing
step:  592
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) < ACTUAL_POSITION -> 0 < ACTUAL_POSITION
Transitivity:  (ACTUAL_POSITION - 1) < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition -> (ACTUAL_POSITION - 1) < #PCS::MaxPosition
Transitivity:  0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition -> 0 < #PCS::MaxPosition

This Proof Obligation:

[serial 3422]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [441]->
Q [443] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for:   normalization of [serial 3420]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 3424]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [441]->
Q [443] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for: Transitivity: x<y and y<z -> x<z [serial 3422]

. . . done adding transitive terms [27.2 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 3424]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [441]->
Q [443] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for: Transitivity: x<y and y<z -> x<z [serial 3422]


Done adding transitive relations
step:  593
****partial to total order****
Making partial orders into total orders . . .
Making partial orders into total orders . . .

This Proof Obligation:

[serial 3424]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [441]->
Q [443] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
Reason:  Partial Order Law 3:  a <= (b-1)  is  a<b
  What for: Transitivity: x<y and y<z -> x<z [serial 3422]

Has applied Partial Order Law 3:  a <= (b-1)  is  a<b (0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION
(ACTUAL_POSITION - 1)<#PCS::MaxPosition  ->  (ACTUAL_POSITION - 1)<=#PCS::MaxPosition
  ) to get:

[serial 3425]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and -1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [441]->
Q [443] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for: 0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION
(ACTUAL_POSITION - 1)<#PCS::MaxPosition  ->  (ACTUAL_POSITION - 1)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 3424]

. . . done making partial orders into total orders [27.2 seconds ]
After making partial orders into total orders 
Obligations:

[serial 3425]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and -1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [441]->
Q [443] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
  What for: 0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION
(ACTUAL_POSITION - 1)<#PCS::MaxPosition  ->  (ACTUAL_POSITION - 1)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 3424]


Done making partial orders into total orders
step:  594
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3425]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and -1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [441]->
Q [443] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: 0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION
(ACTUAL_POSITION - 1)<#PCS::MaxPosition  ->  (ACTUAL_POSITION - 1)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 3424]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [27.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 3349]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  595
#[serial 2120] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2104]
step:  596
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 3349]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  Substitution of Assertion Labels
  What for: Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]

Has substituted Assertions' predicates for labels to get:

[serial 3426]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and (((ACTUAL_POSITION - 1) < ACTUAL_POSITION)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [441]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3349]

. . . done Substituting Assertions for Labels [27.2 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 3426]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and (((ACTUAL_POSITION - 1) < ACTUAL_POSITION)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [441]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3349]


Done substituting Assertion labels in preconditions
step:  597
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3426]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and (((ACTUAL_POSITION - 1) < ACTUAL_POSITION)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [441]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for: substituted Assertions' predicates for  labels in preconditions [serial 3349]

  Normalization Axioms:

    Reflexivity of Equality: (a=b) = (b=a)

    Add Unnecessary Parentheses For No Good Reason: a = (a)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3428]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [441]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3426]

. . . done Normalizing Unsolved Proof Obligations [27.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 3428]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [441]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3426]


Done Normalizing
step:  598
****guided-sub-equals****
guided substitution of equals "Delta" . . .
equality selected for substitution:  -1 = Delta

This Proof Obligation:

[serial 3428]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [441]->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
Reason:  Guided Substitution of Equals
  What for:   normalization of [serial 3426]

Has substituted 
"Delta" with its = "-1"
 to get:

[serial 3430]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [441]->
Q [130] << (ACTUAL_POSITION + -1) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 3428]

. . . done guided substitution of equals  [27.2 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 3430]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [441]->
Q [130] << (ACTUAL_POSITION + -1) <= #PCS::MaxPosition >>
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 3428]


Done guided substituting an equals
step:  599
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) < ACTUAL_POSITION -> 0 < ACTUAL_POSITION
Transitivity:  (ACTUAL_POSITION - 1) < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition -> (ACTUAL_POSITION - 1) < #PCS::MaxPosition
Transitivity:  0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition -> 0 < #PCS::MaxPosition

This Proof Obligation:

[serial 3430]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [441]->
Q [130] << (ACTUAL_POSITION + -1) <= #PCS::MaxPosition >>
Reason:  Transitivity: x<y and y<z -> x<z
  What for: Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 3428]

Has applied Transitivity: x<y and y<z -> x<z to get:

[serial 3431]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [441]->
Q [130] << (ACTUAL_POSITION + -1) <= #PCS::MaxPosition >>
  What for: Transitivity: x<y and y<z -> x<z [serial 3430]

. . . done adding transitive terms [27.2 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 3431]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [441]->
Q [130] << (ACTUAL_POSITION + -1) <= #PCS::MaxPosition >>
  What for: Transitivity: x<y and y<z -> x<z [serial 3430]


Done adding transitive relations
step:  600
****change subtraction to adding unary minus****
changing subtraction to adding negation . . .

This Proof Obligation:

[serial 3431]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [441]->
Q [130] << (ACTUAL_POSITION + -1) <= #PCS::MaxPosition >>
Reason:  Equivlence of negation and subtraction: (a-b) = (a + (-b))
  What for: Transitivity: x<y and y<z -> x<z [serial 3430]

Has changed subtraction to adding negation to get:

[serial 3432]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION +  -1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
 -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
 -1) < ACTUAL_POSITION and 0 < ACTUAL_POSITION and (ACTUAL_POSITION +  -1) < #PCS::MaxPosition and 
0 < #PCS::MaxPosition >>
S [441]->
Q [130] << (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition >>
  What for:  changing adding negation to subtraction  [serial 3431]

. . . done substituting all equals  [27.3 seconds ]
After changing subtraction to adding unary minus remaining 
Obligations:

[serial 3432]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION +  -1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
 -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
 -1) < ACTUAL_POSITION and 0 < ACTUAL_POSITION and (ACTUAL_POSITION +  -1) < #PCS::MaxPosition and 
0 < #PCS::MaxPosition >>
S [441]->
Q [130] << (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition >>
  What for:  changing adding negation to subtraction  [serial 3431]


Done changing subtraction to adding unary minus
step:  601
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 3432]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (ACTUAL_POSITION +  -1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
 -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
 -1) < ACTUAL_POSITION and 0 < ACTUAL_POSITION and (ACTUAL_POSITION +  -1) < #PCS::MaxPosition and 
0 < #PCS::MaxPosition >>
S [441]->
Q [130] << (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition >>
Reason:  Normalization
  What for:  changing adding negation to subtraction  [serial 3431]

  Normalization Axioms:

    Literal Arithmetic

    Reflexivity of Equality: (a=b) = (b=a)

    Unary Minus:  -(x-y) is (y-x)

    Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 3434]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (-1 + ACTUAL_POSITION) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION and 
0 < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION and (
-1 + ACTUAL_POSITION) < #PCS::MaxPosition >>
S [441]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3432]

. . . done Normalizing Unsolved Proof Obligations [27.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 3434]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (-1 + ACTUAL_POSITION) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION and 
0 < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION and (
-1 + ACTUAL_POSITION) < #PCS::MaxPosition >>
S [441]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for:   normalization of [serial 3432]


Done Normalizing
step:  602
****partial to total order****
Making partial orders into total orders . . .
Making partial orders into total orders . . .

This Proof Obligation:

[serial 3434]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 <= (-1 + ACTUAL_POSITION) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION and 
0 < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION and (
-1 + ACTUAL_POSITION) < #PCS::MaxPosition >>
S [441]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
Reason:  Partial Order Law 3:  a <= (b-1)  is  a<b
  What for:   normalization of [serial 3432]

Has applied Partial Order Law 3:  a <= (b-1)  is  a<b (0<=(--1+ACTUAL_POSITION)  is  0<ACTUAL_POSITION
(-1 + ACTUAL_POSITION)<#PCS::MaxPosition  ->  (-1 + ACTUAL_POSITION)<=#PCS::MaxPosition
  ) to get:

[serial 3436]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and -1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 
(-1 + ACTUAL_POSITION) < ACTUAL_POSITION and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
S [441]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for: 0<=(--1+ACTUAL_POSITION)  is  0<ACTUAL_POSITION
(-1 + ACTUAL_POSITION)<#PCS::MaxPosition  ->  (-1 + ACTUAL_POSITION)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 3434]

. . . done making partial orders into total orders [27.3 seconds ]
After making partial orders into total orders 
Obligations:

[serial 3436]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and -1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 
(-1 + ACTUAL_POSITION) < ACTUAL_POSITION and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
S [441]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
  What for: 0<=(--1+ACTUAL_POSITION)  is  0<ACTUAL_POSITION
(-1 + ACTUAL_POSITION)<#PCS::MaxPosition  ->  (-1 + ACTUAL_POSITION)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 3434]


Done making partial orders into total orders
step:  603
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 3436]: ControlSoftware::FragilePositionControlThread.MultiStep
P [438] << 0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and -1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 
(-1 + ACTUAL_POSITION) < ACTUAL_POSITION and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
S [441]->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
Reason:  And Introduction Schema (aisph):  (X and Y)->X
  What for: 0<=(--1+ACTUAL_POSITION)  is  0<ACTUAL_POSITION
(-1 + ACTUAL_POSITION)<#PCS::MaxPosition  ->  (-1 + ACTUAL_POSITION)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 3434]

Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [27.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1041]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << (E_MS() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition < 0))) >>
S [449]->
Q [305] << true >>
  What for:  <<M(ShutDown) and x>> -> <<M(Error)>> for ms10er:ShutDown-[x]->Error{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  604
#[serial 1041]  <<M(ShutDown) and x>> -> <<M(Error)>> for ms10er:ShutDown-[x]->Error{};
step:  605
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1041]: ControlSoftware::FragilePositionControlThread.MultiStep
P [300] << (E_MS() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition < 0))) >>
S [449]->
Q [305] << true >>
Reason:  True Conclusion Schema (tc): P->true
  What for:  <<M(ShutDown) and x>> -> <<M(Error)>> for ms10er:ShutDown-[x]->Error{};

Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [27.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1042]: ControlSoftware::FragilePositionControlThread.MultiStep
P [302] << (E_MS() and ACTUAL_IN_RANGE()) >>
S [451]->
Q [300] << (E_MS() and ACTUAL_IN_RANGE()) >>
  What for:  <<M(StillClosing) and x>> -> <<M(ShutDown)>> for ms11cl:StillClosing-[x]->ShutDown{};


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  606
#[serial 1042]  <<M(StillClosing) and x>> -> <<M(ShutDown)>> for ms11cl:StillClosing-[x]->ShutDown{};
step:  607
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1042]: ControlSoftware::FragilePositionControlThread.MultiStep
P [302] << (E_MS() and ACTUAL_IN_RANGE()) >>
S [451]->
Q [300] << (E_MS() and ACTUAL_IN_RANGE()) >>
Reason:  Identity (id):  P->P is tautology
  What for:  <<M(StillClosing) and x>> -> <<M(ShutDown)>> for ms11cl:StillClosing-[x]->ShutDown{};

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [27.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1059]: PositionSetpoint -> c.PositionSetpoint
P [4] << (PositionSetpoint = DESIRED_POSITION) >>
S [2]->
Q [5] << (PositionSetpoint = DESIRED_POSITION) >>
  What for: Composition of Subcomponents via Directional Connection PositionSetpoint -> c.PositionSetpoint:
 PositionSetpoint -> PositionSetpoint


The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
Main proof script resumed.
step:  8
#connections
step:  9
#[serial 1059]: PositionSetpoint -> c.PositionSetpoint
step:  10
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1059]: PositionSetpoint -> c.PositionSetpoint
P [4] << (PositionSetpoint = DESIRED_POSITION) >>
S [2]->
Q [5] << (PositionSetpoint = DESIRED_POSITION) >>
Reason:  Identity (id):  P->P is tautology
  What for: Composition of Subcomponents via Directional Connection PositionSetpoint -> c.PositionSetpoint:
 PositionSetpoint -> PositionSetpoint

Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [27.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
There are no more unsolved proof obligations.
All proof obligations have been solved.  Q.E.D.
opening proof file "/Applications/osate2_2020-06-master2/Eclipse.app/Contents/MacOS/proof.txt" Sun Mar 07 16:24:25 CST 2021
Theorem (1)                               [serial 1003] 
P [167] << (E() and ACTUAL_IN_RANGE()) >>
S [149] ->
Q [149] << ACTUAL_IN_RANGE() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (2)                               [serial 1004] 
P [159] << (E() and D() and ACTUAL_IN_RANGE()) >>
S [149] ->
Q [149] << ACTUAL_IN_RANGE() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (3)                               [serial 1547] 
P [165] << ACTUAL_IN_RANGE() and E() >>
S [165] ->
Q [165] << true >>
by True Conclusion Schema (tc): P->true


Theorem (4)                               [serial 1545] 
P [165] << ACTUAL_IN_RANGE() and E() >>
S [165] ->
Q [165] << 0 = EstimatedActualPosition or 0 < EstimatedActualPosition or EstimatedActualPosition < 0 >>
by Less than, greater than, or equal:  |-a<b or b<a or a=b
and theorem 3:
Theorem (3) [serial 1547] used for:
  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1545]
 


Theorem (5)                               [serial 1005] 
P [165] << (E() and ACTUAL_IN_RANGE()) >>
S [165] ->
Q [165] << (((EstimatedActualPosition = 0)) or ((EstimatedActualPosition > 0)) or 
((EstimatedActualPosition < 0))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 4:
Theorem (4) [serial 1545] used for:
    normalization of [serial 1005]
 


Theorem (6)                               [serial 1558] 
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161] ->
Q [161] << true >>
by True Conclusion Schema (tc): P->true


Theorem (7)                               [serial 1556] 
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161] ->
Q [161] << (true) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 6:
Theorem (6) [serial 1558] used for:
    normalization of [serial 1556]
 


Theorem (8)                               [serial 1555] 
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161] ->
Q [161] << (true) and (true) >>
by Law of And-Simplification:  P and P is P
and theorem 7:
Theorem (7) [serial 1556] used for:
  Law of And-Simplification:  P and P is P [serial 1555]
 


Theorem (9)                               [serial 1554] 
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161] ->
Q [161] << (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0 or 
(not (DESIRED_POSITION^0 < 0))) and (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0 or 
(not (#PCS::MaxPosition < DESIRED_POSITION^0))) >>
by Law of Excluded Middle: P or not P is tautology
and theorem 8:
Theorem (8) [serial 1555] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1554]
 


Theorem (10)                               [serial 1553] 
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161] ->
Q [161] << ((not (DESIRED_POSITION^0 < 0)) or (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0)) and 
((not (#PCS::MaxPosition < DESIRED_POSITION^0)) or (DESIRED_POSITION^0 < 0 or 
#PCS::MaxPosition < DESIRED_POSITION^0)) >>
by Associativity: (b.c).a = a.b.c
and theorem 9:
Theorem (9) [serial 1554] used for:
  Associativity: (b.c).a = a.b.c [serial 1553]
 


Theorem (11)                               [serial 1552] 
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161] ->
Q [161] << (0 <= DESIRED_POSITION^0 or (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0)) and 
(DESIRED_POSITION^0 <= #PCS::MaxPosition or (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0)) >>
by At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 10:
Theorem (10) [serial 1553] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a) [serial 1552]
 


Theorem (12)                               [serial 1549] 
P [161] << ACTUAL_IN_RANGE() and E() >>
S [161] ->
Q [161] << (0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition) or 
(DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0) >>
by Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 11:
Theorem (11) [serial 1552] used for:
  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and while transforming into
  conjunctive normal form [serial 1549]
 


Theorem (13)                               [serial 1006] 
P [161] << (E() and ACTUAL_IN_RANGE()) >>
S [161] ->
Q [161] << (((((DESIRED_POSITION)^0 >= 0)) and (((DESIRED_POSITION)^0 <= #PCS::MaxPosition))) or 
(((((DESIRED_POSITION)^0 < 0))) or ((((DESIRED_POSITION)^0 > #PCS::MaxPosition))))) >>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 12:
Theorem (12) [serial 1549] used for:
    normalization of [serial 1006]
 


Theorem (14)                               [serial 1007] 
P [157] << (ACTUAL_POSITION = 0) >>
S [157] ->
Q [157] << true >>
by True Conclusion Schema (tc): P->true


Theorem (15)                               [serial 1569] 
P [163] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E() >>
S [163] ->
Q [163] << true >>
by True Conclusion Schema (tc): P->true


Theorem (16)                               [serial 1567] 
P [163] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E() >>
S [163] ->
Q [163] << (true) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 15:
Theorem (15) [serial 1569] used for:
    normalization of [serial 1567]
 


Theorem (17)                               [serial 1566] 
P [163] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E() >>
S [163] ->
Q [163] << (true) and (true) >>
by Law of And-Simplification:  P and P is P
and theorem 16:
Theorem (16) [serial 1567] used for:
  Law of And-Simplification:  P and P is P [serial 1566]
 


Theorem (18)                               [serial 1565] 
P [163] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E() >>
S [163] ->
Q [163] << (DESIRED_POSITION^0 < (1 + EstimatedActualPosition) or (not ((EstimatedActualPosition - 1) < DESIRED_POSITION^0)) or 
(not (DESIRED_POSITION^0 < (1 + EstimatedActualPosition))) or DESIRED_POSITION^0 = EstimatedActualPosition) and 
((EstimatedActualPosition - 1) < DESIRED_POSITION^0 or (not ((EstimatedActualPosition - 1) < DESIRED_POSITION^0)) or 
(not (DESIRED_POSITION^0 < (1 + EstimatedActualPosition))) or DESIRED_POSITION^0 = EstimatedActualPosition) >>
by Law of Excluded Middle: P or not P is tautology
and theorem 17:
Theorem (17) [serial 1566] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1565]
 


Theorem (19)                               [serial 1564] 
P [163] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E() >>
S [163] ->
Q [163] << (DESIRED_POSITION^0 < (1 + EstimatedActualPosition) or DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) or 
(1 + EstimatedActualPosition) <= DESIRED_POSITION^0 or DESIRED_POSITION^0 = EstimatedActualPosition) and 
((EstimatedActualPosition - 1) < DESIRED_POSITION^0 or DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) or 
(1 + EstimatedActualPosition) <= DESIRED_POSITION^0 or DESIRED_POSITION^0 = EstimatedActualPosition) >>
by At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 18:
Theorem (18) [serial 1565] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a) [serial 1564]
 


Theorem (20)                               [serial 1561] 
P [163] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E() >>
S [163] ->
Q [163] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) or (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 or 
DESIRED_POSITION^0 = EstimatedActualPosition or (DESIRED_POSITION^0 < (1 + 
EstimatedActualPosition) and (EstimatedActualPosition - 1) < DESIRED_POSITION^0) >>
by Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 19:
Theorem (19) [serial 1564] used for:
  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and while transforming into
  conjunctive normal form [serial 1561]
 


Theorem (21)                               [serial 1008] 
P [163] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
S [163] ->
Q [163] << ((((DESIRED_POSITION)^0 = EstimatedActualPosition)) or (((EstimatedActualPosition + 
1) <= (DESIRED_POSITION)^0)) or (((DESIRED_POSITION)^0 <= (EstimatedActualPosition - 1))) or 
((((DESIRED_POSITION)^0 > (EstimatedActualPosition - 1))) and (((EstimatedActualPosition + 
1) > (DESIRED_POSITION)^0)))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 20:
Theorem (20) [serial 1561] used for:
    normalization of [serial 1008]
 


Theorem (22)                               [serial 1603] 
P [157] << 0 = ACTUAL_POSITION >>
S [157] ->
Q [15] << 0 = ACTUAL_POSITION >>
by Identity (id):  P->P is tautology


Theorem (23)                               [serial 1597] 
P [157] << 0 = ACTUAL_POSITION >>
S [157] ->
Q [15] << (0 = ACTUAL_POSITION) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 22:
Theorem (22) [serial 1603] used for:
    normalization of [serial 1597]
 


Theorem (24)                               [serial 1595] 
P [157] << 0 = ACTUAL_POSITION >>
S [157] ->
Q [15] << 0 = ACTUAL_POSITION and true >>
by Law of And-Simplification:  P and true is P
and theorem 23:
Theorem (23) [serial 1597] used for:
  Law of And-Simplification:  P and true is P [serial 1595]
 


Theorem (25)                               [serial 1603] 
P [157] << 0 = ACTUAL_POSITION >>
S [157] ->
Q [15] << 0 = ACTUAL_POSITION >>
by Identity (id):  P->P is tautology


Theorem (26)                               [serial 1597] 
P [157] << 0 = ACTUAL_POSITION >>
S [157] ->
Q [15] << (0 = ACTUAL_POSITION) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 25:
Theorem (25) [serial 1603] used for:
    normalization of [serial 1597]
 


Theorem (27)                               [serial 1595] 
P [157] << 0 = ACTUAL_POSITION >>
S [157] ->
Q [15] << 0 = ACTUAL_POSITION and true >>
by Law of And-Simplification:  P and true is P
and theorem 26:
Theorem (26) [serial 1597] used for:
  Law of And-Simplification:  P and true is P [serial 1595]
 


Theorem (28)                               [serial 1579] 
P [157] << 0 = ACTUAL_POSITION >>
S [157] ->
Q [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 27 27:
Theorem (27) [serial 1595] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (27) [serial 1595] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (29)                               [serial 1571] 
P [157] << (ACTUAL_POSITION = 0) >>
S [157] ->
Q [15] << (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 28:
Theorem (28) [serial 1579] used for:
    normalization of [serial 1571]
 


Theorem (30)                               [serial 1660] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159] ->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by Identity (id):  P->P is tautology


Theorem (31)                               [serial 1656] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159] ->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 30:
Theorem (30) [serial 1660] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1656]
 


Theorem (32)                               [serial 1648] 
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159] ->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1))) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Constants are always the same
and theorem 31:
Theorem (31) [serial 1656] used for:
    normalization of [serial 1648]
 


Theorem (33)                               [serial 1647] 
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159] ->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 32:
Theorem (32) [serial 1648] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1647]
 


Theorem (34)                               [serial 1646] 
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159] ->
Q [15] << ((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1 and 
(Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 33:
Theorem (33) [serial 1647] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1646]
 


Theorem (35)                               [serial 1642] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159] ->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 34:
Theorem (34) [serial 1646] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1642]
 


Theorem (36)                               [serial 1611] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159] ->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
by Associativity: (b.c).a = a.b.c
and theorem 35:
Theorem (35) [serial 1642] used for:
  Associativity: (b.c).a = a.b.c [serial 1611]
 


Theorem (37)                               [serial 1606] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159] ->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 36:
Theorem (36) [serial 1611] used for:
    normalization of [serial 1606]
 


Theorem (38)                               [serial 1581] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159] ->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
by Substitution of Assertion Labels
and theorem 37:
Theorem (37) [serial 1606] used for:
  substituted Assertions' predicates for  labels  [serial 1581]
 


Theorem (39)                               [serial 1572] 
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [159] ->
Q [15] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 38:
Theorem (38) [serial 1581] used for:
    normalization of [serial 1572]
 


Theorem (40)                               [serial 1665] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174] ->
Q [1] << true >>
by True Conclusion Schema (tc): P->true


Theorem (41)                               [serial 1661] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174] ->
Q [1] << 0 <= 0 >>
by Partial Order Law 1:  a<=a by definition
and theorem 40:
Theorem (40) [serial 1665] used for:
  Partial Order Law 1:  a<=a by definition [serial 1661]
 


Theorem (42)                               [serial 1626] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by Substitution in Postcondition of All Equivalents in Precondition
and theorem 41:
Theorem (41) [serial 1661] used for:
  Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1626]
 


Theorem (43)                               [serial 1662] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174] ->
Q [130] << 0 <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (44)                               [serial 1627] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174] ->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Substitution in Postcondition of All Equivalents in Precondition
and theorem 43:
Theorem (43) [serial 1662] used for:
  Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1627]
 


Theorem (45)                               [serial 1628] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174] ->
Q [175] << 0 = ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (46)                               [serial 1615] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [174] ->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 42 44 45:
Theorem (42) [serial 1626] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]
 
Theorem (44) [serial 1627] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]
 
Theorem (45) [serial 1628] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1615]
 


Theorem (47)                               [serial 1608] 
P [15] << 0 = ACTUAL_POSITION and ((0 <= #PCS::MaxPosition)) >>
S [174] ->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 46:
Theorem (46) [serial 1615] used for:
    normalization of [serial 1608]
 


Theorem (48)                               [serial 1594] 
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [174] ->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
by Substitution of Assertion Labels
and theorem 47:
Theorem (47) [serial 1608] used for:
  substituted Assertions' predicates for  labels  [serial 1594]
 


Theorem (49)                               [serial 1593] 
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [174] ->
Q [15] << 0 = ACTUAL_POSITION and (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
by Associativity: (b.c).a = a.b.c
and theorem 48:
Theorem (48) [serial 1594] used for:
  Associativity: (b.c).a = a.b.c [serial 1593]
 


Theorem (50)                               [serial 1583] 
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [174] ActuatorCommand(pc:0)
Q [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
by Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
and theorem 49:
Theorem (49) [serial 1593] used for:
  applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1583]
 


Theorem (51)                               [serial 1573] 
P [15] << (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
S [174] ActuatorCommand(pc:0)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 50:
Theorem (50) [serial 1583] used for:
    normalization of [serial 1573]
 


Theorem (52)                               [serial 1619] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177] ->
Q [178] << 0 = ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (53)                               [serial 1643] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177] ->
Q [179] << true >>
by True Conclusion Schema (tc): P->true


Theorem (54)                               [serial 1637] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177] ->
Q [179] << 0 = 0 >>
by Equality Law (idistr):  a=a <-> true
and theorem 53:
Theorem (53) [serial 1643] used for:
  Equality Law (idistr):  a=a <-> true [serial 1637]
 


Theorem (55)                               [serial 1629] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177] ->
Q [179] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Subtraction of Same:  a-a is 0
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 54:
Theorem (54) [serial 1637] used for:
    normalization of [serial 1629]
 


Theorem (56)                               [serial 1620] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177] ->
Q [179] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Guided Substitution of Equals
and theorem 55:
Theorem (55) [serial 1629] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1620]
 


Theorem (57)                               [serial 1621] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177] ->
Q [178] << ACTUAL_POSITION = ACTUAL_POSITION' >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (58)                               [serial 1598] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177] ->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 52 56 57:
Theorem (52) [serial 1619] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1598]
 
Theorem (56) [serial 1620] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1598]
 
Theorem (57) [serial 1621] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1598]
 


Theorem (59)                               [serial 1596] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177] ->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' and true >>
by Law of And-Simplification:  P and true is P
and theorem 58:
Theorem (58) [serial 1598] used for:
  Law of And-Simplification:  P and true is P [serial 1596]
 


Theorem (60)                               [serial 1619] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177] ->
Q [178] << 0 = ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (61)                               [serial 1643] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177] ->
Q [179] << true >>
by True Conclusion Schema (tc): P->true


Theorem (62)                               [serial 1637] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177] ->
Q [179] << 0 = 0 >>
by Equality Law (idistr):  a=a <-> true
and theorem 61:
Theorem (61) [serial 1643] used for:
  Equality Law (idistr):  a=a <-> true [serial 1637]
 


Theorem (63)                               [serial 1629] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177] ->
Q [179] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Subtraction of Same:  a-a is 0
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 62:
Theorem (62) [serial 1637] used for:
    normalization of [serial 1629]
 


Theorem (64)                               [serial 1620] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177] ->
Q [179] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Guided Substitution of Equals
and theorem 63:
Theorem (63) [serial 1629] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1620]
 


Theorem (65)                               [serial 1621] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177] ->
Q [178] << ACTUAL_POSITION = ACTUAL_POSITION' >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (66)                               [serial 1598] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177] ->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 60 64 65:
Theorem (60) [serial 1619] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1598]
 
Theorem (64) [serial 1620] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1598]
 
Theorem (65) [serial 1621] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1598]
 


Theorem (67)                               [serial 1596] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177] ->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' and true >>
by Law of And-Simplification:  P and true is P
and theorem 66:
Theorem (66) [serial 1598] used for:
  Law of And-Simplification:  P and true is P [serial 1596]
 


Theorem (68)                               [serial 1585] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [177] ->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' and AXIOM_MPGT0() >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 67 67:
Theorem (67) [serial 1596] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (67) [serial 1596] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (69)                               [serial 1576] 
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
S [177] ->
Q [15] << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(0 = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 68:
Theorem (68) [serial 1585] used for:
    normalization of [serial 1576]
 


Theorem (70)                               [serial 1574] 
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
S [177] Delta := 0
Q [15] << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 69:
Theorem (69) [serial 1576] used for:
  applied wp for assignment [serial 1574]
 


Theorem (71)                               [serial 1666] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181] ->
Q [1] << true >>
by True Conclusion Schema (tc): P->true


Theorem (72)                               [serial 1663] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181] ->
Q [1] << 0 <= 0 >>
by Partial Order Law 1:  a<=a by definition
and theorem 71:
Theorem (71) [serial 1666] used for:
  Partial Order Law 1:  a<=a by definition [serial 1663]
 


Theorem (73)                               [serial 1652] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by Substitution in Postcondition of All Equivalents in Precondition
and theorem 72:
Theorem (72) [serial 1663] used for:
  Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1652]
 


Theorem (74)                               [serial 1644] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = (ACTUAL_POSITION)^1 and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
S [181] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 73:
Theorem (73) [serial 1652] used for:
    normalization of [serial 1644]
 


Theorem (75)                               [serial 1630] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 74:
Theorem (74) [serial 1644] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1630]
 


Theorem (76)                               [serial 1622] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181] ->
Q [1] << 0 <= ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 75:
Theorem (75) [serial 1630] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1622]
 


Theorem (77)                               [serial 1664] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181] ->
Q [184] << 0 <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (78)                               [serial 1654] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [181] ->
Q [184] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Substitution in Postcondition of All Equivalents in Precondition
and theorem 77:
Theorem (77) [serial 1664] used for:
  Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1654]
 


Theorem (79)                               [serial 1645] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = (ACTUAL_POSITION)^1 and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
S [181] ->
Q [184] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 78:
Theorem (78) [serial 1654] used for:
    normalization of [serial 1645]
 


Theorem (80)                               [serial 1631] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181] ->
Q [184] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 79:
Theorem (79) [serial 1645] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1631]
 


Theorem (81)                               [serial 1623] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181] ->
Q [184] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
by Guided Substitution of Equals
and theorem 80:
Theorem (80) [serial 1631] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1623]
 


Theorem (82)                               [serial 1632] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181] ->
Q [182] << 0 = ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (83)                               [serial 1624] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181] ->
Q [182] << 0 = ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 82:
Theorem (82) [serial 1632] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1624]
 


Theorem (84)                               [serial 1625] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181] ->
Q [183] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (85)                               [serial 1613] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [181] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 76 81 83 84:
Theorem (76) [serial 1622] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1613]
 
Theorem (81) [serial 1623] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1613]
 
Theorem (83) [serial 1624] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1613]
 
Theorem (84) [serial 1625] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1613]
 


Theorem (86)                               [serial 1607] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((0 <= #PCS::MaxPosition)) >>
S [181] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 85:
Theorem (85) [serial 1613] used for:
    normalization of [serial 1607]
 


Theorem (87)                               [serial 1587] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [181] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Substitution of Assertion Labels
and theorem 86:
Theorem (86) [serial 1607] used for:
  substituted Assertions' predicates for  labels  [serial 1587]
 


Theorem (88)                               [serial 1577] 
P [15] << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
S [181] ->
Q [15] << ((0 = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 87:
Theorem (87) [serial 1587] used for:
    normalization of [serial 1577]
 


Theorem (89)                               [serial 1575] 
P [15] << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
S [181] EstimatedActualPosition' := 0
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 88:
Theorem (88) [serial 1577] used for:
  applied wp for assignment [serial 1575]
 


Theorem (90)                               [serial 1009] 
P [157] << (ACTUAL_POSITION = 0) >>
S [173] << (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
ActuatorCommand(pc:0)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
;
Delta := 0
<< ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
;
EstimatedActualPosition' := 0
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [159] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 29 39 51 70 89:
Theorem (29) [serial 1571] used for:
  P -> P1 in sequential composition for [serial 1009]
 
Theorem (39) [serial 1572] used for:
  Q2 -> Q in sequential composition for [serial 1009]
 
Theorem (51) [serial 1573] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1009]
 
Theorem (70) [serial 1574] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1009]
 
Theorem (89) [serial 1575] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1009]
 


Theorem (91)                               [serial 1668] 
P [159] << ACTUAL_IN_RANGE() and D() and E() >>
S [186] ->
Q [161] << ACTUAL_IN_RANGE() and E() >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (92)                               [serial 1010] 
P [159] << (E() and D() and ACTUAL_IN_RANGE()) >>
S [186] ->
Q [161] << (E() and ACTUAL_IN_RANGE()) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 91:
Theorem (91) [serial 1668] used for:
    normalization of [serial 1010]
 


Theorem (93)                               [serial 1675] 
P [161] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [187] ->
Q [163] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (94)                               [serial 1674] 
P [161] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) and (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [187] ->
Q [163] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) >>
by Associativity: (b.c).a = a.b.c
and theorem 93:
Theorem (93) [serial 1675] used for:
  Associativity: (b.c).a = a.b.c [serial 1674]
 


Theorem (95)                               [serial 1672] 
P [161] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= DESIRED_POSITION^0 and 
DESIRED_POSITION^0 <= #PCS::MaxPosition) and (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [187] ->
Q [163] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 94:
Theorem (94) [serial 1674] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1672]
 


Theorem (96)                               [serial 1670] 
P [161] << (((EstimatedActualPosition = ACTUAL_POSITION)) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((((DESIRED_POSITION)^0 >= 0)) and 
(((DESIRED_POSITION)^0 <= #PCS::MaxPosition)))) >>
S [187] ->
Q [163] << (((EstimatedActualPosition = ACTUAL_POSITION)) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 95:
Theorem (95) [serial 1672] used for:
    normalization of [serial 1670]
 


Theorem (97)                               [serial 1011] 
P [161] << (E() and ACTUAL_IN_RANGE() and ((((DESIRED_POSITION)^0 >= 0)) and (((DESIRED_POSITION)^0 <= #PCS::MaxPosition)))) >>
S [187] ->
Q [163] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
by Substitution of Assertion Labels
and theorem 96:
Theorem (96) [serial 1670] used for:
  substituted Assertions' predicates for  labels  [serial 1011]
 


Theorem (98)                               [serial 1012] 
P [161] << (E() and ACTUAL_IN_RANGE() and (((((DESIRED_POSITION)^0 < 0))) or ((((DESIRED_POSITION)^0 > #PCS::MaxPosition))))) >>
S [189] ->
Q [170] << true >>
by True Conclusion Schema (tc): P->true


Theorem (99)                               [serial 1745] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (100)                               [serial 1746] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163] ->
Q [25] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (101)                               [serial 1772] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163] ->
Q [193] << true >>
by True Conclusion Schema (tc): P->true


Theorem (102)                               [serial 1771] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163] ->
Q [193] << EstimatedActualPosition = EstimatedActualPosition >>
by Equality Law (idistr):  a=a <-> true
and theorem 101:
Theorem (101) [serial 1772] used for:
  Equality Law (idistr):  a=a <-> true [serial 1771]
 


Theorem (103)                               [serial 1747] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163] ->
Q [193] << ACTUAL_POSITION = DESIRED_POSITION >>
by Substitution in Postcondition of All Equivalents in Precondition
and theorem 102:
Theorem (102) [serial 1771] used for:
  Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1747]
 


Theorem (104)                               [serial 1748] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163] ->
Q [152] << ACTUAL_POSITION = EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (105)                               [serial 1733] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [163] ->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 99 100 103 104:
Theorem (99) [serial 1745] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]
 
Theorem (100) [serial 1746] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]
 
Theorem (103) [serial 1747] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]
 
Theorem (104) [serial 1748] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1733]
 


Theorem (106)                               [serial 1726] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163] ->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 105:
Theorem (105) [serial 1733] used for:
    normalization of [serial 1726]
 


Theorem (107)                               [serial 1711] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163] ->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 106:
Theorem (106) [serial 1726] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1711]
 


Theorem (108)                               [serial 1705] 
P [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
(DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION^0 = EstimatedActualPosition and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [163] ->
Q [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION = DESIRED_POSITION and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 107:
Theorem (107) [serial 1711] used for:
    normalization of [serial 1705]
 


Theorem (109)                               [serial 1700] 
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [163] ->
Q [15] << ACTUAL_POSITION = DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
by Associativity: (b.c).a = a.b.c
and theorem 108:
Theorem (108) [serial 1705] used for:
  Associativity: (b.c).a = a.b.c [serial 1700]
 


Theorem (110)                               [serial 1684] 
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163] ->
Q [15] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E() >>
by Substitution of Assertion Labels
and theorem 109:
Theorem (109) [serial 1700] used for:
  substituted Assertions' predicates for  labels  [serial 1684]
 


Theorem (111)                               [serial 1676] 
P [15] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 = EstimatedActualPosition))) >>
S [163] ->
Q [15] << (E() and (DESIRED_POSITION = ACTUAL_POSITION) and ACTUAL_IN_RANGE()) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 110:
Theorem (110) [serial 1684] used for:
    normalization of [serial 1676]
 


Theorem (112)                               [serial 1758] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159] ->
Q [1] << 0 <= ACTUAL_POSITION^1 >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (113)                               [serial 1759] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159] ->
Q [25] << ACTUAL_POSITION^1 <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (114)                               [serial 1760] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159] ->
Q [152] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (115)                               [serial 1761] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159] ->
Q [154] << Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (116)                               [serial 1744] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159] ->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 112 113 114 115:
Theorem (112) [serial 1758] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1744]
 
Theorem (113) [serial 1759] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1744]
 
Theorem (114) [serial 1760] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1744]
 
Theorem (115) [serial 1761] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1744]
 


Theorem (117)                               [serial 1739] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159] ->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 116:
Theorem (116) [serial 1744] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1739]
 


Theorem (118)                               [serial 1731] 
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159] ->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1))) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Constants are always the same
and theorem 117:
Theorem (117) [serial 1739] used for:
    normalization of [serial 1731]
 


Theorem (119)                               [serial 1730] 
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159] ->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 118:
Theorem (118) [serial 1731] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1730]
 


Theorem (120)                               [serial 1727] 
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159] ->
Q [15] << ((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1 and 
(Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 119:
Theorem (119) [serial 1730] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1727]
 


Theorem (121)                               [serial 1713] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159] ->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 120:
Theorem (120) [serial 1727] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1713]
 


Theorem (122)                               [serial 1706] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159] ->
Q [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 121:
Theorem (121) [serial 1713] used for:
    normalization of [serial 1706]
 


Theorem (123)                               [serial 1701] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159] ->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
by Associativity: (b.c).a = a.b.c
and theorem 122:
Theorem (122) [serial 1706] used for:
  Associativity: (b.c).a = a.b.c [serial 1701]
 


Theorem (124)                               [serial 1686] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159] ->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
by Substitution of Assertion Labels
and theorem 123:
Theorem (123) [serial 1701] used for:
  substituted Assertions' predicates for  labels  [serial 1686]
 


Theorem (125)                               [serial 1677] 
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [159] ->
Q [15] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 124:
Theorem (124) [serial 1686] used for:
    normalization of [serial 1677]
 


Theorem (126)                               [serial 1725] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [194] ->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (127)                               [serial 1719] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [194] ->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
by Law of And-Simplification:  P and P is P
and theorem 126:
Theorem (126) [serial 1725] used for:
  Law of And-Simplification:  P and P is P [serial 1719]
 


Theorem (128)                               [serial 1709] 
P [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION = DESIRED_POSITION and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [194] ->
Q [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 127:
Theorem (127) [serial 1719] used for:
    normalization of [serial 1709]
 


Theorem (129)                               [serial 1704] 
P [15] << ACTUAL_POSITION = DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [194] ->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
by Associativity: (b.c).a = a.b.c
and theorem 128:
Theorem (128) [serial 1709] used for:
  Associativity: (b.c).a = a.b.c [serial 1704]
 


Theorem (130)                               [serial 1699] 
P [15] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E() >>
S [194] ->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_IN_RANGE() and 
E() >>
by Substitution of Assertion Labels
and theorem 129:
Theorem (129) [serial 1704] used for:
  substituted Assertions' predicates for  labels  [serial 1699]
 


Theorem (131)                               [serial 1698] 
P [15] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E() >>
S [194] ->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and ACTUAL_IN_RANGE() and 
E() >>
by Associativity: (b.c).a = a.b.c
and theorem 130:
Theorem (130) [serial 1699] used for:
  Associativity: (b.c).a = a.b.c [serial 1698]
 


Theorem (132)                               [serial 1688] 
P [15] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E() >>
S [194] ActuatorCommand(pc:0)
Q [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E() >>
by Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
and theorem 131:
Theorem (131) [serial 1698] used for:
  applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1688]
 


Theorem (133)                               [serial 1678] 
P [15] << (E() and (DESIRED_POSITION = ACTUAL_POSITION) and ACTUAL_IN_RANGE()) >>
S [194] ActuatorCommand(pc:0)
Q [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E() and ACTUAL_IN_RANGE()) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 132:
Theorem (132) [serial 1688] used for:
    normalization of [serial 1678]
 


Theorem (134)                               [serial 1749] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (135)                               [serial 1750] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197] ->
Q [25] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (136)                               [serial 1770] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197] ->
Q [199] << true >>
by True Conclusion Schema (tc): P->true


Theorem (137)                               [serial 1768] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197] ->
Q [199] << 0 = 0 >>
by Equality Law (idistr):  a=a <-> true
and theorem 136:
Theorem (136) [serial 1770] used for:
  Equality Law (idistr):  a=a <-> true [serial 1768]
 


Theorem (138)                               [serial 1762] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197] ->
Q [199] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Subtraction of Same:  a-a is 0
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 137:
Theorem (137) [serial 1768] used for:
    normalization of [serial 1762]
 


Theorem (139)                               [serial 1751] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197] ->
Q [199] << 0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by Guided Substitution of Equals
and theorem 138:
Theorem (138) [serial 1762] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "ACTUAL_POSITION" in its postcondition [serial 1751]
 


Theorem (140)                               [serial 1752] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197] ->
Q [198] << ACTUAL_POSITION^1 = ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (141)                               [serial 1753] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197] ->
Q [152] << ACTUAL_POSITION = EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (142)                               [serial 1735] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [197] ->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
ACTUAL_POSITION^1 = ACTUAL_POSITION and ACTUAL_POSITION = EstimatedActualPosition >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 134 135 139 140 141:
Theorem (134) [serial 1749] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735]
 
Theorem (135) [serial 1750] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735]
 
Theorem (139) [serial 1751] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735]
 
Theorem (140) [serial 1752] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735]
 
Theorem (141) [serial 1753] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1735]
 


Theorem (143)                               [serial 1728] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = (ACTUAL_POSITION)^1 >>
S [197] ->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and 
ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = (ACTUAL_POSITION)^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 142:
Theorem (142) [serial 1735] used for:
    normalization of [serial 1728]
 


Theorem (144)                               [serial 1715] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [197] ->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 143:
Theorem (143) [serial 1728] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1715]
 


Theorem (145)                               [serial 1707] 
P [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [197] ->
Q [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION = ACTUAL_POSITION' and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 144:
Theorem (144) [serial 1715] used for:
    normalization of [serial 1707]
 


Theorem (146)                               [serial 1702] 
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [197] ->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION = ACTUAL_POSITION' and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
by Associativity: (b.c).a = a.b.c
and theorem 145:
Theorem (145) [serial 1707] used for:
  Associativity: (b.c).a = a.b.c [serial 1702]
 


Theorem (147)                               [serial 1690] 
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E() >>
S [197] ->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION = ACTUAL_POSITION' and 
ACTUAL_IN_RANGE() and E() >>
by Substitution of Assertion Labels
and theorem 146:
Theorem (146) [serial 1702] used for:
  substituted Assertions' predicates for  labels  [serial 1690]
 


Theorem (148)                               [serial 1681] 
P [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E() and ACTUAL_IN_RANGE()) >>
S [197] ->
Q [15] << (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E() and ACTUAL_IN_RANGE() and 
((0 = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 147:
Theorem (147) [serial 1690] used for:
    normalization of [serial 1681]
 


Theorem (149)                               [serial 1679] 
P [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E() and ACTUAL_IN_RANGE()) >>
S [197] Delta := 0
Q [15] << (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E() and ACTUAL_IN_RANGE() and 
((Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 148:
Theorem (148) [serial 1681] used for:
  applied wp for assignment [serial 1679]
 


Theorem (150)                               [serial 1763] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (151)                               [serial 1754] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201] ->
Q [1] << 0 <= ACTUAL_POSITION^1 >>
by Guided Substitution of Equals
and theorem 150:
Theorem (150) [serial 1763] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "ACTUAL_POSITION" in its postcondition [serial 1754]
 


Theorem (152)                               [serial 1764] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201] ->
Q [204] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (153)                               [serial 1755] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201] ->
Q [204] << ACTUAL_POSITION^1 <= #PCS::MaxPosition >>
by Guided Substitution of Equals
and theorem 152:
Theorem (152) [serial 1764] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "ACTUAL_POSITION" in its postcondition [serial 1755]
 


Theorem (154)                               [serial 1765] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201] ->
Q [202] << ACTUAL_POSITION = EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (155)                               [serial 1756] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201] ->
Q [202] << ACTUAL_POSITION^1 = EstimatedActualPosition >>
by Guided Substitution of Equals
and theorem 154:
Theorem (154) [serial 1765] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "ACTUAL_POSITION" in its postcondition [serial 1756]
 


Theorem (156)                               [serial 1757] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201] ->
Q [203] << Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (157)                               [serial 1737] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION^1 = ACTUAL_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [201] ->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 151 153 155 156:
Theorem (151) [serial 1754] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737]
 
Theorem (153) [serial 1755] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737]
 
Theorem (155) [serial 1756] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737]
 
Theorem (156) [serial 1757] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1737]
 


Theorem (158)                               [serial 1729] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = (ACTUAL_POSITION)^1 and Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
S [201] ->
Q [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and EstimatedActualPosition = (ACTUAL_POSITION)^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 157:
Theorem (157) [serial 1737] used for:
    normalization of [serial 1729]
 


Theorem (159)                               [serial 1717] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [201] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 158:
Theorem (158) [serial 1729] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1717]
 


Theorem (160)                               [serial 1708] 
P [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [201] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 159:
Theorem (159) [serial 1717] used for:
    normalization of [serial 1708]
 


Theorem (161)                               [serial 1703] 
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [201] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
by Associativity: (b.c).a = a.b.c
and theorem 160:
Theorem (160) [serial 1708] used for:
  Associativity: (b.c).a = a.b.c [serial 1703]
 


Theorem (162)                               [serial 1692] 
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E() >>
S [201] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
by Substitution of Assertion Labels
and theorem 161:
Theorem (161) [serial 1703] used for:
  substituted Assertions' predicates for  labels  [serial 1692]
 


Theorem (163)                               [serial 1682] 
P [15] << (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E() and ACTUAL_IN_RANGE() and 
((Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
S [201] ->
Q [15] << ((EstimatedActualPosition = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 162:
Theorem (162) [serial 1692] used for:
    normalization of [serial 1682]
 


Theorem (164)                               [serial 1680] 
P [15] << (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E() and ACTUAL_IN_RANGE() and 
((Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
S [201] EstimatedActualPosition' := EstimatedActualPosition
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 163:
Theorem (163) [serial 1682] used for:
  applied wp for assignment [serial 1680]
 


Theorem (165)                               [serial 1013] 
P [163] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 = EstimatedActualPosition))) >>
S [193] << (E() and (DESIRED_POSITION = ACTUAL_POSITION) and ACTUAL_IN_RANGE()) >>
ActuatorCommand(pc:0)
<< (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E() and ACTUAL_IN_RANGE()) >>
;
Delta := 0
<< (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E() and ACTUAL_IN_RANGE() and ((Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
;
EstimatedActualPosition' := EstimatedActualPosition
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [159] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 111 125 133 149 164:
Theorem (111) [serial 1676] used for:
  P -> P1 in sequential composition for [serial 1013]
 
Theorem (125) [serial 1677] used for:
  Q2 -> Q in sequential composition for [serial 1013]
 
Theorem (133) [serial 1678] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1013]
 
Theorem (149) [serial 1679] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1013]
 
Theorem (164) [serial 1680] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1013]
 


Theorem (166)                               [serial 1843] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (167)                               [serial 1844] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163] ->
Q [25] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (168)                               [serial 1845] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163] ->
Q [1] << 0 <= DESIRED_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (169)                               [serial 1846] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163] ->
Q [22] << DESIRED_POSITION <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (170)                               [serial 1936] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and EstimatedActualPosition < DESIRED_POSITION >>
S [163] ->
Q [208] << EstimatedActualPosition < DESIRED_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (171)                               [serial 1926] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and EstimatedActualPosition < DESIRED_POSITION >>
S [163] ->
Q [208] << ACTUAL_POSITION < DESIRED_POSITION >>
by Substitution in Postcondition of All Equivalents in Precondition
and theorem 170:
Theorem (170) [serial 1936] used for:
  Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1926]
 


Theorem (172)                               [serial 1918] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
EstimatedActualPosition < DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition >>
S [163] ->
Q [208] << ACTUAL_POSITION < DESIRED_POSITION >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 171:
Theorem (171) [serial 1926] used for:
    normalization of [serial 1918]
 


Theorem (173)                               [serial 1916] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
EstimatedActualPosition < DESIRED_POSITION^0 and ACTUAL_POSITION = EstimatedActualPosition >>
S [163] ->
Q [208] << ACTUAL_POSITION < DESIRED_POSITION >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 172:
Theorem (172) [serial 1918] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1916]
 


Theorem (174)                               [serial 1903] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
(1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and ACTUAL_POSITION = EstimatedActualPosition >>
S [163] ->
Q [208] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
by Partial Order Law 2:  (1+a)<=b  is  a<b
and theorem 173:
Theorem (173) [serial 1916] used for:
  (1+EstimatedActualPosition)<=DESIRED_POSITION^0  is  EstimatedActualPosition<DESIRED_POSITION^0
  (1+ACTUAL_POSITION)<=DESIRED_POSITION  is  ACTUAL_POSITION<DESIRED_POSITION

Partial Order Law 2:  (1+a)<=b  is  a<b [serial 1903]
 


Theorem (175)                               [serial 1893] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition and 0 <= #PCS::MaxPosition >>
S [163] ->
Q [208] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 174:
Theorem (174) [serial 1903] used for:
    normalization of [serial 1893]
 


Theorem (176)                               [serial 1862] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163] ->
Q [208] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
by Transitivity: x<y and y<z -> x<z
and theorem 175:
Theorem (175) [serial 1893] used for:
  Transitivity: x<y and y<z -> x<z [serial 1862]
 


Theorem (177)                               [serial 1847] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163] ->
Q [208] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 176:
Theorem (176) [serial 1862] used for:
    normalization of [serial 1847]
 


Theorem (178)                               [serial 1848] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163] ->
Q [152] << ACTUAL_POSITION = EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (179)                               [serial 1831] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163] ->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 166 167 168 169 177 178:
Theorem (166) [serial 1843] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]
 
Theorem (167) [serial 1844] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]
 
Theorem (168) [serial 1845] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]
 
Theorem (169) [serial 1846] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]
 
Theorem (177) [serial 1847] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]
 
Theorem (178) [serial 1848] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1831]
 


Theorem (180)                               [serial 1817] 
P [15] << (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [163] ->
Q [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
by Associativity: (b.c).a = a.b.c
and theorem 179:
Theorem (179) [serial 1831] used for:
  Associativity: (b.c).a = a.b.c [serial 1817]
 


Theorem (181)                               [serial 1811] 
P [15] << (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [163] ->
Q [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 180:
Theorem (180) [serial 1817] used for:
    normalization of [serial 1811]
 


Theorem (182)                               [serial 1779] 
P [15] << (1 + EstimatedActualPosition) <= DESIRED_POSITION^0 and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163] ->
Q [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
by Substitution of Assertion Labels
and theorem 181:
Theorem (181) [serial 1811] used for:
  substituted Assertions' predicates for  labels  [serial 1779]
 


Theorem (183)                               [serial 1773] 
P [15] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition + 
1) <= (DESIRED_POSITION)^0))) >>
S [163] ->
Q [15] << (((ACTUAL_POSITION + 1) <= DESIRED_POSITION) and E() and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE()) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 182:
Theorem (182) [serial 1779] used for:
    normalization of [serial 1773]
 


Theorem (184)                               [serial 1933] 
P [15] << 0 <= ACTUAL_POSITION^1 and 0 <= #PCS::MaxPosition and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159] ->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (185)                               [serial 1928] 
P [15] << 0 <= ACTUAL_POSITION^1 and 0 <= #PCS::MaxPosition and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159] ->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 184:
Theorem (184) [serial 1933] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1928]
 


Theorem (186)                               [serial 1920] 
P [15] << 0 <= #PCS::MaxPosition and 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159] ->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1))) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Constants are always the same
and theorem 185:
Theorem (185) [serial 1928] used for:
    normalization of [serial 1920]
 


Theorem (187)                               [serial 1919] 
P [15] << 0 <= #PCS::MaxPosition and 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159] ->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 186:
Theorem (186) [serial 1920] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1919]
 


Theorem (188)                               [serial 1917] 
P [15] << 0 <= #PCS::MaxPosition and 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159] ->
Q [15] << ((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1 and 
(Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 187:
Theorem (187) [serial 1919] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1917]
 


Theorem (189)                               [serial 1897] 
P [15] << 0 <= #PCS::MaxPosition and 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159] ->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 188:
Theorem (188) [serial 1917] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1897]
 


Theorem (190)                               [serial 1890] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' and 0 <= #PCS::MaxPosition >>
S [159] ->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 189:
Theorem (189) [serial 1897] used for:
    normalization of [serial 1890]
 


Theorem (191)                               [serial 1832] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159] ->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
by Transitivity: x<y and y<z -> x<z
and theorem 190:
Theorem (190) [serial 1890] used for:
  Transitivity: x<y and y<z -> x<z [serial 1832]
 


Theorem (192)                               [serial 1819] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159] ->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
by Associativity: (b.c).a = a.b.c
and theorem 191:
Theorem (191) [serial 1832] used for:
  Associativity: (b.c).a = a.b.c [serial 1819]
 


Theorem (193)                               [serial 1812] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159] ->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 192:
Theorem (192) [serial 1819] used for:
    normalization of [serial 1812]
 


Theorem (194)                               [serial 1781] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159] ->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
by Substitution of Assertion Labels
and theorem 193:
Theorem (193) [serial 1812] used for:
  substituted Assertions' predicates for  labels  [serial 1781]
 


Theorem (195)                               [serial 1774] 
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [159] ->
Q [15] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 194:
Theorem (194) [serial 1781] used for:
    normalization of [serial 1774]
 


Theorem (196)                               [serial 1849] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (197)                               [serial 1850] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210] ->
Q [212] << DESIRED_POSITION <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (198)                               [serial 1851] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210] ->
Q [1] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (199)                               [serial 1905] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
(1 + ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210] ->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (200)                               [serial 1894] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and 0 <= #PCS::MaxPosition and 
(1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
S [210] ->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 199:
Theorem (199) [serial 1905] used for:
    normalization of [serial 1894]
 


Theorem (201)                               [serial 1864] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210] ->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
by Transitivity: x<y and y<z -> x<z
and theorem 200:
Theorem (200) [serial 1894] used for:
  Transitivity: x<y and y<z -> x<z [serial 1864]
 


Theorem (202)                               [serial 1852] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210] ->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 201:
Theorem (201) [serial 1864] used for:
    normalization of [serial 1852]
 


Theorem (203)                               [serial 1853] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210] ->
Q [152] << ACTUAL_POSITION = EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (204)                               [serial 1833] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 196 197 198 202 203:
Theorem (196) [serial 1849] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]
 
Theorem (197) [serial 1850] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]
 
Theorem (198) [serial 1851] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]
 
Theorem (202) [serial 1852] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]
 
Theorem (203) [serial 1853] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]
 


Theorem (205)                               [serial 1825] 
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [210] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
by Associativity: (b.c).a = a.b.c
and theorem 204:
Theorem (204) [serial 1833] used for:
  Associativity: (b.c).a = a.b.c [serial 1825]
 


Theorem (206)                               [serial 1815] 
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [210] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 205:
Theorem (205) [serial 1825] used for:
    normalization of [serial 1815]
 


Theorem (207)                               [serial 1810] 
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
E() >>
by Substitution of Assertion Labels
and theorem 206:
Theorem (206) [serial 1815] used for:
  substituted Assertions' predicates for  labels  [serial 1810]
 


Theorem (208)                               [serial 1809] 
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
true and E() >>
by Law of And-Simplification:  P and true is P
and theorem 207:
Theorem (207) [serial 1810] used for:
  Law of And-Simplification:  P and true is P [serial 1809]
 


Theorem (209)                               [serial 1849] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (210)                               [serial 1850] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210] ->
Q [212] << DESIRED_POSITION <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (211)                               [serial 1851] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210] ->
Q [1] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (212)                               [serial 1905] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
(1 + ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210] ->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (213)                               [serial 1894] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and 0 <= #PCS::MaxPosition and 
(1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
S [210] ->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 212:
Theorem (212) [serial 1905] used for:
    normalization of [serial 1894]
 


Theorem (214)                               [serial 1864] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210] ->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
by Transitivity: x<y and y<z -> x<z
and theorem 213:
Theorem (213) [serial 1894] used for:
  Transitivity: x<y and y<z -> x<z [serial 1864]
 


Theorem (215)                               [serial 1852] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210] ->
Q [214] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 214:
Theorem (214) [serial 1864] used for:
    normalization of [serial 1852]
 


Theorem (216)                               [serial 1853] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210] ->
Q [152] << ACTUAL_POSITION = EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (217)                               [serial 1833] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (1 + ACTUAL_POSITION) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [210] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 209 210 211 215 216:
Theorem (209) [serial 1849] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]
 
Theorem (210) [serial 1850] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]
 
Theorem (211) [serial 1851] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]
 
Theorem (215) [serial 1852] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]
 
Theorem (216) [serial 1853] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1833]
 


Theorem (218)                               [serial 1825] 
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [210] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
by Associativity: (b.c).a = a.b.c
and theorem 217:
Theorem (217) [serial 1833] used for:
  Associativity: (b.c).a = a.b.c [serial 1825]
 


Theorem (219)                               [serial 1815] 
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [210] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 218:
Theorem (218) [serial 1825] used for:
    normalization of [serial 1815]
 


Theorem (220)                               [serial 1810] 
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
E() >>
by Substitution of Assertion Labels
and theorem 219:
Theorem (219) [serial 1815] used for:
  substituted Assertions' predicates for  labels  [serial 1810]
 


Theorem (221)                               [serial 1809] 
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
true and E() >>
by Law of And-Simplification:  P and true is P
and theorem 220:
Theorem (220) [serial 1810] used for:
  Law of And-Simplification:  P and true is P [serial 1809]
 


Theorem (222)                               [serial 1798] 
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
AXIOM_LT(ACTUAL_POSITION) and E() >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 221 221:
Theorem (221) [serial 1809] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (221) [serial 1809] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (223)                               [serial 1796] 
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
true and AXIOM_LT(ACTUAL_POSITION) and E() >>
by Law of And-Simplification:  P and true is P
and theorem 222:
Theorem (222) [serial 1798] used for:
  Law of And-Simplification:  P and true is P [serial 1796]
 


Theorem (224)                               [serial 1793] 
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = 1 and AXIOM_LT(ACTUAL_POSITION) and E() >>
by Equality Law (idistr):  a=a <-> true
and theorem 223:
Theorem (223) [serial 1796] used for:
  Equality Law (idistr):  a=a <-> true [serial 1793]
 


Theorem (225)                               [serial 1783] 
P [15] << (1 + ACTUAL_POSITION) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [210] Delta := 1
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 224:
Theorem (224) [serial 1793] used for:
  applied wp for assignment [serial 1783]
 


Theorem (226)                               [serial 1775] 
P [15] << (((ACTUAL_POSITION + 1) <= DESIRED_POSITION) and E() and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE()) >>
S [210] Delta := 1
Q [15] << (E() and (DESIRED_POSITION >= (ACTUAL_POSITION + 1)) and (Delta = 1) and 
(ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LT(ACTUAL_POSITION) and 
((ACTUAL_POSITION + 1) <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 225:
Theorem (225) [serial 1783] used for:
    normalization of [serial 1775]
 


Theorem (227)                               [serial 1838] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (228)                               [serial 1939] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216] ->
Q [1] << true >>
by True Conclusion Schema (tc): P->true


Theorem (229)                               [serial 1937] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216] ->
Q [1] << 0 < 1 >>
by Literal Value Comparison
and theorem 228:
Theorem (228) [serial 1939] used for:
  Literal Value Comparison [serial 1937]
 


Theorem (230)                               [serial 1934] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216] ->
Q [1] << 0 < 1 >>
by Law of And-Simplification:  P and P is P
and theorem 229:
Theorem (229) [serial 1937] used for:
  Law of And-Simplification:  P and P is P [serial 1934]
 


Theorem (231)                               [serial 1922] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216] ->
Q [1] << 0 < Delta >>
by Substitution in Postcondition of All Equivalents in Precondition
and theorem 230:
Theorem (230) [serial 1934] used for:
  Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1922]
 


Theorem (232)                               [serial 1914] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < DESIRED_POSITION and 0 < (1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition >>
S [216] ->
Q [1] << 0 < Delta >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 231:
Theorem (231) [serial 1922] used for:
    normalization of [serial 1914]
 


Theorem (233)                               [serial 1899] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 
0 < (1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Partial Order Law 2:  (1+a)<=b  is  a<b
and theorem 232:
Theorem (232) [serial 1914] used for:
  (1+ACTUAL_POSITION)<=DESIRED_POSITION  is  ACTUAL_POSITION<DESIRED_POSITION
(1+ACTUAL_POSITION)<=#PCS::MaxPosition  is  ACTUAL_POSITION<#PCS::MaxPosition
  0<=(-ACTUAL_POSITION+Delta)  is  0<Delta

Partial Order Law 2:  (1+a)<=b  is  a<b [serial 1899]
 


Theorem (234)                               [serial 1891] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) and 0 < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < DESIRED_POSITION and 
0 < DESIRED_POSITION and ACTUAL_POSITION < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [216] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 233:
Theorem (233) [serial 1899] used for:
    normalization of [serial 1891]
 


Theorem (235)                               [serial 1839] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Transitivity: x<y and y<z -> x<z
and theorem 234:
Theorem (234) [serial 1891] used for:
  Transitivity: x<y and y<z -> x<z [serial 1839]
 


Theorem (236)                               [serial 1944] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216] ->
Q [130] << ACTUAL_POSITION < #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (237)                               [serial 1942] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216] ->
Q [130] << (1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
by Partial Order Law 2:  (1+a)<=b  is  a<b
and theorem 236:
Theorem (236) [serial 1944] used for:
    (1+ACTUAL_POSITION)<=#PCS::MaxPosition  is  ACTUAL_POSITION<#PCS::MaxPosition

Partial Order Law 2:  (1+a)<=b  is  a<b [serial 1942]
 


Theorem (238)                               [serial 1940] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216] ->
Q [130] << (ACTUAL_POSITION + 1) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Addition: a+b=b+a
and theorem 237:
Theorem (237) [serial 1942] used for:
    normalization of [serial 1940]
 


Theorem (239)                               [serial 1938] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216] ->
Q [130] << (EstimatedActualPosition + 1) <= #PCS::MaxPosition >>
by Substitution in Postcondition of All Equivalents in Precondition
and theorem 238:
Theorem (238) [serial 1940] used for:
  Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1938]
 


Theorem (240)                               [serial 1935] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216] ->
Q [130] << (EstimatedActualPosition + 1) <= #PCS::MaxPosition >>
by Law of And-Simplification:  P and P is P
and theorem 239:
Theorem (239) [serial 1938] used for:
  Law of And-Simplification:  P and P is P [serial 1935]
 


Theorem (241)                               [serial 1924] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 0 < (
1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216] ->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by Substitution in Postcondition of All Equivalents in Precondition
and theorem 240:
Theorem (240) [serial 1935] used for:
  Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1924]
 


Theorem (242)                               [serial 1915] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < DESIRED_POSITION and 0 < (1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and 
ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (1 + ACTUAL_POSITION) and 
ACTUAL_POSITION < #PCS::MaxPosition >>
S [216] ->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 241:
Theorem (241) [serial 1924] used for:
    normalization of [serial 1915]
 


Theorem (243)                               [serial 1901] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < DESIRED_POSITION and 
0 < (1 + ACTUAL_POSITION) and 0 < #PCS::MaxPosition and ACTUAL_POSITION < DESIRED_POSITION and 
ACTUAL_POSITION < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [216] ->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by Partial Order Law 2:  (1+a)<=b  is  a<b
and theorem 242:
Theorem (242) [serial 1915] used for:
  (1+ACTUAL_POSITION)<=DESIRED_POSITION  is  ACTUAL_POSITION<DESIRED_POSITION
(1+ACTUAL_POSITION)<=#PCS::MaxPosition  is  ACTUAL_POSITION<#PCS::MaxPosition
  
Partial Order Law 2:  (1+a)<=b  is  a<b [serial 1901]
 


Theorem (244)                               [serial 1892] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) and 0 < (1 + ACTUAL_POSITION) and ACTUAL_POSITION < DESIRED_POSITION and 
0 < DESIRED_POSITION and ACTUAL_POSITION < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [216] ->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 243:
Theorem (243) [serial 1901] used for:
    normalization of [serial 1892]
 


Theorem (245)                               [serial 1840] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216] ->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by Transitivity: x<y and y<z -> x<z
and theorem 244:
Theorem (244) [serial 1892] used for:
  Transitivity: x<y and y<z -> x<z [serial 1840]
 


Theorem (246)                               [serial 1841] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216] ->
Q [218] << 1 = Delta >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (247)                               [serial 1842] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216] ->
Q [152] << ACTUAL_POSITION = EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (248)                               [serial 1823] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION < (
1 + ACTUAL_POSITION) >>
S [216] ->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 227 235 245 246 247:
Theorem (227) [serial 1838] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]
 
Theorem (235) [serial 1839] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]
 
Theorem (245) [serial 1840] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]
 
Theorem (246) [serial 1841] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]
 
Theorem (247) [serial 1842] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1823]
 


Theorem (249)                               [serial 1814] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and ((ACTUAL_POSITION < (ACTUAL_POSITION + 1))) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [216] ->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 248:
Theorem (248) [serial 1823] used for:
    normalization of [serial 1814]
 


Theorem (250)                               [serial 1808] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
S [216] ->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and E() >>
by Substitution of Assertion Labels
and theorem 249:
Theorem (249) [serial 1814] used for:
  substituted Assertions' predicates for  labels  [serial 1808]
 


Theorem (251)                               [serial 1804] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
S [216] ->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + 
Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and E() >>
by Law of And-Simplification:  P and P is P
and theorem 250:
Theorem (250) [serial 1808] used for:
  Law of And-Simplification:  P and P is P [serial 1804]
 


Theorem (252)                               [serial 1797] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
S [216] ->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and E() >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 251:
Theorem (251) [serial 1804] used for:
    normalization of [serial 1797]
 


Theorem (253)                               [serial 1794] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
S [216] ->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (0 <= (ACTUAL_POSITION + Delta) and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and E() >>
by Associativity: (b.c).a = a.b.c
and theorem 252:
Theorem (252) [serial 1797] used for:
  Associativity: (b.c).a = a.b.c [serial 1794]
 


Theorem (254)                               [serial 1785] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (1 + 
ACTUAL_POSITION) <= DESIRED_POSITION and (1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
1 = Delta and AXIOM_LT(ACTUAL_POSITION) and E() >>
S [216] ActuatorCommand(pc:Delta)
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E() >>
by Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
and theorem 253:
Theorem (253) [serial 1794] used for:
  applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1785]
 


Theorem (255)                               [serial 1776] 
P [15] << (E() and (DESIRED_POSITION >= (ACTUAL_POSITION + 1)) and (Delta = 1) and 
(ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LT(ACTUAL_POSITION) and 
((ACTUAL_POSITION + 1) <= #PCS::MaxPosition)) >>
S [216] ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E() and (Delta = 1) and 
(ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 254:
Theorem (254) [serial 1785] used for:
    normalization of [serial 1776]
 


Theorem (256)                               [serial 1877] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (257)                               [serial 1867] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221] ->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 256:
Theorem (256) [serial 1877] used for:
    normalization of [serial 1867]
 


Theorem (258)                               [serial 1834] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221] ->
Q [1] << 0 <= ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 257:
Theorem (257) [serial 1867] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 1834]
 


Theorem (259)                               [serial 1879] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221] ->
Q [224] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (260)                               [serial 1868] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221] ->
Q [224] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 259:
Theorem (259) [serial 1879] used for:
    normalization of [serial 1868]
 


Theorem (261)                               [serial 1835] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221] ->
Q [224] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
by Guided Substitution of Equals
and theorem 260:
Theorem (260) [serial 1868] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 1835]
 


Theorem (262)                               [serial 1888] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221] ->
Q [223] << true >>
by True Conclusion Schema (tc): P->true


Theorem (263)                               [serial 1881] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221] ->
Q [223] << Delta = Delta >>
by Equality Law (idistr):  a=a <-> true
and theorem 262:
Theorem (262) [serial 1888] used for:
  Equality Law (idistr):  a=a <-> true [serial 1881]
 


Theorem (264)                               [serial 1869] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221] ->
Q [223] << Delta = (((ACTUAL_POSITION + Delta)) - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Subtaction of Added Value:  (a+b)-a is b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 263:
Theorem (263) [serial 1881] used for:
    normalization of [serial 1869]
 


Theorem (265)                               [serial 1836] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221] ->
Q [223] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Guided Substitution of Equals
and theorem 264:
Theorem (264) [serial 1869] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 1836]
 


Theorem (266)                               [serial 1907] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221] ->
Q [222] << ACTUAL_POSITION = EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (267)                               [serial 1895] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 0 <= #PCS::MaxPosition >>
S [221] ->
Q [222] << (ACTUAL_POSITION) = (EstimatedActualPosition) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 266:
Theorem (266) [serial 1907] used for:
    normalization of [serial 1895]
 


Theorem (268)                               [serial 1889] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221] ->
Q [222] << (ACTUAL_POSITION) = (EstimatedActualPosition) >>
by Transitivity: x<y and y<z -> x<z
and theorem 267:
Theorem (267) [serial 1895] used for:
  Transitivity: x<y and y<z -> x<z [serial 1889]
 


Theorem (269)                               [serial 1883] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221] ->
Q [222] << (ACTUAL_POSITION + Delta) = (Delta + EstimatedActualPosition) >>
by Add both sides of equality:  a=b -> x+a=x+b
and theorem 268:
Theorem (268) [serial 1889] used for:
  Add both sides of equality:  a=b -> x+a=x+b [serial 1883]
 


Theorem (270)                               [serial 1870] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221] ->
Q [222] << (Delta + EstimatedActualPosition) = ((ACTUAL_POSITION + Delta)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 269:
Theorem (269) [serial 1883] used for:
    normalization of [serial 1870]
 


Theorem (271)                               [serial 1837] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221] ->
Q [222] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 270:
Theorem (270) [serial 1870] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 1837]
 


Theorem (272)                               [serial 1821] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [221] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 258 261 265 271:
Theorem (258) [serial 1834] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1821]
 
Theorem (261) [serial 1835] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1821]
 
Theorem (265) [serial 1836] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1821]
 
Theorem (271) [serial 1837] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1821]
 


Theorem (273)                               [serial 1813] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [221] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 272:
Theorem (272) [serial 1821] used for:
    normalization of [serial 1813]
 


Theorem (274)                               [serial 1802] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E() >>
S [221] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Substitution of Assertion Labels
and theorem 273:
Theorem (273) [serial 1813] used for:
  substituted Assertions' predicates for  labels  [serial 1802]
 


Theorem (275)                               [serial 1795] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E() >>
S [221] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 274:
Theorem (274) [serial 1802] used for:
    normalization of [serial 1795]
 


Theorem (276)                               [serial 1787] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and 1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E() >>
S [221] EstimatedActualPosition' := (Delta + EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 275:
Theorem (275) [serial 1795] used for:
  applied wp for assignment [serial 1787]
 


Theorem (277)                               [serial 1777] 
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E() and (Delta = 1) and 
(ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
S [221] EstimatedActualPosition' := (EstimatedActualPosition + Delta)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 276:
Theorem (276) [serial 1787] used for:
    normalization of [serial 1777]
 


Theorem (278)                               [serial 1014] 
P [163] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition + 
1) <= (DESIRED_POSITION)^0))) >>
S [208] << (((ACTUAL_POSITION + 1) <= DESIRED_POSITION) and E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Delta := 1
<< (E() and (DESIRED_POSITION >= (ACTUAL_POSITION + 1)) and (Delta = 1) and (ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LT(ACTUAL_POSITION) and ((ACTUAL_POSITION + 1) <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E() and (Delta = 1) and (ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition + Delta)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [159] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 183 195 226 255 277:
Theorem (183) [serial 1773] used for:
  P -> P1 in sequential composition for [serial 1014]
 
Theorem (195) [serial 1774] used for:
  Q2 -> Q in sequential composition for [serial 1014]
 
Theorem (226) [serial 1775] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1014]
 
Theorem (255) [serial 1776] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1014]
 
Theorem (277) [serial 1777] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1014]
 


Theorem (279)                               [serial 2147] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition >>
S [163] ->
Q [228] << DESIRED_POSITION < EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (280)                               [serial 2142] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= #PCS::MaxPosition and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition >>
S [163] ->
Q [228] << DESIRED_POSITION < ACTUAL_POSITION >>
by Substitution in Postcondition of All Equivalents in Precondition
and theorem 279:
Theorem (279) [serial 2147] used for:
  Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 2142]
 


Theorem (281)                               [serial 2139] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 < EstimatedActualPosition and 
0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION < EstimatedActualPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [163] ->
Q [228] << DESIRED_POSITION < ACTUAL_POSITION >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 280:
Theorem (280) [serial 2142] used for:
    normalization of [serial 2139]
 


Theorem (282)                               [serial 2128] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= (-1 + EstimatedActualPosition) and 
0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (
-1 + EstimatedActualPosition) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163] ->
Q [228] << DESIRED_POSITION <= (-1 + ACTUAL_POSITION) >>
by Partial Order Law 3:  a <= (b-1)  is  a<b
and theorem 281:
Theorem (281) [serial 2139] used for:
  0<=(--1+EstimatedActualPosition)  is  0<EstimatedActualPosition
DESIRED_POSITION<=(--1+EstimatedActualPosition)  is  DESIRED_POSITION<EstimatedActualPosition
  DESIRED_POSITION<=(--1+ACTUAL_POSITION)  is  DESIRED_POSITION<ACTUAL_POSITION

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2128]
 


Theorem (283)                               [serial 2123] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= (EstimatedActualPosition + 
 -1) and 0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (EstimatedActualPosition +  -1) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163] ->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION +  -1) >>
by Normalization
  Normalization Axiom:
    Literal Arithmetic
and theorem 282:
Theorem (282) [serial 2128] used for:
    normalization of [serial 2123]
 


Theorem (284)                               [serial 2092] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= (EstimatedActualPosition - 1) and 
0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (EstimatedActualPosition - 1) and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [163] ->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 283:
Theorem (283) [serial 2123] used for:
   changing adding negation to subtraction  [serial 2092]
 


Theorem (285)                               [serial 2078] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (EstimatedActualPosition - 1) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and 0 <= #PCS::MaxPosition and 
0 <= (EstimatedActualPosition - 1) >>
S [163] ->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 284:
Theorem (284) [serial 2092] used for:
    normalization of [serial 2078]
 


Theorem (286)                               [serial 2062] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (EstimatedActualPosition - 1) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163] ->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
by Transitivity: x<y and y<z -> x<z
and theorem 285:
Theorem (285) [serial 2078] used for:
  Transitivity: x<y and y<z -> x<z [serial 2062]
 


Theorem (287)                               [serial 2048] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (EstimatedActualPosition - 1) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163] ->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 286:
Theorem (286) [serial 2062] used for:
    normalization of [serial 2048]
 


Theorem (288)                               [serial 2040] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [163] ->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 287:
Theorem (287) [serial 2048] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2040]
 


Theorem (289)                               [serial 2012] 
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [163] ->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
by Associativity: (b.c).a = a.b.c
and theorem 288:
Theorem (288) [serial 2040] used for:
  Associativity: (b.c).a = a.b.c [serial 2012]
 


Theorem (290)                               [serial 2000] 
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [163] ->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 289:
Theorem (289) [serial 2012] used for:
    normalization of [serial 2000]
 


Theorem (291)                               [serial 1983] 
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163] ->
Q [228] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
by Substitution of Assertion Labels
and theorem 290:
Theorem (290) [serial 2000] used for:
  substituted Assertions' predicates for  labels  [serial 1983]
 


Theorem (292)                               [serial 1984] 
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163] ->
Q [229] << ACTUAL_IN_RANGE() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (293)                               [serial 1985] 
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163] ->
Q [229] << DESIRED_IN_RANGE() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (294)                               [serial 1986] 
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163] ->
Q [229] << E() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (295)                               [serial 1951] 
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - 1) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E() >>
S [163] ->
Q [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 291 292 293 294:
Theorem (291) [serial 1983] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1951]
 
Theorem (292) [serial 1984] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1951]
 
Theorem (293) [serial 1985] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1951]
 
Theorem (294) [serial 1986] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1951]
 


Theorem (296)                               [serial 1945] 
P [15] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 <= (EstimatedActualPosition - 1)))) >>
S [163] ->
Q [15] << ((DESIRED_POSITION <= (ACTUAL_POSITION - 1)) and E() and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE()) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 295:
Theorem (295) [serial 1951] used for:
    normalization of [serial 1945]
 


Theorem (297)                               [serial 2071] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159] ->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by Identity (id):  P->P is tautology


Theorem (298)                               [serial 2064] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [159] ->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 297:
Theorem (297) [serial 2071] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2064]
 


Theorem (299)                               [serial 2050] 
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159] ->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1))) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Constants are always the same
and theorem 298:
Theorem (298) [serial 2064] used for:
    normalization of [serial 2050]
 


Theorem (300)                               [serial 2049] 
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159] ->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
(Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 299:
Theorem (299) [serial 2050] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2049]
 


Theorem (301)                               [serial 2047] 
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [159] ->
Q [15] << ((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1 and 
(Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 300:
Theorem (300) [serial 2049] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2047]
 


Theorem (302)                               [serial 2039] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159] ->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
ACTUAL_POSITION = EstimatedActualPosition)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 301:
Theorem (301) [serial 2047] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2039]
 


Theorem (303)                               [serial 2010] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159] ->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
by Associativity: (b.c).a = a.b.c
and theorem 302:
Theorem (302) [serial 2039] used for:
  Associativity: (b.c).a = a.b.c [serial 2010]
 


Theorem (304)                               [serial 1999] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159] ->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 303:
Theorem (303) [serial 2010] used for:
    normalization of [serial 1999]
 


Theorem (305)                               [serial 1953] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [159] ->
Q [15] << (ACTUAL_IN_RANGE() and D() and E())^1 >>
by Substitution of Assertion Labels
and theorem 304:
Theorem (304) [serial 1999] used for:
  substituted Assertions' predicates for  labels  [serial 1953]
 


Theorem (306)                               [serial 1946] 
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [159] ->
Q [15] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 305:
Theorem (305) [serial 1953] used for:
    normalization of [serial 1946]
 


Theorem (307)                               [serial 2041] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [230] ->
Q [1] << 0 <= DESIRED_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (308)                               [serial 2026] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [230] ->
Q [1] << 0 <= DESIRED_POSITION >>
by Associativity: (b.c).a = a.b.c
and theorem 307:
Theorem (307) [serial 2041] used for:
  Associativity: (b.c).a = a.b.c [serial 2026]
 


Theorem (309)                               [serial 2007] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [230] ->
Q [1] << 0 <= DESIRED_POSITION >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 308:
Theorem (308) [serial 2026] used for:
    normalization of [serial 2007]
 


Theorem (310)                               [serial 1995] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230] ->
Q [1] << 0 <= DESIRED_POSITION >>
by Substitution of Assertion Labels
and theorem 309:
Theorem (309) [serial 2007] used for:
  substituted Assertions' predicates for  labels  [serial 1995]
 


Theorem (311)                               [serial 2042] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [230] ->
Q [233] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (312)                               [serial 2028] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [230] ->
Q [233] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Associativity: (b.c).a = a.b.c
and theorem 311:
Theorem (311) [serial 2042] used for:
  Associativity: (b.c).a = a.b.c [serial 2028]
 


Theorem (313)                               [serial 2008] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [230] ->
Q [233] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 312:
Theorem (312) [serial 2028] used for:
    normalization of [serial 2008]
 


Theorem (314)                               [serial 1996] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230] ->
Q [233] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 313:
Theorem (313) [serial 2008] used for:
  substituted Assertions' predicates for  labels  [serial 1996]
 


Theorem (315)                               [serial 1997] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230] ->
Q [1] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (316)                               [serial 1998] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230] ->
Q [231] << E() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (317)                               [serial 1982] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230] ->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
E() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 310 314 315 316:
Theorem (310) [serial 1995] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1982]
 
Theorem (314) [serial 1996] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1982]
 
Theorem (315) [serial 1997] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1982]
 
Theorem (316) [serial 1998] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1982]
 


Theorem (318)                               [serial 1980] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230] ->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
true and E() >>
by Law of And-Simplification:  P and true is P
and theorem 317:
Theorem (317) [serial 1982] used for:
  Law of And-Simplification:  P and true is P [serial 1980]
 


Theorem (319)                               [serial 2041] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [230] ->
Q [1] << 0 <= DESIRED_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (320)                               [serial 2026] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [230] ->
Q [1] << 0 <= DESIRED_POSITION >>
by Associativity: (b.c).a = a.b.c
and theorem 319:
Theorem (319) [serial 2041] used for:
  Associativity: (b.c).a = a.b.c [serial 2026]
 


Theorem (321)                               [serial 2007] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [230] ->
Q [1] << 0 <= DESIRED_POSITION >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 320:
Theorem (320) [serial 2026] used for:
    normalization of [serial 2007]
 


Theorem (322)                               [serial 1995] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230] ->
Q [1] << 0 <= DESIRED_POSITION >>
by Substitution of Assertion Labels
and theorem 321:
Theorem (321) [serial 2007] used for:
  substituted Assertions' predicates for  labels  [serial 1995]
 


Theorem (323)                               [serial 2042] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [230] ->
Q [233] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (324)                               [serial 2028] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [230] ->
Q [233] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Associativity: (b.c).a = a.b.c
and theorem 323:
Theorem (323) [serial 2042] used for:
  Associativity: (b.c).a = a.b.c [serial 2028]
 


Theorem (325)                               [serial 2008] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [230] ->
Q [233] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 324:
Theorem (324) [serial 2028] used for:
    normalization of [serial 2008]
 


Theorem (326)                               [serial 1996] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230] ->
Q [233] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 325:
Theorem (325) [serial 2008] used for:
  substituted Assertions' predicates for  labels  [serial 1996]
 


Theorem (327)                               [serial 1997] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230] ->
Q [1] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (328)                               [serial 1998] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230] ->
Q [231] << E() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (329)                               [serial 1982] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230] ->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
E() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 322 326 327 328:
Theorem (322) [serial 1995] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1982]
 
Theorem (326) [serial 1996] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1982]
 
Theorem (327) [serial 1997] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1982]
 
Theorem (328) [serial 1998] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1982]
 


Theorem (330)                               [serial 1980] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230] ->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
true and E() >>
by Law of And-Simplification:  P and true is P
and theorem 329:
Theorem (329) [serial 1982] used for:
  Law of And-Simplification:  P and true is P [serial 1980]
 


Theorem (331)                               [serial 1970] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230] ->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
AXIOM_GT(ACTUAL_POSITION) and E() >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 330 330:
Theorem (330) [serial 1980] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (330) [serial 1980] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (332)                               [serial 1968] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230] ->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
true and AXIOM_GT(ACTUAL_POSITION) and E() >>
by Law of And-Simplification:  P and true is P
and theorem 331:
Theorem (331) [serial 1970] used for:
  Law of And-Simplification:  P and true is P [serial 1968]
 


Theorem (333)                               [serial 1965] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230] ->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = -1 and AXIOM_GT(ACTUAL_POSITION) and E() >>
by Equality Law (idistr):  a=a <-> true
and theorem 332:
Theorem (332) [serial 1968] used for:
  Equality Law (idistr):  a=a <-> true [serial 1965]
 


Theorem (334)                               [serial 1955] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - 1) and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E() >>
S [230] Delta := -1
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 333:
Theorem (333) [serial 1965] used for:
  applied wp for assignment [serial 1955]
 


Theorem (335)                               [serial 1947] 
P [15] << ((DESIRED_POSITION <= (ACTUAL_POSITION - 1)) and E() and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE()) >>
S [230] Delta := -1
Q [15] << (E() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= DESIRED_POSITION) and 
AXIOM_GT(ACTUAL_POSITION) and (DESIRED_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 334:
Theorem (334) [serial 1955] used for:
    normalization of [serial 1947]
 


Theorem (336)                               [serial 2132] 
P [15] << 0 <= DESIRED_POSITION and 0 <= (-1 + ACTUAL_POSITION) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (-1 + ACTUAL_POSITION) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION and 
(-1 + ACTUAL_POSITION) < #PCS::MaxPosition >>
S [235] ->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (337)                               [serial 2125] 
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION +  -1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION +  -1) and  -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION +  -1) < ACTUAL_POSITION and 
(ACTUAL_POSITION +  -1) < #PCS::MaxPosition >>
S [235] ->
Q [1] << 0 <= (ACTUAL_POSITION +  -1) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Equality: (a=b) = (b=a)
    Unary Minus:  -(x-y) is (y-x)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 336:
Theorem (336) [serial 2132] used for:
    normalization of [serial 2125]
 


Theorem (338)                               [serial 2121] 
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - 1) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
(ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [235] ->
Q [1] << 0 <= (ACTUAL_POSITION + -1) >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 337:
Theorem (337) [serial 2125] used for:
   changing adding negation to subtraction  [serial 2121]
 


Theorem (339)                               [serial 2080] 
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - 1) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
(ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [235] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Guided Substitution of Equals
and theorem 338:
Theorem (338) [serial 2121] used for:
  Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 2080]
 


Theorem (340)                               [serial 2072] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) < #PCS::MaxPosition and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition >>
S [235] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 339:
Theorem (339) [serial 2080] used for:
    normalization of [serial 2072]
 


Theorem (341)                               [serial 2022] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [235] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Transitivity: x<y and y<z -> x<z
and theorem 340:
Theorem (340) [serial 2072] used for:
  Transitivity: x<y and y<z -> x<z [serial 2022]
 


Theorem (342)                               [serial 2005] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and (((ACTUAL_POSITION - 1) < ACTUAL_POSITION)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [235] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 341:
Theorem (341) [serial 2022] used for:
    normalization of [serial 2005]
 


Theorem (343)                               [serial 1991] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Substitution of Assertion Labels
and theorem 342:
Theorem (342) [serial 2005] used for:
  substituted Assertions' predicates for  labels  [serial 1991]
 


Theorem (344)                               [serial 2144] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and (-1 + 
ACTUAL_POSITION) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION >>
S [235] ->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (345)                               [serial 2140] 
P [15] << 0 <= DESIRED_POSITION and 0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION < ACTUAL_POSITION and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION and 
(-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
S [235] ->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 344:
Theorem (344) [serial 2144] used for:
    normalization of [serial 2140]
 


Theorem (346)                               [serial 2134] 
P [15] << 0 <= DESIRED_POSITION and 0 <= (-1 + ACTUAL_POSITION) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (-1 + ACTUAL_POSITION) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION and 
(-1 + ACTUAL_POSITION) < #PCS::MaxPosition >>
S [235] ->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
by Partial Order Law 3:  a <= (b-1)  is  a<b
and theorem 345:
Theorem (345) [serial 2140] used for:
  0<=(--1+ACTUAL_POSITION)  is  0<ACTUAL_POSITION
DESIRED_POSITION<=(--1+ACTUAL_POSITION)  is  DESIRED_POSITION<ACTUAL_POSITION
(-1 + ACTUAL_POSITION)<#PCS::MaxPosition  ->  (-1 + ACTUAL_POSITION)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2134]
 


Theorem (347)                               [serial 2126] 
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION +  -1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION +  -1) and  -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION +  -1) < ACTUAL_POSITION and 
(ACTUAL_POSITION +  -1) < #PCS::MaxPosition >>
S [235] ->
Q [130] << (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Equality: (a=b) = (b=a)
    Unary Minus:  -(x-y) is (y-x)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 346:
Theorem (346) [serial 2134] used for:
    normalization of [serial 2126]
 


Theorem (348)                               [serial 2122] 
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - 1) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
(ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [235] ->
Q [130] << (ACTUAL_POSITION + -1) <= #PCS::MaxPosition >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 347:
Theorem (347) [serial 2126] used for:
   changing adding negation to subtraction  [serial 2122]
 


Theorem (349)                               [serial 2082] 
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - 1) and -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and 
DESIRED_POSITION < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
(ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [235] ->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by Guided Substitution of Equals
and theorem 348:
Theorem (348) [serial 2122] used for:
  Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 2082]
 


Theorem (350)                               [serial 2073] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) < #PCS::MaxPosition and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition >>
S [235] ->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 349:
Theorem (349) [serial 2082] used for:
    normalization of [serial 2073]
 


Theorem (351)                               [serial 2024] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [235] ->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by Transitivity: x<y and y<z -> x<z
and theorem 350:
Theorem (350) [serial 2073] used for:
  Transitivity: x<y and y<z -> x<z [serial 2024]
 


Theorem (352)                               [serial 2006] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and (((ACTUAL_POSITION - 1) < ACTUAL_POSITION)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [235] ->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 351:
Theorem (351) [serial 2024] used for:
    normalization of [serial 2006]
 


Theorem (353)                               [serial 1992] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235] ->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 352:
Theorem (352) [serial 2006] used for:
  substituted Assertions' predicates for  labels  [serial 1992]
 


Theorem (354)                               [serial 1993] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235] ->
Q [236] << -1 = Delta >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (355)                               [serial 1994] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235] ->
Q [237] << E() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (356)                               [serial 1981] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235] ->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and E() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 343 353 354 355:
Theorem (343) [serial 1991] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1981]
 
Theorem (353) [serial 1992] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1981]
 
Theorem (354) [serial 1993] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1981]
 
Theorem (355) [serial 1994] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1981]
 


Theorem (357)                               [serial 1976] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235] ->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + Delta) and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and E() >>
by Law of And-Simplification:  P and P is P
and theorem 356:
Theorem (356) [serial 1981] used for:
  Law of And-Simplification:  P and P is P [serial 1976]
 


Theorem (358)                               [serial 1969] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235] ->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and E() >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 357:
Theorem (357) [serial 1976] used for:
    normalization of [serial 1969]
 


Theorem (359)                               [serial 1966] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235] ->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and 
E() >>
by Associativity: (b.c).a = a.b.c
and theorem 358:
Theorem (358) [serial 1969] used for:
  Associativity: (b.c).a = a.b.c [serial 1966]
 


Theorem (360)                               [serial 1957] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - 1) and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [235] ActuatorCommand(pc:Delta)
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
by Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
and theorem 359:
Theorem (359) [serial 1966] used for:
  applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1957]
 


Theorem (361)                               [serial 1948] 
P [15] << (E() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= DESIRED_POSITION) and 
AXIOM_GT(ACTUAL_POSITION) and (DESIRED_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) >>
S [235] ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and 
((ACTUAL_POSITION + Delta) >= 0) and E() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 360:
Theorem (360) [serial 1957] used for:
    normalization of [serial 1948]
 


Theorem (362)                               [serial 2108] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (363)                               [serial 2100] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240] ->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 362:
Theorem (362) [serial 2108] used for:
    normalization of [serial 2100]
 


Theorem (364)                               [serial 2084] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240] ->
Q [1] << 0 <= ACTUAL_POSITION^1 >>
by Guided Substitution of Equals
and theorem 363:
Theorem (363) [serial 2100] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2084]
 


Theorem (365)                               [serial 2074] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition and 
0 <= #PCS::MaxPosition >>
S [240] ->
Q [1] << 0 <= ACTUAL_POSITION^1 >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 364:
Theorem (364) [serial 2084] used for:
    normalization of [serial 2074]
 


Theorem (366)                               [serial 2054] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240] ->
Q [1] << 0 <= ACTUAL_POSITION^1 >>
by Transitivity: x<y and y<z -> x<z
and theorem 365:
Theorem (365) [serial 2074] used for:
  Transitivity: x<y and y<z -> x<z [serial 2054]
 


Theorem (367)                               [serial 2043] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = (ACTUAL_POSITION)^1 >>
S [240] ->
Q [1] << 0 <= (ACTUAL_POSITION)^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 366:
Theorem (366) [serial 2054] used for:
    normalization of [serial 2043]
 


Theorem (368)                               [serial 2014] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [240] ->
Q [1] << 0 <= ACTUAL_POSITION' >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 367:
Theorem (367) [serial 2043] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2014]
 


Theorem (369)                               [serial 2001] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [240] ->
Q [1] << 0 <= ACTUAL_POSITION' >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 368:
Theorem (368) [serial 2014] used for:
    normalization of [serial 2001]
 


Theorem (370)                               [serial 1987] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240] ->
Q [1] << 0 <= ACTUAL_POSITION' >>
by Substitution of Assertion Labels
and theorem 369:
Theorem (369) [serial 2001] used for:
  substituted Assertions' predicates for  labels  [serial 1987]
 


Theorem (371)                               [serial 2110] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240] ->
Q [243] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (372)                               [serial 2101] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240] ->
Q [243] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 371:
Theorem (371) [serial 2110] used for:
    normalization of [serial 2101]
 


Theorem (373)                               [serial 2086] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240] ->
Q [243] << ACTUAL_POSITION^1 <= #PCS::MaxPosition >>
by Guided Substitution of Equals
and theorem 372:
Theorem (372) [serial 2101] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2086]
 


Theorem (374)                               [serial 2075] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition and 
0 <= #PCS::MaxPosition >>
S [240] ->
Q [243] << ACTUAL_POSITION^1 <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 373:
Theorem (373) [serial 2086] used for:
    normalization of [serial 2075]
 


Theorem (375)                               [serial 2056] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240] ->
Q [243] << ACTUAL_POSITION^1 <= #PCS::MaxPosition >>
by Transitivity: x<y and y<z -> x<z
and theorem 374:
Theorem (374) [serial 2075] used for:
  Transitivity: x<y and y<z -> x<z [serial 2056]
 


Theorem (376)                               [serial 2044] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = (ACTUAL_POSITION)^1 >>
S [240] ->
Q [243] << (ACTUAL_POSITION)^1 <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 375:
Theorem (375) [serial 2056] used for:
    normalization of [serial 2044]
 


Theorem (377)                               [serial 2016] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [240] ->
Q [243] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 376:
Theorem (376) [serial 2044] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2016]
 


Theorem (378)                               [serial 2002] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [240] ->
Q [243] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 377:
Theorem (377) [serial 2016] used for:
    normalization of [serial 2002]
 


Theorem (379)                               [serial 1988] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240] ->
Q [243] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 378:
Theorem (378) [serial 2002] used for:
  substituted Assertions' predicates for  labels  [serial 1988]
 


Theorem (380)                               [serial 2119] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240] ->
Q [242] << true >>
by True Conclusion Schema (tc): P->true


Theorem (381)                               [serial 2112] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240] ->
Q [242] << Delta = Delta >>
by Equality Law (idistr):  a=a <-> true
and theorem 380:
Theorem (380) [serial 2119] used for:
  Equality Law (idistr):  a=a <-> true [serial 2112]
 


Theorem (382)                               [serial 2102] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240] ->
Q [242] << Delta = (((ACTUAL_POSITION + Delta)) - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Subtaction of Added Value:  (a+b)-a is b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 381:
Theorem (381) [serial 2112] used for:
    normalization of [serial 2102]
 


Theorem (383)                               [serial 2088] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240] ->
Q [242] << Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by Guided Substitution of Equals
and theorem 382:
Theorem (382) [serial 2102] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2088]
 


Theorem (384)                               [serial 2076] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition and 
0 <= #PCS::MaxPosition >>
S [240] ->
Q [242] << Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 383:
Theorem (383) [serial 2088] used for:
    normalization of [serial 2076]
 


Theorem (385)                               [serial 2058] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240] ->
Q [242] << Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by Transitivity: x<y and y<z -> x<z
and theorem 384:
Theorem (384) [serial 2076] used for:
  Transitivity: x<y and y<z -> x<z [serial 2058]
 


Theorem (386)                               [serial 2045] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = (ACTUAL_POSITION)^1 >>
S [240] ->
Q [242] << Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 385:
Theorem (385) [serial 2058] used for:
    normalization of [serial 2045]
 


Theorem (387)                               [serial 2018] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [240] ->
Q [242] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 386:
Theorem (386) [serial 2045] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2018]
 


Theorem (388)                               [serial 2003] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [240] ->
Q [242] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 387:
Theorem (387) [serial 2018] used for:
    normalization of [serial 2003]
 


Theorem (389)                               [serial 1989] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240] ->
Q [242] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Substitution of Assertion Labels
and theorem 388:
Theorem (388) [serial 2003] used for:
  substituted Assertions' predicates for  labels  [serial 1989]
 


Theorem (390)                               [serial 2130] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240] ->
Q [241] << ACTUAL_POSITION = EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (391)                               [serial 2124] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and  -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240] ->
Q [241] << (ACTUAL_POSITION) = (EstimatedActualPosition) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Unary Minus:  -(x-y) is (y-x)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 390:
Theorem (390) [serial 2130] used for:
    normalization of [serial 2124]
 


Theorem (392)                               [serial 2120] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240] ->
Q [241] << (ACTUAL_POSITION) = (EstimatedActualPosition) >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 391:
Theorem (391) [serial 2124] used for:
   changing adding negation to subtraction  [serial 2120]
 


Theorem (393)                               [serial 2114] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240] ->
Q [241] << (ACTUAL_POSITION + Delta) = (Delta + EstimatedActualPosition) >>
by Add both sides of equality:  a=b -> x+a=x+b
and theorem 392:
Theorem (392) [serial 2120] used for:
  Add both sides of equality:  a=b -> x+a=x+b [serial 2114]
 


Theorem (394)                               [serial 2103] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240] ->
Q [241] << ((ACTUAL_POSITION + Delta)) = (Delta + EstimatedActualPosition) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 393:
Theorem (393) [serial 2114] used for:
    normalization of [serial 2103]
 


Theorem (395)                               [serial 2090] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and -1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240] ->
Q [241] << ACTUAL_POSITION^1 = (Delta + EstimatedActualPosition) >>
by Guided Substitution of Equals
and theorem 394:
Theorem (394) [serial 2103] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2090]
 


Theorem (396)                               [serial 2077] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition and 
0 <= #PCS::MaxPosition >>
S [240] ->
Q [241] << ACTUAL_POSITION^1 = (Delta + EstimatedActualPosition) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 395:
Theorem (395) [serial 2090] used for:
    normalization of [serial 2077]
 


Theorem (397)                               [serial 2060] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION^1 = (ACTUAL_POSITION + Delta) and ACTUAL_POSITION = EstimatedActualPosition >>
S [240] ->
Q [241] << ACTUAL_POSITION^1 = (Delta + EstimatedActualPosition) >>
by Transitivity: x<y and y<z -> x<z
and theorem 396:
Theorem (396) [serial 2077] used for:
  Transitivity: x<y and y<z -> x<z [serial 2060]
 


Theorem (398)                               [serial 2046] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = (ACTUAL_POSITION)^1 >>
S [240] ->
Q [241] << (Delta + EstimatedActualPosition) = (ACTUAL_POSITION)^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 397:
Theorem (397) [serial 2060] used for:
    normalization of [serial 2046]
 


Theorem (399)                               [serial 2020] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [240] ->
Q [241] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 398:
Theorem (398) [serial 2046] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2020]
 


Theorem (400)                               [serial 2004] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [240] ->
Q [241] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 399:
Theorem (399) [serial 2020] used for:
    normalization of [serial 2004]
 


Theorem (401)                               [serial 1990] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240] ->
Q [241] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Substitution of Assertion Labels
and theorem 400:
Theorem (400) [serial 2004] used for:
  substituted Assertions' predicates for  labels  [serial 1990]
 


Theorem (402)                               [serial 1974] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 370 379 389 401:
Theorem (370) [serial 1987] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1974]
 
Theorem (379) [serial 1988] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1974]
 
Theorem (389) [serial 1989] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1974]
 
Theorem (401) [serial 1990] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1974]
 


Theorem (403)                               [serial 1967] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 402:
Theorem (402) [serial 1974] used for:
    normalization of [serial 1967]
 


Theorem (404)                               [serial 1959] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [240] EstimatedActualPosition' := (Delta + EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 403:
Theorem (403) [serial 1967] used for:
  applied wp for assignment [serial 1959]
 


Theorem (405)                               [serial 1949] 
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and 
((ACTUAL_POSITION + Delta) >= 0) and E() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
S [240] EstimatedActualPosition' := (EstimatedActualPosition + Delta)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 404:
Theorem (404) [serial 1959] used for:
    normalization of [serial 1949]
 


Theorem (406)                               [serial 1015] 
P [163] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 <= (EstimatedActualPosition - 1)))) >>
S [228] << ((DESIRED_POSITION <= (ACTUAL_POSITION - 1)) and E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Delta := -1
<< (E() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= DESIRED_POSITION) and AXIOM_GT(ACTUAL_POSITION) and (DESIRED_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and ((ACTUAL_POSITION + Delta) >= 0) and E() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition + Delta)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [159] << (E() and D() and ACTUAL_IN_RANGE())^1 >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 296 306 335 361 405:
Theorem (296) [serial 1945] used for:
  P -> P1 in sequential composition for [serial 1015]
 
Theorem (306) [serial 1946] used for:
  Q2 -> Q in sequential composition for [serial 1015]
 
Theorem (335) [serial 1947] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1015]
 
Theorem (361) [serial 1948] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1015]
 
Theorem (405) [serial 1949] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1015]
 


Theorem (407)                               [serial 1016] 
P [163] << (E() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and ((((DESIRED_POSITION)^0 > (EstimatedActualPosition - 1))) and 
(((EstimatedActualPosition + 1) > (DESIRED_POSITION)^0)))) >>
S [246] ->
Q [170] << true >>
by True Conclusion Schema (tc): P->true


Theorem (408)                               [serial 2151] 
P [249] << stop@now and ACTUAL_IN_RANGE() and D() and E() and false and not (exists u~time
  in tops,,now 
  that stop@u ) >>
S [249] ->
Q [165] << ACTUAL_IN_RANGE() and E() >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (409)                               [serial 2149] 
P [249] << (E() and D() and ACTUAL_IN_RANGE() and stop@now and not (true) and not (exists u~time
  in tops,,now 
  that stop@u )) >>
S [249] ->
Q [165] << (E() and ACTUAL_IN_RANGE()) >>
by Normalization
  Normalization Axioms:
    Complement
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 408:
Theorem (408) [serial 2151] used for:
    normalization of [serial 2149]
 


Theorem (410)                               [serial 2148] 
P [249] << (E() and D() and ACTUAL_IN_RANGE() and stop@now and not (exists u~time
  in tops,,now 
  that true ) and not (exists u~time
  in tops,,now 
  that stop@u )) >>
S [249] ->
Q [165] << (E() and ACTUAL_IN_RANGE()) >>
by Existential Quantification Introduction
and theorem 409:
Theorem (409) [serial 2149] used for:
  Existential Quantification Introduction [serial 2148]
 


Theorem (411)                               [serial 1017] 
P [249] << ((E() and D() and ACTUAL_IN_RANGE()) and stop@now and not (exists u~time
  in tops,,now 
  that true ) and not (exists u~time
  in tops,,now 
  that stop@u )) >>
S [249] ->
Q [165] << (E() and ACTUAL_IN_RANGE()) >>
by Associativity: (b.c).a = a.b.c
and theorem 410:
Theorem (410) [serial 2148] used for:
  Associativity: (b.c).a = a.b.c [serial 1017]
 


Theorem (412)                               [serial 2158] 
P [165] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [251] ->
Q [169] << 0 = EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (413)                               [serial 2157] 
P [165] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [251] ->
Q [169] << 0 = ACTUAL_POSITION >>
by Substitution in Postcondition of All Equivalents in Precondition
and theorem 412:
Theorem (412) [serial 2158] used for:
  Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 2157]
 


Theorem (414)                               [serial 2155] 
P [165] << 0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [251] ->
Q [169] << 0 = ACTUAL_POSITION >>
by Associativity: (b.c).a = a.b.c
and theorem 413:
Theorem (413) [serial 2157] used for:
  Associativity: (b.c).a = a.b.c [serial 2155]
 


Theorem (415)                               [serial 2153] 
P [165] << (((EstimatedActualPosition = ACTUAL_POSITION)) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = 0))) >>
S [251] ->
Q [169] << (ACTUAL_POSITION = 0) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 414:
Theorem (414) [serial 2155] used for:
    normalization of [serial 2153]
 


Theorem (416)                               [serial 1018] 
P [165] << (E() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition = 0))) >>
S [251] ->
Q [169] << (ACTUAL_POSITION = 0) >>
by Substitution of Assertion Labels
and theorem 415:
Theorem (415) [serial 2153] used for:
  substituted Assertions' predicates for  labels  [serial 1018]
 


Theorem (417)                               [serial 2196] 
P [15] << ACTUAL_IN_RANGE() and E() and 0 < EstimatedActualPosition >>
S [165] ->
Q [254] << ACTUAL_IN_RANGE() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (418)                               [serial 2197] 
P [15] << ACTUAL_IN_RANGE() and E() and 0 < EstimatedActualPosition >>
S [165] ->
Q [254] << E() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (419)                               [serial 2226] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < EstimatedActualPosition >>
S [165] ->
Q [1] << 0 < EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (420)                               [serial 2225] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < EstimatedActualPosition >>
S [165] ->
Q [1] << 0 < ACTUAL_POSITION >>
by Substitution in Postcondition of All Equivalents in Precondition
and theorem 419:
Theorem (419) [serial 2226] used for:
  Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 2225]
 


Theorem (421)                               [serial 2223] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and 0 < EstimatedActualPosition >>
S [165] ->
Q [1] << 0 < ACTUAL_POSITION >>
by Associativity: (b.c).a = a.b.c
and theorem 420:
Theorem (420) [serial 2225] used for:
  Associativity: (b.c).a = a.b.c [serial 2223]
 


Theorem (422)                               [serial 2221] 
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < EstimatedActualPosition >>
S [165] ->
Q [1] << 0 < ACTUAL_POSITION >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 421:
Theorem (421) [serial 2223] used for:
    normalization of [serial 2221]
 


Theorem (423)                               [serial 2198] 
P [15] << ACTUAL_IN_RANGE() and E() and 0 < EstimatedActualPosition >>
S [165] ->
Q [1] << 0 < ACTUAL_POSITION >>
by Substitution of Assertion Labels
and theorem 422:
Theorem (422) [serial 2221] used for:
  substituted Assertions' predicates for  labels  [serial 2198]
 


Theorem (424)                               [serial 2165] 
P [15] << ACTUAL_IN_RANGE() and E() and 0 < EstimatedActualPosition >>
S [165] ->
Q [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 417 418 423:
Theorem (417) [serial 2196] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2165]
 
Theorem (418) [serial 2197] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2165]
 
Theorem (423) [serial 2198] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2165]
 


Theorem (425)                               [serial 2159] 
P [15] << (E() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition > 0))) >>
S [165] ->
Q [15] << (E() and (ACTUAL_POSITION > 0) and ACTUAL_IN_RANGE()) >>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 424:
Theorem (424) [serial 2165] used for:
    normalization of [serial 2159]
 


Theorem (426)                               [serial 2219] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [167] ->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
by Identity (id):  P->P is tautology


Theorem (427)                               [serial 2217] 
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
(ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [167] ->
Q [15] << (((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1) and 
((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1)) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
and theorem 426:
Theorem (426) [serial 2219] used for:
    normalization of [serial 2217]
 


Theorem (428)                               [serial 2216] 
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
(ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [167] ->
Q [15] << ((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1 and 
(ACTUAL_POSITION = EstimatedActualPosition)^1) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 427:
Theorem (427) [serial 2217] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2216]
 


Theorem (429)                               [serial 2215] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [167] ->
Q [15] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 428:
Theorem (428) [serial 2216] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2215]
 


Theorem (430)                               [serial 2213] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [167] ->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
by Associativity: (b.c).a = a.b.c
and theorem 429:
Theorem (429) [serial 2215] used for:
  Associativity: (b.c).a = a.b.c [serial 2213]
 


Theorem (431)                               [serial 2211] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [167] ->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 430:
Theorem (430) [serial 2213] used for:
    normalization of [serial 2211]
 


Theorem (432)                               [serial 2167] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [167] ->
Q [15] << (ACTUAL_IN_RANGE() and E())^1 >>
by Substitution of Assertion Labels
and theorem 431:
Theorem (431) [serial 2211] used for:
  substituted Assertions' predicates for  labels  [serial 2167]
 


Theorem (433)                               [serial 2160] 
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION' >= 0) and 
(ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [167] ->
Q [15] << (E() and ACTUAL_IN_RANGE())^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 432:
Theorem (432) [serial 2167] used for:
    normalization of [serial 2160]
 


Theorem (434)                               [serial 2232] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [255] ->
Q [1] << 0 < ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (435)                               [serial 2230] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [255] ->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
by Partial Order Law 3:  a <= (b-1)  is  a<b
and theorem 434:
Theorem (434) [serial 2232] used for:
    0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2230]
 


Theorem (436)                               [serial 2228] 
P [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [255] ->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 435:
Theorem (435) [serial 2230] used for:
    normalization of [serial 2228]
 


Theorem (437)                               [serial 2227] 
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [255] ->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
by Associativity: (b.c).a = a.b.c
and theorem 436:
Theorem (436) [serial 2228] used for:
  Associativity: (b.c).a = a.b.c [serial 2227]
 


Theorem (438)                               [serial 2199] 
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255] ->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
by Substitution of Assertion Labels
and theorem 437:
Theorem (437) [serial 2227] used for:
  substituted Assertions' predicates for  labels  [serial 2199]
 


Theorem (439)                               [serial 2237] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [255] ->
Q [257] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (440)                               [serial 2235] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and 0 < ACTUAL_POSITION >>
S [255] ->
Q [257] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Associativity: (b.c).a = a.b.c
and theorem 439:
Theorem (439) [serial 2237] used for:
  Associativity: (b.c).a = a.b.c [serial 2235]
 


Theorem (441)                               [serial 2233] 
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [255] ->
Q [257] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 440:
Theorem (440) [serial 2235] used for:
    normalization of [serial 2233]
 


Theorem (442)                               [serial 2200] 
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255] ->
Q [257] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 441:
Theorem (441) [serial 2233] used for:
  substituted Assertions' predicates for  labels  [serial 2200]
 


Theorem (443)                               [serial 2201] 
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255] ->
Q [256] << E() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (444)                               [serial 2186] 
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255] ->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
E() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 438 442 443:
Theorem (438) [serial 2199] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2186]
 
Theorem (442) [serial 2200] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2186]
 
Theorem (443) [serial 2201] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2186]
 


Theorem (445)                               [serial 2185] 
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255] ->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
true and E() >>
by Law of And-Simplification:  P and true is P
and theorem 444:
Theorem (444) [serial 2186] used for:
  Law of And-Simplification:  P and true is P [serial 2185]
 


Theorem (446)                               [serial 2232] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [255] ->
Q [1] << 0 < ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (447)                               [serial 2230] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [255] ->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
by Partial Order Law 3:  a <= (b-1)  is  a<b
and theorem 446:
Theorem (446) [serial 2232] used for:
    0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2230]
 


Theorem (448)                               [serial 2228] 
P [15] << (ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [255] ->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 447:
Theorem (447) [serial 2230] used for:
    normalization of [serial 2228]
 


Theorem (449)                               [serial 2227] 
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [255] ->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
by Associativity: (b.c).a = a.b.c
and theorem 448:
Theorem (448) [serial 2228] used for:
  Associativity: (b.c).a = a.b.c [serial 2227]
 


Theorem (450)                               [serial 2199] 
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255] ->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
by Substitution of Assertion Labels
and theorem 449:
Theorem (449) [serial 2227] used for:
  substituted Assertions' predicates for  labels  [serial 2199]
 


Theorem (451)                               [serial 2237] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [255] ->
Q [257] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (452)                               [serial 2235] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and 0 < ACTUAL_POSITION >>
S [255] ->
Q [257] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Associativity: (b.c).a = a.b.c
and theorem 451:
Theorem (451) [serial 2237] used for:
  Associativity: (b.c).a = a.b.c [serial 2235]
 


Theorem (453)                               [serial 2233] 
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [255] ->
Q [257] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 452:
Theorem (452) [serial 2235] used for:
    normalization of [serial 2233]
 


Theorem (454)                               [serial 2200] 
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255] ->
Q [257] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 453:
Theorem (453) [serial 2233] used for:
  substituted Assertions' predicates for  labels  [serial 2200]
 


Theorem (455)                               [serial 2201] 
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255] ->
Q [256] << E() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (456)                               [serial 2186] 
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255] ->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
E() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 450 454 455:
Theorem (450) [serial 2199] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2186]
 
Theorem (454) [serial 2200] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2186]
 
Theorem (455) [serial 2201] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2186]
 


Theorem (457)                               [serial 2185] 
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255] ->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
true and E() >>
by Law of And-Simplification:  P and true is P
and theorem 456:
Theorem (456) [serial 2186] used for:
  Law of And-Simplification:  P and true is P [serial 2185]
 


Theorem (458)                               [serial 2184] 
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255] ->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
AXIOM_GT(ACTUAL_POSITION) and E() >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 457 457:
Theorem (457) [serial 2185] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (457) [serial 2185] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (459)                               [serial 2182] 
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255] ->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
true and AXIOM_GT(ACTUAL_POSITION) and E() >>
by Law of And-Simplification:  P and true is P
and theorem 458:
Theorem (458) [serial 2184] used for:
  Law of And-Simplification:  P and true is P [serial 2182]
 


Theorem (460)                               [serial 2179] 
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255] ->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = -1 and AXIOM_GT(ACTUAL_POSITION) and E() >>
by Equality Law (idistr):  a=a <-> true
and theorem 459:
Theorem (459) [serial 2182] used for:
  Equality Law (idistr):  a=a <-> true [serial 2179]
 


Theorem (461)                               [serial 2169] 
P [15] << ACTUAL_IN_RANGE() and E() and 0 < ACTUAL_POSITION >>
S [255] Delta := -1
Q [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 460:
Theorem (460) [serial 2179] used for:
  applied wp for assignment [serial 2169]
 


Theorem (462)                               [serial 2161] 
P [15] << (E() and (ACTUAL_POSITION > 0) and ACTUAL_IN_RANGE()) >>
S [255] Delta := -1
Q [15] << (E() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= 0) and AXIOM_GT(ACTUAL_POSITION) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 461:
Theorem (461) [serial 2169] used for:
    normalization of [serial 2161]
 


Theorem (463)                               [serial 2205] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259] ->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (464)                               [serial 2267] 
P [15] << 0 <= (-1 + ACTUAL_POSITION) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259] ->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (465)                               [serial 2265] 
P [15] << 0 <= (ACTUAL_POSITION +  -1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
 -1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259] ->
Q [1] << 0 <= ( -1 + ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Unary Minus:  -(x-y) is (y-x)
and theorem 464:
Theorem (464) [serial 2267] used for:
    normalization of [serial 2265]
 


Theorem (466)                               [serial 2264] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259] ->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 465:
Theorem (465) [serial 2265] used for:
   changing adding negation to subtraction  [serial 2264]
 


Theorem (467)                               [serial 2206] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
and theorem 466:
Theorem (466) [serial 2264] used for:
  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
 replacing "Delta"
 with its ="
 (-1)" [serial 2206]
 


Theorem (468)                               [serial 2274] 
P [15] << 0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and -1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [259] ->
Q [261] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (469)                               [serial 2273] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [259] ->
Q [261] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
by Partial Order Law 3:  a <= (b-1)  is  a<b
and theorem 468:
Theorem (468) [serial 2274] used for:
  0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION
(ACTUAL_POSITION - 1)<#PCS::MaxPosition  ->  (ACTUAL_POSITION - 1)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2273]
 


Theorem (470)                               [serial 2271] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [259] ->
Q [261] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
by Transitivity: x<y and y<z -> x<z
and theorem 469:
Theorem (469) [serial 2273] used for:
  Transitivity: x<y and y<z -> x<z [serial 2271]
 


Theorem (471)                               [serial 2269] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and (((ACTUAL_POSITION - 1) < ACTUAL_POSITION)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [259] ->
Q [261] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 470:
Theorem (470) [serial 2271] used for:
    normalization of [serial 2269]
 


Theorem (472)                               [serial 2207] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259] ->
Q [261] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 471:
Theorem (471) [serial 2269] used for:
  substituted Assertions' predicates for  labels  [serial 2207]
 


Theorem (473)                               [serial 2288] 
P [15] << 0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and -1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 
(-1 + ACTUAL_POSITION) < ACTUAL_POSITION and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
S [259] ->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (474)                               [serial 2286] 
P [15] << 0 <= (-1 + ACTUAL_POSITION) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION and 
0 < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION and (
-1 + ACTUAL_POSITION) < #PCS::MaxPosition >>
S [259] ->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
by Partial Order Law 3:  a <= (b-1)  is  a<b
and theorem 473:
Theorem (473) [serial 2288] used for:
  0<=(--1+ACTUAL_POSITION)  is  0<ACTUAL_POSITION
(-1 + ACTUAL_POSITION)<#PCS::MaxPosition  ->  (-1 + ACTUAL_POSITION)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2286]
 


Theorem (475)                               [serial 2284] 
P [15] << 0 <= (ACTUAL_POSITION +  -1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
 -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION and 
0 < #PCS::MaxPosition and (ACTUAL_POSITION +  -1) < ACTUAL_POSITION and 
(ACTUAL_POSITION +  -1) < #PCS::MaxPosition >>
S [259] ->
Q [130] << ( -1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Unary Minus:  -(x-y) is (y-x)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 474:
Theorem (474) [serial 2286] used for:
    normalization of [serial 2284]
 


Theorem (476)                               [serial 2282] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION and 
0 < #PCS::MaxPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and (ACTUAL_POSITION - 1) < #PCS::MaxPosition >>
S [259] ->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 475:
Theorem (475) [serial 2284] used for:
   changing adding negation to subtraction  [serial 2282]
 


Theorem (477)                               [serial 2280] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [259] ->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 476:
Theorem (476) [serial 2282] used for:
    normalization of [serial 2280]
 


Theorem (478)                               [serial 2278] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [259] ->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
by Transitivity: x<y and y<z -> x<z
and theorem 477:
Theorem (477) [serial 2280] used for:
  Transitivity: x<y and y<z -> x<z [serial 2278]
 


Theorem (479)                               [serial 2276] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and (((ACTUAL_POSITION - 1) < ACTUAL_POSITION)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [259] ->
Q [130] << (ACTUAL_POSITION + -1) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 478:
Theorem (478) [serial 2278] used for:
    normalization of [serial 2276]
 


Theorem (480)                               [serial 2275] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259] ->
Q [130] << (ACTUAL_POSITION + -1) <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 479:
Theorem (479) [serial 2276] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2275]
 


Theorem (481)                               [serial 2208] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259] ->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by Guided Substitution of Equals
and theorem 480:
Theorem (480) [serial 2275] used for:
  Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 2208]
 


Theorem (482)                               [serial 2209] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259] ->
Q [260] << -1 = Delta >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (483)                               [serial 2210] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259] ->
Q [261] << E() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (484)                               [serial 2192] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259] ->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and -1 = Delta and E() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 463 467 472 481 482 483:
Theorem (463) [serial 2205] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]
 
Theorem (467) [serial 2206] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]
 
Theorem (472) [serial 2207] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]
 
Theorem (481) [serial 2208] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]
 
Theorem (482) [serial 2209] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]
 
Theorem (483) [serial 2210] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2192]
 


Theorem (485)                               [serial 2183] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259] ->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and E() >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 484:
Theorem (484) [serial 2192] used for:
    normalization of [serial 2183]
 


Theorem (486)                               [serial 2180] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259] ->
Q [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and 
E() >>
by Associativity: (b.c).a = a.b.c
and theorem 485:
Theorem (485) [serial 2183] used for:
  Associativity: (b.c).a = a.b.c [serial 2180]
 


Theorem (487)                               [serial 2171] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E() >>
S [259] ActuatorCommand(pc:Delta)
Q [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
by Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
and theorem 486:
Theorem (486) [serial 2180] used for:
  applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2171]
 


Theorem (488)                               [serial 2162] 
P [15] << (E() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= 0) and AXIOM_GT(ACTUAL_POSITION) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) >>
S [259] ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and 
((ACTUAL_POSITION - 1) >= 0) and E() and ((ACTUAL_POSITION - 1) <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 487:
Theorem (487) [serial 2171] used for:
    normalization of [serial 2162]
 


Theorem (489)                               [serial 2245] 
P [15] << 0 <= (-1 + ACTUAL_POSITION) and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263] ->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (490)                               [serial 2243] 
P [15] << 0 <= (ACTUAL_POSITION +  -1) and (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition and 
 -1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263] ->
Q [1] << 0 <= ( -1 + ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Unary Minus:  -(x-y) is (y-x)
and theorem 489:
Theorem (489) [serial 2245] used for:
    normalization of [serial 2243]
 


Theorem (491)                               [serial 2241] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263] ->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 490:
Theorem (490) [serial 2243] used for:
   changing adding negation to subtraction  [serial 2241]
 


Theorem (492)                               [serial 2239] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263] ->
Q [1] << 0 <= ((ACTUAL_POSITION + -1)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 491:
Theorem (491) [serial 2241] used for:
    normalization of [serial 2239]
 


Theorem (493)                               [serial 2238] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263] ->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
by Guided Substitution of Equals
and theorem 492:
Theorem (492) [serial 2239] used for:
  Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 2238]
 


Theorem (494)                               [serial 2202] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263] ->
Q [1] << 0 <= ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 493:
Theorem (493) [serial 2238] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2202]
 


Theorem (495)                               [serial 2252] 
P [15] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and -1 = Delta and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E() and 0 < ACTUAL_POSITION >>
S [263] ->
Q [265] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (496)                               [serial 2250] 
P [15] << 0 < ACTUAL_POSITION and (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition and 
 -1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263] ->
Q [265] << ((ACTUAL_POSITION +  -1)) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Equality: (a=b) = (b=a)
    Unary Minus:  -(x-y) is (y-x)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 495:
Theorem (495) [serial 2252] used for:
    normalization of [serial 2250]
 


Theorem (497)                               [serial 2249] 
P [15] << 0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263] ->
Q [265] << ((ACTUAL_POSITION + -1)) <= #PCS::MaxPosition >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 496:
Theorem (496) [serial 2250] used for:
   changing adding negation to subtraction  [serial 2249]
 


Theorem (498)                               [serial 2248] 
P [15] << 0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263] ->
Q [265] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
by Guided Substitution of Equals
and theorem 497:
Theorem (497) [serial 2249] used for:
  Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 2248]
 


Theorem (499)                               [serial 2247] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263] ->
Q [265] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
by Partial Order Law 3:  a <= (b-1)  is  a<b
and theorem 498:
Theorem (498) [serial 2248] used for:
  0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2247]
 


Theorem (500)                               [serial 2203] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263] ->
Q [265] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
by Guided Substitution of Equals
and theorem 499:
Theorem (499) [serial 2247] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2203]
 


Theorem (501)                               [serial 2263] 
P [15] << 0 <= ( -1 + ACTUAL_POSITION) and ( -1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
 -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [263] ->
Q [264] << true >>
by True Conclusion Schema (tc): P->true


Theorem (502)                               [serial 2262] 
P [15] << 0 <= ( -1 + ACTUAL_POSITION) and ( -1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
 -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [263] ->
Q [264] << (-1 + ACTUAL_POSITION) = (-1 + ACTUAL_POSITION) >>
by Equality Law (idistr):  a=a <-> true
and theorem 501:
Theorem (501) [serial 2263] used for:
  Equality Law (idistr):  a=a <-> true [serial 2262]
 


Theorem (503)                               [serial 2261] 
P [15] << 0 <= ( -1 + ACTUAL_POSITION) and ( -1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
 -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [263] ->
Q [264] << ( -1 + ACTUAL_POSITION) = ( -1 + EstimatedActualPosition) >>
by Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
and theorem 502:
Theorem (502) [serial 2262] used for:
  Substitution of Equals (anywhere):
  <<...(P[a/b] and a=b)>> S <<Q>>
  ----------------------
   <<...(P and a=b)>> S <<Q>>
 replacing "EstimatedActualPosition"
 with its ="
 (ACTUAL_POSITION)" [serial 2261]
 


Theorem (504)                               [serial 2259] 
P [15] << 0 <= (-1 + ACTUAL_POSITION) and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [263] ->
Q [264] << (-1 + ACTUAL_POSITION) = (-1 + EstimatedActualPosition) >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 503:
Theorem (503) [serial 2261] used for:
   changing adding negation to subtraction  [serial 2259]
 


Theorem (505)                               [serial 2257] 
P [15] << 0 <= (ACTUAL_POSITION +  -1) and (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition and 
 -1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [263] ->
Q [264] << (EstimatedActualPosition +  -1) = ((ACTUAL_POSITION +  -1)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Equality: (a=b) = (b=a)
    Unary Minus:  -(x-y) is (y-x)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 504:
Theorem (504) [serial 2259] used for:
    normalization of [serial 2257]
 


Theorem (506)                               [serial 2256] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [263] ->
Q [264] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + -1)) >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 505:
Theorem (505) [serial 2257] used for:
   changing adding negation to subtraction  [serial 2256]
 


Theorem (507)                               [serial 2255] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263] ->
Q [264] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + -1)) >>
by Substitution of Assertion Labels
and theorem 506:
Theorem (506) [serial 2256] used for:
  substituted Assertions' predicates for  labels  [serial 2255]
 


Theorem (508)                               [serial 2254] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263] ->
Q [264] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + Delta)) >>
by Guided Substitution of Equals
and theorem 507:
Theorem (507) [serial 2255] used for:
  Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 2254]
 


Theorem (509)                               [serial 2204] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263] ->
Q [264] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 508:
Theorem (508) [serial 2254] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2204]
 


Theorem (510)                               [serial 2190] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 494 500 509:
Theorem (494) [serial 2202] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2190]
 
Theorem (500) [serial 2203] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2190]
 
Theorem (509) [serial 2204] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2190]
 


Theorem (511)                               [serial 2181] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 510:
Theorem (510) [serial 2190] used for:
    normalization of [serial 2181]
 


Theorem (512)                               [serial 2173] 
P [15] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E() >>
S [263] EstimatedActualPosition' := (EstimatedActualPosition - 1)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 511:
Theorem (511) [serial 2181] used for:
  applied wp for assignment [serial 2173]
 


Theorem (513)                               [serial 2163] 
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and 
((ACTUAL_POSITION - 1) >= 0) and E() and ((ACTUAL_POSITION - 1) <= #PCS::MaxPosition)) >>
S [263] EstimatedActualPosition' := (EstimatedActualPosition - 1)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION' >= 0) and 
(ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 512:
Theorem (512) [serial 2173] used for:
    normalization of [serial 2163]
 


Theorem (514)                               [serial 1019] 
P [165] << (E() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition > 0))) >>
S [254] << (E() and (ACTUAL_POSITION > 0) and ACTUAL_IN_RANGE()) >>
Delta := -1
<< (E() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= 0) and AXIOM_GT(ACTUAL_POSITION) and (ACTUAL_POSITION <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and ((ACTUAL_POSITION - 1) >= 0) and E() and ((ACTUAL_POSITION - 1) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition - 1)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [167] << (E() and ACTUAL_IN_RANGE())^1 >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 425 433 462 488 513:
Theorem (425) [serial 2159] used for:
  P -> P1 in sequential composition for [serial 1019]
 
Theorem (433) [serial 2160] used for:
  Q2 -> Q in sequential composition for [serial 1019]
 
Theorem (462) [serial 2161] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1019]
 
Theorem (488) [serial 2162] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1019]
 
Theorem (513) [serial 2163] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1019]
 


Theorem (515)                               [serial 1020] 
P [165] << (E() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition < 0))) >>
S [268] ->
Q [170] << true >>
by True Conclusion Schema (tc): P->true


Theorem (516)                               [serial 1021] 
P [167] << (E() and ACTUAL_IN_RANGE()) >>
S [269] ->
Q [165] << (E() and ACTUAL_IN_RANGE()) >>
by Identity (id):  P->P is tautology


Theorem (517)                               [serial 1002] 
P [149] <<   >>
S [149] ->
Q [149] << FragilePositionControlThread.SingleStep proof obligations >>
by Initial Thread Obligations
and theorems 1 2 5 13 14 21 90 92 97 98 165 278 406 407 411 416 514 515 516:
Theorem (1) [serial 1003] used for:
  <<M(StillClosing)>> -> <<I>> from invariant I when complete state StillClosing has Assertion <<M(StillClosing)>> in its definition.
 
Theorem (2) [serial 1004] used for:
  <<M(Run)>> -> <<I>> from invariant I when complete state Run has Assertion <<M(Run)>> in its definition.
 
Theorem (5) [serial 1005] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state ShutDown, <<M(ShutDown)>> -> <<e1 or e2 or . . . en>>
 
Theorem (13) [serial 1006] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state Check, <<M(Check)>> -> <<e1 or e2 or . . . en>>
 
Theorem (14) [serial 1007] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state PowerOn, <<M(PowerOn)>> -> <<e1 or e2 or . . . en>>
 
Theorem (21) [serial 1008] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state Decide, <<M(Decide)>> -> <<e1 or e2 or . . . en>>
 
Theorem (90) [serial 1009] used for:
   <<M(PowerOn)>> A <<M(Run)>> for fra0po:PowerOn-[ ]->Run{A};
 
Theorem (92) [serial 1010] used for:
   <<M(Run) and x>> -> <<M(Check)>> for fra1run:Run-[x]->Check{};
 
Theorem (97) [serial 1011] used for:
   <<M(Check) and x>> -> <<M(Decide)>> for fra1ok:Check-[x]->Decide{};
 
Theorem (98) [serial 1012] used for:
   <<M(Check) and x>> -> <<M(Error)>> for fra1er:Check-[x]->Error{};
 
Theorem (165) [serial 1013] used for:
   <<M(Decide) and x>> A <<M(Run)>> for fra2eq:Decide-[x]->Run{A};
 
Theorem (278) [serial 1014] used for:
   <<M(Decide) and x>> A <<M(Run)>> for fra3gt:Decide-[x]->Run{A};
 
Theorem (406) [serial 1015] used for:
   <<M(Decide) and x>> A <<M(Run)>> for fra4lt:Decide-[x]->Run{A};
 
Theorem (407) [serial 1016] used for:
   <<M(Decide) and x>> -> <<M(Error)>> for fraSerban:Decide-[x]->Error{};
 
Theorem (411) [serial 1017] used for:
   <<M(Run) and x>> -> <<M(ShutDown)>> for fra5stop:Run-[x]->ShutDown{};
 
Theorem (416) [serial 1018] used for:
   <<M(ShutDown) and x>> -> <<M(Done)>> for fra6done:ShutDown-[x]->Done{};
 
Theorem (514) [serial 1019] used for:
   <<M(ShutDown) and x>> A <<M(StillClosing)>> for fra7sc:ShutDown-[x]->StillClosing{A};
 
Theorem (515) [serial 1020] used for:
   <<M(ShutDown) and x>> -> <<M(Error)>> for fra8er:ShutDown-[x]->Error{};
 
Theorem (516) [serial 1021] used for:
   <<M(StillClosing) and x>> -> <<M(ShutDown)>> for fra9cl:StillClosing-[x]->ShutDown{};
 


Theorem (518)                               [serial 1023] 
P [302] << (E_MS() and ACTUAL_IN_RANGE()) >>
S [284] ->
Q [284] << (E_MS() and ACTUAL_IN_RANGE()) >>
by Identity (id):  P->P is tautology


Theorem (519)                               [serial 2290] 
P [294] << ACTUAL_IN_RANGE() and D_MS() and E_MS() >>
S [284] ->
Q [284] << ACTUAL_IN_RANGE() and E_MS() >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (520)                               [serial 1024] 
P [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE()) >>
S [284] ->
Q [284] << (E_MS() and ACTUAL_IN_RANGE()) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 519:
Theorem (519) [serial 2290] used for:
    normalization of [serial 1024]
 


Theorem (521)                               [serial 2295] 
P [300] << ACTUAL_IN_RANGE() and E_MS() >>
S [300] ->
Q [300] << true >>
by True Conclusion Schema (tc): P->true


Theorem (522)                               [serial 2293] 
P [300] << ACTUAL_IN_RANGE() and E_MS() >>
S [300] ->
Q [300] << 0 = EstimatedActualPosition or 0 < EstimatedActualPosition or EstimatedActualPosition < 0 >>
by Less than, greater than, or equal:  |-a<b or b<a or a=b
and theorem 521:
Theorem (521) [serial 2295] used for:
  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 2293]
 


Theorem (523)                               [serial 1025] 
P [300] << (E_MS() and ACTUAL_IN_RANGE()) >>
S [300] ->
Q [300] << (((EstimatedActualPosition = 0)) or ((EstimatedActualPosition > 0)) or 
((EstimatedActualPosition < 0))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 522:
Theorem (522) [serial 2293] used for:
    normalization of [serial 1025]
 


Theorem (524)                               [serial 2309] 
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296] ->
Q [296] << true >>
by True Conclusion Schema (tc): P->true


Theorem (525)                               [serial 2307] 
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296] ->
Q [296] << (true) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 524:
Theorem (524) [serial 2309] used for:
    normalization of [serial 2307]
 


Theorem (526)                               [serial 2306] 
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296] ->
Q [296] << (true) and (true) >>
by Law of And-Simplification:  P and P is P
and theorem 525:
Theorem (525) [serial 2307] used for:
  Law of And-Simplification:  P and P is P [serial 2306]
 


Theorem (527)                               [serial 2305] 
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296] ->
Q [296] << (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0 or 
not DESIRED_POSITION^0 < 0) and (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0 or 
not #PCS::MaxPosition < DESIRED_POSITION^0) >>
by Law of Excluded Middle: P or not P is tautology
and theorem 526:
Theorem (526) [serial 2306] used for:
  Law of Excluded Middle: P or not P is tautology [serial 2305]
 


Theorem (528)                               [serial 2304] 
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296] ->
Q [296] << (not DESIRED_POSITION^0 < 0 or (DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0)) and 
(not #PCS::MaxPosition < DESIRED_POSITION^0 or (DESIRED_POSITION^0 < 0 or 
#PCS::MaxPosition < DESIRED_POSITION^0)) >>
by Associativity: (b.c).a = a.b.c
and theorem 527:
Theorem (527) [serial 2305] used for:
  Associativity: (b.c).a = a.b.c [serial 2304]
 


Theorem (529)                               [serial 2301] 
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296] ->
Q [296] << (not DESIRED_POSITION^0 < 0 and not #PCS::MaxPosition < DESIRED_POSITION^0) or 
(DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0) >>
by Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 528:
Theorem (528) [serial 2304] used for:
  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and while transforming into
  conjunctive normal form [serial 2301]
 


Theorem (530)                               [serial 2299] 
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296] ->
Q [296] << ((not (DESIRED_POSITION^0 < 0)) and (not (#PCS::MaxPosition < DESIRED_POSITION^0))) or 
(DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 529:
Theorem (529) [serial 2301] used for:
    normalization of [serial 2299]
 


Theorem (531)                               [serial 2297] 
P [296] << ACTUAL_IN_RANGE() and E_MS() >>
S [296] ->
Q [296] << (0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition) or 
(DESIRED_POSITION^0 < 0 or #PCS::MaxPosition < DESIRED_POSITION^0) >>
by At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 530:
Theorem (530) [serial 2299] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a) [serial 2297]
 


Theorem (532)                               [serial 1026] 
P [296] << (E_MS() and ACTUAL_IN_RANGE()) >>
S [296] ->
Q [296] << (((((DESIRED_POSITION)^0 >= 0)) and (((DESIRED_POSITION)^0 <= #PCS::MaxPosition))) or 
(((((DESIRED_POSITION)^0 < 0))) or ((((DESIRED_POSITION)^0 > #PCS::MaxPosition))))) >>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 531:
Theorem (531) [serial 2297] used for:
    normalization of [serial 1026]
 


Theorem (533)                               [serial 1027] 
P [292] << (ACTUAL_POSITION = 0) >>
S [292] ->
Q [292] << true >>
by True Conclusion Schema (tc): P->true


Theorem (534)                               [serial 2326] 
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [298] << true >>
by True Conclusion Schema (tc): P->true


Theorem (535)                               [serial 2324] 
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [298] << (true) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 534:
Theorem (534) [serial 2326] used for:
    normalization of [serial 2324]
 


Theorem (536)                               [serial 2323] 
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [298] << (true) and (true) >>
by Law of And-Simplification:  P and P is P
and theorem 535:
Theorem (535) [serial 2324] used for:
  Law of And-Simplification:  P and P is P [serial 2323]
 


Theorem (537)                               [serial 2322] 
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [298] << (true) and (true) and (true) >>
by Law of And-Simplification:  P and P is P
and theorem 536:
Theorem (536) [serial 2323] used for:
  Law of And-Simplification:  P and P is P [serial 2322]
 


Theorem (538)                               [serial 2321] 
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [298] << (true) and (DESIRED_POSITION^0 < EstimatedActualPosition or EstimatedActualPosition < DESIRED_POSITION^0 or 
DESIRED_POSITION^0 = EstimatedActualPosition or not DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) or not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) and 
(true) >>
by Less than, greater than, or equal:  |-a<b or b<a or a=b
and theorem 537:
Theorem (537) [serial 2322] used for:
  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 2321]
 


Theorem (539)                               [serial 2320] 
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [298] << (true) and (true) and (DESIRED_POSITION^0 < EstimatedActualPosition or 
EstimatedActualPosition < DESIRED_POSITION^0 or DESIRED_POSITION^0 = EstimatedActualPosition or 
not DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp) or 
not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) and 
(true) >>
by Law of And-Simplification:  P and P is P
and theorem 538:
Theorem (538) [serial 2321] used for:
  Law of And-Simplification:  P and P is P [serial 2320]
 


Theorem (540)                               [serial 2319] 
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [298] << (DESIRED_POSITION^0 < EstimatedActualPosition or DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) or DESIRED_POSITION^0 = EstimatedActualPosition or 
not DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp) or 
not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) and 
((EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 or DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) or DESIRED_POSITION^0 = EstimatedActualPosition or 
not DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp) or 
not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) and 
(DESIRED_POSITION^0 < EstimatedActualPosition or EstimatedActualPosition < DESIRED_POSITION^0 or 
DESIRED_POSITION^0 = EstimatedActualPosition or not DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) or not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) and 
((EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 or EstimatedActualPosition < DESIRED_POSITION^0 or 
DESIRED_POSITION^0 = EstimatedActualPosition or not DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) or not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) >>
by Law of Excluded Middle: P or not P is tautology
and theorem 539:
Theorem (539) [serial 2320] used for:
  Law of Excluded Middle: P or not P is tautology [serial 2319]
 


Theorem (541)                               [serial 2316] 
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [298] << DESIRED_POSITION^0 = EstimatedActualPosition or not DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) or not (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 or 
(DESIRED_POSITION^0 < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) or 
(DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0) >>
by Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 540:
Theorem (540) [serial 2319] used for:
  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and while transforming into
  conjunctive normal form [serial 2316]
 


Theorem (542)                               [serial 2314] 
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [298] << (not ((EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0)) or 
(not (DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp))) or 
DESIRED_POSITION^0 = EstimatedActualPosition or (DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) or (DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 541:
Theorem (541) [serial 2316] used for:
    normalization of [serial 2314]
 


Theorem (543)                               [serial 2312] 
P [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [298] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) or 
(EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 or DESIRED_POSITION^0 = EstimatedActualPosition or 
(DESIRED_POSITION^0 < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) or 
(DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0) >>
by At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 542:
Theorem (542) [serial 2314] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a) [serial 2312]
 


Theorem (544)                               [serial 1028] 
P [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
S [298] ->
Q [298] << ((((DESIRED_POSITION)^0 = EstimatedActualPosition)) or (((EstimatedActualPosition + 
#PCS::MaxStepsUp) <= (DESIRED_POSITION)^0)) or (((DESIRED_POSITION)^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp))) or 
(((EstimatedActualPosition < (DESIRED_POSITION)^0)) and (((EstimatedActualPosition + 
#PCS::MaxStepsUp) > (DESIRED_POSITION)^0))) or (((EstimatedActualPosition > (DESIRED_POSITION)^0)) and 
(((EstimatedActualPosition - #PCS::MaxStepsUp) < (DESIRED_POSITION)^0)))) >>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 543:
Theorem (543) [serial 2312] used for:
    normalization of [serial 1028]
 


Theorem (545)                               [serial 2369] 
P [292] << 0 = ACTUAL_POSITION >>
S [292] ->
Q [15] << 0 = ACTUAL_POSITION >>
by Identity (id):  P->P is tautology


Theorem (546)                               [serial 2363] 
P [292] << 0 = ACTUAL_POSITION >>
S [292] ->
Q [15] << (0 = ACTUAL_POSITION) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 545:
Theorem (545) [serial 2369] used for:
    normalization of [serial 2363]
 


Theorem (547)                               [serial 2361] 
P [292] << 0 = ACTUAL_POSITION >>
S [292] ->
Q [15] << 0 = ACTUAL_POSITION and true >>
by Law of And-Simplification:  P and true is P
and theorem 546:
Theorem (546) [serial 2363] used for:
  Law of And-Simplification:  P and true is P [serial 2361]
 


Theorem (548)                               [serial 2369] 
P [292] << 0 = ACTUAL_POSITION >>
S [292] ->
Q [15] << 0 = ACTUAL_POSITION >>
by Identity (id):  P->P is tautology


Theorem (549)                               [serial 2363] 
P [292] << 0 = ACTUAL_POSITION >>
S [292] ->
Q [15] << (0 = ACTUAL_POSITION) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 548:
Theorem (548) [serial 2369] used for:
    normalization of [serial 2363]
 


Theorem (550)                               [serial 2361] 
P [292] << 0 = ACTUAL_POSITION >>
S [292] ->
Q [15] << 0 = ACTUAL_POSITION and true >>
by Law of And-Simplification:  P and true is P
and theorem 549:
Theorem (549) [serial 2363] used for:
  Law of And-Simplification:  P and true is P [serial 2361]
 


Theorem (551)                               [serial 2334] 
P [292] << 0 = ACTUAL_POSITION >>
S [292] ->
Q [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 550 550:
Theorem (550) [serial 2361] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (550) [serial 2361] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (552)                               [serial 2328] 
P [292] << (ACTUAL_POSITION = 0) >>
S [292] ->
Q [15] << (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 551:
Theorem (551) [serial 2334] used for:
    normalization of [serial 2328]
 


Theorem (553)                               [serial 2391] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by Identity (id):  P->P is tautology


Theorem (554)                               [serial 2388] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
by Associativity: (b.c).a = a.b.c
and theorem 553:
Theorem (553) [serial 2391] used for:
  Associativity: (b.c).a = a.b.c [serial 2388]
 


Theorem (555)                               [serial 2386] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 554:
Theorem (554) [serial 2388] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2386]
 


Theorem (556)                               [serial 2384] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) and 
(((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
and theorem 555:
Theorem (555) [serial 2386] used for:
    normalization of [serial 2384]
 


Theorem (557)                               [serial 2382] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 556:
Theorem (556) [serial 2384] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2382]
 


Theorem (558)                               [serial 2380] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << (Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 557:
Theorem (557) [serial 2382] used for:
    normalization of [serial 2380]
 


Theorem (559)                               [serial 2378] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 558:
Theorem (558) [serial 2380] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2378]
 


Theorem (560)                               [serial 2376] 
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [294] ->
Q [15] << ((Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 559:
Theorem (559) [serial 2378] used for:
    normalization of [serial 2376]
 


Theorem (561)                               [serial 2374] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294] ->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 560:
Theorem (560) [serial 2376] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2374]
 


Theorem (562)                               [serial 2372] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294] ->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 561:
Theorem (561) [serial 2374] used for:
    normalization of [serial 2372]
 


Theorem (563)                               [serial 2336] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294] ->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
by Substitution of Assertion Labels
and theorem 562:
Theorem (562) [serial 2372] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 2336]
 


Theorem (564)                               [serial 2329] 
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [294] ->
Q [15] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 563:
Theorem (563) [serial 2336] used for:
    normalization of [serial 2329]
 


Theorem (565)                               [serial 2414] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
S [309] ->
Q [15] << 0 <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (566)                               [serial 2412] 
P [15] << 0 = ACTUAL_POSITION and ((0 <= #PCS::MaxPosition)) >>
S [309] ->
Q [15] << 0 <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 565:
Theorem (565) [serial 2414] used for:
    normalization of [serial 2412]
 


Theorem (567)                               [serial 2410] 
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309] ->
Q [15] << 0 <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 566:
Theorem (566) [serial 2412] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2410]
 


Theorem (568)                               [serial 2408] 
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309] ->
Q [15] << (0 <= #PCS::MaxPosition) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 567:
Theorem (567) [serial 2410] used for:
    normalization of [serial 2408]
 


Theorem (569)                               [serial 2407] 
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309] ->
Q [15] << true and 0 <= #PCS::MaxPosition and true >>
by Law of And-Simplification:  P and true is P
and theorem 568:
Theorem (568) [serial 2408] used for:
  Law of And-Simplification:  P and true is P [serial 2407]
 


Theorem (570)                               [serial 2406] 
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309] ->
Q [15] << 0 <= 0 and 0 <= #PCS::MaxPosition and 0 = 0 >>
by Equality Law (idistr):  a=a <-> true
and theorem 569:
Theorem (569) [serial 2407] used for:
  Equality Law (idistr):  a=a <-> true [serial 2406]
 


Theorem (571)                               [serial 2360] 
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309] ->
Q [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION >>
by Guided Substitution of Equals
and theorem 570:
Theorem (570) [serial 2406] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "0" in its postcondition [serial 2360]
 


Theorem (572)                               [serial 2348] 
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309] ->
Q [15] << 0 = ACTUAL_POSITION and (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
by Associativity: (b.c).a = a.b.c
and theorem 571:
Theorem (571) [serial 2360] used for:
  Associativity: (b.c).a = a.b.c [serial 2348]
 


Theorem (573)                               [serial 2338] 
P [15] << 0 = ACTUAL_POSITION and AXIOM_MPGT0() >>
S [309] ActuatorCommand(pc:0)
Q [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
by Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
and theorem 572:
Theorem (572) [serial 2348] used for:
  applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2338]
 


Theorem (574)                               [serial 2330] 
P [15] << (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
S [309] ActuatorCommand(pc:0)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 573:
Theorem (573) [serial 2338] used for:
    normalization of [serial 2330]
 


Theorem (575)                               [serial 2416] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312] ->
Q [313] << 0 = ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (576)                               [serial 2423] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312] ->
Q [314] << true >>
by True Conclusion Schema (tc): P->true


Theorem (577)                               [serial 2421] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312] ->
Q [314] << 0 = 0 >>
by Equality Law (idistr):  a=a <-> true
and theorem 576:
Theorem (576) [serial 2423] used for:
  Equality Law (idistr):  a=a <-> true [serial 2421]
 


Theorem (578)                               [serial 2419] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312] ->
Q [314] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Subtraction of Same:  a-a is 0
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 577:
Theorem (577) [serial 2421] used for:
    normalization of [serial 2419]
 


Theorem (579)                               [serial 2417] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312] ->
Q [314] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Guided Substitution of Equals
and theorem 578:
Theorem (578) [serial 2419] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2417]
 


Theorem (580)                               [serial 2418] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312] ->
Q [313] << ACTUAL_POSITION = ACTUAL_POSITION' >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (581)                               [serial 2364] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312] ->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 575 579 580:
Theorem (575) [serial 2416] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2364]
 
Theorem (579) [serial 2417] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2364]
 
Theorem (580) [serial 2418] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2364]
 


Theorem (582)                               [serial 2362] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312] ->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' and true >>
by Law of And-Simplification:  P and true is P
and theorem 581:
Theorem (581) [serial 2364] used for:
  Law of And-Simplification:  P and true is P [serial 2362]
 


Theorem (583)                               [serial 2416] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312] ->
Q [313] << 0 = ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (584)                               [serial 2423] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312] ->
Q [314] << true >>
by True Conclusion Schema (tc): P->true


Theorem (585)                               [serial 2421] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312] ->
Q [314] << 0 = 0 >>
by Equality Law (idistr):  a=a <-> true
and theorem 584:
Theorem (584) [serial 2423] used for:
  Equality Law (idistr):  a=a <-> true [serial 2421]
 


Theorem (586)                               [serial 2419] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312] ->
Q [314] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Subtraction of Same:  a-a is 0
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 585:
Theorem (585) [serial 2421] used for:
    normalization of [serial 2419]
 


Theorem (587)                               [serial 2417] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312] ->
Q [314] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Guided Substitution of Equals
and theorem 586:
Theorem (586) [serial 2419] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2417]
 


Theorem (588)                               [serial 2418] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312] ->
Q [313] << ACTUAL_POSITION = ACTUAL_POSITION' >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (589)                               [serial 2364] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312] ->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 583 587 588:
Theorem (583) [serial 2416] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2364]
 
Theorem (587) [serial 2417] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2364]
 
Theorem (588) [serial 2418] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2364]
 


Theorem (590)                               [serial 2362] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312] ->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' and true >>
by Law of And-Simplification:  P and true is P
and theorem 589:
Theorem (589) [serial 2364] used for:
  Law of And-Simplification:  P and true is P [serial 2362]
 


Theorem (591)                               [serial 2355] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312] ->
Q [15] << 0 = ACTUAL_POSITION and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION = ACTUAL_POSITION' and AXIOM_MPGT0() >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 590 590:
Theorem (590) [serial 2362] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (590) [serial 2362] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (592)                               [serial 2349] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312] ->
Q [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 591:
Theorem (591) [serial 2355] used for:
    normalization of [serial 2349]
 


Theorem (593)                               [serial 2340] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [312] Delta := 0
Q [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 592:
Theorem (592) [serial 2349] used for:
  applied wp for assignment [serial 2340]
 


Theorem (594)                               [serial 2331] 
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
S [312] Delta := 0
Q [15] << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 593:
Theorem (593) [serial 2340] used for:
    normalization of [serial 2331]
 


Theorem (595)                               [serial 2404] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316] ->
Q [1] << true >>
by True Conclusion Schema (tc): P->true


Theorem (596)                               [serial 2403] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316] ->
Q [1] << ACTUAL_POSITION <= ACTUAL_POSITION >>
by Partial Order Law 1:  a<=a by definition
and theorem 595:
Theorem (595) [serial 2404] used for:
  Partial Order Law 1:  a<=a by definition [serial 2403]
 


Theorem (597)                               [serial 2400] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by Guided Substitution of Equals
and theorem 596:
Theorem (596) [serial 2403] used for:
  Guided Substitution of Equals
 replacing "0" with its = "ACTUAL_POSITION" in its postcondition [serial 2400]
 


Theorem (598)                               [serial 2396] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316] ->
Q [1] << 0 <= ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 597:
Theorem (597) [serial 2400] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2396]
 


Theorem (599)                               [serial 2405] 
P [15] << 0 <= #PCS::MaxPosition and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and 
0 = ACTUAL_POSITION' and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316] ->
Q [319] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (600)                               [serial 2401] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316] ->
Q [319] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Remove Equivalent Term: P(a) and P(b) and a=b is P(a) and a=b
and theorem 599:
Theorem (599) [serial 2405] used for:
  Remove Equivalent Term: P(a) and P(b) and a=b is P(a) and a=b [serial 2401]
 


Theorem (601)                               [serial 2397] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316] ->
Q [319] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
by Guided Substitution of Equals
and theorem 600:
Theorem (600) [serial 2401] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2397]
 


Theorem (602)                               [serial 2402] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316] ->
Q [317] << 0 = ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (603)                               [serial 2398] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316] ->
Q [317] << 0 = ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 602:
Theorem (602) [serial 2402] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2398]
 


Theorem (604)                               [serial 2399] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316] ->
Q [318] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (605)                               [serial 2394] 
P [15] << 0 <= #PCS::MaxPosition and 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [316] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 598 601 603 604:
Theorem (598) [serial 2396] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2394]
 
Theorem (601) [serial 2397] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2394]
 
Theorem (603) [serial 2398] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2394]
 
Theorem (604) [serial 2399] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2394]
 


Theorem (606)                               [serial 2392] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((0 <= #PCS::MaxPosition)) >>
S [316] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 605:
Theorem (605) [serial 2394] used for:
    normalization of [serial 2392]
 


Theorem (607)                               [serial 2357] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [316] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and 0 = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Substitution of Assertion Labels
and theorem 606:
Theorem (606) [serial 2392] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2357]
 


Theorem (608)                               [serial 2350] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [316] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = 0 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 607:
Theorem (607) [serial 2357] used for:
    normalization of [serial 2350]
 


Theorem (609)                               [serial 2342] 
P [15] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
AXIOM_MPGT0() >>
S [316] EstimatedActualPosition' := 0
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 608:
Theorem (608) [serial 2350] used for:
  applied wp for assignment [serial 2342]
 


Theorem (610)                               [serial 2332] 
P [15] << ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and 
(Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
S [316] EstimatedActualPosition' := 0
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 609:
Theorem (609) [serial 2342] used for:
    normalization of [serial 2332]
 


Theorem (611)                               [serial 1029] 
P [292] << (ACTUAL_POSITION = 0) >>
S [308] << (AXIOM_MPGT0() and (ACTUAL_POSITION = 0)) >>
ActuatorCommand(pc:0)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + 0)) and (ACTUAL_POSITION = 0)) >>
;
Delta := 0
<< ((ACTUAL_POSITION' = ACTUAL_POSITION) and (ACTUAL_POSITION = 0) and AXIOM_MPGT0() and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
;
EstimatedActualPosition' := 0
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 552 564 574 594 610:
Theorem (552) [serial 2328] used for:
  P -> P1 in sequential composition for [serial 1029]
 
Theorem (564) [serial 2329] used for:
  Q2 -> Q in sequential composition for [serial 1029]
 
Theorem (574) [serial 2330] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1029]
 
Theorem (594) [serial 2331] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1029]
 
Theorem (610) [serial 2332] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1029]
 


Theorem (612)                               [serial 2425] 
P [294] << ACTUAL_IN_RANGE() and D_MS() and E_MS() >>
S [321] ->
Q [296] << ACTUAL_IN_RANGE() and E_MS() >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (613)                               [serial 1030] 
P [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE()) >>
S [321] ->
Q [296] << (E_MS() and ACTUAL_IN_RANGE()) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 612:
Theorem (612) [serial 2425] used for:
    normalization of [serial 1030]
 


Theorem (614)                               [serial 2431] 
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323] ->
Q [298] << ACTUAL_IN_RANGE() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (615)                               [serial 2438] 
P [296] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_IN_RANGE() and 
E_MS() >>
S [323] ->
Q [298] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (616)                               [serial 2436] 
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323] ->
Q [298] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition >>
by Assume Present:  P = P@now = P^0 
and theorem 615:
Theorem (615) [serial 2438] used for:
  Assume Present:  P = P@now = P^0  [serial 2436]
 


Theorem (617)                               [serial 2434] 
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323] ->
Q [298] << ((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 616:
Theorem (616) [serial 2436] used for:
    normalization of [serial 2434]
 


Theorem (618)                               [serial 2432] 
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323] ->
Q [298] << DESIRED_IN_RANGE() >>
by Substitution of Assertion Labels
and theorem 617:
Theorem (617) [serial 2434] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 2432]
 


Theorem (619)                               [serial 2433] 
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323] ->
Q [298] << E_MS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (620)                               [serial 2430] 
P [296] << 0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition and 
ACTUAL_IN_RANGE() and E_MS() >>
S [323] ->
Q [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 614 618 619:
Theorem (614) [serial 2431] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2430]
 
Theorem (618) [serial 2432] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2430]
 
Theorem (619) [serial 2433] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2430]
 


Theorem (621)                               [serial 2428] 
P [296] << ACTUAL_IN_RANGE() and E_MS() and (0 <= DESIRED_POSITION^0 and DESIRED_POSITION^0 <= #PCS::MaxPosition) >>
S [323] ->
Q [298] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
by Associativity: (b.c).a = a.b.c
and theorem 620:
Theorem (620) [serial 2430] used for:
  Associativity: (b.c).a = a.b.c [serial 2428]
 


Theorem (622)                               [serial 1031] 
P [296] << (E_MS() and ACTUAL_IN_RANGE() and ((((DESIRED_POSITION)^0 >= 0)) and 
(((DESIRED_POSITION)^0 <= #PCS::MaxPosition)))) >>
S [323] ->
Q [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
by Normalization
  Normalization Axioms:
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 621:
Theorem (621) [serial 2428] used for:
    normalization of [serial 1031]
 


Theorem (623)                               [serial 1032] 
P [296] << (E_MS() and ACTUAL_IN_RANGE() and (((((DESIRED_POSITION)^0 < 0))) or 
((((DESIRED_POSITION)^0 > #PCS::MaxPosition))))) >>
S [325] ->
Q [305] << true >>
by True Conclusion Schema (tc): P->true


Theorem (624)                               [serial 2537] 
P [298] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [298] ->
Q [330] << ACTUAL_POSITION = EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (625)                               [serial 2536] 
P [298] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = EstimatedActualPosition >>
S [298] ->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
by Guided Substitution of Equals
and theorem 624:
Theorem (624) [serial 2537] used for:
  Guided Substitution of Equals
 replacing "DESIRED_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 2536]
 


Theorem (626)                               [serial 2515] 
P [298] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298] ->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
by Assume Present:  P = P@now = P^0 
and theorem 625:
Theorem (625) [serial 2536] used for:
  Assume Present:  P = P@now = P^0  [serial 2515]
 


Theorem (627)                               [serial 2506] 
P [298] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298] ->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 626:
Theorem (626) [serial 2515] used for:
    normalization of [serial 2506]
 


Theorem (628)                               [serial 2486] 
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [298] ->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
by Associativity: (b.c).a = a.b.c
and theorem 627:
Theorem (627) [serial 2506] used for:
  Associativity: (b.c).a = a.b.c [serial 2486]
 


Theorem (629)                               [serial 2477] 
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [298] ->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 628:
Theorem (628) [serial 2486] used for:
    normalization of [serial 2477]
 


Theorem (630)                               [serial 2462] 
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION >>
by Substitution of Assertion Labels
and theorem 629:
Theorem (629) [serial 2477] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2462]
 


Theorem (631)                               [serial 2463] 
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [330] << ACTUAL_IN_RANGE() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (632)                               [serial 2464] 
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [330] << E_MS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (633)                               [serial 2442] 
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 630 631 632:
Theorem (630) [serial 2462] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2442]
 
Theorem (631) [serial 2463] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2442]
 
Theorem (632) [serial 2464] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2442]
 


Theorem (634)                               [serial 2557] 
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by Identity (id):  P->P is tautology


Theorem (635)                               [serial 2554] 
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
by Associativity: (b.c).a = a.b.c
and theorem 634:
Theorem (634) [serial 2557] used for:
  Associativity: (b.c).a = a.b.c [serial 2554]
 


Theorem (636)                               [serial 2552] 
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 635:
Theorem (635) [serial 2554] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2552]
 


Theorem (637)                               [serial 2550] 
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) and 
(((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
and theorem 636:
Theorem (636) [serial 2552] used for:
    normalization of [serial 2550]
 


Theorem (638)                               [serial 2548] 
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 637:
Theorem (637) [serial 2550] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2548]
 


Theorem (639)                               [serial 2546] 
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << (Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 638:
Theorem (638) [serial 2548] used for:
    normalization of [serial 2546]
 


Theorem (640)                               [serial 2544] 
P [339] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 639:
Theorem (639) [serial 2546] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2544]
 


Theorem (641)                               [serial 2542] 
P [339] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [294] ->
Q [15] << ((Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 640:
Theorem (640) [serial 2544] used for:
    normalization of [serial 2542]
 


Theorem (642)                               [serial 2540] 
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294] ->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 641:
Theorem (641) [serial 2542] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2540]
 


Theorem (643)                               [serial 2538] 
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294] ->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 642:
Theorem (642) [serial 2540] used for:
    normalization of [serial 2538]
 


Theorem (644)                               [serial 2443] 
P [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294] ->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
by Substitution of Assertion Labels
and theorem 643:
Theorem (643) [serial 2538] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 2443]
 


Theorem (645)                               [serial 2511] 
P [330] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [331] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (646)                               [serial 2496] 
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [331] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by Associativity: (b.c).a = a.b.c
and theorem 645:
Theorem (645) [serial 2511] used for:
  Associativity: (b.c).a = a.b.c [serial 2496]
 


Theorem (647)                               [serial 2482] 
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [331] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 646:
Theorem (646) [serial 2496] used for:
    normalization of [serial 2482]
 


Theorem (648)                               [serial 2473] 
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by Substitution of Assertion Labels
and theorem 647:
Theorem (647) [serial 2482] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2473]
 


Theorem (649)                               [serial 2512] 
P [330] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [331] ->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (650)                               [serial 2498] 
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [331] ->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Associativity: (b.c).a = a.b.c
and theorem 649:
Theorem (649) [serial 2512] used for:
  Associativity: (b.c).a = a.b.c [serial 2498]
 


Theorem (651)                               [serial 2483] 
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [331] ->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 650:
Theorem (650) [serial 2498] used for:
    normalization of [serial 2483]
 


Theorem (652)                               [serial 2474] 
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331] ->
Q [130] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 651:
Theorem (651) [serial 2483] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2474]
 


Theorem (653)                               [serial 2475] 
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331] ->
Q [332] << ACTUAL_IN_RANGE() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (654)                               [serial 2476] 
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331] ->
Q [332] << E_MS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (655)                               [serial 2461] 
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331] ->
Q [332] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_IN_RANGE() and 
E_MS() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 648 652 653 654:
Theorem (648) [serial 2473] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2461]
 
Theorem (652) [serial 2474] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2461]
 
Theorem (653) [serial 2475] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2461]
 
Theorem (654) [serial 2476] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2461]
 


Theorem (656)                               [serial 2453] 
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331] ->
Q [332] << ACTUAL_IN_RANGE() and E_MS() and (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
by Associativity: (b.c).a = a.b.c
and theorem 655:
Theorem (655) [serial 2461] used for:
  Associativity: (b.c).a = a.b.c [serial 2453]
 


Theorem (657)                               [serial 2447] 
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331] ->
Q [332] << (0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and ACTUAL_IN_RANGE() and 
E_MS() >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 656:
Theorem (656) [serial 2453] used for:
    normalization of [serial 2447]
 


Theorem (658)                               [serial 2444] 
P [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
S [331] ActuatorCommand(pc:0)
Q [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
by Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
and theorem 657:
Theorem (657) [serial 2447] used for:
  applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2444]
 


Theorem (659)                               [serial 2535] 
P [332] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [334] ->
Q [336] << true >>
by True Conclusion Schema (tc): P->true


Theorem (660)                               [serial 2528] 
P [332] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [334] ->
Q [336] << 0 = 0 >>
by Equality Law (idistr):  a=a <-> true
and theorem 659:
Theorem (659) [serial 2535] used for:
  Equality Law (idistr):  a=a <-> true [serial 2528]
 


Theorem (661)                               [serial 2521] 
P [332] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [334] ->
Q [336] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Subtraction of Same:  a-a is 0
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 660:
Theorem (660) [serial 2528] used for:
    normalization of [serial 2521]
 


Theorem (662)                               [serial 2507] 
P [332] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' >>
S [334] ->
Q [336] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Guided Substitution of Equals
and theorem 661:
Theorem (661) [serial 2521] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2507]
 


Theorem (663)                               [serial 2488] 
P [332] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [334] ->
Q [336] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Associativity: (b.c).a = a.b.c
and theorem 662:
Theorem (662) [serial 2507] used for:
  Associativity: (b.c).a = a.b.c [serial 2488]
 


Theorem (664)                               [serial 2478] 
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [334] ->
Q [336] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 663:
Theorem (663) [serial 2488] used for:
    normalization of [serial 2478]
 


Theorem (665)                               [serial 2465] 
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334] ->
Q [336] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Substitution of Assertion Labels
and theorem 664:
Theorem (664) [serial 2478] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2465]
 


Theorem (666)                               [serial 2466] 
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334] ->
Q [335] << ACTUAL_POSITION = ACTUAL_POSITION' >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (667)                               [serial 2467] 
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334] ->
Q [335] << ACTUAL_IN_RANGE() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (668)                               [serial 2468] 
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334] ->
Q [335] << E_MS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (669)                               [serial 2455] 
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334] ->
Q [335] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION = ACTUAL_POSITION' and 
ACTUAL_IN_RANGE() and E_MS() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 665 666 667 668:
Theorem (665) [serial 2465] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2455]
 
Theorem (666) [serial 2466] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2455]
 
Theorem (667) [serial 2467] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2455]
 
Theorem (668) [serial 2468] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2455]
 


Theorem (670)                               [serial 2448] 
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334] ->
Q [335] << ACTUAL_POSITION = ACTUAL_POSITION' and 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 669:
Theorem (669) [serial 2455] used for:
    normalization of [serial 2448]
 


Theorem (671)                               [serial 2445] 
P [332] << ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
S [334] Delta := 0
Q [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 670:
Theorem (670) [serial 2448] used for:
  applied wp for assignment [serial 2445]
 


Theorem (672)                               [serial 2522] 
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (673)                               [serial 2508] 
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338] ->
Q [1] << 0 <= ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 672:
Theorem (672) [serial 2522] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2508]
 


Theorem (674)                               [serial 2490] 
P [335] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [338] ->
Q [1] << 0 <= ACTUAL_POSITION' >>
by Associativity: (b.c).a = a.b.c
and theorem 673:
Theorem (673) [serial 2508] used for:
  Associativity: (b.c).a = a.b.c [serial 2490]
 


Theorem (675)                               [serial 2479] 
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [338] ->
Q [1] << 0 <= ACTUAL_POSITION' >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 674:
Theorem (674) [serial 2490] used for:
    normalization of [serial 2479]
 


Theorem (676)                               [serial 2469] 
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338] ->
Q [1] << 0 <= ACTUAL_POSITION' >>
by Substitution of Assertion Labels
and theorem 675:
Theorem (675) [serial 2479] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2469]
 


Theorem (677)                               [serial 2523] 
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338] ->
Q [341] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (678)                               [serial 2509] 
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338] ->
Q [341] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
by Guided Substitution of Equals
and theorem 677:
Theorem (677) [serial 2523] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2509]
 


Theorem (679)                               [serial 2492] 
P [335] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [338] ->
Q [341] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
by Associativity: (b.c).a = a.b.c
and theorem 678:
Theorem (678) [serial 2509] used for:
  Associativity: (b.c).a = a.b.c [serial 2492]
 


Theorem (680)                               [serial 2480] 
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [338] ->
Q [341] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 679:
Theorem (679) [serial 2492] used for:
    normalization of [serial 2480]
 


Theorem (681)                               [serial 2470] 
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338] ->
Q [341] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 680:
Theorem (680) [serial 2480] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2470]
 


Theorem (682)                               [serial 2471] 
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338] ->
Q [340] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (683)                               [serial 2532] 
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338] ->
Q [339] << ACTUAL_POSITION = EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (684)                               [serial 2524] 
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338] ->
Q [339] << EstimatedActualPosition = ACTUAL_POSITION >>
by Normalization
  Normalization Axiom:
    Reflexivity of Equality: (a=b) = (b=a)
and theorem 683:
Theorem (683) [serial 2532] used for:
    normalization of [serial 2524]
 


Theorem (685)                               [serial 2510] 
P [335] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
S [338] ->
Q [339] << EstimatedActualPosition = ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 684:
Theorem (684) [serial 2524] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 2510]
 


Theorem (686)                               [serial 2494] 
P [335] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' and 
Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [338] ->
Q [339] << EstimatedActualPosition = ACTUAL_POSITION' >>
by Associativity: (b.c).a = a.b.c
and theorem 685:
Theorem (685) [serial 2510] used for:
  Associativity: (b.c).a = a.b.c [serial 2494]
 


Theorem (687)                               [serial 2481] 
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [338] ->
Q [339] << EstimatedActualPosition = ACTUAL_POSITION' >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 686:
Theorem (686) [serial 2494] used for:
    normalization of [serial 2481]
 


Theorem (688)                               [serial 2472] 
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338] ->
Q [339] << EstimatedActualPosition = ACTUAL_POSITION' >>
by Substitution of Assertion Labels
and theorem 687:
Theorem (687) [serial 2481] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2472]
 


Theorem (689)                               [serial 2457] 
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338] ->
Q [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
EstimatedActualPosition = ACTUAL_POSITION' >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 676 681 682 688:
Theorem (676) [serial 2469] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2457]
 
Theorem (681) [serial 2470] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2457]
 
Theorem (682) [serial 2471] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2457]
 
Theorem (688) [serial 2472] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2457]
 


Theorem (690)                               [serial 2449] 
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338] ->
Q [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Equality: (a=b) = (b=a)
and theorem 689:
Theorem (689) [serial 2457] used for:
    normalization of [serial 2449]
 


Theorem (691)                               [serial 2446] 
P [335] << ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_IN_RANGE() and E_MS() >>
S [338] EstimatedActualPosition' := EstimatedActualPosition
Q [339] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 690:
Theorem (690) [serial 2449] used for:
  applied wp for assignment [serial 2446]
 


Theorem (692)                               [serial 2440] 
P [298] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [330] << ACTUAL_POSITION = DESIRED_POSITION and ACTUAL_IN_RANGE() and E_MS() >>
ActuatorCommand(pc:0)
<< ACTUAL_POSITION = ACTUAL_POSITION' and ACTUAL_IN_RANGE() and E_MS() >>
;
Delta := 0
<< ACTUAL_POSITION = ACTUAL_POSITION' and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_IN_RANGE() and E_MS() >>
;
EstimatedActualPosition' := EstimatedActualPosition
<< 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and ACTUAL_POSITION' = EstimatedActualPosition' >>
Q [294] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 633 644 658 671 691:
Theorem (633) [serial 2442] used for:
  P -> P1 in sequential composition for [serial 2440]
 
Theorem (644) [serial 2443] used for:
  Q2 -> Q in sequential composition for [serial 2440]
 
Theorem (658) [serial 2444] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 2440]
 
Theorem (671) [serial 2445] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 2440]
 
Theorem (691) [serial 2446] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 2440]
 


Theorem (693)                               [serial 1033] 
P [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 = EstimatedActualPosition))) >>
S [330] << (E_MS() and (DESIRED_POSITION = ACTUAL_POSITION) and ACTUAL_IN_RANGE()) >>
ActuatorCommand(pc:0)
<< (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E_MS() and ACTUAL_IN_RANGE()) >>
;
Delta := 0
<< (((ACTUAL_POSITION' = ACTUAL_POSITION)) and E_MS() and ACTUAL_IN_RANGE() and ((Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
;
EstimatedActualPosition' := EstimatedActualPosition
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 692:
Theorem (692) [serial 2440] used for:
    normalization of [serial 1033]
 


Theorem (694)                               [serial 2652] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298] ->
Q [346] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (695)                               [serial 2651] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298] ->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
by Guided Substitution of Equals
and theorem 694:
Theorem (694) [serial 2652] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 2651]
 


Theorem (696)                               [serial 2649] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298] ->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
by Assume Present:  P = P@now = P^0 
and theorem 695:
Theorem (695) [serial 2651] used for:
  Assume Present:  P = P@now = P^0  [serial 2649]
 


Theorem (697)                               [serial 2647] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298] ->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 696:
Theorem (696) [serial 2649] used for:
    normalization of [serial 2647]
 


Theorem (698)                               [serial 2645] 
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) >>
S [298] ->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
by Associativity: (b.c).a = a.b.c
and theorem 697:
Theorem (697) [serial 2647] used for:
  Associativity: (b.c).a = a.b.c [serial 2645]
 


Theorem (699)                               [serial 2643] 
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [298] ->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 698:
Theorem (698) [serial 2645] used for:
    normalization of [serial 2643]
 


Theorem (700)                               [serial 2602] 
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [346] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
by Substitution of Assertion Labels
and theorem 699:
Theorem (699) [serial 2643] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2602]
 


Theorem (701)                               [serial 2603] 
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [347] << ACTUAL_IN_RANGE() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (702)                               [serial 2604] 
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [347] << DESIRED_IN_RANGE() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (703)                               [serial 2605] 
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [347] << E_MS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (704)                               [serial 2564] 
P [15] << (EstimatedActualPosition + #PCS::MaxStepsUp) <= DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 700 701 702 703:
Theorem (700) [serial 2602] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2564]
 
Theorem (701) [serial 2603] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2564]
 
Theorem (702) [serial 2604] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2564]
 
Theorem (703) [serial 2605] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2564]
 


Theorem (705)                               [serial 2558] 
P [15] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition + 
#PCS::MaxStepsUp) <= (DESIRED_POSITION)^0))) >>
S [298] ->
Q [15] << (((ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION) and E_MS() and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 704:
Theorem (704) [serial 2564] used for:
    normalization of [serial 2558]
 


Theorem (706)                               [serial 2642] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by Identity (id):  P->P is tautology


Theorem (707)                               [serial 2639] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
by Associativity: (b.c).a = a.b.c
and theorem 706:
Theorem (706) [serial 2642] used for:
  Associativity: (b.c).a = a.b.c [serial 2639]
 


Theorem (708)                               [serial 2637] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 707:
Theorem (707) [serial 2639] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2637]
 


Theorem (709)                               [serial 2635] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) and 
(((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
and theorem 708:
Theorem (708) [serial 2637] used for:
    normalization of [serial 2635]
 


Theorem (710)                               [serial 2633] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 709:
Theorem (709) [serial 2635] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2633]
 


Theorem (711)                               [serial 2631] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << (Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 710:
Theorem (710) [serial 2633] used for:
    normalization of [serial 2631]
 


Theorem (712)                               [serial 2629] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 711:
Theorem (711) [serial 2631] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2629]
 


Theorem (713)                               [serial 2627] 
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [294] ->
Q [15] << ((Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 712:
Theorem (712) [serial 2629] used for:
    normalization of [serial 2627]
 


Theorem (714)                               [serial 2625] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294] ->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 713:
Theorem (713) [serial 2627] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2625]
 


Theorem (715)                               [serial 2623] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294] ->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 714:
Theorem (714) [serial 2625] used for:
    normalization of [serial 2623]
 


Theorem (716)                               [serial 2566] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294] ->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
by Substitution of Assertion Labels
and theorem 715:
Theorem (715) [serial 2623] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 2566]
 


Theorem (717)                               [serial 2559] 
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [294] ->
Q [15] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 716:
Theorem (716) [serial 2566] used for:
    normalization of [serial 2559]
 


Theorem (718)                               [serial 2678] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [348] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (719)                               [serial 2676] 
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [348] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by Associativity: (b.c).a = a.b.c
and theorem 718:
Theorem (718) [serial 2678] used for:
  Associativity: (b.c).a = a.b.c [serial 2676]
 


Theorem (720)                               [serial 2674] 
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [348] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 719:
Theorem (719) [serial 2676] used for:
    normalization of [serial 2674]
 


Theorem (721)                               [serial 2610] 
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by Substitution of Assertion Labels
and theorem 720:
Theorem (720) [serial 2674] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2610]
 


Theorem (722)                               [serial 2683] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [348] ->
Q [350] << DESIRED_POSITION <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (723)                               [serial 2681] 
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [348] ->
Q [350] << DESIRED_POSITION <= #PCS::MaxPosition >>
by Associativity: (b.c).a = a.b.c
and theorem 722:
Theorem (722) [serial 2683] used for:
  Associativity: (b.c).a = a.b.c [serial 2681]
 


Theorem (724)                               [serial 2679] 
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [348] ->
Q [350] << DESIRED_POSITION <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 723:
Theorem (723) [serial 2681] used for:
    normalization of [serial 2679]
 


Theorem (725)                               [serial 2611] 
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348] ->
Q [350] << DESIRED_POSITION <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 724:
Theorem (724) [serial 2679] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2611]
 


Theorem (726)                               [serial 2612] 
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348] ->
Q [1] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (727)                               [serial 2692] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition and 0 <= #PCS::MaxPosition and 
(ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
S [348] ->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (728)                               [serial 2690] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [348] ->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
by Transitivity: x<y and y<z -> x<z
and theorem 727:
Theorem (727) [serial 2692] used for:
  Transitivity: x<y and y<z -> x<z [serial 2690]
 


Theorem (729)                               [serial 2688] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [348] ->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 728:
Theorem (728) [serial 2690] used for:
    normalization of [serial 2688]
 


Theorem (730)                               [serial 2686] 
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [348] ->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
by Associativity: (b.c).a = a.b.c
and theorem 729:
Theorem (729) [serial 2688] used for:
  Associativity: (b.c).a = a.b.c [serial 2686]
 


Theorem (731)                               [serial 2684] 
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [348] ->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 730:
Theorem (730) [serial 2686] used for:
    normalization of [serial 2684]
 


Theorem (732)                               [serial 2613] 
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348] ->
Q [352] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 731:
Theorem (731) [serial 2684] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2613]
 


Theorem (733)                               [serial 2693] 
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348] ->
Q [351] << true >>
by True Conclusion Schema (tc): P->true


Theorem (734)                               [serial 2693] 
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348] ->
Q [351] << true >>
by True Conclusion Schema (tc): P->true


Theorem (735)                               [serial 2614] 
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348] ->
Q [351] << AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 734 734:
Theorem (734) [serial 2693] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (734) [serial 2693] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (736)                               [serial 2615] 
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348] ->
Q [349] << E_MS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (737)                               [serial 2594] 
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and E_MS() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 721 725 726 732 735 736:
Theorem (721) [serial 2610] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]
 
Theorem (725) [serial 2611] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]
 
Theorem (726) [serial 2612] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]
 
Theorem (732) [serial 2613] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]
 
Theorem (735) [serial 2614] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]
 
Theorem (736) [serial 2615] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2594]
 


Theorem (738)                               [serial 2592] 
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
true and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and E_MS() >>
by Law of And-Simplification:  P and true is P
and theorem 737:
Theorem (737) [serial 2594] used for:
  Law of And-Simplification:  P and true is P [serial 2592]
 


Theorem (739)                               [serial 2584] 
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
#PCS::MaxStepsUp = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
by Equality Law (idistr):  a=a <-> true
and theorem 738:
Theorem (738) [serial 2592] used for:
  Equality Law (idistr):  a=a <-> true [serial 2584]
 


Theorem (740)                               [serial 2578] 
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
(#PCS::MaxStepsUp) = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 739:
Theorem (739) [serial 2584] used for:
    normalization of [serial 2578]
 


Theorem (741)                               [serial 2568] 
P [15] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [348] Delta := #PCS::MaxStepsUp
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 740:
Theorem (740) [serial 2578] used for:
  applied wp for assignment [serial 2568]
 


Theorem (742)                               [serial 2560] 
P [15] << (((ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION) and E_MS() and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
S [348] Delta := #PCS::MaxStepsUp
Q [15] << (E_MS() and (DESIRED_POSITION >= (ACTUAL_POSITION + #PCS::MaxStepsUp)) and 
(Delta = #PCS::MaxStepsUp) and (ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and ((ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 741:
Theorem (741) [serial 2568] used for:
    normalization of [serial 2560]
 


Theorem (743)                               [serial 2616] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (744)                               [serial 2710] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < DESIRED_POSITION and 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) and 0 < #PCS::MaxPosition and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (
ACTUAL_POSITION + #PCS::MaxStepsUp) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [354] ->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (745)                               [serial 2708] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < DESIRED_POSITION and 0 < (ACTUAL_POSITION + #PCS::MaxStepsUp) and 0 < #PCS::MaxPosition and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < DESIRED_POSITION and ACTUAL_POSITION < (
ACTUAL_POSITION + #PCS::MaxStepsUp) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [354] ->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
by Partial Order Law 3:  a <= (b-1)  is  a<b
and theorem 744:
Theorem (744) [serial 2710] used for:
  0<(ACTUAL_POSITION + #PCS::MaxStepsUp)  ->  0<=(ACTUAL_POSITION + #PCS::MaxStepsUp)
 null <=(- null + null)  is   null < null
   null <=(- null + null)  is   null < null

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2708]
 


Theorem (746)                               [serial 2706] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) and 
0 < (ACTUAL_POSITION + #PCS::MaxStepsUp) and ACTUAL_POSITION < DESIRED_POSITION and 
0 < DESIRED_POSITION and ACTUAL_POSITION < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [354] ->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 745:
Theorem (745) [serial 2708] used for:
    normalization of [serial 2706]
 


Theorem (747)                               [serial 2704] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [354] ->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
by Transitivity: x<y and y<z -> x<z
and theorem 746:
Theorem (746) [serial 2706] used for:
  Transitivity: x<y and y<z -> x<z [serial 2704]
 


Theorem (748)                               [serial 2702] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [354] ->
Q [1] << 0 <= (ACTUAL_POSITION + (#PCS::MaxStepsUp)) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 747:
Theorem (747) [serial 2704] used for:
    normalization of [serial 2702]
 


Theorem (749)                               [serial 2700] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [354] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Guided Substitution of Equals
and theorem 748:
Theorem (748) [serial 2702] used for:
  Guided Substitution of Equals
 replacing "Delta" with its = "(#PCS::MaxStepsUp)" in its postcondition [serial 2700]
 


Theorem (750)                               [serial 2698] 
P [15] << 0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) and 
0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp >>
S [354] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 749:
Theorem (749) [serial 2700] used for:
    normalization of [serial 2698]
 


Theorem (751)                               [serial 2696] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
(0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp)) >>
S [354] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Associativity: (b.c).a = a.b.c
and theorem 750:
Theorem (750) [serial 2698] used for:
  Associativity: (b.c).a = a.b.c [serial 2696]
 


Theorem (752)                               [serial 2694] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and ((ACTUAL_POSITION < (ACTUAL_POSITION + (#PCS::MaxStepsUp))) and 
((#PCS::MaxStepsUp) > 0)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [354] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 751:
Theorem (751) [serial 2696] used for:
    normalization of [serial 2694]
 


Theorem (753)                               [serial 2617] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Substitution of Assertion Labels
and theorem 752:
Theorem (752) [serial 2694] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2617]
 


Theorem (754)                               [serial 2724] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) and 
0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) and ACTUAL_POSITION < DESIRED_POSITION and 
0 < DESIRED_POSITION and ACTUAL_POSITION < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [354] ->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (755)                               [serial 2723] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) and 
0 < (ACTUAL_POSITION + #PCS::MaxStepsUp) and ACTUAL_POSITION < DESIRED_POSITION and 
0 < DESIRED_POSITION and ACTUAL_POSITION < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [354] ->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
by Partial Order Law 3:  a <= (b-1)  is  a<b
and theorem 754:
Theorem (754) [serial 2724] used for:
  0<(ACTUAL_POSITION + #PCS::MaxStepsUp)  ->  0<=(ACTUAL_POSITION + #PCS::MaxStepsUp)
 null <=(- null + null)  is   null < null
   null <=(- null + null)  is   null < null

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2723]
 


Theorem (756)                               [serial 2721] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [354] ->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
by Transitivity: x<y and y<z -> x<z
and theorem 755:
Theorem (755) [serial 2723] used for:
  Transitivity: x<y and y<z -> x<z [serial 2721]
 


Theorem (757)                               [serial 2719] 
P [15] << 0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) and 
0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp >>
S [354] ->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 756:
Theorem (756) [serial 2721] used for:
    normalization of [serial 2719]
 


Theorem (758)                               [serial 2717] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = #PCS::MaxStepsUp and 
(0 < #PCS::MaxStepsUp and ACTUAL_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp)) >>
S [354] ->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
by Associativity: (b.c).a = a.b.c
and theorem 757:
Theorem (757) [serial 2719] used for:
  Associativity: (b.c).a = a.b.c [serial 2717]
 


Theorem (759)                               [serial 2715] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and ((ACTUAL_POSITION < (ACTUAL_POSITION + (#PCS::MaxStepsUp))) and 
((#PCS::MaxStepsUp) > 0)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [354] ->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 758:
Theorem (758) [serial 2717] used for:
    normalization of [serial 2715]
 


Theorem (760)                               [serial 2713] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354] ->
Q [1] << 0 <= (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
by Substitution of Assertion Labels
and theorem 759:
Theorem (759) [serial 2715] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2713]
 


Theorem (761)                               [serial 2711] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354] ->
Q [1] << 0 <= (ACTUAL_POSITION + (#PCS::MaxStepsUp)) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 760:
Theorem (760) [serial 2713] used for:
    normalization of [serial 2711]
 


Theorem (762)                               [serial 2618] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Guided Substitution of Equals
and theorem 761:
Theorem (761) [serial 2711] used for:
  Guided Substitution of Equals
 replacing "Delta" with its = "(#PCS::MaxStepsUp)" in its postcondition [serial 2618]
 


Theorem (763)                               [serial 2727] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354] ->
Q [130] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (764)                               [serial 2725] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354] ->
Q [130] << (ACTUAL_POSITION + (#PCS::MaxStepsUp)) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 763:
Theorem (763) [serial 2727] used for:
    normalization of [serial 2725]
 


Theorem (765)                               [serial 2619] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354] ->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by Guided Substitution of Equals
and theorem 764:
Theorem (764) [serial 2725] used for:
  Guided Substitution of Equals
 replacing "Delta" with its = "(#PCS::MaxStepsUp)" in its postcondition [serial 2619]
 


Theorem (766)                               [serial 2731] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354] ->
Q [357] << (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (767)                               [serial 2729] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354] ->
Q [357] << (ACTUAL_POSITION + (#PCS::MaxStepsUp)) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 766:
Theorem (766) [serial 2731] used for:
    normalization of [serial 2729]
 


Theorem (768)                               [serial 2620] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354] ->
Q [357] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by Guided Substitution of Equals
and theorem 767:
Theorem (767) [serial 2729] used for:
  Guided Substitution of Equals
 replacing "Delta" with its = "(#PCS::MaxStepsUp)" in its postcondition [serial 2620]
 


Theorem (769)                               [serial 2621] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354] ->
Q [356] << Delta = #PCS::MaxStepsUp >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (770)                               [serial 2622] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354] ->
Q [355] << E_MS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (771)                               [serial 2599] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354] ->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + 
Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and E_MS() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 743 753 762 765 768 769 770:
Theorem (743) [serial 2616] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]
 
Theorem (753) [serial 2617] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]
 
Theorem (762) [serial 2618] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]
 
Theorem (765) [serial 2619] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]
 
Theorem (768) [serial 2620] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]
 
Theorem (769) [serial 2621] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]
 
Theorem (770) [serial 2622] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2599]
 


Theorem (772)                               [serial 2593] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354] ->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and E_MS() >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 771:
Theorem (771) [serial 2599] used for:
    normalization of [serial 2593]
 


Theorem (773)                               [serial 2586] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354] ->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and E_MS() and 
(0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) >>
by Associativity: (b.c).a = a.b.c
and theorem 772:
Theorem (772) [serial 2593] used for:
  Associativity: (b.c).a = a.b.c [serial 2586]
 


Theorem (774)                               [serial 2579] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354] ->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (0 <= (ACTUAL_POSITION + 
Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and E_MS() >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 773:
Theorem (773) [serial 2586] used for:
    normalization of [serial 2579]
 


Theorem (775)                               [serial 2570] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= DESIRED_POSITION and (ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition and 
Delta = #PCS::MaxStepsUp and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [354] ActuatorCommand(pc:Delta)
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
by Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
and theorem 774:
Theorem (774) [serial 2579] used for:
  applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2570]
 


Theorem (776)                               [serial 2561] 
P [15] << (E_MS() and (DESIRED_POSITION >= (ACTUAL_POSITION + #PCS::MaxStepsUp)) and 
(Delta = #PCS::MaxStepsUp) and (ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and ((ACTUAL_POSITION + 
#PCS::MaxStepsUp) <= #PCS::MaxPosition)) >>
S [354] ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and (Delta = #PCS::MaxStepsUp) and 
(ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 775:
Theorem (775) [serial 2570] used for:
    normalization of [serial 2561]
 


Theorem (777)                               [serial 2655] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (778)                               [serial 2653] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359] ->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 777:
Theorem (777) [serial 2655] used for:
    normalization of [serial 2653]
 


Theorem (779)                               [serial 2606] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359] ->
Q [1] << 0 <= ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 778:
Theorem (778) [serial 2653] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2606]
 


Theorem (780)                               [serial 2659] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359] ->
Q [362] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (781)                               [serial 2657] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359] ->
Q [362] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 780:
Theorem (780) [serial 2659] used for:
    normalization of [serial 2657]
 


Theorem (782)                               [serial 2607] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359] ->
Q [362] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
by Guided Substitution of Equals
and theorem 781:
Theorem (781) [serial 2657] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2607]
 


Theorem (783)                               [serial 2665] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359] ->
Q [361] << true >>
by True Conclusion Schema (tc): P->true


Theorem (784)                               [serial 2663] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359] ->
Q [361] << Delta = Delta >>
by Equality Law (idistr):  a=a <-> true
and theorem 783:
Theorem (783) [serial 2665] used for:
  Equality Law (idistr):  a=a <-> true [serial 2663]
 


Theorem (785)                               [serial 2661] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359] ->
Q [361] << Delta = (((ACTUAL_POSITION + Delta)) - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Subtaction of Added Value:  (a+b)-a is b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 784:
Theorem (784) [serial 2663] used for:
    normalization of [serial 2661]
 


Theorem (786)                               [serial 2608] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359] ->
Q [361] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Guided Substitution of Equals
and theorem 785:
Theorem (785) [serial 2661] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2608]
 


Theorem (787)                               [serial 2672] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [359] ->
Q [360] << (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (788)                               [serial 2670] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [359] ->
Q [360] << (Delta + ACTUAL_POSITION) = ACTUAL_POSITION' >>
by Normalization
  Normalization Axiom:
    Reflexivity of Addition: a+b=b+a
and theorem 787:
Theorem (787) [serial 2672] used for:
    normalization of [serial 2670]
 


Theorem (789)                               [serial 2668] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [359] ->
Q [360] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 788:
Theorem (788) [serial 2670] used for:
  Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 2668]
 


Theorem (790)                               [serial 2666] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [359] ->
Q [360] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 789:
Theorem (789) [serial 2668] used for:
    normalization of [serial 2666]
 


Theorem (791)                               [serial 2609] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359] ->
Q [360] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Substitution of Assertion Labels
and theorem 790:
Theorem (790) [serial 2666] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2609]
 


Theorem (792)                               [serial 2588] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 779 782 786 791:
Theorem (779) [serial 2606] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2588]
 
Theorem (782) [serial 2607] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2588]
 
Theorem (786) [serial 2608] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2588]
 
Theorem (791) [serial 2609] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2588]
 


Theorem (793)                               [serial 2580] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 792:
Theorem (792) [serial 2588] used for:
    normalization of [serial 2580]
 


Theorem (794)                               [serial 2572] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = #PCS::MaxStepsUp and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' and E_MS() >>
S [359] EstimatedActualPosition' := (Delta + EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 793:
Theorem (793) [serial 2580] used for:
  applied wp for assignment [serial 2572]
 


Theorem (795)                               [serial 2562] 
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and (Delta = #PCS::MaxStepsUp) and 
(ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
S [359] EstimatedActualPosition' := (EstimatedActualPosition + Delta)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 794:
Theorem (794) [serial 2572] used for:
    normalization of [serial 2562]
 


Theorem (796)                               [serial 1034] 
P [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition + 
#PCS::MaxStepsUp) <= (DESIRED_POSITION)^0))) >>
S [346] << (((ACTUAL_POSITION + #PCS::MaxStepsUp) <= DESIRED_POSITION) and E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Delta := #PCS::MaxStepsUp
<< (E_MS() and (DESIRED_POSITION >= (ACTUAL_POSITION + #PCS::MaxStepsUp)) and (Delta = #PCS::MaxStepsUp) and (ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and ((ACTUAL_POSITION + #PCS::MaxStepsUp) <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and (Delta = #PCS::MaxStepsUp) and (ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition + Delta)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 705 717 742 776 795:
Theorem (705) [serial 2558] used for:
  P -> P1 in sequential composition for [serial 1034]
 
Theorem (717) [serial 2559] used for:
  Q2 -> Q in sequential composition for [serial 1034]
 
Theorem (742) [serial 2560] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1034]
 
Theorem (776) [serial 2561] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1034]
 
Theorem (795) [serial 2562] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1034]
 


Theorem (797)                               [serial 2823] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (EstimatedActualPosition - #PCS::MaxStepsUp) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298] ->
Q [367] << DESIRED_POSITION <= (EstimatedActualPosition - #PCS::MaxStepsUp) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (798)                               [serial 2822] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298] ->
Q [367] << DESIRED_POSITION <= (EstimatedActualPosition - #PCS::MaxStepsUp) >>
by Assume Present:  P = P@now = P^0 
and theorem 797:
Theorem (797) [serial 2823] used for:
  Assume Present:  P = P@now = P^0  [serial 2822]
 


Theorem (799)                               [serial 2820] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298] ->
Q [367] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
by Guided Substitution of Equals
and theorem 798:
Theorem (798) [serial 2822] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 2820]
 


Theorem (800)                               [serial 2818] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [298] ->
Q [367] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 799:
Theorem (799) [serial 2820] used for:
    normalization of [serial 2818]
 


Theorem (801)                               [serial 2816] 
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) >>
S [298] ->
Q [367] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
by Associativity: (b.c).a = a.b.c
and theorem 800:
Theorem (800) [serial 2818] used for:
  Associativity: (b.c).a = a.b.c [serial 2816]
 


Theorem (802)                               [serial 2814] 
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [298] ->
Q [367] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 801:
Theorem (801) [serial 2816] used for:
    normalization of [serial 2814]
 


Theorem (803)                               [serial 2775] 
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [367] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
by Substitution of Assertion Labels
and theorem 802:
Theorem (802) [serial 2814] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2775]
 


Theorem (804)                               [serial 2776] 
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [368] << ACTUAL_IN_RANGE() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (805)                               [serial 2777] 
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [368] << DESIRED_IN_RANGE() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (806)                               [serial 2778] 
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [368] << E_MS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (807)                               [serial 2739] 
P [15] << DESIRED_POSITION^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp) and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 803 804 805 806:
Theorem (803) [serial 2775] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2739]
 
Theorem (804) [serial 2776] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2739]
 
Theorem (805) [serial 2777] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2739]
 
Theorem (806) [serial 2778] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2739]
 


Theorem (808)                               [serial 2733] 
P [15] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp)))) >>
S [298] ->
Q [15] << ((DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp)) and E_MS() and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 807:
Theorem (807) [serial 2739] used for:
    normalization of [serial 2733]
 


Theorem (809)                               [serial 2813] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by Identity (id):  P->P is tautology


Theorem (810)                               [serial 2810] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
by Associativity: (b.c).a = a.b.c
and theorem 809:
Theorem (809) [serial 2813] used for:
  Associativity: (b.c).a = a.b.c [serial 2810]
 


Theorem (811)                               [serial 2808] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 810:
Theorem (810) [serial 2810] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2808]
 


Theorem (812)                               [serial 2806] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) and 
(((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
and theorem 811:
Theorem (811) [serial 2808] used for:
    normalization of [serial 2806]
 


Theorem (813)                               [serial 2804] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 812:
Theorem (812) [serial 2806] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2804]
 


Theorem (814)                               [serial 2802] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << (Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 813:
Theorem (813) [serial 2804] used for:
    normalization of [serial 2802]
 


Theorem (815)                               [serial 2800] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 814:
Theorem (814) [serial 2802] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2800]
 


Theorem (816)                               [serial 2798] 
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [294] ->
Q [15] << ((Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 815:
Theorem (815) [serial 2800] used for:
    normalization of [serial 2798]
 


Theorem (817)                               [serial 2796] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294] ->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 816:
Theorem (816) [serial 2798] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2796]
 


Theorem (818)                               [serial 2794] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294] ->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 817:
Theorem (817) [serial 2796] used for:
    normalization of [serial 2794]
 


Theorem (819)                               [serial 2741] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294] ->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
by Substitution of Assertion Labels
and theorem 818:
Theorem (818) [serial 2794] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 2741]
 


Theorem (820)                               [serial 2734] 
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [294] ->
Q [15] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 819:
Theorem (819) [serial 2741] used for:
    normalization of [serial 2734]
 


Theorem (821)                               [serial 2849] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [369] ->
Q [1] << 0 <= DESIRED_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (822)                               [serial 2847] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [369] ->
Q [1] << 0 <= DESIRED_POSITION >>
by Associativity: (b.c).a = a.b.c
and theorem 821:
Theorem (821) [serial 2849] used for:
  Associativity: (b.c).a = a.b.c [serial 2847]
 


Theorem (823)                               [serial 2845] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [369] ->
Q [1] << 0 <= DESIRED_POSITION >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 822:
Theorem (822) [serial 2847] used for:
    normalization of [serial 2845]
 


Theorem (824)                               [serial 2783] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369] ->
Q [1] << 0 <= DESIRED_POSITION >>
by Substitution of Assertion Labels
and theorem 823:
Theorem (823) [serial 2845] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2783]
 


Theorem (825)                               [serial 2856] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and DESIRED_POSITION <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [369] ->
Q [372] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (826)                               [serial 2854] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [369] ->
Q [372] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 825:
Theorem (825) [serial 2856] used for:
    normalization of [serial 2854]
 


Theorem (827)                               [serial 2852] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition) >>
S [369] ->
Q [372] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Associativity: (b.c).a = a.b.c
and theorem 826:
Theorem (826) [serial 2854] used for:
  Associativity: (b.c).a = a.b.c [serial 2852]
 


Theorem (828)                               [serial 2850] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ((ACTUAL_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [369] ->
Q [372] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 827:
Theorem (827) [serial 2852] used for:
    normalization of [serial 2850]
 


Theorem (829)                               [serial 2784] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369] ->
Q [372] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 828:
Theorem (828) [serial 2850] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2784]
 


Theorem (830)                               [serial 2785] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369] ->
Q [1] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (831)                               [serial 2858] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369] ->
Q [371] << true >>
by True Conclusion Schema (tc): P->true


Theorem (832)                               [serial 2858] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369] ->
Q [371] << true >>
by True Conclusion Schema (tc): P->true


Theorem (833)                               [serial 2786] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369] ->
Q [371] << AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 832 832:
Theorem (832) [serial 2858] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (832) [serial 2858] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (834)                               [serial 2787] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369] ->
Q [370] << E_MS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (835)                               [serial 2767] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369] ->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and E_MS() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 824 829 830 833 834:
Theorem (824) [serial 2783] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]
 
Theorem (829) [serial 2784] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]
 
Theorem (830) [serial 2785] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]
 
Theorem (833) [serial 2786] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]
 
Theorem (834) [serial 2787] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2767]
 


Theorem (836)                               [serial 2765] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369] ->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
true and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and E_MS() >>
by Law of And-Simplification:  P and true is P
and theorem 835:
Theorem (835) [serial 2767] used for:
  Law of And-Simplification:  P and true is P [serial 2765]
 


Theorem (837)                               [serial 2753] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369] ->
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
( -#PCS::MaxStepsUp) =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,
k:#PCS::MaxStepsUp) and E_MS() >>
by Equality Law (idistr):  a=a <-> true
and theorem 836:
Theorem (836) [serial 2765] used for:
  Equality Law (idistr):  a=a <-> true [serial 2753]
 


Theorem (838)                               [serial 2743] 
P [15] << DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and ACTUAL_IN_RANGE() and 
DESIRED_IN_RANGE() and E_MS() >>
S [369] Delta := -#PCS::MaxStepsUp
Q [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 837:
Theorem (837) [serial 2753] used for:
  applied wp for assignment [serial 2743]
 


Theorem (839)                               [serial 2735] 
P [15] << ((DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp)) and E_MS() and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
S [369] Delta := -#PCS::MaxStepsUp
Q [15] << (E_MS() and (Delta =  -#PCS::MaxStepsUp) and ((ACTUAL_POSITION - #PCS::MaxStepsUp) >= DESIRED_POSITION) and 
AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and (DESIRED_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 838:
Theorem (838) [serial 2743] used for:
    normalization of [serial 2735]
 


Theorem (840)                               [serial 2862] 
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374] ->
Q [1] << 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (841)                               [serial 2860] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
S [374] ->
Q [1] << 0 <= (ACTUAL_POSITION + ( -#PCS::MaxStepsUp)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Conjunction: (m and k) = (k and m)
    Associativity: (b.c).a = a.b.c
and theorem 840:
Theorem (840) [serial 2862] used for:
    normalization of [serial 2860]
 


Theorem (842)                               [serial 2859] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374] ->
Q [1] << 0 <= (ACTUAL_POSITION + ( -#PCS::MaxStepsUp)) >>
by Transitivity: x<y and y<z -> x<z
and theorem 841:
Theorem (841) [serial 2860] used for:
  Transitivity: x<y and y<z -> x<z [serial 2859]
 


Theorem (843)                               [serial 2788] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Guided Substitution of Equals
and theorem 842:
Theorem (842) [serial 2859] used for:
  Guided Substitution of Equals
 replacing "Delta" with its = "(-#PCS::MaxStepsUp)" in its postcondition [serial 2788]
 


Theorem (844)                               [serial 2876] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and 
0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition >>
S [374] ->
Q [1] << 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (845)                               [serial 2874] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374] ->
Q [1] << 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
by Transitivity: x<y and y<z -> x<z
and theorem 844:
Theorem (844) [serial 2876] used for:
  Transitivity: x<y and y<z -> x<z [serial 2874]
 


Theorem (846)                               [serial 2872] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374] ->
Q [1] << 0 <= (ACTUAL_POSITION + ( -#PCS::MaxStepsUp)) >>
by Normalization
  Normalization Axiom:
    Associativity: (b.c).a = a.b.c
and theorem 845:
Theorem (845) [serial 2874] used for:
    normalization of [serial 2872]
 


Theorem (847)                               [serial 2870] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Guided Substitution of Equals
and theorem 846:
Theorem (846) [serial 2872] used for:
  Guided Substitution of Equals
 replacing "Delta" with its = "(-#PCS::MaxStepsUp)" in its postcondition [serial 2870]
 


Theorem (848)                               [serial 2868] 
P [15] << 0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and 
0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp >>
S [374] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 847:
Theorem (847) [serial 2870] used for:
    normalization of [serial 2868]
 


Theorem (849)                               [serial 2866] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
(0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION) >>
S [374] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Associativity: (b.c).a = a.b.c
and theorem 848:
Theorem (848) [serial 2868] used for:
  Associativity: (b.c).a = a.b.c [serial 2866]
 


Theorem (850)                               [serial 2864] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and ((ACTUAL_POSITION > (ACTUAL_POSITION - (#PCS::MaxStepsUp))) and 
((#PCS::MaxStepsUp) > 0)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [374] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 849:
Theorem (849) [serial 2866] used for:
    normalization of [serial 2864]
 


Theorem (851)                               [serial 2789] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Substitution of Assertion Labels
and theorem 850:
Theorem (850) [serial 2864] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2789]
 


Theorem (852)                               [serial 2893] 
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 0 < #PCS::MaxStepsUp and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
S [374] ->
Q [130] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (853)                               [serial 2891] 
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 0 < #PCS::MaxStepsUp and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition >>
S [374] ->
Q [130] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
by Partial Order Law 3:  a <= (b-1)  is  a<b
and theorem 852:
Theorem (852) [serial 2893] used for:
  (ACTUAL_POSITION - #PCS::MaxStepsUp)<#PCS::MaxPosition  ->  (ACTUAL_POSITION - #PCS::MaxStepsUp)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2891]
 


Theorem (854)                               [serial 2889] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and 
0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition >>
S [374] ->
Q [130] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 853:
Theorem (853) [serial 2891] used for:
    normalization of [serial 2889]
 


Theorem (855)                               [serial 2887] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374] ->
Q [130] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
by Transitivity: x<y and y<z -> x<z
and theorem 854:
Theorem (854) [serial 2889] used for:
  Transitivity: x<y and y<z -> x<z [serial 2887]
 


Theorem (856)                               [serial 2885] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374] ->
Q [130] << (ACTUAL_POSITION + ( -#PCS::MaxStepsUp)) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Associativity: (b.c).a = a.b.c
and theorem 855:
Theorem (855) [serial 2887] used for:
    normalization of [serial 2885]
 


Theorem (857)                               [serial 2883] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374] ->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by Guided Substitution of Equals
and theorem 856:
Theorem (856) [serial 2885] used for:
  Guided Substitution of Equals
 replacing "Delta" with its = "(-#PCS::MaxStepsUp)" in its postcondition [serial 2883]
 


Theorem (858)                               [serial 2881] 
P [15] << 0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and 
0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp >>
S [374] ->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 857:
Theorem (857) [serial 2883] used for:
    normalization of [serial 2881]
 


Theorem (859)                               [serial 2879] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
(0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION) >>
S [374] ->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by Associativity: (b.c).a = a.b.c
and theorem 858:
Theorem (858) [serial 2881] used for:
  Associativity: (b.c).a = a.b.c [serial 2879]
 


Theorem (860)                               [serial 2877] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and ((ACTUAL_POSITION > (ACTUAL_POSITION - (#PCS::MaxStepsUp))) and 
((#PCS::MaxStepsUp) > 0)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [374] ->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 859:
Theorem (859) [serial 2879] used for:
    normalization of [serial 2877]
 


Theorem (861)                               [serial 2790] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374] ->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 860:
Theorem (860) [serial 2877] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2790]
 


Theorem (862)                               [serial 2914] 
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 0 < #PCS::MaxStepsUp and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
S [374] ->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (863)                               [serial 2912] 
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 0 < #PCS::MaxStepsUp and 
DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition >>
S [374] ->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
by Partial Order Law 3:  a <= (b-1)  is  a<b
and theorem 862:
Theorem (862) [serial 2914] used for:
  (ACTUAL_POSITION - #PCS::MaxStepsUp)<#PCS::MaxPosition  ->  (ACTUAL_POSITION - #PCS::MaxStepsUp)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 2912]
 


Theorem (864)                               [serial 2910] 
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < #PCS::MaxPosition and 
0 < #PCS::MaxPosition and DESIRED_POSITION < ACTUAL_POSITION and DESIRED_POSITION < #PCS::MaxPosition >>
S [374] ->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 863:
Theorem (863) [serial 2912] used for:
    normalization of [serial 2910]
 


Theorem (865)                               [serial 2908] 
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION >>
S [374] ->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
by Transitivity: x<y and y<z -> x<z
and theorem 864:
Theorem (864) [serial 2910] used for:
  Transitivity: x<y and y<z -> x<z [serial 2908]
 


Theorem (866)                               [serial 2906] 
P [15] << 0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION and 
0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp >>
S [374] ->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 865:
Theorem (865) [serial 2908] used for:
    normalization of [serial 2906]
 


Theorem (867)                               [serial 2904] 
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
(0 < #PCS::MaxStepsUp and (ACTUAL_POSITION - #PCS::MaxStepsUp) < ACTUAL_POSITION) >>
S [374] ->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
by Associativity: (b.c).a = a.b.c
and theorem 866:
Theorem (866) [serial 2906] used for:
  Associativity: (b.c).a = a.b.c [serial 2904]
 


Theorem (868)                               [serial 2902] 
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and ((ACTUAL_POSITION > (ACTUAL_POSITION - (#PCS::MaxStepsUp))) and 
((#PCS::MaxStepsUp) > 0)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [374] ->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 867:
Theorem (867) [serial 2904] used for:
    normalization of [serial 2902]
 


Theorem (869)                               [serial 2900] 
P [15] << 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374] ->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 868:
Theorem (868) [serial 2902] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2900]
 


Theorem (870)                               [serial 2898] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() and 0 <= (ACTUAL_POSITION - #PCS::MaxStepsUp) >>
S [374] ->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 869:
Theorem (869) [serial 2900] used for:
    normalization of [serial 2898]
 


Theorem (871)                               [serial 2896] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374] ->
Q [377] << (ACTUAL_POSITION - #PCS::MaxStepsUp) <= #PCS::MaxPosition >>
by Transitivity: x<y and y<z -> x<z
and theorem 870:
Theorem (870) [serial 2898] used for:
  Transitivity: x<y and y<z -> x<z [serial 2896]
 


Theorem (872)                               [serial 2894] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374] ->
Q [377] << (ACTUAL_POSITION + ( -#PCS::MaxStepsUp)) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Associativity: (b.c).a = a.b.c
and theorem 871:
Theorem (871) [serial 2896] used for:
    normalization of [serial 2894]
 


Theorem (873)                               [serial 2791] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374] ->
Q [377] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by Guided Substitution of Equals
and theorem 872:
Theorem (872) [serial 2894] used for:
  Guided Substitution of Equals
 replacing "Delta" with its = "(-#PCS::MaxStepsUp)" in its postcondition [serial 2791]
 


Theorem (874)                               [serial 2792] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374] ->
Q [375] << Delta =  -#PCS::MaxStepsUp >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (875)                               [serial 2793] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374] ->
Q [376] << E_MS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (876)                               [serial 2772] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374] ->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + Delta) and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and E_MS() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 843 851 861 873 874 875:
Theorem (843) [serial 2788] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]
 
Theorem (851) [serial 2789] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]
 
Theorem (861) [serial 2790] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]
 
Theorem (873) [serial 2791] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]
 
Theorem (874) [serial 2792] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]
 
Theorem (875) [serial 2793] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2772]
 


Theorem (877)                               [serial 2766] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374] ->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and E_MS() >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 876:
Theorem (876) [serial 2772] used for:
    normalization of [serial 2766]
 


Theorem (878)                               [serial 2760] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374] ->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and E_MS() and (0 <= (ACTUAL_POSITION + Delta) and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) >>
by Associativity: (b.c).a = a.b.c
and theorem 877:
Theorem (877) [serial 2766] used for:
  Associativity: (b.c).a = a.b.c [serial 2760]
 


Theorem (879)                               [serial 2754] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374] ->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition) and E_MS() >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 878:
Theorem (878) [serial 2760] used for:
    normalization of [serial 2754]
 


Theorem (880)                               [serial 2745] 
P [15] << 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp) and 
Delta =  -#PCS::MaxStepsUp and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and 
E_MS() >>
S [374] ActuatorCommand(pc:Delta)
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
by Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
and theorem 879:
Theorem (879) [serial 2754] used for:
  applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2745]
 


Theorem (881)                               [serial 2736] 
P [15] << (E_MS() and (Delta =  -#PCS::MaxStepsUp) and ((ACTUAL_POSITION - #PCS::MaxStepsUp) >= DESIRED_POSITION) and 
AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and (DESIRED_POSITION >= 0) and 
(ACTUAL_POSITION <= #PCS::MaxPosition)) >>
S [374] ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta =  -#PCS::MaxStepsUp) and 
((ACTUAL_POSITION + Delta) >= 0) and E_MS() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 880:
Theorem (880) [serial 2745] used for:
    normalization of [serial 2736]
 


Theorem (882)                               [serial 2826] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (883)                               [serial 2824] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379] ->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 882:
Theorem (882) [serial 2826] used for:
    normalization of [serial 2824]
 


Theorem (884)                               [serial 2779] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379] ->
Q [1] << 0 <= ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 883:
Theorem (883) [serial 2824] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2779]
 


Theorem (885)                               [serial 2830] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379] ->
Q [382] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (886)                               [serial 2828] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379] ->
Q [382] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 885:
Theorem (885) [serial 2830] used for:
    normalization of [serial 2828]
 


Theorem (887)                               [serial 2780] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379] ->
Q [382] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
by Guided Substitution of Equals
and theorem 886:
Theorem (886) [serial 2828] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2780]
 


Theorem (888)                               [serial 2836] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379] ->
Q [381] << true >>
by True Conclusion Schema (tc): P->true


Theorem (889)                               [serial 2834] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379] ->
Q [381] << Delta = Delta >>
by Equality Law (idistr):  a=a <-> true
and theorem 888:
Theorem (888) [serial 2836] used for:
  Equality Law (idistr):  a=a <-> true [serial 2834]
 


Theorem (890)                               [serial 2832] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379] ->
Q [381] << Delta = (((ACTUAL_POSITION + Delta)) - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Subtaction of Added Value:  (a+b)-a is b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 889:
Theorem (889) [serial 2834] used for:
    normalization of [serial 2832]
 


Theorem (891)                               [serial 2781] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379] ->
Q [381] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Guided Substitution of Equals
and theorem 890:
Theorem (890) [serial 2832] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2781]
 


Theorem (892)                               [serial 2843] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [379] ->
Q [380] << (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (893)                               [serial 2841] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [379] ->
Q [380] << (Delta + ACTUAL_POSITION) = ACTUAL_POSITION' >>
by Normalization
  Normalization Axiom:
    Reflexivity of Addition: a+b=b+a
and theorem 892:
Theorem (892) [serial 2843] used for:
    normalization of [serial 2841]
 


Theorem (894)                               [serial 2839] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta =  -#PCS::MaxStepsUp and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [379] ->
Q [380] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 893:
Theorem (893) [serial 2841] used for:
  Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 2839]
 


Theorem (895)                               [serial 2837] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [379] ->
Q [380] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 894:
Theorem (894) [serial 2839] used for:
    normalization of [serial 2837]
 


Theorem (896)                               [serial 2782] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379] ->
Q [380] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Substitution of Assertion Labels
and theorem 895:
Theorem (895) [serial 2837] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2782]
 


Theorem (897)                               [serial 2762] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 884 887 891 896:
Theorem (884) [serial 2779] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2762]
 
Theorem (887) [serial 2780] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2762]
 
Theorem (891) [serial 2781] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2762]
 
Theorem (896) [serial 2782] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2762]
 


Theorem (898)                               [serial 2755] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 897:
Theorem (897) [serial 2762] used for:
    normalization of [serial 2755]
 


Theorem (899)                               [serial 2747] 
P [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
Delta =  -#PCS::MaxStepsUp and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
E_MS() >>
S [379] EstimatedActualPosition' := (Delta + EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 898:
Theorem (898) [serial 2755] used for:
  applied wp for assignment [serial 2747]
 


Theorem (900)                               [serial 2737] 
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta =  -#PCS::MaxStepsUp) and 
((ACTUAL_POSITION + Delta) >= 0) and E_MS() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
S [379] EstimatedActualPosition' := (EstimatedActualPosition + Delta)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 899:
Theorem (899) [serial 2747] used for:
    normalization of [serial 2737]
 


Theorem (901)                               [serial 1035] 
P [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((DESIRED_POSITION)^0 <= (EstimatedActualPosition - #PCS::MaxStepsUp)))) >>
S [367] << ((DESIRED_POSITION <= (ACTUAL_POSITION - #PCS::MaxStepsUp)) and E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Delta := -#PCS::MaxStepsUp
<< (E_MS() and (Delta =  -#PCS::MaxStepsUp) and ((ACTUAL_POSITION - #PCS::MaxStepsUp) >= DESIRED_POSITION) and AXIOM_GTK(z:ACTUAL_POSITION,k:#PCS::MaxStepsUp) and (DESIRED_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta =  -#PCS::MaxStepsUp) and ((ACTUAL_POSITION + Delta) >= 0) and E_MS() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition + Delta)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 808 820 839 881 900:
Theorem (808) [serial 2733] used for:
  P -> P1 in sequential composition for [serial 1035]
 
Theorem (820) [serial 2734] used for:
  Q2 -> Q in sequential composition for [serial 1035]
 
Theorem (839) [serial 2735] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1035]
 
Theorem (881) [serial 2736] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1035]
 
Theorem (900) [serial 2737] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1035]
 


Theorem (902)                               [serial 2967] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298] ->
Q [389] << ACTUAL_IN_RANGE() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (903)                               [serial 2968] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298] ->
Q [389] << DESIRED_IN_RANGE() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (904)                               [serial 2969] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298] ->
Q [389] << E_MS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (905)                               [serial 3030] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298] ->
Q [388] << EstimatedActualPosition < DESIRED_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (906)                               [serial 3028] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298] ->
Q [388] << ACTUAL_POSITION < DESIRED_POSITION >>
by Guided Substitution of Equals
and theorem 905:
Theorem (905) [serial 3030] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 3028]
 


Theorem (907)                               [serial 3026] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298] ->
Q [388] << ACTUAL_POSITION < DESIRED_POSITION >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 906:
Theorem (906) [serial 3028] used for:
    normalization of [serial 3026]
 


Theorem (908)                               [serial 3025] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298] ->
Q [388] << ACTUAL_POSITION < DESIRED_POSITION >>
by Associativity: (b.c).a = a.b.c
and theorem 907:
Theorem (907) [serial 3026] used for:
  Associativity: (b.c).a = a.b.c [serial 3025]
 


Theorem (909)                               [serial 3024] 
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298] ->
Q [388] << ACTUAL_POSITION < DESIRED_POSITION >>
by Assume Present:  P = P@now = P^0 
and theorem 908:
Theorem (908) [serial 3025] used for:
  Assume Present:  P = P@now = P^0  [serial 3024]
 


Theorem (910)                               [serial 2970] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298] ->
Q [388] << ACTUAL_POSITION < DESIRED_POSITION >>
by Substitution of Assertion Labels
and theorem 909:
Theorem (909) [serial 3024] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2970]
 


Theorem (911)                               [serial 3037] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298] ->
Q [1] << DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (912)                               [serial 3035] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298] ->
Q [1] << DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
by Guided Substitution of Equals
and theorem 911:
Theorem (911) [serial 3037] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 3035]
 


Theorem (913)                               [serial 3033] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298] ->
Q [1] << DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 912:
Theorem (912) [serial 3035] used for:
    normalization of [serial 3033]
 


Theorem (914)                               [serial 3032] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < (EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION >>
S [298] ->
Q [1] << DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
by Associativity: (b.c).a = a.b.c
and theorem 913:
Theorem (913) [serial 3033] used for:
  Associativity: (b.c).a = a.b.c [serial 3032]
 


Theorem (915)                               [serial 3031] 
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298] ->
Q [1] << DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
by Assume Present:  P = P@now = P^0 
and theorem 914:
Theorem (914) [serial 3032] used for:
  Assume Present:  P = P@now = P^0  [serial 3031]
 


Theorem (916)                               [serial 2971] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298] ->
Q [1] << DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
by Substitution of Assertion Labels
and theorem 915:
Theorem (915) [serial 3031] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2971]
 


Theorem (917)                               [serial 2955] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [298] ->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 902 903 904 910 916:
Theorem (902) [serial 2967] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2955]
 
Theorem (903) [serial 2968] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2955]
 
Theorem (904) [serial 2969] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2955]
 
Theorem (910) [serial 2970] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2955]
 
Theorem (916) [serial 2971] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2955]
 


Theorem (918)                               [serial 2949] 
P [15] << DESIRED_POSITION^0 < (EstimatedActualPosition + #PCS::MaxStepsUp) and 
EstimatedActualPosition < DESIRED_POSITION^0 and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and 
E_MS() >>
S [298] ->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 917:
Theorem (917) [serial 2955] used for:
    normalization of [serial 2949]
 


Theorem (919)                               [serial 2921] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and (DESIRED_POSITION^0 < (
EstimatedActualPosition + #PCS::MaxStepsUp) and EstimatedActualPosition < DESIRED_POSITION^0) >>
S [298] ->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
by Associativity: (b.c).a = a.b.c
and theorem 918:
Theorem (918) [serial 2949] used for:
  Associativity: (b.c).a = a.b.c [serial 2921]
 


Theorem (920)                               [serial 2915] 
P [15] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition < (DESIRED_POSITION)^0)) and 
(((EstimatedActualPosition + #PCS::MaxStepsUp) > (DESIRED_POSITION)^0)))) >>
S [298] ->
Q [15] << (((ACTUAL_POSITION + #PCS::MaxStepsUp) > DESIRED_POSITION) and (ACTUAL_POSITION < DESIRED_POSITION) and 
E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 919:
Theorem (919) [serial 2921] used for:
    normalization of [serial 2915]
 


Theorem (921)                               [serial 3002] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by Identity (id):  P->P is tautology


Theorem (922)                               [serial 2999] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
by Associativity: (b.c).a = a.b.c
and theorem 921:
Theorem (921) [serial 3002] used for:
  Associativity: (b.c).a = a.b.c [serial 2999]
 


Theorem (923)                               [serial 2997] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 922:
Theorem (922) [serial 2999] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2997]
 


Theorem (924)                               [serial 2995] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) and 
(((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
and theorem 923:
Theorem (923) [serial 2997] used for:
    normalization of [serial 2995]
 


Theorem (925)                               [serial 2993] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 924:
Theorem (924) [serial 2995] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2993]
 


Theorem (926)                               [serial 2991] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << (Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 925:
Theorem (925) [serial 2993] used for:
    normalization of [serial 2991]
 


Theorem (927)                               [serial 2989] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 926:
Theorem (926) [serial 2991] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2989]
 


Theorem (928)                               [serial 2987] 
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [294] ->
Q [15] << ((Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 927:
Theorem (927) [serial 2989] used for:
    normalization of [serial 2987]
 


Theorem (929)                               [serial 2985] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294] ->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 928:
Theorem (928) [serial 2987] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 2985]
 


Theorem (930)                               [serial 2983] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294] ->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 929:
Theorem (929) [serial 2985] used for:
    normalization of [serial 2983]
 


Theorem (931)                               [serial 2923] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294] ->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
by Substitution of Assertion Labels
and theorem 930:
Theorem (930) [serial 2983] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 2923]
 


Theorem (932)                               [serial 2916] 
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [294] ->
Q [15] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 931:
Theorem (931) [serial 2923] used for:
    normalization of [serial 2916]
 


Theorem (933)                               [serial 3055] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (934)                               [serial 3053] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by Associativity: (b.c).a = a.b.c
and theorem 933:
Theorem (933) [serial 3055] used for:
  Associativity: (b.c).a = a.b.c [serial 3053]
 


Theorem (935)                               [serial 3051] 
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 934:
Theorem (934) [serial 3053] used for:
    normalization of [serial 3051]
 


Theorem (936)                               [serial 2977] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by Substitution of Assertion Labels
and theorem 935:
Theorem (935) [serial 3051] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2977]
 


Theorem (937)                               [serial 3062] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (938)                               [serial 3060] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 937:
Theorem (937) [serial 3062] used for:
    normalization of [serial 3060]
 


Theorem (939)                               [serial 3058] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
by Associativity: (b.c).a = a.b.c
and theorem 938:
Theorem (938) [serial 3060] used for:
  Associativity: (b.c).a = a.b.c [serial 3058]
 


Theorem (940)                               [serial 3056] 
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 939:
Theorem (939) [serial 3058] used for:
    normalization of [serial 3056]
 


Theorem (941)                               [serial 2978] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 940:
Theorem (940) [serial 3056] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2978]
 


Theorem (942)                               [serial 3075] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [395] << DESIRED_POSITION <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (943)                               [serial 3073] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - ACTUAL_POSITION) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Subtaction of Added Value:  (a+b)-a is b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 942:
Theorem (942) [serial 3075] used for:
    normalization of [serial 3073]
 


Theorem (944)                               [serial 3071] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
by Guided Substitution of Equals
and theorem 943:
Theorem (943) [serial 3073] used for:
  Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3071]
 


Theorem (945)                               [serial 3069] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 944:
Theorem (944) [serial 3071] used for:
    normalization of [serial 3069]
 


Theorem (946)                               [serial 3067] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
by Associativity: (b.c).a = a.b.c
and theorem 945:
Theorem (945) [serial 3069] used for:
  Associativity: (b.c).a = a.b.c [serial 3067]
 


Theorem (947)                               [serial 3065] 
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 946:
Theorem (946) [serial 3067] used for:
    normalization of [serial 3065]
 


Theorem (948)                               [serial 3064] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 947:
Theorem (947) [serial 3065] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 3064]
 


Theorem (949)                               [serial 2979] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [395] << ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
by Assume Present:  P = P@now = P^0 
and theorem 948:
Theorem (948) [serial 3064] used for:
  Assume Present:  P = P@now = P^0  [serial 2979]
 


Theorem (950)                               [serial 3090] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [391] << true >>
by True Conclusion Schema (tc): P->true


Theorem (951)                               [serial 3088] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [391] << DESIRED_POSITION = DESIRED_POSITION >>
by Equality Law (idistr):  a=a <-> true
and theorem 950:
Theorem (950) [serial 3090] used for:
  Equality Law (idistr):  a=a <-> true [serial 3088]
 


Theorem (952)                               [serial 3086] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Subtaction of Added Value:  (a+b)-a is b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 951:
Theorem (951) [serial 3088] used for:
    normalization of [serial 3086]
 


Theorem (953)                               [serial 3084] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
by Guided Substitution of Equals
and theorem 952:
Theorem (952) [serial 3086] used for:
  Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3084]
 


Theorem (954)                               [serial 3082] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 953:
Theorem (953) [serial 3084] used for:
    normalization of [serial 3082]
 


Theorem (955)                               [serial 3080] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
by Associativity: (b.c).a = a.b.c
and theorem 954:
Theorem (954) [serial 3082] used for:
  Associativity: (b.c).a = a.b.c [serial 3080]
 


Theorem (956)                               [serial 3078] 
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 955:
Theorem (955) [serial 3080] used for:
    normalization of [serial 3078]
 


Theorem (957)                               [serial 3077] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
by Substitution of Assertion Labels
and theorem 956:
Theorem (956) [serial 3078] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 3077]
 


Theorem (958)                               [serial 2980] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [391] << DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) >>
by Assume Present:  P = P@now = P^0 
and theorem 957:
Theorem (957) [serial 3077] used for:
  Assume Present:  P = P@now = P^0  [serial 2980]
 


Theorem (959)                               [serial 3101] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [392] << true >>
by True Conclusion Schema (tc): P->true


Theorem (960)                               [serial 3100] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - ACTUAL_POSITION) >>
by Equality Law (idistr):  a=a <-> true
and theorem 959:
Theorem (959) [serial 3101] used for:
  Equality Law (idistr):  a=a <-> true [serial 3100]
 


Theorem (961)                               [serial 3098] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
by Guided Substitution of Equals
and theorem 960:
Theorem (960) [serial 3100] used for:
  Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3098]
 


Theorem (962)                               [serial 3096] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 961:
Theorem (961) [serial 3098] used for:
    normalization of [serial 3096]
 


Theorem (963)                               [serial 3094] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
by Associativity: (b.c).a = a.b.c
and theorem 962:
Theorem (962) [serial 3096] used for:
  Associativity: (b.c).a = a.b.c [serial 3094]
 


Theorem (964)                               [serial 3092] 
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 963:
Theorem (963) [serial 3094] used for:
    normalization of [serial 3092]
 


Theorem (965)                               [serial 3091] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
by Substitution of Assertion Labels
and theorem 964:
Theorem (964) [serial 3092] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 3091]
 


Theorem (966)                               [serial 2981] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [392] << (DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) >>
by Assume Present:  P = P@now = P^0 
and theorem 965:
Theorem (965) [serial 3091] used for:
  Assume Present:  P = P@now = P^0  [serial 2981]
 


Theorem (967)                               [serial 2982] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [391] << E_MS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (968)                               [serial 2962] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ((
DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition and 
DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) and 
(DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) and 
E_MS() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 936 941 949 958 966 967:
Theorem (936) [serial 2977] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]
 
Theorem (941) [serial 2978] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]
 
Theorem (949) [serial 2979] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]
 
Theorem (958) [serial 2980] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]
 
Theorem (966) [serial 2981] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]
 
Theorem (967) [serial 2982] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]
 


Theorem (969)                               [serial 2960] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ((
DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition and 
DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) and 
(DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) and 
true and E_MS() >>
by Law of And-Simplification:  P and true is P
and theorem 968:
Theorem (968) [serial 2962] used for:
  Law of And-Simplification:  P and true is P [serial 2960]
 


Theorem (970)                               [serial 3055] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (971)                               [serial 3053] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by Associativity: (b.c).a = a.b.c
and theorem 970:
Theorem (970) [serial 3055] used for:
  Associativity: (b.c).a = a.b.c [serial 3053]
 


Theorem (972)                               [serial 3051] 
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 971:
Theorem (971) [serial 3053] used for:
    normalization of [serial 3051]
 


Theorem (973)                               [serial 2977] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by Substitution of Assertion Labels
and theorem 972:
Theorem (972) [serial 3051] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2977]
 


Theorem (974)                               [serial 3062] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (975)                               [serial 3060] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 974:
Theorem (974) [serial 3062] used for:
    normalization of [serial 3060]
 


Theorem (976)                               [serial 3058] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
by Associativity: (b.c).a = a.b.c
and theorem 975:
Theorem (975) [serial 3060] used for:
  Associativity: (b.c).a = a.b.c [serial 3058]
 


Theorem (977)                               [serial 3056] 
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 976:
Theorem (976) [serial 3058] used for:
    normalization of [serial 3056]
 


Theorem (978)                               [serial 2978] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [393] << DESIRED_POSITION <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 977:
Theorem (977) [serial 3056] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2978]
 


Theorem (979)                               [serial 3075] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [395] << DESIRED_POSITION <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (980)                               [serial 3073] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - ACTUAL_POSITION) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Subtaction of Added Value:  (a+b)-a is b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 979:
Theorem (979) [serial 3075] used for:
    normalization of [serial 3073]
 


Theorem (981)                               [serial 3071] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
by Guided Substitution of Equals
and theorem 980:
Theorem (980) [serial 3073] used for:
  Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3071]
 


Theorem (982)                               [serial 3069] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 981:
Theorem (981) [serial 3071] used for:
    normalization of [serial 3069]
 


Theorem (983)                               [serial 3067] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
by Associativity: (b.c).a = a.b.c
and theorem 982:
Theorem (982) [serial 3069] used for:
  Associativity: (b.c).a = a.b.c [serial 3067]
 


Theorem (984)                               [serial 3065] 
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 983:
Theorem (983) [serial 3067] used for:
    normalization of [serial 3065]
 


Theorem (985)                               [serial 3064] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [395] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 984:
Theorem (984) [serial 3065] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 3064]
 


Theorem (986)                               [serial 2979] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [395] << ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
by Assume Present:  P = P@now = P^0 
and theorem 985:
Theorem (985) [serial 3064] used for:
  Assume Present:  P = P@now = P^0  [serial 2979]
 


Theorem (987)                               [serial 3090] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [391] << true >>
by True Conclusion Schema (tc): P->true


Theorem (988)                               [serial 3088] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [391] << DESIRED_POSITION = DESIRED_POSITION >>
by Equality Law (idistr):  a=a <-> true
and theorem 987:
Theorem (987) [serial 3090] used for:
  Equality Law (idistr):  a=a <-> true [serial 3088]
 


Theorem (989)                               [serial 3086] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Subtaction of Added Value:  (a+b)-a is b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 988:
Theorem (988) [serial 3088] used for:
    normalization of [serial 3086]
 


Theorem (990)                               [serial 3084] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
by Guided Substitution of Equals
and theorem 989:
Theorem (989) [serial 3086] used for:
  Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3084]
 


Theorem (991)                               [serial 3082] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 990:
Theorem (990) [serial 3084] used for:
    normalization of [serial 3082]
 


Theorem (992)                               [serial 3080] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
by Associativity: (b.c).a = a.b.c
and theorem 991:
Theorem (991) [serial 3082] used for:
  Associativity: (b.c).a = a.b.c [serial 3080]
 


Theorem (993)                               [serial 3078] 
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 992:
Theorem (992) [serial 3080] used for:
    normalization of [serial 3078]
 


Theorem (994)                               [serial 3077] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [391] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
by Substitution of Assertion Labels
and theorem 993:
Theorem (993) [serial 3078] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 3077]
 


Theorem (995)                               [serial 2980] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [391] << DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) >>
by Assume Present:  P = P@now = P^0 
and theorem 994:
Theorem (994) [serial 3077] used for:
  Assume Present:  P = P@now = P^0  [serial 2980]
 


Theorem (996)                               [serial 3101] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [392] << true >>
by True Conclusion Schema (tc): P->true


Theorem (997)                               [serial 3100] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - ACTUAL_POSITION) >>
by Equality Law (idistr):  a=a <-> true
and theorem 996:
Theorem (996) [serial 3101] used for:
  Equality Law (idistr):  a=a <-> true [serial 3100]
 


Theorem (998)                               [serial 3098] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
by Guided Substitution of Equals
and theorem 997:
Theorem (997) [serial 3100] used for:
  Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3098]
 


Theorem (999)                               [serial 3096] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 998:
Theorem (998) [serial 3098] used for:
    normalization of [serial 3096]
 


Theorem (1000)                               [serial 3094] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
ACTUAL_POSITION < DESIRED_POSITION and DESIRED_POSITION < (ACTUAL_POSITION + 
#PCS::MaxStepsUp) >>
S [390] ->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
by Associativity: (b.c).a = a.b.c
and theorem 999:
Theorem (999) [serial 3096] used for:
  Associativity: (b.c).a = a.b.c [serial 3094]
 


Theorem (1001)                               [serial 3092] 
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1000:
Theorem (1000) [serial 3094] used for:
    normalization of [serial 3092]
 


Theorem (1002)                               [serial 3091] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [392] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
by Substitution of Assertion Labels
and theorem 1001:
Theorem (1001) [serial 3092] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 3091]
 


Theorem (1003)                               [serial 2981] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [392] << (DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) >>
by Assume Present:  P = P@now = P^0 
and theorem 1002:
Theorem (1002) [serial 3091] used for:
  Assume Present:  P = P@now = P^0  [serial 2981]
 


Theorem (1004)                               [serial 2982] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [391] << E_MS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1005)                               [serial 2962] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ((
DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition and 
DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) and 
(DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) and 
E_MS() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 973 978 986 995 1003 1004:
Theorem (973) [serial 2977] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]
 
Theorem (978) [serial 2978] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]
 
Theorem (986) [serial 2979] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]
 
Theorem (995) [serial 2980] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]
 
Theorem (1003) [serial 2981] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]
 
Theorem (1004) [serial 2982] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2962]
 


Theorem (1006)                               [serial 2960] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ((
DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition and 
DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) and 
(DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) and 
true and E_MS() >>
by Law of And-Simplification:  P and true is P
and theorem 1005:
Theorem (1005) [serial 2962] used for:
  Law of And-Simplification:  P and true is P [serial 2960]
 


Theorem (1007)                               [serial 2941] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ((
DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition and 
DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) and 
(DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:(DESIRED_POSITION^0 - EstimatedActualPosition)) and 
E_MS() >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 1006 1006:
Theorem (1006) [serial 2960] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (1006) [serial 2960] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (1008)                               [serial 2935] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
(((DESIRED_POSITION)^0 - EstimatedActualPosition))) <= #PCS::MaxPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + (((DESIRED_POSITION)^0 - EstimatedActualPosition))) and 
(((DESIRED_POSITION)^0 - EstimatedActualPosition)) = (DESIRED_POSITION - ACTUAL_POSITION) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:(((DESIRED_POSITION)^0 - EstimatedActualPosition))) and 
E_MS() >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Associativity: (b.c).a = a.b.c
and theorem 1007:
Theorem (1007) [serial 2941] used for:
    normalization of [serial 2935]
 


Theorem (1009)                               [serial 2925] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and ACTUAL_POSITION < DESIRED_POSITION and 
DESIRED_POSITION < (ACTUAL_POSITION + #PCS::MaxStepsUp) >>
S [390] Delta := (DesiredPosition? - EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 1008:
Theorem (1008) [serial 2935] used for:
  applied wp for assignment [serial 2925]
 


Theorem (1010)                               [serial 2917] 
P [15] << (((ACTUAL_POSITION + #PCS::MaxStepsUp) > DESIRED_POSITION) and (ACTUAL_POSITION < DESIRED_POSITION) and 
E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
S [390] Delta := (DesiredPosition? - EstimatedActualPosition)
Q [15] << (E_MS() and (DESIRED_POSITION = (ACTUAL_POSITION + Delta)) and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and 
(ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(
z:ACTUAL_POSITION,k:Delta) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1009:
Theorem (1009) [serial 2925] used for:
    normalization of [serial 2917]
 


Theorem (1011)                               [serial 2972] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1012)                               [serial 3050] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
0 < Delta and 0 < Delta and 0 < #PCS::MaxPosition and ACTUAL_POSITION < (
ACTUAL_POSITION + Delta) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [397] ->
Q [1] << 0 < Delta >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1013)                               [serial 3048] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
0 < Delta and 0 < (ACTUAL_POSITION + Delta) and 0 < #PCS::MaxPosition and 
ACTUAL_POSITION < (ACTUAL_POSITION + Delta) and ACTUAL_POSITION < #PCS::MaxPosition >>
S [397] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Partial Order Law 3:  a <= (b-1)  is  a<b
and theorem 1012:
Theorem (1012) [serial 3050] used for:
  0<(ACTUAL_POSITION + Delta)  ->  0<=(ACTUAL_POSITION + Delta)
0<=(-ACTUAL_POSITION+Delta)  is  0<Delta
  0<=(-ACTUAL_POSITION+Delta)  is  0<Delta

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 3048]
 


Theorem (1014)                               [serial 3046] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
0 < Delta and ACTUAL_POSITION < (ACTUAL_POSITION + Delta) and 0 < (ACTUAL_POSITION + 
Delta) and ACTUAL_POSITION < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [397] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1013:
Theorem (1013) [serial 3048] used for:
    normalization of [serial 3046]
 


Theorem (1015)                               [serial 3044] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
0 < Delta and ACTUAL_POSITION < (ACTUAL_POSITION + Delta) >>
S [397] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Transitivity: x<y and y<z -> x<z
and theorem 1014:
Theorem (1014) [serial 3046] used for:
  Transitivity: x<y and y<z -> x<z [serial 3044]
 


Theorem (1016)                               [serial 3042] 
P [15] << 0 < Delta and ACTUAL_POSITION < (ACTUAL_POSITION + Delta) and 0 <= ACTUAL_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = (ACTUAL_POSITION + 
Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) >>
S [397] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1015:
Theorem (1015) [serial 3044] used for:
    normalization of [serial 3042]
 


Theorem (1017)                               [serial 3040] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(0 < Delta and ACTUAL_POSITION < (ACTUAL_POSITION + Delta)) >>
S [397] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Associativity: (b.c).a = a.b.c
and theorem 1016:
Theorem (1016) [serial 3042] used for:
  Associativity: (b.c).a = a.b.c [serial 3040]
 


Theorem (1018)                               [serial 3038] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and ((ACTUAL_POSITION < (ACTUAL_POSITION + 
Delta)) and (Delta > 0)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [397] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1017:
Theorem (1017) [serial 3040] used for:
    normalization of [serial 3038]
 


Theorem (1019)                               [serial 2973] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Substitution of Assertion Labels
and theorem 1018:
Theorem (1018) [serial 3038] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2973]
 


Theorem (1020)                               [serial 2974] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397] ->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1021)                               [serial 2975] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397] ->
Q [399] << Delta = (DESIRED_POSITION - ACTUAL_POSITION) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1022)                               [serial 2976] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397] ->
Q [398] << E_MS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1023)                               [serial 2961] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397] ->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
E_MS() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1011 1019 1020 1021 1022:
Theorem (1011) [serial 2972] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2961]
 
Theorem (1019) [serial 2973] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2961]
 
Theorem (1020) [serial 2974] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2961]
 
Theorem (1021) [serial 2975] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2961]
 
Theorem (1022) [serial 2976] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2961]
 


Theorem (1024)                               [serial 2957] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397] ->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + 
Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
E_MS() >>
by Law of And-Simplification:  P and P is P
and theorem 1023:
Theorem (1023) [serial 2961] used for:
  Law of And-Simplification:  P and P is P [serial 2957]
 


Theorem (1025)                               [serial 2950] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397] ->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
E_MS() >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1024:
Theorem (1024) [serial 2957] used for:
    normalization of [serial 2950]
 


Theorem (1026)                               [serial 2943] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397] ->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
E_MS() and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) >>
by Associativity: (b.c).a = a.b.c
and theorem 1025:
Theorem (1025) [serial 2950] used for:
  Associativity: (b.c).a = a.b.c [serial 2943]
 


Theorem (1027)                               [serial 2936] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397] ->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and 
E_MS() >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1026:
Theorem (1026) [serial 2943] used for:
    normalization of [serial 2936]
 


Theorem (1028)                               [serial 2927] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k:Delta) and E_MS() >>
S [397] ActuatorCommand(pc:Delta)
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
by Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
and theorem 1027:
Theorem (1027) [serial 2936] used for:
  applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 2927]
 


Theorem (1029)                               [serial 2918] 
P [15] << (E_MS() and (DESIRED_POSITION = (ACTUAL_POSITION + Delta)) and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and 
(ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(
z:ACTUAL_POSITION,k:Delta) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
S [397] ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and 
(ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1028:
Theorem (1028) [serial 2927] used for:
    normalization of [serial 2918]
 


Theorem (1030)                               [serial 3005] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1031)                               [serial 3003] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402] ->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1030:
Theorem (1030) [serial 3005] used for:
    normalization of [serial 3003]
 


Theorem (1032)                               [serial 2963] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402] ->
Q [1] << 0 <= ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 1031:
Theorem (1031) [serial 3003] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2963]
 


Theorem (1033)                               [serial 3009] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402] ->
Q [405] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1034)                               [serial 3007] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402] ->
Q [405] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1033:
Theorem (1033) [serial 3009] used for:
    normalization of [serial 3007]
 


Theorem (1035)                               [serial 2964] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402] ->
Q [405] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
by Guided Substitution of Equals
and theorem 1034:
Theorem (1034) [serial 3007] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2964]
 


Theorem (1036)                               [serial 3015] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402] ->
Q [404] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1037)                               [serial 3013] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402] ->
Q [404] << Delta = Delta >>
by Equality Law (idistr):  a=a <-> true
and theorem 1036:
Theorem (1036) [serial 3015] used for:
  Equality Law (idistr):  a=a <-> true [serial 3013]
 


Theorem (1038)                               [serial 3011] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402] ->
Q [404] << Delta = (((ACTUAL_POSITION + Delta)) - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Subtaction of Added Value:  (a+b)-a is b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1037:
Theorem (1037) [serial 3013] used for:
    normalization of [serial 3011]
 


Theorem (1039)                               [serial 2965] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402] ->
Q [404] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Guided Substitution of Equals
and theorem 1038:
Theorem (1038) [serial 3011] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 2965]
 


Theorem (1040)                               [serial 3022] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [402] ->
Q [403] << (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1041)                               [serial 3020] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [402] ->
Q [403] << (Delta + ACTUAL_POSITION) = ACTUAL_POSITION' >>
by Normalization
  Normalization Axiom:
    Reflexivity of Addition: a+b=b+a
and theorem 1040:
Theorem (1040) [serial 3022] used for:
    normalization of [serial 3020]
 


Theorem (1042)                               [serial 3018] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [402] ->
Q [403] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 1041:
Theorem (1041) [serial 3020] used for:
  Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3018]
 


Theorem (1043)                               [serial 3016] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [402] ->
Q [403] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1042:
Theorem (1042) [serial 3018] used for:
    normalization of [serial 3016]
 


Theorem (1044)                               [serial 2966] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402] ->
Q [403] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Substitution of Assertion Labels
and theorem 1043:
Theorem (1043) [serial 3016] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 2966]
 


Theorem (1045)                               [serial 2945] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1032 1035 1039 1044:
Theorem (1032) [serial 2963] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2945]
 
Theorem (1035) [serial 2964] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2945]
 
Theorem (1039) [serial 2965] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2945]
 
Theorem (1044) [serial 2966] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 2945]
 


Theorem (1046)                               [serial 2937] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1045:
Theorem (1045) [serial 2945] used for:
    normalization of [serial 2937]
 


Theorem (1047)                               [serial 2929] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [402] EstimatedActualPosition' := (Delta + EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 1046:
Theorem (1046) [serial 2937] used for:
  applied wp for assignment [serial 2929]
 


Theorem (1048)                               [serial 2919] 
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and 
(ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
S [402] EstimatedActualPosition' := (EstimatedActualPosition + Delta)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1047:
Theorem (1047) [serial 2929] used for:
    normalization of [serial 2919]
 


Theorem (1049)                               [serial 1036] 
P [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition < (DESIRED_POSITION)^0)) and 
(((EstimatedActualPosition + #PCS::MaxStepsUp) > (DESIRED_POSITION)^0)))) >>
S [387] << (((ACTUAL_POSITION + #PCS::MaxStepsUp) > DESIRED_POSITION) and (ACTUAL_POSITION < DESIRED_POSITION) and E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Delta := (DesiredPosition? - EstimatedActualPosition)
<< (E_MS() and (DESIRED_POSITION = (ACTUAL_POSITION + Delta)) and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and (ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(z:ACTUAL_POSITION,k:Delta) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and (ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition + Delta)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 920 932 1010 1029 1048:
Theorem (920) [serial 2915] used for:
  P -> P1 in sequential composition for [serial 1036]
 
Theorem (932) [serial 2916] used for:
  Q2 -> Q in sequential composition for [serial 1036]
 
Theorem (1010) [serial 2917] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1036]
 
Theorem (1029) [serial 2918] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1036]
 
Theorem (1048) [serial 2919] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1036]
 


Theorem (1050)                               [serial 3160] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298] ->
Q [412] << ACTUAL_IN_RANGE() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1051)                               [serial 3161] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298] ->
Q [412] << DESIRED_IN_RANGE() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1052)                               [serial 3162] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298] ->
Q [412] << E_MS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1053)                               [serial 3272] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298] ->
Q [1] << DESIRED_POSITION < EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1054)                               [serial 3270] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298] ->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
by Guided Substitution of Equals
and theorem 1053:
Theorem (1053) [serial 3272] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 3270]
 


Theorem (1055)                               [serial 3268] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298] ->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1054:
Theorem (1054) [serial 3270] used for:
    normalization of [serial 3268]
 


Theorem (1056)                               [serial 3266] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298] ->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
by Associativity: (b.c).a = a.b.c
and theorem 1055:
Theorem (1055) [serial 3268] used for:
  Associativity: (b.c).a = a.b.c [serial 3266]
 


Theorem (1057)                               [serial 3264] 
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298] ->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1056:
Theorem (1056) [serial 3266] used for:
    normalization of [serial 3264]
 


Theorem (1058)                               [serial 3263] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298] ->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
by Substitution of Assertion Labels
and theorem 1057:
Theorem (1057) [serial 3264] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 3263]
 


Theorem (1059)                               [serial 3163] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298] ->
Q [1] << DESIRED_POSITION < ACTUAL_POSITION >>
by Assume Present:  P = P@now = P^0 
and theorem 1058:
Theorem (1058) [serial 3263] used for:
  Assume Present:  P = P@now = P^0  [serial 3163]
 


Theorem (1060)                               [serial 3282] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298] ->
Q [410] << (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1061)                               [serial 3280] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298] ->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
by Guided Substitution of Equals
and theorem 1060:
Theorem (1060) [serial 3282] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 3280]
 


Theorem (1062)                               [serial 3278] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298] ->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1061:
Theorem (1061) [serial 3280] used for:
    normalization of [serial 3278]
 


Theorem (1063)                               [serial 3276] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298] ->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
by Associativity: (b.c).a = a.b.c
and theorem 1062:
Theorem (1062) [serial 3278] used for:
  Associativity: (b.c).a = a.b.c [serial 3276]
 


Theorem (1064)                               [serial 3274] 
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298] ->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1063:
Theorem (1063) [serial 3276] used for:
    normalization of [serial 3274]
 


Theorem (1065)                               [serial 3273] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [298] ->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
by Substitution of Assertion Labels
and theorem 1064:
Theorem (1064) [serial 3274] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 3273]
 


Theorem (1066)                               [serial 3164] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298] ->
Q [410] << (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
by Assume Present:  P = P@now = P^0 
and theorem 1065:
Theorem (1065) [serial 3273] used for:
  Assume Present:  P = P@now = P^0  [serial 3164]
 


Theorem (1067)                               [serial 3142] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 >>
S [298] ->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1050 1051 1052 1059 1066:
Theorem (1050) [serial 3160] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3142]
 
Theorem (1051) [serial 3161] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3142]
 
Theorem (1052) [serial 3162] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3142]
 
Theorem (1059) [serial 3163] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3142]
 
Theorem (1066) [serial 3164] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3142]
 


Theorem (1068)                               [serial 3136] 
P [15] << DESIRED_POSITION^0 < EstimatedActualPosition and (EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0 and 
ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() >>
S [298] ->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1067:
Theorem (1067) [serial 3142] used for:
    normalization of [serial 3136]
 


Theorem (1069)                               [serial 3108] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and (DESIRED_POSITION^0 < EstimatedActualPosition and 
(EstimatedActualPosition - #PCS::MaxStepsUp) < DESIRED_POSITION^0) >>
S [298] ->
Q [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
by Associativity: (b.c).a = a.b.c
and theorem 1068:
Theorem (1068) [serial 3136] used for:
  Associativity: (b.c).a = a.b.c [serial 3108]
 


Theorem (1070)                               [serial 3102] 
P [15] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition > (DESIRED_POSITION)^0)) and 
(((EstimatedActualPosition - #PCS::MaxStepsUp) < (DESIRED_POSITION)^0)))) >>
S [298] ->
Q [15] << (((ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION) and (ACTUAL_POSITION > DESIRED_POSITION) and 
E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1069:
Theorem (1069) [serial 3108] used for:
    normalization of [serial 3102]
 


Theorem (1071)                               [serial 3190] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by Identity (id):  P->P is tautology


Theorem (1072)                               [serial 3187] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
by Associativity: (b.c).a = a.b.c
and theorem 1071:
Theorem (1071) [serial 3190] used for:
  Associativity: (b.c).a = a.b.c [serial 3187]
 


Theorem (1073)                               [serial 3185] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) and 
(0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1072:
Theorem (1072) [serial 3187] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3185]
 


Theorem (1074)                               [serial 3183] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) and 
(((0)^1 <= (ACTUAL_POSITION)^1) and ((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
and theorem 1073:
Theorem (1073) [serial 3185] used for:
    normalization of [serial 3183]
 


Theorem (1075)                               [serial 3181] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^0 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1074:
Theorem (1074) [serial 3183] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3181]
 


Theorem (1076)                               [serial 3179] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << (Delta^(-1+1) = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) and ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and 
((0 <= ACTUAL_POSITION)^1 and (ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1075:
Theorem (1075) [serial 3181] used for:
    normalization of [serial 3179]
 


Theorem (1077)                               [serial 3177] 
P [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [294] ->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1076:
Theorem (1076) [serial 3179] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3177]
 


Theorem (1078)                               [serial 3175] 
P [15] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
Delta = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [294] ->
Q [15] << ((Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 and (ACTUAL_POSITION = EstimatedActualPosition)^1 and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1077:
Theorem (1077) [serial 3177] used for:
    normalization of [serial 3175]
 


Theorem (1079)                               [serial 3173] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294] ->
Q [15] << (Delta^-1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1078:
Theorem (1078) [serial 3175] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3173]
 


Theorem (1080)                               [serial 3171] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294] ->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((Delta^(-1) = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1079:
Theorem (1079) [serial 3173] used for:
    normalization of [serial 3171]
 


Theorem (1081)                               [serial 3110] 
P [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
S [294] ->
Q [15] << (ACTUAL_IN_RANGE() and D_MS() and E_MS())^1 >>
by Substitution of Assertion Labels
and theorem 1080:
Theorem (1080) [serial 3171] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 3110]
 


Theorem (1082)                               [serial 3103] 
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
S [294] ->
Q [15] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1081:
Theorem (1081) [serial 3110] used for:
    normalization of [serial 3103]
 


Theorem (1083)                               [serial 3195] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1084)                               [serial 3193] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by Associativity: (b.c).a = a.b.c
and theorem 1083:
Theorem (1083) [serial 3195] used for:
  Associativity: (b.c).a = a.b.c [serial 3193]
 


Theorem (1085)                               [serial 3191] 
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1084:
Theorem (1084) [serial 3193] used for:
    normalization of [serial 3191]
 


Theorem (1086)                               [serial 3148] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by Substitution of Assertion Labels
and theorem 1085:
Theorem (1085) [serial 3191] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 3148]
 


Theorem (1087)                               [serial 3200] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [416] << DESIRED_POSITION <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1088)                               [serial 3198] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [416] << DESIRED_POSITION <= #PCS::MaxPosition >>
by Associativity: (b.c).a = a.b.c
and theorem 1087:
Theorem (1087) [serial 3200] used for:
  Associativity: (b.c).a = a.b.c [serial 3198]
 


Theorem (1089)                               [serial 3196] 
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [416] << DESIRED_POSITION <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1088:
Theorem (1088) [serial 3198] used for:
    normalization of [serial 3196]
 


Theorem (1090)                               [serial 3149] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [416] << DESIRED_POSITION <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 1089:
Theorem (1089) [serial 3196] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 3149]
 


Theorem (1091)                               [serial 3212] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [418] << DESIRED_POSITION <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1092)                               [serial 3210] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [418] << ((ACTUAL_POSITION + DESIRED_POSITION) - ACTUAL_POSITION) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Subtaction of Added Value:  (a+b)-a is b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1091:
Theorem (1091) [serial 3212] used for:
    normalization of [serial 3210]
 


Theorem (1093)                               [serial 3208] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [418] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
by Guided Substitution of Equals
and theorem 1092:
Theorem (1092) [serial 3210] used for:
  Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3208]
 


Theorem (1094)                               [serial 3206] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [418] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1093:
Theorem (1093) [serial 3208] used for:
    normalization of [serial 3206]
 


Theorem (1095)                               [serial 3204] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [418] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
by Associativity: (b.c).a = a.b.c
and theorem 1094:
Theorem (1094) [serial 3206] used for:
  Associativity: (b.c).a = a.b.c [serial 3204]
 


Theorem (1096)                               [serial 3202] 
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [418] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1095:
Theorem (1095) [serial 3204] used for:
    normalization of [serial 3202]
 


Theorem (1097)                               [serial 3201] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [418] << ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 1096:
Theorem (1096) [serial 3202] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 3201]
 


Theorem (1098)                               [serial 3150] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [418] << ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition >>
by Assume Present:  P = P@now = P^0 
and theorem 1097:
Theorem (1097) [serial 3201] used for:
  Assume Present:  P = P@now = P^0  [serial 3150]
 


Theorem (1099)                               [serial 3227] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [414] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1100)                               [serial 3225] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [414] << DESIRED_POSITION = DESIRED_POSITION >>
by Equality Law (idistr):  a=a <-> true
and theorem 1099:
Theorem (1099) [serial 3227] used for:
  Equality Law (idistr):  a=a <-> true [serial 3225]
 


Theorem (1101)                               [serial 3223] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [414] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Subtaction of Added Value:  (a+b)-a is b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1100:
Theorem (1100) [serial 3225] used for:
    normalization of [serial 3223]
 


Theorem (1102)                               [serial 3221] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [414] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
by Guided Substitution of Equals
and theorem 1101:
Theorem (1101) [serial 3223] used for:
  Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3221]
 


Theorem (1103)                               [serial 3219] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [414] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1102:
Theorem (1102) [serial 3221] used for:
    normalization of [serial 3219]
 


Theorem (1104)                               [serial 3217] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [414] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
by Associativity: (b.c).a = a.b.c
and theorem 1103:
Theorem (1103) [serial 3219] used for:
  Associativity: (b.c).a = a.b.c [serial 3217]
 


Theorem (1105)                               [serial 3215] 
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [414] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1104:
Theorem (1104) [serial 3217] used for:
    normalization of [serial 3215]
 


Theorem (1106)                               [serial 3214] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [414] << DESIRED_POSITION = ((ACTUAL_POSITION + DESIRED_POSITION) - EstimatedActualPosition) >>
by Substitution of Assertion Labels
and theorem 1105:
Theorem (1105) [serial 3215] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 3214]
 


Theorem (1107)                               [serial 3151] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [414] << DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) >>
by Assume Present:  P = P@now = P^0 
and theorem 1106:
Theorem (1106) [serial 3214] used for:
  Assume Present:  P = P@now = P^0  [serial 3151]
 


Theorem (1108)                               [serial 3238] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [415] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1109)                               [serial 3237] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [415] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - ACTUAL_POSITION) >>
by Equality Law (idistr):  a=a <-> true
and theorem 1108:
Theorem (1108) [serial 3238] used for:
  Equality Law (idistr):  a=a <-> true [serial 3237]
 


Theorem (1110)                               [serial 3235] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [415] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
by Guided Substitution of Equals
and theorem 1109:
Theorem (1109) [serial 3237] used for:
  Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3235]
 


Theorem (1111)                               [serial 3233] 
P [15] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 <= DESIRED_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [415] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1110:
Theorem (1110) [serial 3235] used for:
    normalization of [serial 3233]
 


Theorem (1112)                               [serial 3231] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and (0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and 
DESIRED_POSITION < ACTUAL_POSITION and (ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [415] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
by Associativity: (b.c).a = a.b.c
and theorem 1111:
Theorem (1111) [serial 3233] used for:
  Associativity: (b.c).a = a.b.c [serial 3231]
 


Theorem (1113)                               [serial 3229] 
P [15] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [415] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1112:
Theorem (1112) [serial 3231] used for:
    normalization of [serial 3229]
 


Theorem (1114)                               [serial 3228] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [415] << (DESIRED_POSITION - ACTUAL_POSITION) = (DESIRED_POSITION - EstimatedActualPosition) >>
by Substitution of Assertion Labels
and theorem 1113:
Theorem (1113) [serial 3229] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 3228]
 


Theorem (1115)                               [serial 3152] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [415] << (DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) >>
by Assume Present:  P = P@now = P^0 
and theorem 1114:
Theorem (1114) [serial 3228] used for:
  Assume Present:  P = P@now = P^0  [serial 3152]
 


Theorem (1116)                               [serial 3239] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [417] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1117)                               [serial 3239] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [417] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1118)                               [serial 3153] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [417] << AXIOM_LTK(z:ACTUAL_POSITION,k:(EstimatedActualPosition - DESIRED_POSITION^0)) >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 1117 1117:
Theorem (1117) [serial 3239] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (1117) [serial 3239] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (1119)                               [serial 3154] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [417] << DESIRED_IN_RANGE() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1120)                               [serial 3155] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [414] << E_MS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1121)                               [serial 3128] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and ((
DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) <= #PCS::MaxPosition and 
DESIRED_POSITION = ((DESIRED_POSITION^0 + ACTUAL_POSITION) - EstimatedActualPosition) and 
(DESIRED_POSITION^0 - EstimatedActualPosition) = (DESIRED_POSITION - ACTUAL_POSITION) and 
AXIOM_LTK(z:ACTUAL_POSITION,k:(EstimatedActualPosition - DESIRED_POSITION^0)) and 
DESIRED_IN_RANGE() and E_MS() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1086 1090 1098 1107 1115 1118 1119 1120:
Theorem (1086) [serial 3148] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]
 
Theorem (1090) [serial 3149] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]
 
Theorem (1098) [serial 3150] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]
 
Theorem (1107) [serial 3151] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]
 
Theorem (1115) [serial 3152] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]
 
Theorem (1118) [serial 3153] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]
 
Theorem (1119) [serial 3154] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]
 
Theorem (1120) [serial 3155] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3128]
 


Theorem (1122)                               [serial 3122] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] ->
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
(((DESIRED_POSITION)^0 - EstimatedActualPosition))) <= #PCS::MaxPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + (((DESIRED_POSITION)^0 - EstimatedActualPosition))) and 
(((DESIRED_POSITION)^0 - EstimatedActualPosition)) = (DESIRED_POSITION - ACTUAL_POSITION) and 
AXIOM_LTK(z:ACTUAL_POSITION,k: -(((DESIRED_POSITION)^0 - EstimatedActualPosition))) and 
DESIRED_IN_RANGE() and E_MS() >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Unary Minus:  -(x-y) is (y-x)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Associativity: (b.c).a = a.b.c
and theorem 1121:
Theorem (1121) [serial 3128] used for:
    normalization of [serial 3122]
 


Theorem (1123)                               [serial 3112] 
P [15] << ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and E_MS() and DESIRED_POSITION < ACTUAL_POSITION and 
(ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION >>
S [413] Delta := (DesiredPosition? - EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 1122:
Theorem (1122) [serial 3122] used for:
  applied wp for assignment [serial 3112]
 


Theorem (1124)                               [serial 3104] 
P [15] << (((ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION) and (ACTUAL_POSITION > DESIRED_POSITION) and 
E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
S [413] Delta := (DesiredPosition? - EstimatedActualPosition)
Q [15] << (E_MS() and (DESIRED_POSITION = (ACTUAL_POSITION + Delta)) and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and 
(ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(
z:ACTUAL_POSITION,k: -Delta) and DESIRED_IN_RANGE() and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1123:
Theorem (1123) [serial 3112] used for:
    normalization of [serial 3104]
 


Theorem (1125)                               [serial 3165] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420] ->
Q [1] << 0 <= ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1126)                               [serial 3291] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = (ACTUAL_POSITION + 
Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 0 < ( -Delta) and 
ACTUAL_POSITION < (ACTUAL_POSITION - Delta) >>
S [420] ->
Q [1] << 0 <= DESIRED_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1127)                               [serial 3289] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = (ACTUAL_POSITION + 
Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 0 < ( -Delta) and 
ACTUAL_POSITION < (ACTUAL_POSITION - Delta) >>
S [420] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Guided Substitution of Equals
and theorem 1126:
Theorem (1126) [serial 3291] used for:
  Guided Substitution of Equals
 replacing "(ACTUAL_POSITION + Delta)" with its = "DESIRED_POSITION" in its postcondition [serial 3289]
 


Theorem (1128)                               [serial 3287] 
P [15] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 0 < ( -Delta) and 
ACTUAL_POSITION < (ACTUAL_POSITION - Delta) and 0 <= ACTUAL_POSITION and 
DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = (ACTUAL_POSITION + 
Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) >>
S [420] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1127:
Theorem (1127) [serial 3289] used for:
    normalization of [serial 3287]
 


Theorem (1129)                               [serial 3285] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
DESIRED_POSITION = (ACTUAL_POSITION + Delta) and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) and (0 < ( -Delta) and 
ACTUAL_POSITION < (ACTUAL_POSITION - Delta)) >>
S [420] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Associativity: (b.c).a = a.b.c
and theorem 1128:
Theorem (1128) [serial 3287] used for:
  Associativity: (b.c).a = a.b.c [serial 3285]
 


Theorem (1130)                               [serial 3283] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and ((ACTUAL_POSITION < (ACTUAL_POSITION + 
( -Delta))) and (( -Delta) > 0)) and ((DESIRED_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [420] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Associativity: (b.c).a = a.b.c
and theorem 1129:
Theorem (1129) [serial 3285] used for:
    normalization of [serial 3283]
 


Theorem (1131)                               [serial 3166] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Substitution of Assertion Labels
and theorem 1130:
Theorem (1130) [serial 3283] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 3166]
 


Theorem (1132)                               [serial 3167] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420] ->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1133)                               [serial 3168] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420] ->
Q [422] << Delta = (DESIRED_POSITION - ACTUAL_POSITION) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1134)                               [serial 3169] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420] ->
Q [421] << DESIRED_IN_RANGE() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1135)                               [serial 3170] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420] ->
Q [421] << E_MS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1136)                               [serial 3147] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420] ->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
DESIRED_IN_RANGE() and E_MS() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1125 1131 1132 1133 1134 1135:
Theorem (1125) [serial 3165] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]
 
Theorem (1131) [serial 3166] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]
 
Theorem (1132) [serial 3167] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]
 
Theorem (1133) [serial 3168] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]
 
Theorem (1134) [serial 3169] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]
 
Theorem (1135) [serial 3170] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3147]
 


Theorem (1137)                               [serial 3144] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420] ->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and 0 <= (ACTUAL_POSITION + 
Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
DESIRED_IN_RANGE() and E_MS() >>
by Law of And-Simplification:  P and P is P
and theorem 1136:
Theorem (1136) [serial 3147] used for:
  Law of And-Simplification:  P and P is P [serial 3144]
 


Theorem (1138)                               [serial 3137] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420] ->
Q [15] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
DESIRED_IN_RANGE() and E_MS() >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1137:
Theorem (1137) [serial 3144] used for:
    normalization of [serial 3137]
 


Theorem (1139)                               [serial 3130] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420] ->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
DESIRED_IN_RANGE() and E_MS() and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition) >>
by Associativity: (b.c).a = a.b.c
and theorem 1138:
Theorem (1138) [serial 3137] used for:
  Associativity: (b.c).a = a.b.c [serial 3130]
 


Theorem (1140)                               [serial 3123] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420] ->
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and 
DESIRED_IN_RANGE() and E_MS() >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1139:
Theorem (1139) [serial 3130] used for:
    normalization of [serial 3123]
 


Theorem (1141)                               [serial 3114] 
P [15] << 0 <= ACTUAL_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and DESIRED_POSITION = (ACTUAL_POSITION + Delta) and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and AXIOM_LTK(z:ACTUAL_POSITION,
k: -Delta) and DESIRED_IN_RANGE() and E_MS() >>
S [420] ActuatorCommand(pc:Delta)
Q [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
by Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
and theorem 1140:
Theorem (1140) [serial 3123] used for:
  applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 3114]
 


Theorem (1142)                               [serial 3105] 
P [15] << (E_MS() and (DESIRED_POSITION = (ACTUAL_POSITION + Delta)) and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and 
(ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(
z:ACTUAL_POSITION,k: -Delta) and DESIRED_IN_RANGE() and ((ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition)) >>
S [420] ActuatorCommand(pc:Delta)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and DESIRED_IN_RANGE() and 
(Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and (ACTUAL_POSITION >= 0) and 
((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1141:
Theorem (1141) [serial 3114] used for:
    normalization of [serial 3105]
 


Theorem (1143)                               [serial 3242] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1144)                               [serial 3240] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425] ->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1143:
Theorem (1143) [serial 3242] used for:
    normalization of [serial 3240]
 


Theorem (1145)                               [serial 3156] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425] ->
Q [1] << 0 <= ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 1144:
Theorem (1144) [serial 3240] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3156]
 


Theorem (1146)                               [serial 3246] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425] ->
Q [428] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1147)                               [serial 3244] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425] ->
Q [428] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1146:
Theorem (1146) [serial 3246] used for:
    normalization of [serial 3244]
 


Theorem (1148)                               [serial 3157] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425] ->
Q [428] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
by Guided Substitution of Equals
and theorem 1147:
Theorem (1147) [serial 3244] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3157]
 


Theorem (1149)                               [serial 3252] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425] ->
Q [427] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1150)                               [serial 3250] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425] ->
Q [427] << Delta = Delta >>
by Equality Law (idistr):  a=a <-> true
and theorem 1149:
Theorem (1149) [serial 3252] used for:
  Equality Law (idistr):  a=a <-> true [serial 3250]
 


Theorem (1151)                               [serial 3248] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425] ->
Q [427] << Delta = (((ACTUAL_POSITION + Delta)) - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Subtaction of Added Value:  (a+b)-a is b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1150:
Theorem (1150) [serial 3250] used for:
    normalization of [serial 3248]
 


Theorem (1152)                               [serial 3158] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425] ->
Q [427] << Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Guided Substitution of Equals
and theorem 1151:
Theorem (1151) [serial 3248] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3158]
 


Theorem (1153)                               [serial 3261] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= DESIRED_POSITION and 0 <= (ACTUAL_POSITION + 
Delta) and DESIRED_POSITION <= #PCS::MaxPosition and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [425] ->
Q [426] << ACTUAL_POSITION = EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1154)                               [serial 3259] 
P [15] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 0 <= ACTUAL_POSITION and 
0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [425] ->
Q [426] << (ACTUAL_POSITION) = (EstimatedActualPosition) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1153:
Theorem (1153) [serial 3261] used for:
    normalization of [serial 3259]
 


Theorem (1155)                               [serial 3258] 
P [15] << 0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition and 0 <= ACTUAL_POSITION and 
0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
ACTUAL_POSITION = EstimatedActualPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' >>
S [425] ->
Q [426] << (ACTUAL_POSITION + Delta) = (Delta + EstimatedActualPosition) >>
by Add both sides of equality:  a=b -> x+a=x+b
and theorem 1154:
Theorem (1154) [serial 3259] used for:
  Add both sides of equality:  a=b -> x+a=x+b [serial 3258]
 


Theorem (1156)                               [serial 3256] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (DESIRED_POSITION - ACTUAL_POSITION) and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and 
(0 <= DESIRED_POSITION and DESIRED_POSITION <= #PCS::MaxPosition) >>
S [425] ->
Q [426] << (ACTUAL_POSITION + Delta) = (Delta + EstimatedActualPosition) >>
by Associativity: (b.c).a = a.b.c
and theorem 1155:
Theorem (1155) [serial 3258] used for:
  Associativity: (b.c).a = a.b.c [serial 3256]
 


Theorem (1157)                               [serial 3254] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((DESIRED_POSITION >= 0) and 
(DESIRED_POSITION <= #PCS::MaxPosition)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [425] ->
Q [426] << (Delta + EstimatedActualPosition) = ((ACTUAL_POSITION + Delta)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1156:
Theorem (1156) [serial 3256] used for:
    normalization of [serial 3254]
 


Theorem (1158)                               [serial 3253] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425] ->
Q [426] << (Delta + EstimatedActualPosition) = ((ACTUAL_POSITION + Delta)) >>
by Substitution of Assertion Labels
and theorem 1157:
Theorem (1157) [serial 3254] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 3253]
 


Theorem (1159)                               [serial 3159] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425] ->
Q [426] << (Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 1158:
Theorem (1158) [serial 3253] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3159]
 


Theorem (1160)                               [serial 3132] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
(Delta + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1145 1148 1152 1159:
Theorem (1145) [serial 3156] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3132]
 
Theorem (1148) [serial 3157] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3132]
 
Theorem (1152) [serial 3158] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3132]
 
Theorem (1159) [serial 3159] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3132]
 


Theorem (1161)                               [serial 3124] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425] ->
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = ((Delta + EstimatedActualPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1160:
Theorem (1160) [serial 3132] used for:
    normalization of [serial 3124]
 


Theorem (1162)                               [serial 3116] 
P [15] << 0 <= ACTUAL_POSITION and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition and Delta = (DESIRED_POSITION - ACTUAL_POSITION) and 
(ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and DESIRED_IN_RANGE() and 
E_MS() >>
S [425] EstimatedActualPosition' := (Delta + EstimatedActualPosition)
Q [15] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and Delta = (ACTUAL_POSITION' - ACTUAL_POSITION) and 
ACTUAL_POSITION' = EstimatedActualPosition' >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 1161:
Theorem (1161) [serial 3124] used for:
  applied wp for assignment [serial 3116]
 


Theorem (1163)                               [serial 3106] 
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and DESIRED_IN_RANGE() and 
(Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and (ACTUAL_POSITION >= 0) and 
((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
S [425] EstimatedActualPosition' := (EstimatedActualPosition + Delta)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and 
(ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1162:
Theorem (1162) [serial 3116] used for:
    normalization of [serial 3106]
 


Theorem (1164)                               [serial 1037] 
P [298] << (E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE() and (((EstimatedActualPosition > (DESIRED_POSITION)^0)) and 
(((EstimatedActualPosition - #PCS::MaxStepsUp) < (DESIRED_POSITION)^0)))) >>
S [410] << (((ACTUAL_POSITION - #PCS::MaxStepsUp) < DESIRED_POSITION) and (ACTUAL_POSITION > DESIRED_POSITION) and E_MS() and ACTUAL_IN_RANGE() and DESIRED_IN_RANGE()) >>
Delta := (DesiredPosition? - EstimatedActualPosition)
<< (E_MS() and (DESIRED_POSITION = (ACTUAL_POSITION + Delta)) and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and (ACTUAL_POSITION >= 0) and (DESIRED_POSITION <= #PCS::MaxPosition) and AXIOM_LTK(z:ACTUAL_POSITION,k: -Delta) and DESIRED_IN_RANGE() and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and E_MS() and DESIRED_IN_RANGE() and (Delta = (DESIRED_POSITION - ACTUAL_POSITION)) and (ACTUAL_POSITION >= 0) and ((ACTUAL_POSITION + Delta) >= 0) and ((ACTUAL_POSITION + Delta) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition + Delta)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (Delta = (ACTUAL_POSITION' - ACTUAL_POSITION)) and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [294] << (E_MS() and D_MS() and ACTUAL_IN_RANGE())^1 >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 1070 1082 1124 1142 1163:
Theorem (1070) [serial 3102] used for:
  P -> P1 in sequential composition for [serial 1037]
 
Theorem (1082) [serial 3103] used for:
  Q2 -> Q in sequential composition for [serial 1037]
 
Theorem (1124) [serial 3104] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1037]
 
Theorem (1142) [serial 3105] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1037]
 
Theorem (1163) [serial 3106] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1037]
 


Theorem (1165)                               [serial 3296] 
P [431] << ACTUAL_IN_RANGE() and D_MS() and E_MS() and stop@now and not (exists u~time
  in tops,,now 
  that stop@u ) and not (true) >>
S [430] ->
Q [300] << ACTUAL_IN_RANGE() and E_MS() >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (1166)                               [serial 3295] 
P [431] << ACTUAL_IN_RANGE() and D_MS() and E_MS() and stop@now and not (exists u~time
  in tops,,now 
  that stop@u ) and not (exists u~time
  in tops,,now 
  that true ) >>
S [430] ->
Q [300] << ACTUAL_IN_RANGE() and E_MS() >>
by Existential Quantification Introduction
and theorem 1165:
Theorem (1165) [serial 3296] used for:
  Existential Quantification Introduction [serial 3295]
 


Theorem (1167)                               [serial 3293] 
P [431] << stop@now and not (exists u~time
  in tops,,now 
  that stop@u ) and not (exists u~time
  in tops,,now 
  that true ) and (ACTUAL_IN_RANGE() and D_MS() and E_MS()) >>
S [430] ->
Q [300] << ACTUAL_IN_RANGE() and E_MS() >>
by Associativity: (b.c).a = a.b.c
and theorem 1166:
Theorem (1166) [serial 3295] used for:
  Associativity: (b.c).a = a.b.c [serial 3293]
 


Theorem (1168)                               [serial 1038] 
P [431] << ((E_MS() and D_MS() and ACTUAL_IN_RANGE()) and stop@now and not (exists u~time
  in tops,,now 
  that true ) and not (exists u~time
  in tops,,now 
  that stop@u )) >>
S [430] ->
Q [300] << (E_MS() and ACTUAL_IN_RANGE()) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1167:
Theorem (1167) [serial 3293] used for:
    normalization of [serial 1038]
 


Theorem (1169)                               [serial 3305] 
P [300] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [432] ->
Q [304] << 0 = EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1170)                               [serial 3304] 
P [300] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and 0 = EstimatedActualPosition and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [432] ->
Q [304] << 0 = ACTUAL_POSITION >>
by Guided Substitution of Equals
and theorem 1169:
Theorem (1169) [serial 3305] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 3304]
 


Theorem (1171)                               [serial 3302] 
P [300] << 0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
(0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition) >>
S [432] ->
Q [304] << 0 = ACTUAL_POSITION >>
by Associativity: (b.c).a = a.b.c
and theorem 1170:
Theorem (1170) [serial 3304] used for:
  Associativity: (b.c).a = a.b.c [serial 3302]
 


Theorem (1172)                               [serial 3300] 
P [300] << 0 = EstimatedActualPosition and ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [432] ->
Q [304] << 0 = ACTUAL_POSITION >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1171:
Theorem (1171) [serial 3302] used for:
    normalization of [serial 3300]
 


Theorem (1173)                               [serial 3298] 
P [300] << 0 = EstimatedActualPosition and ACTUAL_IN_RANGE() and E_MS() >>
S [432] ->
Q [304] << 0 = ACTUAL_POSITION >>
by Substitution of Assertion Labels
and theorem 1172:
Theorem (1172) [serial 3300] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 3298]
 


Theorem (1174)                               [serial 1039] 
P [300] << (E_MS() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition = 0))) >>
S [432] ->
Q [304] << (ACTUAL_POSITION = 0) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1173:
Theorem (1173) [serial 3298] used for:
    normalization of [serial 1039]
 


Theorem (1175)                               [serial 3336] 
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [300] ->
Q [436] << ACTUAL_IN_RANGE() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1176)                               [serial 3337] 
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [300] ->
Q [436] << E_MS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1177)                               [serial 3376] 
P [300] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < EstimatedActualPosition >>
S [300] ->
Q [1] << 0 < EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1178)                               [serial 3375] 
P [300] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < EstimatedActualPosition >>
S [300] ->
Q [1] << 0 < ACTUAL_POSITION >>
by Guided Substitution of Equals
and theorem 1177:
Theorem (1177) [serial 3376] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 3375]
 


Theorem (1179)                               [serial 3373] 
P [300] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and 0 < EstimatedActualPosition >>
S [300] ->
Q [1] << 0 < ACTUAL_POSITION >>
by Associativity: (b.c).a = a.b.c
and theorem 1178:
Theorem (1178) [serial 3375] used for:
  Associativity: (b.c).a = a.b.c [serial 3373]
 


Theorem (1180)                               [serial 3371] 
P [300] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < EstimatedActualPosition >>
S [300] ->
Q [1] << 0 < ACTUAL_POSITION >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1179:
Theorem (1179) [serial 3373] used for:
    normalization of [serial 3371]
 


Theorem (1181)                               [serial 3338] 
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [300] ->
Q [1] << 0 < ACTUAL_POSITION >>
by Substitution of Assertion Labels
and theorem 1180:
Theorem (1180) [serial 3371] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 3338]
 


Theorem (1182)                               [serial 3309] 
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [300] ->
Q [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1175 1176 1181:
Theorem (1175) [serial 3336] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3309]
 
Theorem (1176) [serial 3337] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3309]
 
Theorem (1181) [serial 3338] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3309]
 


Theorem (1183)                               [serial 3370] 
P [446] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [302] ->
Q [15] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
by Identity (id):  P->P is tautology


Theorem (1184)                               [serial 3367] 
P [446] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [302] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and (0 <= ACTUAL_POSITION^1 and 
ACTUAL_POSITION^1 <= #PCS::MaxPosition) >>
by Associativity: (b.c).a = a.b.c
and theorem 1183:
Theorem (1183) [serial 3370] used for:
  Associativity: (b.c).a = a.b.c [serial 3367]
 


Theorem (1185)                               [serial 3365] 
P [446] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [302] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and (((0)^1 <= (ACTUAL_POSITION)^1) and 
((ACTUAL_POSITION)^1 <= (#PCS::MaxPosition)^1)) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
and theorem 1184:
Theorem (1184) [serial 3367] used for:
    normalization of [serial 3365]
 


Theorem (1186)                               [serial 3363] 
P [446] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [302] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and ((0 <= ACTUAL_POSITION)^1 and 
(ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1185:
Theorem (1185) [serial 3365] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3363]
 


Theorem (1187)                               [serial 3361] 
P [446] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [302] ->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((0 <= ACTUAL_POSITION)^1 and 
(ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1186:
Theorem (1186) [serial 3363] used for:
    normalization of [serial 3361]
 


Theorem (1188)                               [serial 3359] 
P [446] << 0 <= ACTUAL_POSITION^1 and ACTUAL_POSITION^1 <= #PCS::MaxPosition and 
ACTUAL_POSITION^1 = EstimatedActualPosition^1 >>
S [302] ->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1187:
Theorem (1187) [serial 3361] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3359]
 


Theorem (1189)                               [serial 3357] 
P [446] << 0 <= (ACTUAL_POSITION)^1 and (ACTUAL_POSITION)^1 <= #PCS::MaxPosition and 
(ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [302] ->
Q [15] << ((ACTUAL_POSITION = EstimatedActualPosition)^1 and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition)^1) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1188:
Theorem (1188) [serial 3359] used for:
    normalization of [serial 3357]
 


Theorem (1190)                               [serial 3355] 
P [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [302] ->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1189:
Theorem (1189) [serial 3357] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 3355]
 


Theorem (1191)                               [serial 3353] 
P [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [302] ->
Q [15] << (((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1190:
Theorem (1190) [serial 3355] used for:
    normalization of [serial 3353]
 


Theorem (1192)                               [serial 3310] 
P [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [302] ->
Q [15] << (ACTUAL_IN_RANGE() and E_MS())^1 >>
by Substitution of Assertion Labels
and theorem 1191:
Theorem (1191) [serial 3353] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 3310]
 


Theorem (1193)                               [serial 3412] 
P [436] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [437] ->
Q [1] << 0 < ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1194)                               [serial 3411] 
P [436] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [437] ->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
by Partial Order Law 3:  a <= (b-1)  is  a<b
and theorem 1193:
Theorem (1193) [serial 3412] used for:
    0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION

Partial Order Law 3:  a <= (b-1)  is  a<b [serial 3411]
 


Theorem (1195)                               [serial 3409] 
P [436] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and 0 < ACTUAL_POSITION >>
S [437] ->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
by Associativity: (b.c).a = a.b.c
and theorem 1194:
Theorem (1194) [serial 3411] used for:
  Associativity: (b.c).a = a.b.c [serial 3409]
 


Theorem (1196)                               [serial 3407] 
P [436] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [437] ->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1195:
Theorem (1195) [serial 3409] used for:
    normalization of [serial 3407]
 


Theorem (1197)                               [serial 3342] 
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437] ->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
by Substitution of Assertion Labels
and theorem 1196:
Theorem (1196) [serial 3407] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 3342]
 


Theorem (1198)                               [serial 3417] 
P [436] << 0 <= ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and ACTUAL_POSITION = EstimatedActualPosition and 
0 < ACTUAL_POSITION >>
S [437] ->
Q [439] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1199)                               [serial 3415] 
P [436] << ACTUAL_POSITION = EstimatedActualPosition and (0 <= ACTUAL_POSITION and 
ACTUAL_POSITION <= #PCS::MaxPosition) and 0 < ACTUAL_POSITION >>
S [437] ->
Q [439] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Associativity: (b.c).a = a.b.c
and theorem 1198:
Theorem (1198) [serial 3417] used for:
  Associativity: (b.c).a = a.b.c [serial 3415]
 


Theorem (1200)                               [serial 3413] 
P [436] << ((ACTUAL_POSITION >= 0) and (ACTUAL_POSITION <= #PCS::MaxPosition)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [437] ->
Q [439] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1199:
Theorem (1199) [serial 3415] used for:
    normalization of [serial 3413]
 


Theorem (1201)                               [serial 3343] 
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437] ->
Q [439] << ACTUAL_POSITION <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 1200:
Theorem (1200) [serial 3413] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 3343]
 


Theorem (1202)                               [serial 3352] 
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437] ->
Q [438] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1203)                               [serial 3352] 
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437] ->
Q [438] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1204)                               [serial 3344] 
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437] ->
Q [438] << AXIOM_GT(ACTUAL_POSITION) >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 1203 1203:
Theorem (1203) [serial 3352] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (1203) [serial 3352] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (1205)                               [serial 3345] 
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437] ->
Q [438] << E_MS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1206)                               [serial 3328] 
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437] ->
Q [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1197 1201 1204 1205:
Theorem (1197) [serial 3342] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]
 
Theorem (1201) [serial 3343] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]
 
Theorem (1204) [serial 3344] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]
 
Theorem (1205) [serial 3345] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3328]
 


Theorem (1207)                               [serial 3326] 
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437] ->
Q [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
true and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
by Law of And-Simplification:  P and true is P
and theorem 1206:
Theorem (1206) [serial 3328] used for:
  Law of And-Simplification:  P and true is P [serial 3326]
 


Theorem (1208)                               [serial 3314] 
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437] ->
Q [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = -1 and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
by Equality Law (idistr):  a=a <-> true
and theorem 1207:
Theorem (1207) [serial 3326] used for:
  Equality Law (idistr):  a=a <-> true [serial 3314]
 


Theorem (1209)                               [serial 3311] 
P [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
S [437] Delta := -1
Q [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 1208:
Theorem (1208) [serial 3314] used for:
  applied wp for assignment [serial 3311]
 


Theorem (1210)                               [serial 3346] 
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441] ->
Q [1] << 0 <= (ACTUAL_POSITION - 1) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1211)                               [serial 3419] 
P [438] << 0 <= (ACTUAL_POSITION +  -1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
 -1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441] ->
Q [1] << 0 <= (ACTUAL_POSITION +  -1) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1212)                               [serial 3418] 
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441] ->
Q [1] << 0 <= (ACTUAL_POSITION + -1) >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 1211:
Theorem (1211) [serial 3419] used for:
   changing adding negation to subtraction  [serial 3418]
 


Theorem (1213)                               [serial 3347] 
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441] ->
Q [1] << 0 <= (ACTUAL_POSITION + Delta) >>
by Guided Substitution of Equals
and theorem 1212:
Theorem (1212) [serial 3418] used for:
  Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 3347]
 


Theorem (1214)                               [serial 3425] 
P [438] << 0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and -1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [441] ->
Q [443] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1215)                               [serial 3424] 
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [441] ->
Q [443] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
by Partial Order Law 3:  a <= (b-1)  is  a<b
and theorem 1214:
Theorem (1214) [serial 3425] used for:
  0<=(ACTUAL_POSITION-1)  is  0<ACTUAL_POSITION
(ACTUAL_POSITION - 1)<#PCS::MaxPosition  ->  (ACTUAL_POSITION - 1)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 3424]
 


Theorem (1216)                               [serial 3422] 
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [441] ->
Q [443] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
by Transitivity: x<y and y<z -> x<z
and theorem 1215:
Theorem (1215) [serial 3424] used for:
  Transitivity: x<y and y<z -> x<z [serial 3422]
 


Theorem (1217)                               [serial 3420] 
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and (((ACTUAL_POSITION - 1) < ACTUAL_POSITION)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [441] ->
Q [443] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1216:
Theorem (1216) [serial 3422] used for:
    normalization of [serial 3420]
 


Theorem (1218)                               [serial 3348] 
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441] ->
Q [443] << (ACTUAL_POSITION - 1) <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 1217:
Theorem (1217) [serial 3420] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 3348]
 


Theorem (1219)                               [serial 3436] 
P [438] << 0 < ACTUAL_POSITION and ACTUAL_POSITION <= #PCS::MaxPosition and -1 = Delta and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION and 0 < #PCS::MaxPosition and 
(-1 + ACTUAL_POSITION) < ACTUAL_POSITION and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
S [441] ->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1220)                               [serial 3434] 
P [438] << 0 <= (-1 + ACTUAL_POSITION) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION and 
0 < #PCS::MaxPosition and (-1 + ACTUAL_POSITION) < ACTUAL_POSITION and (
-1 + ACTUAL_POSITION) < #PCS::MaxPosition >>
S [441] ->
Q [130] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
by Partial Order Law 3:  a <= (b-1)  is  a<b
and theorem 1219:
Theorem (1219) [serial 3436] used for:
  0<=(--1+ACTUAL_POSITION)  is  0<ACTUAL_POSITION
(-1 + ACTUAL_POSITION)<#PCS::MaxPosition  ->  (-1 + ACTUAL_POSITION)<=#PCS::MaxPosition
  
Partial Order Law 3:  a <= (b-1)  is  a<b [serial 3434]
 


Theorem (1221)                               [serial 3432] 
P [438] << 0 <= (ACTUAL_POSITION +  -1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
 -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
 -1) < ACTUAL_POSITION and 0 < ACTUAL_POSITION and (ACTUAL_POSITION +  -1) < #PCS::MaxPosition and 
0 < #PCS::MaxPosition >>
S [441] ->
Q [130] << (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Equality: (a=b) = (b=a)
    Unary Minus:  -(x-y) is (y-x)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1220:
Theorem (1220) [serial 3434] used for:
    normalization of [serial 3432]
 


Theorem (1222)                               [serial 3431] 
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION and 
0 < ACTUAL_POSITION and (ACTUAL_POSITION - 1) < #PCS::MaxPosition and 0 < #PCS::MaxPosition >>
S [441] ->
Q [130] << (ACTUAL_POSITION + -1) <= #PCS::MaxPosition >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 1221:
Theorem (1221) [serial 3432] used for:
   changing adding negation to subtraction  [serial 3431]
 


Theorem (1223)                               [serial 3430] 
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [441] ->
Q [130] << (ACTUAL_POSITION + -1) <= #PCS::MaxPosition >>
by Transitivity: x<y and y<z -> x<z
and theorem 1222:
Theorem (1222) [serial 3431] used for:
  Transitivity: x<y and y<z -> x<z [serial 3430]
 


Theorem (1224)                               [serial 3428] 
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION - 1) < ACTUAL_POSITION >>
S [441] ->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by Guided Substitution of Equals
and theorem 1223:
Theorem (1223) [serial 3430] used for:
  Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 3428]
 


Theorem (1225)                               [serial 3426] 
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and (((ACTUAL_POSITION - 1) < ACTUAL_POSITION)) and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [441] ->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1224:
Theorem (1224) [serial 3428] used for:
    normalization of [serial 3426]
 


Theorem (1226)                               [serial 3349] 
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441] ->
Q [130] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by Substitution of Assertion Labels
and theorem 1225:
Theorem (1225) [serial 3426] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 3349]
 


Theorem (1227)                               [serial 3350] 
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441] ->
Q [442] << -1 = Delta >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1228)                               [serial 3351] 
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441] ->
Q [443] << E_MS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1229)                               [serial 3333] 
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441] ->
Q [442] << 0 <= (ACTUAL_POSITION - 1) and 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
(ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and -1 = Delta and E_MS() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1210 1213 1218 1226 1227 1228:
Theorem (1210) [serial 3346] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]
 
Theorem (1213) [serial 3347] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]
 
Theorem (1218) [serial 3348] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]
 
Theorem (1226) [serial 3349] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]
 
Theorem (1227) [serial 3350] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]
 
Theorem (1228) [serial 3351] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3333]
 


Theorem (1230)                               [serial 3327] 
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441] ->
Q [442] << 0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition and 
0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and E_MS() >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1229:
Theorem (1229) [serial 3333] used for:
    normalization of [serial 3327]
 


Theorem (1231)                               [serial 3321] 
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441] ->
Q [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and E_MS() and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + 
Delta) <= #PCS::MaxPosition) >>
by Associativity: (b.c).a = a.b.c
and theorem 1230:
Theorem (1230) [serial 3327] used for:
  Associativity: (b.c).a = a.b.c [serial 3321]
 


Theorem (1232)                               [serial 3315] 
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441] ->
Q [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (0 <= (ACTUAL_POSITION + Delta) and (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition) and 
E_MS() >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1231:
Theorem (1231) [serial 3321] used for:
    normalization of [serial 3315]
 


Theorem (1233)                               [serial 3312] 
P [438] << 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and 
-1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
S [441] ActuatorCommand(pc:Delta)
Q [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
by Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
and theorem 1232:
Theorem (1232) [serial 3315] used for:
  applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 3312]
 


Theorem (1234)                               [serial 3384] 
P [442] << 0 <= (-1 + ACTUAL_POSITION) and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445] ->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1235)                               [serial 3382] 
P [442] << 0 <= (ACTUAL_POSITION +  -1) and (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition and 
 -1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445] ->
Q [1] << 0 <= ( -1 + ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Unary Minus:  -(x-y) is (y-x)
and theorem 1234:
Theorem (1234) [serial 3384] used for:
    normalization of [serial 3382]
 


Theorem (1236)                               [serial 3380] 
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445] ->
Q [1] << 0 <= (-1 + ACTUAL_POSITION) >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 1235:
Theorem (1235) [serial 3382] used for:
   changing adding negation to subtraction  [serial 3380]
 


Theorem (1237)                               [serial 3378] 
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445] ->
Q [1] << 0 <= ((ACTUAL_POSITION + -1)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1236:
Theorem (1236) [serial 3380] used for:
    normalization of [serial 3378]
 


Theorem (1238)                               [serial 3377] 
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445] ->
Q [1] << 0 <= ((ACTUAL_POSITION + Delta)) >>
by Guided Substitution of Equals
and theorem 1237:
Theorem (1237) [serial 3378] used for:
  Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 3377]
 


Theorem (1239)                               [serial 3339] 
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445] ->
Q [1] << 0 <= ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 1238:
Theorem (1238) [serial 3377] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3339]
 


Theorem (1240)                               [serial 3393] 
P [442] << 0 <= (-1 + ACTUAL_POSITION) and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445] ->
Q [447] << (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1241)                               [serial 3391] 
P [442] << 0 <= (ACTUAL_POSITION +  -1) and (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition and 
 -1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445] ->
Q [447] << (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Equality: (a=b) = (b=a)
    Unary Minus:  -(x-y) is (y-x)
and theorem 1240:
Theorem (1240) [serial 3393] used for:
    normalization of [serial 3391]
 


Theorem (1242)                               [serial 3390] 
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445] ->
Q [447] << (ACTUAL_POSITION + -1) <= #PCS::MaxPosition >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 1241:
Theorem (1241) [serial 3391] used for:
   changing adding negation to subtraction  [serial 3390]
 


Theorem (1243)                               [serial 3388] 
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445] ->
Q [447] << (ACTUAL_POSITION + Delta) <= #PCS::MaxPosition >>
by Guided Substitution of Equals
and theorem 1242:
Theorem (1242) [serial 3390] used for:
  Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 3388]
 


Theorem (1244)                               [serial 3386] 
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445] ->
Q [447] << ((ACTUAL_POSITION + Delta)) <= #PCS::MaxPosition >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1243:
Theorem (1243) [serial 3388] used for:
    normalization of [serial 3386]
 


Theorem (1245)                               [serial 3340] 
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445] ->
Q [447] << ACTUAL_POSITION' <= #PCS::MaxPosition >>
by Guided Substitution of Equals
and theorem 1244:
Theorem (1244) [serial 3386] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3340]
 


Theorem (1246)                               [serial 3406] 
P [442] << 0 <= (-1 + ACTUAL_POSITION) and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445] ->
Q [446] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1247)                               [serial 3404] 
P [442] << 0 <= (-1 + ACTUAL_POSITION) and (-1 + ACTUAL_POSITION) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445] ->
Q [446] << (-1 + ACTUAL_POSITION) = (-1 + ACTUAL_POSITION) >>
by Equality Law (idistr):  a=a <-> true
and theorem 1246:
Theorem (1246) [serial 3406] used for:
  Equality Law (idistr):  a=a <-> true [serial 3404]
 


Theorem (1248)                               [serial 3402] 
P [442] << 0 <= (ACTUAL_POSITION +  -1) and (ACTUAL_POSITION +  -1) <= #PCS::MaxPosition and 
 -1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445] ->
Q [446] << (ACTUAL_POSITION +  -1) = ((ACTUAL_POSITION +  -1)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Equality: (a=b) = (b=a)
    Unary Minus:  -(x-y) is (y-x)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1247:
Theorem (1247) [serial 3404] used for:
    normalization of [serial 3402]
 


Theorem (1249)                               [serial 3401] 
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445] ->
Q [446] << (ACTUAL_POSITION - 1) = ((ACTUAL_POSITION + -1)) >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 1248:
Theorem (1248) [serial 3402] used for:
   changing adding negation to subtraction  [serial 3401]
 


Theorem (1250)                               [serial 3400] 
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445] ->
Q [446] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + -1)) >>
by Guided Substitution of Equals
and theorem 1249:
Theorem (1249) [serial 3401] used for:
  Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 3400]
 


Theorem (1251)                               [serial 3399] 
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445] ->
Q [446] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + Delta)) >>
by Guided Substitution of Equals
and theorem 1250:
Theorem (1250) [serial 3400] used for:
  Guided Substitution of Equals
 replacing "Delta" with its = "-1" in its postcondition [serial 3399]
 


Theorem (1252)                               [serial 3397] 
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
Delta) = ACTUAL_POSITION' >>
S [445] ->
Q [446] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 1251:
Theorem (1251) [serial 3399] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + Delta))" in its postcondition [serial 3397]
 


Theorem (1253)                               [serial 3395] 
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [445] ->
Q [446] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1252:
Theorem (1252) [serial 3397] used for:
    normalization of [serial 3395]
 


Theorem (1254)                               [serial 3341] 
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445] ->
Q [446] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
by Substitution of Assertion Labels
and theorem 1253:
Theorem (1253) [serial 3395] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 3341]
 


Theorem (1255)                               [serial 3323] 
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445] ->
Q [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1239 1245 1254:
Theorem (1239) [serial 3339] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3323]
 
Theorem (1245) [serial 3340] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3323]
 
Theorem (1254) [serial 3341] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 3323]
 


Theorem (1256)                               [serial 3316] 
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445] ->
Q [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1255:
Theorem (1255) [serial 3323] used for:
    normalization of [serial 3316]
 


Theorem (1257)                               [serial 3313] 
P [442] << 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and 
-1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
S [445] EstimatedActualPosition' := (EstimatedActualPosition - 1)
Q [446] << 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 1256:
Theorem (1256) [serial 3316] used for:
  applied wp for assignment [serial 3313]
 


Theorem (1258)                               [serial 3307] 
P [300] << ACTUAL_IN_RANGE() and E_MS() and 0 < EstimatedActualPosition >>
S [436] << ACTUAL_IN_RANGE() and E_MS() and 0 < ACTUAL_POSITION >>
Delta := -1
<< 0 <= (ACTUAL_POSITION - 1) and ACTUAL_POSITION <= #PCS::MaxPosition and -1 = Delta and AXIOM_GT(ACTUAL_POSITION) and E_MS() >>
;
ActuatorCommand(pc:Delta)
<< 0 <= (ACTUAL_POSITION - 1) and (ACTUAL_POSITION - 1) <= #PCS::MaxPosition and -1 = Delta and (ACTUAL_POSITION + Delta) = ACTUAL_POSITION' and E_MS() >>
;
EstimatedActualPosition' := (EstimatedActualPosition - 1)
<< 0 <= ACTUAL_POSITION' and ACTUAL_POSITION' <= #PCS::MaxPosition and ACTUAL_POSITION' = EstimatedActualPosition' >>
Q [302] << (ACTUAL_IN_RANGE() and E_MS())^1 >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 1182 1192 1209 1233 1257:
Theorem (1182) [serial 3309] used for:
  P -> P1 in sequential composition for [serial 3307]
 
Theorem (1192) [serial 3310] used for:
  Q2 -> Q in sequential composition for [serial 3307]
 
Theorem (1209) [serial 3311] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 3307]
 
Theorem (1233) [serial 3312] used for:
  <<Q0 and P1>> S1 <<Q1 and P2>> in sequential composition for [serial 3307]
 
Theorem (1257) [serial 3313] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 3307]
 


Theorem (1259)                               [serial 1040] 
P [300] << (E_MS() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition > 0))) >>
S [436] << (E_MS() and (ACTUAL_POSITION > 0) and ACTUAL_IN_RANGE()) >>
Delta := -1
<< (E_MS() and (Delta = -1) and ((ACTUAL_POSITION - 1) >= 0) and AXIOM_GT(ACTUAL_POSITION) and (ACTUAL_POSITION <= #PCS::MaxPosition)) >>
;
ActuatorCommand(pc:Delta)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + Delta)) and (Delta = -1) and ((ACTUAL_POSITION - 1) >= 0) and E_MS() and ((ACTUAL_POSITION - 1) <= #PCS::MaxPosition)) >>
;
EstimatedActualPosition' := (EstimatedActualPosition - 1)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION' >= 0) and (ACTUAL_POSITION' <= #PCS::MaxPosition)) >>
Q [302] << (E_MS() and ACTUAL_IN_RANGE())^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Irreflexivity of At Least: (a>=b) = (b<=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1258:
Theorem (1258) [serial 3307] used for:
    normalization of [serial 1040]
 


Theorem (1260)                               [serial 1041] 
P [300] << (E_MS() and ACTUAL_IN_RANGE() and ((EstimatedActualPosition < 0))) >>
S [449] ->
Q [305] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1261)                               [serial 1042] 
P [302] << (E_MS() and ACTUAL_IN_RANGE()) >>
S [451] ->
Q [300] << (E_MS() and ACTUAL_IN_RANGE()) >>
by Identity (id):  P->P is tautology


Theorem (1262)                               [serial 1022] 
P [284] <<   >>
S [284] ->
Q [284] << FragilePositionControlThread.MultiStep proof obligations >>
by Initial Thread Obligations
and theorems 518 520 523 532 533 544 611 613 622 623 693 796 901 1049 1164 1168 1174 1259 1260 1261:
Theorem (518) [serial 1023] used for:
  <<M(StillClosing)>> -> <<I>> from invariant I when complete state StillClosing has Assertion <<M(StillClosing)>> in its definition.
 
Theorem (520) [serial 1024] used for:
  <<M(Run)>> -> <<I>> from invariant I when complete state Run has Assertion <<M(Run)>> in its definition.
 
Theorem (523) [serial 1025] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state ShutDown, <<M(ShutDown)>> -> <<e1 or e2 or . . . en>>
 
Theorem (532) [serial 1026] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state Check, <<M(Check)>> -> <<e1 or e2 or . . . en>>
 
Theorem (533) [serial 1027] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state PowerOn, <<M(PowerOn)>> -> <<e1 or e2 or . . . en>>
 
Theorem (544) [serial 1028] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state Decide, <<M(Decide)>> -> <<e1 or e2 or . . . en>>
 
Theorem (611) [serial 1029] used for:
   <<M(PowerOn)>> A <<M(Run)>> for ms0po:PowerOn-[ ]->Run{A};
 
Theorem (613) [serial 1030] used for:
   <<M(Run) and x>> -> <<M(Check)>> for ms1run:Run-[x]->Check{};
 
Theorem (622) [serial 1031] used for:
   <<M(Check) and x>> -> <<M(Decide)>> for ms1ok:Check-[x]->Decide{};
 
Theorem (623) [serial 1032] used for:
   <<M(Check) and x>> -> <<M(Error)>> for ms1er:Check-[x]->Error{};
 
Theorem (693) [serial 1033] used for:
   <<M(Decide) and x>> A <<M(Run)>> for ms2eq:Decide-[x]->Run{A};
 
Theorem (796) [serial 1034] used for:
   <<M(Decide) and x>> A <<M(Run)>> for ms3om:Decide-[x]->Run{A};
 
Theorem (901) [serial 1035] used for:
   <<M(Decide) and x>> A <<M(Run)>> for ms4cm:Decide-[x]->Run{A};
 
Theorem (1049) [serial 1036] used for:
   <<M(Decide) and x>> A <<M(Run)>> for ms5od:Decide-[x]->Run{A};
 
Theorem (1164) [serial 1037] used for:
   <<M(Decide) and x>> A <<M(Run)>> for ms6cd:Decide-[x]->Run{A};
 
Theorem (1168) [serial 1038] used for:
   <<M(Run) and x>> -> <<M(ShutDown)>> for ms7stop:Run-[x]->ShutDown{};
 
Theorem (1174) [serial 1039] used for:
   <<M(ShutDown) and x>> -> <<M(Done)>> for ms8done:ShutDown-[x]->Done{};
 
Theorem (1259) [serial 1040] used for:
   <<M(ShutDown) and x>> A <<M(StillClosing)>> for ms9sc:ShutDown-[x]->StillClosing{A};
 
Theorem (1260) [serial 1041] used for:
   <<M(ShutDown) and x>> -> <<M(Error)>> for ms10er:ShutDown-[x]->Error{};
 
Theorem (1261) [serial 1042] used for:
   <<M(StillClosing) and x>> -> <<M(ShutDown)>> for ms11cl:StillClosing-[x]->ShutDown{};
 


Theorem (1263)                               [serial 1044] 
P [59] << (E_SS() and ((ACTUAL_POSITION^(-1) > 0))) >>
S [40] ->
Q [40] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1264)                               [serial 1045] 
P [53] << (E_SS() and D_SS()) >>
S [40] ->
Q [40] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1265)                               [serial 1063] 
P [57] << E_SS() >>
S [57] ->
Q [57] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1266)                               [serial 1061] 
P [57] << E_SS() >>
S [57] ->
Q [57] << 0 = EstimatedActualPosition or 0 < EstimatedActualPosition or EstimatedActualPosition < 0 >>
by Less than, greater than, or equal:  |-a<b or b<a or a=b
and theorem 1265:
Theorem (1265) [serial 1063] used for:
  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1061]
 


Theorem (1267)                               [serial 1046] 
P [57] << E_SS() >>
S [57] ->
Q [57] << (((EstimatedActualPosition = 0)) or ((EstimatedActualPosition > 0)) or 
((EstimatedActualPosition < 0))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1266:
Theorem (1266) [serial 1061] used for:
    normalization of [serial 1046]
 


Theorem (1268)                               [serial 1047] 
P [51] << (ACTUAL_POSITION = 0) >>
S [51] ->
Q [51] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1269)                               [serial 1067] 
P [55] << D_SS() and E_SS() >>
S [55] ->
Q [55] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1270)                               [serial 1065] 
P [55] << D_SS() and E_SS() >>
S [55] ->
Q [55] << DESIRED_POSITION^0 = EstimatedActualPosition or DESIRED_POSITION^0 < EstimatedActualPosition or 
EstimatedActualPosition < DESIRED_POSITION^0 >>
by Less than, greater than, or equal:  |-a<b or b<a or a=b
and theorem 1269:
Theorem (1269) [serial 1067] used for:
  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1065]
 


Theorem (1271)                               [serial 1048] 
P [55] << (E_SS() and D_SS()) >>
S [55] ->
Q [55] << ((((DESIRED_POSITION)^0 = EstimatedActualPosition)) or (((DESIRED_POSITION)^0 > EstimatedActualPosition)) or 
(((DESIRED_POSITION)^0 < EstimatedActualPosition))) >>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
    Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 1270:
Theorem (1270) [serial 1065] used for:
    normalization of [serial 1048]
 


Theorem (1272)                               [serial 1071] 
P [51] << 0 = ACTUAL_POSITION >>
S [51] ->
Q [65] << 0 = ACTUAL_POSITION >>
by Identity (id):  P->P is tautology


Theorem (1273)                               [serial 1123] 
P [70] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by Identity (id):  P->P is tautology


Theorem (1274)                               [serial 1121] 
P [70] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1273:
Theorem (1273) [serial 1123] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1121]
 


Theorem (1275)                               [serial 1119] 
P [70] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((Delta)^1 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1))) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1274:
Theorem (1274) [serial 1121] used for:
    normalization of [serial 1119]
 


Theorem (1276)                               [serial 1118] 
P [70] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((Delta)^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1275:
Theorem (1275) [serial 1119] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1118]
 


Theorem (1277)                               [serial 1116] 
P [70] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1276:
Theorem (1276) [serial 1118] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1116]
 


Theorem (1278)                               [serial 1114] 
P [70] << ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) = (Delta)^1 and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [53] ->
Q [15] << (((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1))))^1 and ((EstimatedActualPosition = ACTUAL_POSITION))^1) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1277:
Theorem (1277) [serial 1116] used for:
    normalization of [serial 1114]
 


Theorem (1279)                               [serial 1113] 
P [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53] ->
Q [15] << (((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1278:
Theorem (1278) [serial 1114] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1113]
 


Theorem (1280)                               [serial 1072] 
P [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53] ->
Q [15] << (D_SS() and E_SS())^1 >>
by Substitution of Assertion Labels
and theorem 1279:
Theorem (1279) [serial 1113] used for:
  substituted Assertions' predicates for  labels  [serial 1072]
 


Theorem (1281)                               [serial 1092] 
P [65] << 0 = ACTUAL_POSITION >>
S [66] ->
Q [67] << 0 = ACTUAL_POSITION >>
by Identity (id):  P->P is tautology


Theorem (1282)                               [serial 1086] 
P [65] << 0 = ACTUAL_POSITION >>
S [66] ->
Q [67] << (0 = ACTUAL_POSITION) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1281:
Theorem (1281) [serial 1092] used for:
    normalization of [serial 1086]
 


Theorem (1283)                               [serial 1075] 
P [65] << 0 = ACTUAL_POSITION >>
S [66] ->
Q [67] << 0 = ACTUAL_POSITION and true >>
by Law of And-Simplification:  P and true is P
and theorem 1282:
Theorem (1282) [serial 1086] used for:
  Law of And-Simplification:  P and true is P [serial 1075]
 


Theorem (1284)                               [serial 1073] 
P [65] << 0 = ACTUAL_POSITION >>
S [66] ActuatorCommand(pc:0)
Q [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
by Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
and theorem 1283:
Theorem (1283) [serial 1075] used for:
  applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1073]
 


Theorem (1285)                               [serial 1111] 
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69] ->
Q [71] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1286)                               [serial 1104] 
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69] ->
Q [71] << 0 = 0 >>
by Equality Law (idistr):  a=a <-> true
and theorem 1285:
Theorem (1285) [serial 1111] used for:
  Equality Law (idistr):  a=a <-> true [serial 1104]
 


Theorem (1287)                               [serial 1098] 
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69] ->
Q [71] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Subtraction of Same:  a-a is 0
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1286:
Theorem (1286) [serial 1104] used for:
    normalization of [serial 1098]
 


Theorem (1288)                               [serial 1094] 
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69] ->
Q [71] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Guided Substitution of Equals
and theorem 1287:
Theorem (1287) [serial 1098] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1094]
 


Theorem (1289)                               [serial 1099] 
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69] ->
Q [70] << 0 = ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1290)                               [serial 1095] 
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69] ->
Q [70] << 0 = ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 1289:
Theorem (1289) [serial 1099] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1095]
 


Theorem (1291)                               [serial 1081] 
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69] ->
Q [70] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 0 = ACTUAL_POSITION' >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1288 1290:
Theorem (1288) [serial 1094] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
 
Theorem (1290) [serial 1095] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
 


Theorem (1292)                               [serial 1112] 
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69] ->
Q [71] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1293)                               [serial 1107] 
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69] ->
Q [71] << 0 = 0 >>
by Equality Law (idistr):  a=a <-> true
and theorem 1292:
Theorem (1292) [serial 1112] used for:
  Equality Law (idistr):  a=a <-> true [serial 1107]
 


Theorem (1294)                               [serial 1100] 
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69] ->
Q [71] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Subtraction of Same:  a-a is 0
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1293:
Theorem (1293) [serial 1107] used for:
    normalization of [serial 1100]
 


Theorem (1295)                               [serial 1096] 
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69] ->
Q [71] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Guided Substitution of Equals
and theorem 1294:
Theorem (1294) [serial 1100] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1096]
 


Theorem (1296)                               [serial 1101] 
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69] ->
Q [70] << 0 = ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1297)                               [serial 1097] 
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69] ->
Q [70] << 0 = ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 1296:
Theorem (1296) [serial 1101] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1097]
 


Theorem (1298)                               [serial 1083] 
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69] ->
Q [70] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and 0 = ACTUAL_POSITION' >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1295 1297:
Theorem (1295) [serial 1096] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1083]
 
Theorem (1297) [serial 1097] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1083]
 


Theorem (1299)                               [serial 1076] 
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69] ->
Q [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = 0 and ACTUAL_POSITION' = 0 >>
by Normalization
  Normalization Axiom:
    Reflexivity of Equality: (a=b) = (b=a)
and theorems 1291 1298:
Theorem (1291) [serial 1081] used for:
    normalization of [serial 1076]
 
Theorem (1298) [serial 1083] used for:
    normalization of [serial 1076]
 


Theorem (1300)                               [serial 1074] 
P [67] << 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [69] |EstimatedActualPosition',Delta' := 0,0|  
Q [70] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
by Simultaneous Assignment
and theorem 1299:
Theorem (1299) [serial 1076] used for:
  applied wp for simultaneous assignment [serial 1074]
 


Theorem (1301)                               [serial 1069] 
P [51] << 0 = ACTUAL_POSITION >>
S [65] << 0 = ACTUAL_POSITION >>
ActuatorCommand(pc:0)
<< 0 = ACTUAL_POSITION and ACTUAL_POSITION = ACTUAL_POSITION' >>
;
|EstimatedActualPosition',Delta' := 0,0|  
<< (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
Q [53] << (D_SS() and E_SS())^1 >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 1272 1280 1284 1300:
Theorem (1272) [serial 1071] used for:
  P -> P1 in sequential composition for [serial 1069]
 
Theorem (1280) [serial 1072] used for:
  Q1 -> Q in sequential composition for [serial 1069]
 
Theorem (1284) [serial 1073] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1069]
 
Theorem (1300) [serial 1074] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1069]
 


Theorem (1302)                               [serial 1049] 
P [51] << (ACTUAL_POSITION = 0) >>
S [65] << (ACTUAL_POSITION = 0) >>
ActuatorCommand(pc:0)
<< (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and ((ACTUAL_POSITION = 0))) >>
;
|EstimatedActualPosition',Delta' := 0,0|  
<< (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
Q [53] << (E_SS() and D_SS())^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1301:
Theorem (1301) [serial 1069] used for:
    normalization of [serial 1049]
 


Theorem (1303)                               [serial 1050] 
P [53] << (E_SS() and D_SS()) >>
S [73] ->
Q [55] << (E_SS() and D_SS()) >>
by Identity (id):  P->P is tautology


Theorem (1304)                               [serial 1222] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55] ->
Q [76] << DESIRED_POSITION = EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1305)                               [serial 1220] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55] ->
Q [76] << EstimatedActualPosition = DESIRED_POSITION >>
by Normalization
  Normalization Axiom:
    Reflexivity of Equality: (a=b) = (b=a)
and theorem 1304:
Theorem (1304) [serial 1222] used for:
    normalization of [serial 1220]
 


Theorem (1306)                               [serial 1204] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and DESIRED_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55] ->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
by Guided Substitution of Equals
and theorem 1305:
Theorem (1305) [serial 1220] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1204]
 


Theorem (1307)                               [serial 1201] 
P [15] << DESIRED_POSITION = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55] ->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1306:
Theorem (1306) [serial 1204] used for:
    normalization of [serial 1201]
 


Theorem (1308)                               [serial 1166] 
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition and 
Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) >>
S [55] ->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1307:
Theorem (1307) [serial 1201] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1166]
 


Theorem (1309)                               [serial 1159] 
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and ((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [55] ->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1308:
Theorem (1308) [serial 1166] used for:
    normalization of [serial 1159]
 


Theorem (1310)                               [serial 1153] 
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and D_SS() and E_SS() >>
S [55] ->
Q [76] << ACTUAL_POSITION = DESIRED_POSITION >>
by Substitution of Assertion Labels
and theorem 1309:
Theorem (1309) [serial 1159] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1153]
 


Theorem (1311)                               [serial 1154] 
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and D_SS() and E_SS() >>
S [55] ->
Q [76] << E_SS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1312)                               [serial 1130] 
P [15] << DESIRED_POSITION^0 = EstimatedActualPosition and D_SS() and E_SS() >>
S [55] ->
Q [15] << ACTUAL_POSITION = DESIRED_POSITION and E_SS() >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1310 1311:
Theorem (1310) [serial 1153] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1130]
 
Theorem (1311) [serial 1154] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1130]
 


Theorem (1313)                               [serial 1124] 
P [15] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 = EstimatedActualPosition))) >>
S [55] ->
Q [15] << (E_SS() and (DESIRED_POSITION = ACTUAL_POSITION)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1312:
Theorem (1312) [serial 1130] used for:
    normalization of [serial 1124]
 


Theorem (1314)                               [serial 1219] 
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by Identity (id):  P->P is tautology


Theorem (1315)                               [serial 1217] 
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1314:
Theorem (1314) [serial 1219] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1217]
 


Theorem (1316)                               [serial 1214] 
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1315:
Theorem (1315) [serial 1217] used for:
    normalization of [serial 1214]
 


Theorem (1317)                               [serial 1212] 
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1316:
Theorem (1316) [serial 1214] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1212]
 


Theorem (1318)                               [serial 1209] 
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((Delta)^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1317:
Theorem (1317) [serial 1212] used for:
    normalization of [serial 1209]
 


Theorem (1319)                               [serial 1206] 
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1318:
Theorem (1318) [serial 1209] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1206]
 


Theorem (1320)                               [serial 1202] 
P [15] << ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) = (Delta)^1 and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [53] ->
Q [15] << (((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1))))^1 and ((EstimatedActualPosition = ACTUAL_POSITION))^1) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1319:
Theorem (1319) [serial 1206] used for:
    normalization of [serial 1202]
 


Theorem (1321)                               [serial 1200] 
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53] ->
Q [15] << (((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1320:
Theorem (1320) [serial 1202] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1200]
 


Theorem (1322)                               [serial 1132] 
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53] ->
Q [15] << (D_SS() and E_SS())^1 >>
by Substitution of Assertion Labels
and theorem 1321:
Theorem (1321) [serial 1200] used for:
  substituted Assertions' predicates for  labels  [serial 1132]
 


Theorem (1323)                               [serial 1125] 
P [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
S [53] ->
Q [15] << (E_SS() and D_SS())^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1322:
Theorem (1322) [serial 1132] used for:
    normalization of [serial 1125]
 


Theorem (1324)                               [serial 1151] 
P [15] << ACTUAL_POSITION = DESIRED_POSITION and E_SS() >>
S [77] ->
Q [15] << E_SS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1325)                               [serial 1145] 
P [15] << ACTUAL_POSITION = DESIRED_POSITION and E_SS() >>
S [77] ->
Q [15] << (E_SS()) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1324:
Theorem (1324) [serial 1151] used for:
    normalization of [serial 1145]
 


Theorem (1326)                               [serial 1144] 
P [15] << ACTUAL_POSITION = DESIRED_POSITION and E_SS() >>
S [77] ->
Q [15] << true and E_SS() >>
by Law of And-Simplification:  P and true is P
and theorem 1325:
Theorem (1325) [serial 1145] used for:
  Law of And-Simplification:  P and true is P [serial 1144]
 


Theorem (1327)                               [serial 1134] 
P [15] << ACTUAL_POSITION = DESIRED_POSITION and E_SS() >>
S [77] ActuatorCommand(pc:0)
Q [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
by Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
and theorem 1326:
Theorem (1326) [serial 1144] used for:
  applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1134]
 


Theorem (1328)                               [serial 1126] 
P [15] << (E_SS() and (DESIRED_POSITION = ACTUAL_POSITION)) >>
S [77] ActuatorCommand(pc:0)
Q [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E_SS()) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1327:
Theorem (1327) [serial 1134] used for:
    normalization of [serial 1126]
 


Theorem (1329)                               [serial 1198] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80] ->
Q [82] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1330)                               [serial 1187] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80] ->
Q [82] << 0 = 0 >>
by Equality Law (idistr):  a=a <-> true
and theorem 1329:
Theorem (1329) [serial 1198] used for:
  Equality Law (idistr):  a=a <-> true [serial 1187]
 


Theorem (1331)                               [serial 1180] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80] ->
Q [82] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Subtraction of Same:  a-a is 0
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1330:
Theorem (1330) [serial 1187] used for:
    normalization of [serial 1180]
 


Theorem (1332)                               [serial 1168] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80] ->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Guided Substitution of Equals
and theorem 1331:
Theorem (1331) [serial 1180] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1168]
 


Theorem (1333)                               [serial 1160] 
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [80] ->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1332:
Theorem (1332) [serial 1168] used for:
    normalization of [serial 1160]
 


Theorem (1334)                               [serial 1155] 
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80] ->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Substitution of Assertion Labels
and theorem 1333:
Theorem (1333) [serial 1160] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1155]
 


Theorem (1335)                               [serial 1189] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80] ->
Q [81] << ACTUAL_POSITION = EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1336)                               [serial 1181] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80] ->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION >>
by Normalization
  Normalization Axiom:
    Reflexivity of Equality: (a=b) = (b=a)
and theorem 1335:
Theorem (1335) [serial 1189] used for:
    normalization of [serial 1181]
 


Theorem (1337)                               [serial 1170] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80] ->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 1336:
Theorem (1336) [serial 1181] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1170]
 


Theorem (1338)                               [serial 1161] 
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [80] ->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1337:
Theorem (1337) [serial 1170] used for:
    normalization of [serial 1161]
 


Theorem (1339)                               [serial 1156] 
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80] ->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
by Substitution of Assertion Labels
and theorem 1338:
Theorem (1338) [serial 1161] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1156]
 


Theorem (1340)                               [serial 1136] 
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80] ->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and EstimatedActualPosition = ACTUAL_POSITION' >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1334 1339:
Theorem (1334) [serial 1155] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1136]
 
Theorem (1339) [serial 1156] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1136]
 


Theorem (1341)                               [serial 1199] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80] ->
Q [82] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1342)                               [serial 1191] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80] ->
Q [82] << 0 = 0 >>
by Equality Law (idistr):  a=a <-> true
and theorem 1341:
Theorem (1341) [serial 1199] used for:
  Equality Law (idistr):  a=a <-> true [serial 1191]
 


Theorem (1343)                               [serial 1182] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80] ->
Q [82] << 0 = (ACTUAL_POSITION - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Subtraction of Same:  a-a is 0
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1342:
Theorem (1342) [serial 1191] used for:
    normalization of [serial 1182]
 


Theorem (1344)                               [serial 1172] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80] ->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Guided Substitution of Equals
and theorem 1343:
Theorem (1343) [serial 1182] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1172]
 


Theorem (1345)                               [serial 1162] 
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [80] ->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1344:
Theorem (1344) [serial 1172] used for:
    normalization of [serial 1162]
 


Theorem (1346)                               [serial 1157] 
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80] ->
Q [82] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Substitution of Assertion Labels
and theorem 1345:
Theorem (1345) [serial 1162] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1157]
 


Theorem (1347)                               [serial 1193] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80] ->
Q [81] << ACTUAL_POSITION = EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1348)                               [serial 1183] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80] ->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION >>
by Normalization
  Normalization Axiom:
    Reflexivity of Equality: (a=b) = (b=a)
and theorem 1347:
Theorem (1347) [serial 1193] used for:
    normalization of [serial 1183]
 


Theorem (1349)                               [serial 1174] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and ACTUAL_POSITION = ACTUAL_POSITION' >>
S [80] ->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 1348:
Theorem (1348) [serial 1183] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "ACTUAL_POSITION" in its postcondition [serial 1174]
 


Theorem (1350)                               [serial 1163] 
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [80] ->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1349:
Theorem (1349) [serial 1174] used for:
    normalization of [serial 1163]
 


Theorem (1351)                               [serial 1158] 
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80] ->
Q [81] << EstimatedActualPosition = ACTUAL_POSITION' >>
by Substitution of Assertion Labels
and theorem 1350:
Theorem (1350) [serial 1163] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1158]
 


Theorem (1352)                               [serial 1138] 
P [15] << ACTUAL_POSITION = ACTUAL_POSITION' and E_SS() >>
S [80] ->
Q [15] << 0 = (ACTUAL_POSITION' - ACTUAL_POSITION) and EstimatedActualPosition = ACTUAL_POSITION' >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1346 1351:
Theorem (1346) [serial 1157] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1138]
 
Theorem (1351) [serial 1158] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1138]
 


Theorem (1353)                               [serial 1128] 
P [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E_SS()) >>
S [80] ->
Q [15] << (((EstimatedActualPosition = ACTUAL_POSITION')) and ((0 = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorems 1340 1352:
Theorem (1340) [serial 1136] used for:
    normalization of [serial 1128]
 
Theorem (1352) [serial 1138] used for:
    normalization of [serial 1128]
 


Theorem (1354)                               [serial 1127] 
P [15] << (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E_SS()) >>
S [80] |EstimatedActualPosition',Delta' := EstimatedActualPosition,0|  
Q [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
by Simultaneous Assignment
and theorem 1353:
Theorem (1353) [serial 1128] used for:
  applied wp for simultaneous assignment [serial 1127]
 


Theorem (1355)                               [serial 1051] 
P [55] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 = EstimatedActualPosition))) >>
S [76] << (E_SS() and (DESIRED_POSITION = ACTUAL_POSITION)) >>
ActuatorCommand(pc:0)
<< (((ACTUAL_POSITION' = (ACTUAL_POSITION + 0))) and E_SS()) >>
;
|EstimatedActualPosition',Delta' := EstimatedActualPosition,0|  
<< (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
Q [53] << (E_SS() and D_SS())^1 >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 1313 1323 1328 1354:
Theorem (1313) [serial 1124] used for:
  P -> P1 in sequential composition for [serial 1051]
 
Theorem (1323) [serial 1125] used for:
  Q1 -> Q in sequential composition for [serial 1051]
 
Theorem (1328) [serial 1126] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1051]
 
Theorem (1354) [serial 1127] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1051]
 


Theorem (1356)                               [serial 1282] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55] ->
Q [86] << ACTUAL_POSITION = EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1357)                               [serial 1273] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55] ->
Q [86] << ((EstimatedActualPosition = ACTUAL_POSITION)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1356:
Theorem (1356) [serial 1282] used for:
    normalization of [serial 1273]
 


Theorem (1358)                               [serial 1266] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55] ->
Q [86] << E_SS() >>
by Substitution of Assertion Labels
and theorem 1357:
Theorem (1357) [serial 1273] used for:
  substituted Assertions' predicates for  labels  [serial 1266]
 


Theorem (1359)                               [serial 1357] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55] ->
Q [1] << EstimatedActualPosition < DESIRED_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1360)                               [serial 1331] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55] ->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
by Guided Substitution of Equals
and theorem 1359:
Theorem (1359) [serial 1357] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1331]
 


Theorem (1361)                               [serial 1326] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55] ->
Q [1] << EstimatedActualPosition < DESIRED_POSITION >>
by Guided Substitution of Equals
and theorem 1360:
Theorem (1360) [serial 1331] used for:
  Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 1326]
 


Theorem (1362)                               [serial 1285] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION >>
S [55] ->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
by Guided Substitution of Equals
and theorem 1361:
Theorem (1361) [serial 1326] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1285]
 


Theorem (1363)                               [serial 1267] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55] ->
Q [1] << ACTUAL_POSITION < DESIRED_POSITION >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1362:
Theorem (1362) [serial 1285] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1267]
 


Theorem (1364)                               [serial 1258] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55] ->
Q [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1358 1363:
Theorem (1358) [serial 1266] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1258]
 
Theorem (1363) [serial 1267] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1258]
 


Theorem (1365)                               [serial 1253] 
P [15] << ((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)) and 
EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55] ->
Q [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1364:
Theorem (1364) [serial 1258] used for:
    normalization of [serial 1253]
 


Theorem (1366)                               [serial 1230] 
P [15] << D_SS() and E_SS() and EstimatedActualPosition < DESIRED_POSITION^0 >>
S [55] ->
Q [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
by Substitution of Assertion Labels
and theorem 1365:
Theorem (1365) [serial 1253] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1230]
 


Theorem (1367)                               [serial 1224] 
P [15] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 > EstimatedActualPosition))) >>
S [55] ->
Q [15] << (E_SS() and (DESIRED_POSITION > ACTUAL_POSITION)) >>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1366:
Theorem (1366) [serial 1230] used for:
    normalization of [serial 1224]
 


Theorem (1368)                               [serial 1325] 
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by Identity (id):  P->P is tautology


Theorem (1369)                               [serial 1323] 
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1368:
Theorem (1368) [serial 1325] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1323]
 


Theorem (1370)                               [serial 1316] 
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1369:
Theorem (1369) [serial 1323] used for:
    normalization of [serial 1316]
 


Theorem (1371)                               [serial 1314] 
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1370:
Theorem (1370) [serial 1316] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1314]
 


Theorem (1372)                               [serial 1307] 
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((Delta)^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1371:
Theorem (1371) [serial 1314] used for:
    normalization of [serial 1307]
 


Theorem (1373)                               [serial 1301] 
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1372:
Theorem (1372) [serial 1307] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1301]
 


Theorem (1374)                               [serial 1290] 
P [15] << ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) = (Delta)^1 and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [53] ->
Q [15] << ((ACTUAL_POSITION = EstimatedActualPosition)^1 and (Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1373:
Theorem (1373) [serial 1301] used for:
    normalization of [serial 1290]
 


Theorem (1375)                               [serial 1280] 
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53] ->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1374:
Theorem (1374) [serial 1290] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1280]
 


Theorem (1376)                               [serial 1272] 
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53] ->
Q [15] << (((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1375:
Theorem (1375) [serial 1280] used for:
    normalization of [serial 1272]
 


Theorem (1377)                               [serial 1232] 
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53] ->
Q [15] << (D_SS() and E_SS())^1 >>
by Substitution of Assertion Labels
and theorem 1376:
Theorem (1376) [serial 1272] used for:
  substituted Assertions' predicates for  labels  [serial 1232]
 


Theorem (1378)                               [serial 1225] 
P [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
S [53] ->
Q [15] << (E_SS() and D_SS())^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1377:
Theorem (1377) [serial 1232] used for:
    normalization of [serial 1225]
 


Theorem (1379)                               [serial 1251] 
P [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
S [87] ->
Q [15] << E_SS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1380)                               [serial 1245] 
P [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
S [87] ->
Q [15] << (E_SS()) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1379:
Theorem (1379) [serial 1251] used for:
    normalization of [serial 1245]
 


Theorem (1381)                               [serial 1244] 
P [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
S [87] ->
Q [15] << true and E_SS() >>
by Law of And-Simplification:  P and true is P
and theorem 1380:
Theorem (1380) [serial 1245] used for:
  Law of And-Simplification:  P and true is P [serial 1244]
 


Theorem (1382)                               [serial 1234] 
P [15] << E_SS() and ACTUAL_POSITION < DESIRED_POSITION >>
S [87] ActuatorCommand(pc:1)
Q [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and E_SS() >>
by Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
and theorem 1381:
Theorem (1381) [serial 1244] used for:
  applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1234]
 


Theorem (1383)                               [serial 1226] 
P [15] << (E_SS() and (DESIRED_POSITION > ACTUAL_POSITION)) >>
S [87] ActuatorCommand(pc:1)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 1)) and E_SS()) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1382:
Theorem (1382) [serial 1234] used for:
    normalization of [serial 1226]
 


Theorem (1384)                               [serial 1353] 
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90] ->
Q [92] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1385)                               [serial 1342] 
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90] ->
Q [92] << 1 = 1 >>
by Equality Law (idistr):  a=a <-> true
and theorem 1384:
Theorem (1384) [serial 1353] used for:
  Equality Law (idistr):  a=a <-> true [serial 1342]
 


Theorem (1386)                               [serial 1336] 
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90] ->
Q [92] << 1 = (((1 + ACTUAL_POSITION)) - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Subtaction of Added Value:  (a+b)-a is b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1385:
Theorem (1385) [serial 1342] used for:
    normalization of [serial 1336]
 


Theorem (1387)                               [serial 1332] 
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90] ->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by Guided Substitution of Equals
and theorem 1386:
Theorem (1386) [serial 1336] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((1 + ACTUAL_POSITION))" in its postcondition [serial 1332]
 


Theorem (1388)                               [serial 1327] 
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90] ->
Q [92] << 1 = (EstimatedActualPosition^1 - EstimatedActualPosition) >>
by Guided Substitution of Equals
and theorem 1387:
Theorem (1387) [serial 1332] used for:
  Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 1327]
 


Theorem (1389)                               [serial 1293] 
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90] ->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by Guided Substitution of Equals
and theorem 1388:
Theorem (1388) [serial 1327] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1293]
 


Theorem (1390)                               [serial 1286] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = (ACTUAL_POSITION)^1 >>
S [90] ->
Q [92] << 1 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1389:
Theorem (1389) [serial 1293] used for:
    normalization of [serial 1286]
 


Theorem (1391)                               [serial 1268] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90] ->
Q [92] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1390:
Theorem (1390) [serial 1286] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1268]
 


Theorem (1392)                               [serial 1354] 
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90] ->
Q [91] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1393)                               [serial 1344] 
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90] ->
Q [91] << (1 + ACTUAL_POSITION) = (1 + ACTUAL_POSITION) >>
by Equality Law (idistr):  a=a <-> true
and theorem 1392:
Theorem (1392) [serial 1354] used for:
  Equality Law (idistr):  a=a <-> true [serial 1344]
 


Theorem (1394)                               [serial 1337] 
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90] ->
Q [91] << ((1 + ACTUAL_POSITION)) = (1 + ACTUAL_POSITION) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1393:
Theorem (1393) [serial 1344] used for:
    normalization of [serial 1337]
 


Theorem (1395)                               [serial 1333] 
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90] ->
Q [91] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) >>
by Guided Substitution of Equals
and theorem 1394:
Theorem (1394) [serial 1337] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((1 + ACTUAL_POSITION))" in its postcondition [serial 1333]
 


Theorem (1396)                               [serial 1328] 
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90] ->
Q [91] << EstimatedActualPosition^1 = (1 + EstimatedActualPosition) >>
by Guided Substitution of Equals
and theorem 1395:
Theorem (1395) [serial 1333] used for:
  Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 1328]
 


Theorem (1397)                               [serial 1295] 
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90] ->
Q [91] << ACTUAL_POSITION^1 = (1 + EstimatedActualPosition) >>
by Guided Substitution of Equals
and theorem 1396:
Theorem (1396) [serial 1328] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1295]
 


Theorem (1398)                               [serial 1287] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = (ACTUAL_POSITION)^1 >>
S [90] ->
Q [91] << (1 + EstimatedActualPosition) = (ACTUAL_POSITION)^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1397:
Theorem (1397) [serial 1295] used for:
    normalization of [serial 1287]
 


Theorem (1399)                               [serial 1269] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90] ->
Q [91] << (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1398:
Theorem (1398) [serial 1287] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1269]
 


Theorem (1400)                               [serial 1260] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90] ->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1391 1399:
Theorem (1391) [serial 1268] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1260]
 
Theorem (1399) [serial 1269] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1260]
 


Theorem (1401)                               [serial 1254] 
P [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [90] ->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1400:
Theorem (1400) [serial 1260] used for:
    normalization of [serial 1254]
 


Theorem (1402)                               [serial 1236] 
P [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and E_SS() >>
S [90] ->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Substitution of Assertion Labels
and theorem 1401:
Theorem (1401) [serial 1254] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1236]
 


Theorem (1403)                               [serial 1355] 
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90] ->
Q [92] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1404)                               [serial 1346] 
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90] ->
Q [92] << 1 = 1 >>
by Equality Law (idistr):  a=a <-> true
and theorem 1403:
Theorem (1403) [serial 1355] used for:
  Equality Law (idistr):  a=a <-> true [serial 1346]
 


Theorem (1405)                               [serial 1338] 
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90] ->
Q [92] << 1 = (((1 + ACTUAL_POSITION)) - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Subtaction of Added Value:  (a+b)-a is b
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1404:
Theorem (1404) [serial 1346] used for:
    normalization of [serial 1338]
 


Theorem (1406)                               [serial 1334] 
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90] ->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by Guided Substitution of Equals
and theorem 1405:
Theorem (1405) [serial 1338] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((1 + ACTUAL_POSITION))" in its postcondition [serial 1334]
 


Theorem (1407)                               [serial 1329] 
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90] ->
Q [92] << 1 = (EstimatedActualPosition^1 - EstimatedActualPosition) >>
by Guided Substitution of Equals
and theorem 1406:
Theorem (1406) [serial 1334] used for:
  Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 1329]
 


Theorem (1408)                               [serial 1297] 
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90] ->
Q [92] << 1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by Guided Substitution of Equals
and theorem 1407:
Theorem (1407) [serial 1329] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1297]
 


Theorem (1409)                               [serial 1288] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = (ACTUAL_POSITION)^1 >>
S [90] ->
Q [92] << 1 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1408:
Theorem (1408) [serial 1297] used for:
    normalization of [serial 1288]
 


Theorem (1410)                               [serial 1270] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90] ->
Q [92] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1409:
Theorem (1409) [serial 1288] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1270]
 


Theorem (1411)                               [serial 1356] 
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90] ->
Q [91] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1412)                               [serial 1348] 
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90] ->
Q [91] << (1 + ACTUAL_POSITION) = (1 + ACTUAL_POSITION) >>
by Equality Law (idistr):  a=a <-> true
and theorem 1411:
Theorem (1411) [serial 1356] used for:
  Equality Law (idistr):  a=a <-> true [serial 1348]
 


Theorem (1413)                               [serial 1339] 
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90] ->
Q [91] << ((1 + ACTUAL_POSITION)) = (1 + ACTUAL_POSITION) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1412:
Theorem (1412) [serial 1348] used for:
    normalization of [serial 1339]
 


Theorem (1414)                               [serial 1335] 
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90] ->
Q [91] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) >>
by Guided Substitution of Equals
and theorem 1413:
Theorem (1413) [serial 1339] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION^1" with its = "((1 + ACTUAL_POSITION))" in its postcondition [serial 1335]
 


Theorem (1415)                               [serial 1330] 
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90] ->
Q [91] << EstimatedActualPosition^1 = (1 + EstimatedActualPosition) >>
by Guided Substitution of Equals
and theorem 1414:
Theorem (1414) [serial 1335] used for:
  Guided Substitution of Equals
 replacing "EstimatedActualPosition" with its = "ACTUAL_POSITION" in its postcondition [serial 1330]
 


Theorem (1416)                               [serial 1299] 
P [15] << ACTUAL_POSITION^1 = (1 + ACTUAL_POSITION) and ACTUAL_POSITION = EstimatedActualPosition >>
S [90] ->
Q [91] << ACTUAL_POSITION^1 = (1 + EstimatedActualPosition) >>
by Guided Substitution of Equals
and theorem 1415:
Theorem (1415) [serial 1330] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1299]
 


Theorem (1417)                               [serial 1289] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = (ACTUAL_POSITION)^1 >>
S [90] ->
Q [91] << (1 + EstimatedActualPosition) = (ACTUAL_POSITION)^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1416:
Theorem (1416) [serial 1299] used for:
    normalization of [serial 1289]
 


Theorem (1418)                               [serial 1271] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90] ->
Q [91] << (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1417:
Theorem (1417) [serial 1289] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1271]
 


Theorem (1419)                               [serial 1262] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and (1 + ACTUAL_POSITION) = ACTUAL_POSITION' >>
S [90] ->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1410 1418:
Theorem (1410) [serial 1270] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1262]
 
Theorem (1418) [serial 1271] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1262]
 


Theorem (1420)                               [serial 1255] 
P [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and ((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [90] ->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1419:
Theorem (1419) [serial 1262] used for:
    normalization of [serial 1255]
 


Theorem (1421)                               [serial 1238] 
P [15] << (1 + ACTUAL_POSITION) = ACTUAL_POSITION' and E_SS() >>
S [90] ->
Q [15] << 1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (1 + EstimatedActualPosition) = ACTUAL_POSITION' >>
by Substitution of Assertion Labels
and theorem 1420:
Theorem (1420) [serial 1255] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1238]
 


Theorem (1422)                               [serial 1228] 
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 1)) and E_SS()) >>
S [90] ->
Q [15] << ((((((EstimatedActualPosition + 1))) = ACTUAL_POSITION')) and ((1 = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorems 1402 1421:
Theorem (1402) [serial 1236] used for:
    normalization of [serial 1228]
 
Theorem (1421) [serial 1238] used for:
    normalization of [serial 1228]
 


Theorem (1423)                               [serial 1227] 
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + 1)) and E_SS()) >>
S [90] |EstimatedActualPosition',Delta' := (EstimatedActualPosition + 1),1|  
Q [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
by Simultaneous Assignment
and theorem 1422:
Theorem (1422) [serial 1228] used for:
  applied wp for simultaneous assignment [serial 1227]
 


Theorem (1424)                               [serial 1052] 
P [55] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 > EstimatedActualPosition))) >>
S [86] << (E_SS() and (DESIRED_POSITION > ACTUAL_POSITION)) >>
ActuatorCommand(pc:1)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + 1)) and E_SS()) >>
;
|EstimatedActualPosition',Delta' := (EstimatedActualPosition + 1),1|  
<< (((EstimatedActualPosition' = ACTUAL_POSITION')) and ((Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION)))) >>
Q [53] << (E_SS() and D_SS())^1 >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 1367 1378 1383 1423:
Theorem (1367) [serial 1224] used for:
  P -> P1 in sequential composition for [serial 1052]
 
Theorem (1378) [serial 1225] used for:
  Q1 -> Q in sequential composition for [serial 1052]
 
Theorem (1383) [serial 1226] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1052]
 
Theorem (1423) [serial 1227] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1052]
 


Theorem (1425)                               [serial 1401] 
P [15] << ((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)) and 
DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55] ->
Q [96] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1426)                               [serial 1401] 
P [15] << ((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)) and 
DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55] ->
Q [96] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1427)                               [serial 1395] 
P [15] << ((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)) and 
DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55] ->
Q [96] << AXIOM_MO() >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 1426 1426:
Theorem (1426) [serial 1401] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (1426) [serial 1401] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (1428)                               [serial 1388] 
P [15] << D_SS() and E_SS() and DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55] ->
Q [96] << AXIOM_MO() >>
by Substitution of Assertion Labels
and theorem 1427:
Theorem (1427) [serial 1395] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1388]
 


Theorem (1429)                               [serial 1389] 
P [15] << D_SS() and E_SS() and DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55] ->
Q [96] << E_SS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1430)                               [serial 1426] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
DESIRED_POSITION < EstimatedActualPosition >>
S [55] ->
Q [96] << DESIRED_POSITION < EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1431)                               [serial 1423] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
DESIRED_POSITION < EstimatedActualPosition >>
S [55] ->
Q [96] << DESIRED_POSITION < ACTUAL_POSITION >>
by Guided Substitution of Equals
and theorem 1430:
Theorem (1430) [serial 1426] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1423]
 


Theorem (1432)                               [serial 1408] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1) and 
DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55] ->
Q [96] << DESIRED_POSITION < ACTUAL_POSITION >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1431:
Theorem (1431) [serial 1423] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1408]
 


Theorem (1433)                               [serial 1396] 
P [15] << ((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))) and ((EstimatedActualPosition = ACTUAL_POSITION)) and 
DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55] ->
Q [96] << DESIRED_POSITION < ACTUAL_POSITION >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1432:
Theorem (1432) [serial 1408] used for:
    normalization of [serial 1396]
 


Theorem (1434)                               [serial 1390] 
P [15] << D_SS() and E_SS() and DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55] ->
Q [96] << DESIRED_POSITION < ACTUAL_POSITION >>
by Substitution of Assertion Labels
and theorem 1433:
Theorem (1433) [serial 1396] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1390]
 


Theorem (1435)                               [serial 1363] 
P [15] << D_SS() and E_SS() and DESIRED_POSITION^0 < EstimatedActualPosition >>
S [55] ->
Q [15] << AXIOM_MO() and E_SS() and DESIRED_POSITION < ACTUAL_POSITION >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1428 1429 1434:
Theorem (1428) [serial 1388] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1363]
 
Theorem (1429) [serial 1389] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1363]
 
Theorem (1434) [serial 1390] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1363]
 


Theorem (1436)                               [serial 1358] 
P [15] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 < EstimatedActualPosition))) >>
S [55] ->
Q [15] << (E_SS() and (DESIRED_POSITION < ACTUAL_POSITION) and AXIOM_MO()) >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1435:
Theorem (1435) [serial 1363] used for:
    normalization of [serial 1358]
 


Theorem (1437)                               [serial 1457] 
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
by Identity (id):  P->P is tautology


Theorem (1438)                               [serial 1455] 
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION^0) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1437:
Theorem (1437) [serial 1457] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1455]
 


Theorem (1439)                               [serial 1453] 
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = ((ACTUAL_POSITION)^1 - ACTUAL_POSITION^(-1+1)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1438:
Theorem (1438) [serial 1455] used for:
    normalization of [serial 1453]
 


Theorem (1440)                               [serial 1451] 
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1439:
Theorem (1439) [serial 1453] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1451]
 


Theorem (1441)                               [serial 1449] 
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((Delta)^1 = (ACTUAL_POSITION - ACTUAL_POSITION^-1)^1) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1440:
Theorem (1440) [serial 1451] used for:
    normalization of [serial 1449]
 


Theorem (1442)                               [serial 1447] 
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (Delta = (ACTUAL_POSITION - ACTUAL_POSITION^-1))^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1441:
Theorem (1441) [serial 1449] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1447]
 


Theorem (1443)                               [serial 1445] 
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << (((Delta = (ACTUAL_POSITION - ACTUAL_POSITION^(-1)))))^1 and (((EstimatedActualPosition = ACTUAL_POSITION)))^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1442:
Theorem (1442) [serial 1447] used for:
    normalization of [serial 1445]
 


Theorem (1444)                               [serial 1435] 
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and Delta^1 = (ACTUAL_POSITION^1 - ACTUAL_POSITION) >>
S [53] ->
Q [15] << (D_SS())^1 and (E_SS())^1 >>
by Substitution of Assertion Labels
and theorem 1443:
Theorem (1443) [serial 1445] used for:
  substituted Assertions' predicates for  labels in postconditions [serial 1435]
 


Theorem (1445)                               [serial 1431] 
P [15] << ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) = (Delta)^1 and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [53] ->
Q [15] << ((D_SS())^1 and (E_SS())^1) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1444:
Theorem (1444) [serial 1435] used for:
    normalization of [serial 1431]
 


Theorem (1446)                               [serial 1422] 
P [15] << ((ACTUAL_POSITION)^1 - ACTUAL_POSITION) = (Delta)^1 and (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 >>
S [53] ->
Q [15] << ((D_SS())^1 and (E_SS())^1) >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 1445:
Theorem (1445) [serial 1431] used for:
   changing adding negation to subtraction  [serial 1422]
 


Theorem (1447)                               [serial 1365] 
P [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
S [53] ->
Q [15] << (D_SS() and E_SS())^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1446:
Theorem (1446) [serial 1422] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1365]
 


Theorem (1448)                               [serial 1359] 
P [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and (Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
S [53] ->
Q [15] << (E_SS() and D_SS())^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1447:
Theorem (1447) [serial 1365] used for:
    normalization of [serial 1359]
 


Theorem (1449)                               [serial 1387] 
P [15] << AXIOM_MO() and E_SS() and DESIRED_POSITION < ACTUAL_POSITION >>
S [97] ->
Q [15] << AXIOM_MO() and E_SS() >>
by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (1450)                               [serial 1379] 
P [15] << AXIOM_MO() and E_SS() and DESIRED_POSITION < ACTUAL_POSITION >>
S [97] ->
Q [15] << AXIOM_MO() and E_SS() and true >>
by Law of And-Simplification:  P and true is P
and theorem 1449:
Theorem (1449) [serial 1387] used for:
  Law of And-Simplification:  P and true is P [serial 1379]
 


Theorem (1451)                               [serial 1374] 
P [15] << AXIOM_MO() and E_SS() and DESIRED_POSITION < ACTUAL_POSITION >>
S [97] ->
Q [15] << true and AXIOM_MO() and E_SS() >>
by Normalization
  Normalization Axiom:
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1450:
Theorem (1450) [serial 1379] used for:
    normalization of [serial 1374]
 


Theorem (1452)                               [serial 1367] 
P [15] << AXIOM_MO() and E_SS() and DESIRED_POSITION < ACTUAL_POSITION >>
S [97] ActuatorCommand(pc:MinusOne)
Q [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
by Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
and theorem 1451:
Theorem (1451) [serial 1374] used for:
  applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1367]
 


Theorem (1453)                               [serial 1360] 
P [15] << (E_SS() and (DESIRED_POSITION < ACTUAL_POSITION) and AXIOM_MO()) >>
S [97] ActuatorCommand(pc:MinusOne)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + MinusOne)) and E_SS() and AXIOM_MO()) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1452:
Theorem (1452) [serial 1367] used for:
    normalization of [serial 1360]
 


Theorem (1454)                               [serial 1410] 
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' >>
S [101] ->
Q [103] << -1 = MinusOne >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1455)                               [serial 1402] 
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101] ->
Q [103] << -1 = (((ACTUAL_POSITION + MinusOne)) - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Subtaction of Added Value:  (a+b)-a is b
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1454:
Theorem (1454) [serial 1410] used for:
    normalization of [serial 1402]
 


Theorem (1456)                               [serial 1397] 
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101] ->
Q [103] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Guided Substitution of Equals
and theorem 1455:
Theorem (1455) [serial 1402] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + MinusOne))" in its postcondition [serial 1397]
 


Theorem (1457)                               [serial 1391] 
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101] ->
Q [103] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Substitution of Assertion Labels
and theorem 1456:
Theorem (1456) [serial 1397] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1391]
 


Theorem (1458)                               [serial 1443] 
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [101] ->
Q [102] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1459)                               [serial 1437] 
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [101] ->
Q [102] << (-1 + EstimatedActualPosition) = (-1 + EstimatedActualPosition) >>
by Equality Law (idistr):  a=a <-> true
and theorem 1458:
Theorem (1458) [serial 1443] used for:
  Equality Law (idistr):  a=a <-> true [serial 1437]
 


Theorem (1460)                               [serial 1432] 
P [15] <<  -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101] ->
Q [102] << (EstimatedActualPosition +  -1) = (EstimatedActualPosition +  -1) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Equality: (a=b) = (b=a)
    Unary Minus:  -(x-y) is (y-x)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1459:
Theorem (1459) [serial 1437] used for:
    normalization of [serial 1432]
 


Theorem (1461)                               [serial 1429] 
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101] ->
Q [102] << (EstimatedActualPosition - 1) = (EstimatedActualPosition + -1) >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 1460:
Theorem (1460) [serial 1432] used for:
   changing adding negation to subtraction  [serial 1429]
 


Theorem (1462)                               [serial 1427] 
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101] ->
Q [102] << (EstimatedActualPosition - 1) = (EstimatedActualPosition + MinusOne) >>
by Guided Substitution of Equals
and theorem 1461:
Theorem (1461) [serial 1429] used for:
  Guided Substitution of Equals
 replacing "MinusOne" with its = "-1" in its postcondition [serial 1427]
 


Theorem (1463)                               [serial 1424] 
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101] ->
Q [102] << (EstimatedActualPosition - 1) = (ACTUAL_POSITION + MinusOne) >>
by Guided Substitution of Equals
and theorem 1462:
Theorem (1462) [serial 1427] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1424]
 


Theorem (1464)                               [serial 1412] 
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' >>
S [101] ->
Q [102] << (EstimatedActualPosition - 1) = (ACTUAL_POSITION + MinusOne) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1463:
Theorem (1463) [serial 1424] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1412]
 


Theorem (1465)                               [serial 1403] 
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101] ->
Q [102] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + MinusOne)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1464:
Theorem (1464) [serial 1412] used for:
    normalization of [serial 1403]
 


Theorem (1466)                               [serial 1398] 
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101] ->
Q [102] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 1465:
Theorem (1465) [serial 1403] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + MinusOne))" in its postcondition [serial 1398]
 


Theorem (1467)                               [serial 1392] 
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101] ->
Q [102] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
by Substitution of Assertion Labels
and theorem 1466:
Theorem (1466) [serial 1398] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1392]
 


Theorem (1468)                               [serial 1381] 
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101] ->
Q [15] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1457 1467:
Theorem (1457) [serial 1391] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1381]
 
Theorem (1467) [serial 1392] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1381]
 


Theorem (1469)                               [serial 1414] 
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' >>
S [101] ->
Q [103] << -1 = MinusOne >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1470)                               [serial 1404] 
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101] ->
Q [103] << -1 = (((ACTUAL_POSITION + MinusOne)) - ACTUAL_POSITION) >>
by Normalization
  Normalization Axioms:
    Subtaction of Added Value:  (a+b)-a is b
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1469:
Theorem (1469) [serial 1414] used for:
    normalization of [serial 1404]
 


Theorem (1471)                               [serial 1399] 
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101] ->
Q [103] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Guided Substitution of Equals
and theorem 1470:
Theorem (1470) [serial 1404] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + MinusOne))" in its postcondition [serial 1399]
 


Theorem (1472)                               [serial 1393] 
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101] ->
Q [103] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) >>
by Substitution of Assertion Labels
and theorem 1471:
Theorem (1471) [serial 1399] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1393]
 


Theorem (1473)                               [serial 1444] 
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [101] ->
Q [102] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1474)                               [serial 1439] 
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition >>
S [101] ->
Q [102] << (-1 + EstimatedActualPosition) = (-1 + EstimatedActualPosition) >>
by Equality Law (idistr):  a=a <-> true
and theorem 1473:
Theorem (1473) [serial 1444] used for:
  Equality Law (idistr):  a=a <-> true [serial 1439]
 


Theorem (1475)                               [serial 1433] 
P [15] <<  -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101] ->
Q [102] << (EstimatedActualPosition +  -1) = (EstimatedActualPosition +  -1) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Equality: (a=b) = (b=a)
    Unary Minus:  -(x-y) is (y-x)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1474:
Theorem (1474) [serial 1439] used for:
    normalization of [serial 1433]
 


Theorem (1476)                               [serial 1430] 
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101] ->
Q [102] << (EstimatedActualPosition - 1) = (EstimatedActualPosition + -1) >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 1475:
Theorem (1475) [serial 1433] used for:
   changing adding negation to subtraction  [serial 1430]
 


Theorem (1477)                               [serial 1428] 
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101] ->
Q [102] << (EstimatedActualPosition - 1) = (EstimatedActualPosition + MinusOne) >>
by Guided Substitution of Equals
and theorem 1476:
Theorem (1476) [serial 1430] used for:
  Guided Substitution of Equals
 replacing "MinusOne" with its = "-1" in its postcondition [serial 1428]
 


Theorem (1478)                               [serial 1425] 
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 >>
S [101] ->
Q [102] << (EstimatedActualPosition - 1) = (ACTUAL_POSITION + MinusOne) >>
by Guided Substitution of Equals
and theorem 1477:
Theorem (1477) [serial 1428] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1425]
 


Theorem (1479)                               [serial 1416] 
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' >>
S [101] ->
Q [102] << (EstimatedActualPosition - 1) = (ACTUAL_POSITION + MinusOne) >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1478:
Theorem (1478) [serial 1425] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1416]
 


Theorem (1480)                               [serial 1405] 
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101] ->
Q [102] << (EstimatedActualPosition - 1) = ((ACTUAL_POSITION + MinusOne)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1479:
Theorem (1479) [serial 1416] used for:
    normalization of [serial 1405]
 


Theorem (1481)                               [serial 1400] 
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) >>
S [101] ->
Q [102] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
by Guided Substitution of Equals
and theorem 1480:
Theorem (1480) [serial 1405] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION'" with its = "((ACTUAL_POSITION + MinusOne))" in its postcondition [serial 1400]
 


Theorem (1482)                               [serial 1394] 
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101] ->
Q [102] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
by Substitution of Assertion Labels
and theorem 1481:
Theorem (1481) [serial 1400] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1394]
 


Theorem (1483)                               [serial 1383] 
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101] ->
Q [15] << -1 = (ACTUAL_POSITION' - ACTUAL_POSITION) and (EstimatedActualPosition - 1) = ACTUAL_POSITION' >>
by Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 1472 1482:
Theorem (1472) [serial 1393] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1383]
 
Theorem (1482) [serial 1394] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1383]
 


Theorem (1484)                               [serial 1375] 
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101] ->
Q [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = -1 and ACTUAL_POSITION' = (((EstimatedActualPosition - 1))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorems 1468 1483:
Theorem (1468) [serial 1381] used for:
    normalization of [serial 1375]
 
Theorem (1483) [serial 1383] used for:
    normalization of [serial 1375]
 


Theorem (1485)                               [serial 1369] 
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() >>
S [101] |EstimatedActualPosition',Delta' := (EstimatedActualPosition - 1),-1|  
Q [15] << (ACTUAL_POSITION' - ACTUAL_POSITION) = Delta' and ACTUAL_POSITION' = EstimatedActualPosition' >>
by Simultaneous Assignment
and theorem 1484:
Theorem (1484) [serial 1375] used for:
  applied wp for simultaneous assignment [serial 1369]
 


Theorem (1486)                               [serial 1361] 
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + MinusOne)) and E_SS() and AXIOM_MO()) >>
S [101] |EstimatedActualPosition',Delta' := (EstimatedActualPosition - 1),-1|  
Q [15] << (((EstimatedActualPosition' = ACTUAL_POSITION')) and (Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1485:
Theorem (1485) [serial 1369] used for:
    normalization of [serial 1361]
 


Theorem (1487)                               [serial 1053] 
P [55] << (E_SS() and D_SS() and (((DESIRED_POSITION)^0 < EstimatedActualPosition))) >>
S [96] << (E_SS() and (DESIRED_POSITION < ACTUAL_POSITION) and AXIOM_MO()) >>
ActuatorCommand(pc:MinusOne)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + MinusOne)) and E_SS() and AXIOM_MO()) >>
;
|EstimatedActualPosition',Delta' := (EstimatedActualPosition - 1),-1|  
<< (((EstimatedActualPosition' = ACTUAL_POSITION')) and (Delta' = (ACTUAL_POSITION' - ACTUAL_POSITION))) >>
Q [53] << (E_SS() and D_SS())^1 >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 1436 1448 1453 1486:
Theorem (1436) [serial 1358] used for:
  P -> P1 in sequential composition for [serial 1053]
 
Theorem (1448) [serial 1359] used for:
  Q1 -> Q in sequential composition for [serial 1053]
 
Theorem (1453) [serial 1360] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1053]
 
Theorem (1486) [serial 1361] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1053]
 


Theorem (1488)                               [serial 1464] 
P [106] << D_SS() and E_SS() and stop@now and not (exists u~time
  in tops,,now 
  that stop@u ) and not (true) >>
S [106] ->
Q [57] << E_SS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1489)                               [serial 1463] 
P [106] << D_SS() and E_SS() and stop@now and not (exists u~time
  in tops,,now 
  that stop@u ) and not (exists u~time
  in tops,,now 
  that true ) >>
S [106] ->
Q [57] << E_SS() >>
by Existential Quantification Introduction
and theorem 1488:
Theorem (1488) [serial 1464] used for:
  Existential Quantification Introduction [serial 1463]
 


Theorem (1490)                               [serial 1461] 
P [106] << stop@now and not (exists u~time
  in tops,,now 
  that stop@u ) and not (exists u~time
  in tops,,now 
  that true ) and (D_SS() and E_SS()) >>
S [106] ->
Q [57] << E_SS() >>
by Associativity: (b.c).a = a.b.c
and theorem 1489:
Theorem (1489) [serial 1463] used for:
  Associativity: (b.c).a = a.b.c [serial 1461]
 


Theorem (1491)                               [serial 1054] 
P [106] << ((E_SS() and D_SS()) and stop@now and not (exists u~time
  in tops,,now 
  that true ) and not (exists u~time
  in tops,,now 
  that stop@u )) >>
S [106] ->
Q [57] << E_SS() >>
by Normalization
  Normalization Axioms:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1490:
Theorem (1490) [serial 1461] used for:
    normalization of [serial 1054]
 


Theorem (1492)                               [serial 1469] 
P [57] << 0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [108] ->
Q [61] << 0 = EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1493)                               [serial 1467] 
P [57] << 0 = EstimatedActualPosition and ACTUAL_POSITION = EstimatedActualPosition >>
S [108] ->
Q [61] << 0 = ACTUAL_POSITION >>
by Guided Substitution of Equals
and theorem 1492:
Theorem (1492) [serial 1469] used for:
  Guided Substitution of Equals
 replacing "ACTUAL_POSITION" with its = "EstimatedActualPosition" in its postcondition [serial 1467]
 


Theorem (1494)                               [serial 1465] 
P [57] << ((((EstimatedActualPosition = ACTUAL_POSITION))) and ((EstimatedActualPosition = 0))) >>
S [108] ->
Q [61] << (ACTUAL_POSITION = 0) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1493:
Theorem (1493) [serial 1467] used for:
    normalization of [serial 1465]
 


Theorem (1495)                               [serial 1055] 
P [57] << ((E_SS()) and ((EstimatedActualPosition = 0))) >>
S [108] ->
Q [61] << (ACTUAL_POSITION = 0) >>
by Substitution of Assertion Labels
and theorem 1494:
Theorem (1494) [serial 1465] used for:
  substituted Assertions' predicates for  labels in preconditions [serial 1055]
 


Theorem (1496)                               [serial 1517] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57] ->
Q [15] << 0 < EstimatedActualPosition >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1497)                               [serial 1512] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57] ->
Q [15] << 0 < EstimatedActualPosition >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 1496:
Theorem (1496) [serial 1517] used for:
   changing adding negation to subtraction  [serial 1512]
 


Theorem (1498)                               [serial 1507] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57] ->
Q [15] << (0 < EstimatedActualPosition) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1497:
Theorem (1497) [serial 1512] used for:
    normalization of [serial 1507]
 


Theorem (1499)                               [serial 1506] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57] ->
Q [15] << true and 0 < EstimatedActualPosition >>
by Law of And-Simplification:  P and true is P
and theorem 1498:
Theorem (1498) [serial 1507] used for:
  Law of And-Simplification:  P and true is P [serial 1506]
 


Theorem (1500)                               [serial 1504] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57] ->
Q [15] << EstimatedActualPosition = EstimatedActualPosition and 0 < EstimatedActualPosition >>
by Equality Law (idistr):  a=a <-> true
and theorem 1499:
Theorem (1499) [serial 1506] used for:
  Equality Law (idistr):  a=a <-> true [serial 1504]
 


Theorem (1501)                               [serial 1502] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57] ->
Q [15] << ACTUAL_POSITION = ACTUAL_POSITION and 0 < ACTUAL_POSITION >>
by Substitution in Postcondition of All Equivalents in Precondition
and theorem 1500:
Theorem (1500) [serial 1504] used for:
  Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1502]
 


Theorem (1502)                               [serial 1494] 
P [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < EstimatedActualPosition >>
S [57] ->
Q [15] << ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
by Substitution in Postcondition of All Equivalents in Precondition
and theorem 1501:
Theorem (1501) [serial 1502] used for:
  Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1494]
 


Theorem (1503)                               [serial 1490] 
P [15] << ((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < EstimatedActualPosition >>
S [57] ->
Q [15] << ((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1502:
Theorem (1502) [serial 1494] used for:
    normalization of [serial 1490]
 


Theorem (1504)                               [serial 1475] 
P [15] << E_SS() and 0 < EstimatedActualPosition >>
S [57] ->
Q [15] << E_SS() and 0 < ACTUAL_POSITION >>
by Substitution of Assertion Labels
and theorem 1503:
Theorem (1503) [serial 1490] used for:
  substituted Assertions' predicates for  labels  [serial 1475]
 


Theorem (1505)                               [serial 1470] 
P [15] << ((E_SS()) and ((EstimatedActualPosition > 0))) >>
S [57] ->
Q [15] << (E_SS() and (ACTUAL_POSITION > 0)) >>
by Normalization
  Normalization Axioms:
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1504:
Theorem (1504) [serial 1475] used for:
    normalization of [serial 1470]
 


Theorem (1506)                               [serial 1542] 
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION >>
S [59] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION >>
by Identity (id):  P->P is tautology


Theorem (1507)                               [serial 1539] 
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION >>
S [59] ->
Q [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION^0 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1506:
Theorem (1506) [serial 1542] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1539]
 


Theorem (1508)                               [serial 1535] 
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION >>
S [59] ->
Q [15] << ((ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1) and ((0)^1 < ACTUAL_POSITION^(-1+1)) >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Constants are always the same
and theorem 1507:
Theorem (1507) [serial 1539] used for:
    normalization of [serial 1535]
 


Theorem (1509)                               [serial 1528] 
P [15] << ACTUAL_POSITION^1 = EstimatedActualPosition^1 and 0 < ACTUAL_POSITION >>
S [59] ->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition)^1 and (0 < ACTUAL_POSITION^-1)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1508:
Theorem (1508) [serial 1535] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1528]
 


Theorem (1510)                               [serial 1525] 
P [15] << (ACTUAL_POSITION)^1 = (EstimatedActualPosition)^1 and 0 < ACTUAL_POSITION >>
S [59] ->
Q [15] << ((ACTUAL_POSITION = EstimatedActualPosition)^1 and (0 < ACTUAL_POSITION^-1)^1) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1509:
Theorem (1509) [serial 1528] used for:
    normalization of [serial 1525]
 


Theorem (1511)                               [serial 1519] 
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59] ->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION^-1)^1 >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1510:
Theorem (1510) [serial 1525] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1519]
 


Theorem (1512)                               [serial 1515] 
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59] ->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION^- 1)^1 >>
by Normalization
  Normalization Axiom:
    Unary Minus:  -(x-y) is (y-x)
and theorem 1511:
Theorem (1511) [serial 1519] used for:
    normalization of [serial 1515]
 


Theorem (1513)                               [serial 1496] 
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59] ->
Q [15] << (ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION^-1)^1 >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 1512:
Theorem (1512) [serial 1515] used for:
   changing adding negation to subtraction  [serial 1496]
 


Theorem (1514)                               [serial 1491] 
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59] ->
Q [15] << (((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION^-1)^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1513:
Theorem (1513) [serial 1496] used for:
    normalization of [serial 1491]
 


Theorem (1515)                               [serial 1477] 
P [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
S [59] ->
Q [15] << (E_SS() and 0 < ACTUAL_POSITION^-1)^1 >>
by Substitution of Assertion Labels
and theorem 1514:
Theorem (1514) [serial 1491] used for:
  substituted Assertions' predicates for  labels  [serial 1477]
 


Theorem (1516)                               [serial 1471] 
P [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION > 0)) >>
S [59] ->
Q [15] << (E_SS() and ((ACTUAL_POSITION^(-1) > 0)))^1 >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1515:
Theorem (1515) [serial 1477] used for:
    normalization of [serial 1471]
 


Theorem (1517)                               [serial 1489] 
P [15] << E_SS() and 0 < ACTUAL_POSITION >>
S [112] ->
Q [15] << E_SS() and 0 < ACTUAL_POSITION >>
by Identity (id):  P->P is tautology


Theorem (1518)                               [serial 1488] 
P [15] << E_SS() and 0 < ACTUAL_POSITION >>
S [112] ->
Q [15] << true and true and E_SS() and 0 < ACTUAL_POSITION >>
by Law of And-Simplification:  P and true is P
and theorem 1517:
Theorem (1517) [serial 1489] used for:
  Law of And-Simplification:  P and true is P [serial 1488]
 


Theorem (1519)                               [serial 1489] 
P [15] << E_SS() and 0 < ACTUAL_POSITION >>
S [112] ->
Q [15] << E_SS() and 0 < ACTUAL_POSITION >>
by Identity (id):  P->P is tautology


Theorem (1520)                               [serial 1488] 
P [15] << E_SS() and 0 < ACTUAL_POSITION >>
S [112] ->
Q [15] << true and true and E_SS() and 0 < ACTUAL_POSITION >>
by Law of And-Simplification:  P and true is P
and theorem 1519:
Theorem (1519) [serial 1489] used for:
  Law of And-Simplification:  P and true is P [serial 1488]
 


Theorem (1521)                               [serial 1486] 
P [15] << E_SS() and 0 < ACTUAL_POSITION >>
S [112] ->
Q [15] << true and AXIOM_MO() and E_SS() and 0 < ACTUAL_POSITION >>
by Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 1520 1520:
Theorem (1520) [serial 1488] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 
Theorem (1520) [serial 1488] used for:
   add user-defined axioms to postcondition:
  <<P>> S <<Q>> 
 ----------------
  <<P>> S <<Q and A>> 

 


Theorem (1522)                               [serial 1479] 
P [15] << E_SS() and 0 < ACTUAL_POSITION >>
S [112] ActuatorCommand(pc:MinusOne)
Q [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() and 
0 < ACTUAL_POSITION >>
by Subprogram Invocation: 
  <<P>> -> <<Q[post|pre]>>
  ----------------------
   <<P>> subprogram(X) <<Q>> (bl.si)
and theorem 1521:
Theorem (1521) [serial 1486] used for:
  applied weakest precondition predicate transformation to
+ <<P>> ActuatorCommand(X) <<Q>>
to get <<P>> -> <<Q[post|pre]>> [serial 1479]
 


Theorem (1523)                               [serial 1472] 
P [15] << (E_SS() and (ACTUAL_POSITION > 0)) >>
S [112] ActuatorCommand(pc:MinusOne)
Q [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + MinusOne)) and (ACTUAL_POSITION > 0) and 
E_SS() and AXIOM_MO()) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1522:
Theorem (1522) [serial 1479] used for:
    normalization of [serial 1472]
 


Theorem (1524)                               [serial 1543] 
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
S [116] ->
Q [15] << 0 < ACTUAL_POSITION >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1525)                               [serial 1537] 
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
S [116] ->
Q [15] << 0 < EstimatedActualPosition >>
by Substitution in Postcondition of All Equivalents in Precondition
and theorem 1524:
Theorem (1524) [serial 1543] used for:
  Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1537]
 


Theorem (1526)                               [serial 1534] 
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
S [116] ->
Q [15] << (0 < EstimatedActualPosition) >>
by Normalization
  Normalization Axiom:
    Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 1525:
Theorem (1525) [serial 1537] used for:
    normalization of [serial 1534]
 


Theorem (1527)                               [serial 1533] 
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
S [116] ->
Q [15] << true and 0 < EstimatedActualPosition >>
by Law of And-Simplification:  P and true is P
and theorem 1526:
Theorem (1526) [serial 1534] used for:
  Law of And-Simplification:  P and true is P [serial 1533]
 


Theorem (1528)                               [serial 1530] 
P [15] << -1 = MinusOne and ACTUAL_POSITION^1 = (ACTUAL_POSITION + MinusOne) and 
ACTUAL_POSITION = EstimatedActualPosition and 0 < ACTUAL_POSITION >>
S [116] ->
Q [15] << (-1 + EstimatedActualPosition) = (-1 + EstimatedActualPosition) and 0 < EstimatedActualPosition >>
by Equality Law (idistr):  a=a <-> true
and theorem 1527:
Theorem (1527) [serial 1533] used for:
  Equality Law (idistr):  a=a <-> true [serial 1530]
 


Theorem (1529)                               [serial 1526] 
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = (ACTUAL_POSITION)^1 and 0 < ACTUAL_POSITION >>
S [116] ->
Q [15] << (-1 + EstimatedActualPosition) = (-1 + EstimatedActualPosition) and 0 < EstimatedActualPosition >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1528:
Theorem (1528) [serial 1530] used for:
    normalization of [serial 1526]
 


Theorem (1530)                               [serial 1521] 
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116] ->
Q [15] << (-1 + EstimatedActualPosition) = (-1 + EstimatedActualPosition) and 0 < EstimatedActualPosition >>
by Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k
and theorem 1529:
Theorem (1529) [serial 1526] used for:
  Distribute Carets:  (A^k op B^k or C^k) is (A op B op C)^k [serial 1521]
 


Theorem (1531)                               [serial 1516] 
P [15] <<  -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116] ->
Q [15] << (EstimatedActualPosition +  -1) = ( -1 + EstimatedActualPosition) and 
0 < EstimatedActualPosition >>
by Normalization
  Normalization Axioms:
    Literal Arithmetic
    Reflexivity of Addition: a+b=b+a
    Reflexivity of Equality: (a=b) = (b=a)
    Unary Minus:  -(x-y) is (y-x)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1530:
Theorem (1530) [serial 1521] used for:
    normalization of [serial 1516]
 


Theorem (1532)                               [serial 1510] 
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116] ->
Q [15] << (EstimatedActualPosition - 1) = (-1 + EstimatedActualPosition) and 0 < EstimatedActualPosition >>
by Equivlence of negation and subtraction: (a-b) = (a + (-b))
and theorem 1531:
Theorem (1531) [serial 1516] used for:
   changing adding negation to subtraction  [serial 1510]
 


Theorem (1533)                               [serial 1505] 
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116] ->
Q [15] << (EstimatedActualPosition - 1) = (EstimatedActualPosition + -1) and 0 < EstimatedActualPosition >>
by Normalization
  Normalization Axiom:
    Reflexivity of Addition: a+b=b+a
and theorem 1532:
Theorem (1532) [serial 1510] used for:
    normalization of [serial 1505]
 


Theorem (1534)                               [serial 1503] 
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116] ->
Q [15] << (ACTUAL_POSITION - 1) = (ACTUAL_POSITION + MinusOne) and 0 < ACTUAL_POSITION >>
by Substitution in Postcondition of All Equivalents in Precondition
and theorem 1533:
Theorem (1533) [serial 1505] used for:
  Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1503]
 


Theorem (1535)                               [serial 1498] 
P [15] << -1 = MinusOne and ACTUAL_POSITION = EstimatedActualPosition and (ACTUAL_POSITION + 
MinusOne) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
S [116] ->
Q [15] << (EstimatedActualPosition - 1) = ACTUAL_POSITION' and 0 < ACTUAL_POSITION >>
by Substitution in Postcondition of All Equivalents in Precondition
and theorem 1534:
Theorem (1534) [serial 1503] used for:
  Substitution in Postcondition of All Equivalents in Precondition
 substituting in postcondition all equivalents in precondition [serial 1498]
 


Theorem (1536)                               [serial 1492] 
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and ((MinusOne = -1)) and 
((EstimatedActualPosition = ACTUAL_POSITION)) and 0 < ACTUAL_POSITION >>
S [116] ->
Q [15] << ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) and 0 < ACTUAL_POSITION >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1535:
Theorem (1535) [serial 1498] used for:
    normalization of [serial 1492]
 


Theorem (1537)                               [serial 1487] 
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() and 
0 < ACTUAL_POSITION >>
S [116] ->
Q [15] << ACTUAL_POSITION' = ((EstimatedActualPosition - 1)) and 0 < ACTUAL_POSITION >>
by Substitution of Assertion Labels
and theorem 1536:
Theorem (1536) [serial 1492] used for:
  substituted Assertions' predicates for  labels  [serial 1487]
 


Theorem (1538)                               [serial 1481] 
P [15] << (ACTUAL_POSITION + MinusOne) = ACTUAL_POSITION' and AXIOM_MO() and E_SS() and 
0 < ACTUAL_POSITION >>
S [116] EstimatedActualPosition' := (EstimatedActualPosition - 1)
Q [15] << ACTUAL_POSITION' = EstimatedActualPosition' and 0 < ACTUAL_POSITION >>
by Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>> (bl.a)
and theorem 1537:
Theorem (1537) [serial 1487] used for:
  applied wp for assignment [serial 1481]
 


Theorem (1539)                               [serial 1473] 
P [15] << ((ACTUAL_POSITION' = (ACTUAL_POSITION + MinusOne)) and (ACTUAL_POSITION > 0) and 
E_SS() and AXIOM_MO()) >>
S [116] EstimatedActualPosition' := (EstimatedActualPosition - 1)
Q [15] << ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION > 0)) >>
by Normalization
  Normalization Axioms:
    Reflexivity of Equality: (a=b) = (b=a)
    Irreflexivity of Greater Than: (a>b) = (b<a)
    Add Unnecessary Parentheses For No Good Reason: a = (a)
    Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 1538:
Theorem (1538) [serial 1481] used for:
    normalization of [serial 1473]
 


Theorem (1540)                               [serial 1056] 
P [57] << ((E_SS()) and ((EstimatedActualPosition > 0))) >>
S [111] << (E_SS() and (ACTUAL_POSITION > 0)) >>
ActuatorCommand(pc:MinusOne)
<< ((ACTUAL_POSITION' = (ACTUAL_POSITION + MinusOne)) and (ACTUAL_POSITION > 0) and E_SS() and AXIOM_MO()) >>
;
EstimatedActualPosition' := (EstimatedActualPosition - 1)
<< ((EstimatedActualPosition' = ACTUAL_POSITION') and (ACTUAL_POSITION > 0)) >>
Q [59] << (E_SS() and ((ACTUAL_POSITION^(-1) > 0)))^1 >>
by Sequential Composition Rule:
 <<P1>> S1 <<Q1 and P2>>
 <<Q1 and P2>> S2 <<Q2 and P3>>
 . . .
 <<Qk-1 and Pk>> Sk <<Qk>>
 _____________________________________________
 <<P1>> S1 <<Q1>> ; <<P2>> S2 <<Q2> ; . . . ; <<Pk>> Sk <<Qk>> (bl.sck)
and theorems 1505 1516 1523 1539:
Theorem (1505) [serial 1470] used for:
  P -> P1 in sequential composition for [serial 1056]
 
Theorem (1516) [serial 1471] used for:
  Q1 -> Q in sequential composition for [serial 1056]
 
Theorem (1523) [serial 1472] used for:
  <<P0>> S0 <<Q0 and P1>> in sequential composition for [serial 1056]
 
Theorem (1539) [serial 1473] used for:
  <<Q0 and P1>> S1 <<Q1>> in sequential composition for [serial 1056]
 


Theorem (1541)                               [serial 1057] 
P [57] << ((E_SS()) and ((EstimatedActualPosition < 0))) >>
S [120] ->
Q [62] << true >>
by True Conclusion Schema (tc): P->true


Theorem (1542)                               [serial 1058] 
P [59] << (E_SS() and ((ACTUAL_POSITION^(-1) > 0))) >>
S [121] ->
Q [57] << E_SS() >>
by And Introduction Schema (aisph):  (X and Y)->X


Theorem (1543)                               [serial 1043] 
P [40] <<   >>
S [40] ->
Q [40] << RobustPositionControlThread.SingleStep proof obligations >>
by Initial Thread Obligations
and theorems 1263 1264 1267 1268 1271 1302 1303 1355 1424 1487 1491 1495 1540 1541 1542:
Theorem (1263) [serial 1044] used for:
  <<M(StillClosing)>> -> <<I>> from invariant I when complete state StillClosing has Assertion <<M(StillClosing)>> in its definition.
 
Theorem (1264) [serial 1045] used for:
  <<M(Run)>> -> <<I>> from invariant I when complete state Run has Assertion <<M(Run)>> in its definition.
 
Theorem (1267) [serial 1046] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state ShutDown, <<M(ShutDown)>> -> <<e1 or e2 or . . . en>>
 
Theorem (1268) [serial 1047] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state PowerOn, <<M(PowerOn)>> -> <<e1 or e2 or . . . en>>
 
Theorem (1271) [serial 1048] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state Decide, <<M(Decide)>> -> <<e1 or e2 or . . . en>>
 
Theorem (1302) [serial 1049] used for:
   <<M(PowerOn)>> A <<M(Run)>> for one0po:PowerOn-[ ]->Run{A};
 
Theorem (1303) [serial 1050] used for:
   <<M(Run) and x>> -> <<M(Decide)>> for one1run:Run-[x]->Decide{};
 
Theorem (1355) [serial 1051] used for:
   <<M(Decide) and x>> A <<M(Run)>> for one2eq:Decide-[x]->Run{A};
 
Theorem (1424) [serial 1052] used for:
   <<M(Decide) and x>> A <<M(Run)>> for one3gt:Decide-[x]->Run{A};
 
Theorem (1487) [serial 1053] used for:
   <<M(Decide) and x>> A <<M(Run)>> for one4lt:Decide-[x]->Run{A};
 
Theorem (1491) [serial 1054] used for:
   <<M(Run) and x>> -> <<M(ShutDown)>> for one5stop:Run-[x]->ShutDown{};
 
Theorem (1495) [serial 1055] used for:
   <<M(ShutDown) and x>> -> <<M(Done)>> for one6done:ShutDown-[x]->Done{};
 
Theorem (1540) [serial 1056] used for:
   <<M(ShutDown) and x>> A <<M(StillClosing)>> for one7sc:ShutDown-[x]->StillClosing{A};
 
Theorem (1541) [serial 1057] used for:
   <<M(ShutDown) and x>> -> <<M(Error)>> for one8er:ShutDown-[x]->Error{};
 
Theorem (1542) [serial 1058] used for:
   <<M(StillClosing) and x>> -> <<M(ShutDown)>> for one9cl:StillClosing-[x]->ShutDown{};
 


Theorem (1544)                               [serial 1059] 
P [4] << (PositionSetpoint = DESIRED_POSITION) >>
S [2] ->
Q [5] << (PositionSetpoint = DESIRED_POSITION) >>
by Identity (id):  P->P is tautology


Theorem (1545)                               [serial 1001] 
P     
S     
Q     
by Initial Thread Obligations
and theorems 517 1262 1543 1544:
Theorem (517) [serial 1002] used for:
  Initial proof obligations for FragilePositionControlThread.SingleStep
 
Theorem (1262) [serial 1022] used for:
  Initial proof obligations for FragilePositionControlThread.MultiStep
 
Theorem (1543) [serial 1043] used for:
  Initial proof obligations for RobustPositionControlThread.SingleStep
 
Theorem (1544) [serial 1059] used for:
  Composition of Subcomponents via Directional Connection PositionSetpoint -> c.PositionSetpoint:
 PositionSetpoint -> PositionSetpoint
 


showing tree: Derivations
closing proof.txt file 
proof duration:  29.2 seconds 

