This file, proof.txt, was produced the BLESS Proof Assistant v3.2.4
  at Fri May 10 15:30:31 EDT 2024 by brianlarson

Theorem (1)                               [serial 1086] 
P [256] << MHR_A()
  and POA_A()
  and PSPO2_A() >>
S [242] ->
Q [242] << MHR_A()
  and POA_A()
  and PSPO2_A() >>
Why created:    normalization of [serial 1084]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (2)                               [serial 1084] 
P [256] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
S [242] ->
Q [242] << MHR_A()
  and PSPO2_A()
  and POA_A() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1003]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 1:
Theorem (1) [serial 1086] used for:
    normalization of [serial 1084] 


Theorem (3)                               [serial 1003] 
P [256] << INV_PO() >>
S [242] ->
Q [242] << MHR_A()
  and PSPO2_A()
  and POA_A() >>
Why created:  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 2:
Theorem (2) [serial 1084] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1003] 


Theorem (4)                               [serial 1089] 
P [255] << MHR_A()
  and POA_A()
  and PSPO2_A() >>
S [242] ->
Q [242] << MHR_A()
  and POA_A()
  and PSPO2_A() >>
Why created:    normalization of [serial 1087]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (5)                               [serial 1087] 
P [255] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
S [242] ->
Q [242] << MHR_A()
  and PSPO2_A()
  and POA_A() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1004]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 4:
Theorem (4) [serial 1089] used for:
    normalization of [serial 1087] 


Theorem (6)                               [serial 1004] 
P [255] << INV_PO() >>
S [242] ->
Q [242] << MHR_A()
  and PSPO2_A()
  and POA_A() >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 5:
Theorem (5) [serial 1087] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1004] 


Theorem (7)                               [serial 1005] 
P [254] << INV_PO() >>
S [254] ->
Q [254] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by: Anything Implies True (a1tru): P->true

Theorem (8)                               [serial 1006] 
P [254] << INV_PO() >>
S [258] ->
Q [255] << INV_PO() >>
Why created:   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{};
Solved by: Identity (id):  P->P is tautology

Theorem (9)                               [serial 1090] 
P [255] << INV_PO() >>
S [255] ->
Q [261] << INV_PO() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1007]
Solved by: Identity (id):  P->P is tautology

Theorem (10)                               [serial 1091] 
P [288] << INV_PO() >>
S [256] ->
Q [256] << INV_PO() >>
Why created:  <<Q3>> -> <<Q>> in sequential composition for [serial 1007]
Solved by: Identity (id):  P->P is tautology

Theorem (11)                               [serial 1162] 
P [262] << HEART_RATE = hrr
  and INV_PO() >>
S [262] ->
Q [263] << HEART_RATE = hrr
  and INV_PO() >>
Why created:    normalization of [serial 1160]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (12)                               [serial 1160] 
P [262] << ( INV_PO() )
  and hrr = HEART_RATE >>
S [262] ->
Q [263] << HEART_RATE = hrr
  and INV_PO() >>
Why created:  applied port input of value <<pre and hrr=M(Heart_Rate)>> -> <<post>> [serial 1115]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 11:
Theorem (11) [serial 1162] used for:
    normalization of [serial 1160] 


Theorem (13)                               [serial 1115] 
P [261] << INV_PO() >>
S [262] Heart_Rate?(hrr)
Q [263] << HEART_RATE = hrr
  and INV_PO() >>
Why created:    normalization of [serial 1092]
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 12:
Theorem (12) [serial 1160] used for:
  applied port input of value <<pre and hrr=M(Heart_Rate)>> -> <<post>> [serial 1115] 


Theorem (14)                               [serial 1092] 
P [261] << INV_PO() >>
S [262] Heart_Rate?(hrr)
Q [263] << hrr = HEART_RATE
  and INV_PO() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1007]
Solved by: Equality Commutes. (eqcom) and theorem 13:
Theorem (13) [serial 1115] used for:
    normalization of [serial 1092] 


Theorem (15)                               [serial 1165] 
P [264] << ( HEART_RATE = hrr
  and INV_PO() )
  and SPO2 = sp >>
S [264] ->
Q [265] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1163]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (16)                               [serial 1163] 
P [264] << ( HEART_RATE = hrr
  and INV_PO() )
  and sp = SPO2 >>
S [264] ->
Q [265] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:  applied port input of value <<pre and sp=M(Spo2_Level)>> -> <<post>> [serial 1117]
Solved by: Equality Commutes. (eqcom) and theorem 15:
Theorem (15) [serial 1165] used for:
    normalization of [serial 1163] 


Theorem (17)                               [serial 1117] 
P [263] << HEART_RATE = hrr
  and INV_PO() >>
S [264] Spo2_Level?(sp)
Q [265] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1093]
  Using: (eqcom) (bl.ancom) 
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 16:
Theorem (16) [serial 1163] used for:
  applied port input of value <<pre and sp=M(Spo2_Level)>> -> <<post>> [serial 1117] 


Theorem (18)                               [serial 1093] 
P [263] << hrr = HEART_RATE
  and INV_PO() >>
S [264] Spo2_Level?(sp)
Q [265] << hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1007]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 17:
Theorem (17) [serial 1117] used for:
    normalization of [serial 1093] 


Theorem (19)                               [serial 1170] 
P [265] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [267] ->
Q [267] << ( not ( hrr < mhr ) or hrr < mhr or sp < psp )
  and ( not ( sp < psp ) or hrr < mhr or sp < psp ) >>
Why created:  Distributing Postcondition Or-Over-And [serial 1169]
Solved by: Law of Excluded middle. (exmid)

Theorem (20)                               [serial 1169] 
P [265] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [267] ->
Q [267] << ( not ( hrr < mhr )
  and not ( sp < psp ) ) or hrr < mhr or sp < psp >>
Why created:    normalization of [serial 1167]
Solved by: Distribution and-over-or with wff lists. (bl.dba2owl) and theorem 19:
Theorem (19) [serial 1170] used for:
  Distributing Postcondition Or-Over-And [serial 1169] 


Theorem (21)                               [serial 1167] 
P [265] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [267] ->
Q [267] << ( ( not ( hrr < mhr ) )
  and ( not ( sp < psp ) ) ) or hrr < mhr or sp < psp >>
Why created:  Replacing <= with not < of [serial 1119]
Solved by: [Add unnecessary parentheses] and theorem 20:
Theorem (20) [serial 1169] used for:
    normalization of [serial 1167] 


Theorem (22)                               [serial 1119] 
P [265] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [267] ->
Q [267] << ( mhr <= hrr
  and psp <= sp ) or hrr < mhr or sp < psp >>
Why created:    normalization of [serial 1095]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) (bl.orcom) 
Solved by: 'Less than' expressed in terms of 'less than or equal to'. (ltnle) and theorem 21:
Theorem (21) [serial 1167] used for:
  Replacing <= with not < of [serial 1119] 


Theorem (23)                               [serial 1095] 
P [265] << hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 >>
S [267] ->
Q [267] << ( hrr >= mhr
  and sp >= psp ) or ( hrr < mhr ) or ( sp < psp ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1094]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 22:
Theorem (22) [serial 1119] used for:
    normalization of [serial 1095] 


Theorem (24)                               [serial 1121] 
P [267] << ( mhr <= hrr
  and psp <= sp )
  and ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() ) >>
S [270] ->
Q [270] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1102]
  Using: (eqcom) changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (25)                               [serial 1102] 
P [267] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr >= mhr
  and sp >= psp ) >>
S [270] ->
Q [270] << hrr = HEART_RATE
  and hrr >= mhr
  and sp = SPO2
  and sp >= psp
  and INV_PO() >>
Why created:  P -> P1 in concurrent composition for [serial 1099]
Solved by: Equality Commutes. (eqcom) [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 24:
Theorem (24) [serial 1121] used for:
    normalization of [serial 1102] 


Theorem (26)                               [serial 1103] 
P [272] << INV_PO() >>
S [272] ->
Q [288] << INV_PO() >>
Why created:  Qk -> Q in concurrent composition for [serial 1099]
Solved by: Identity (id):  P->P is tautology

Theorem (27)                               [serial 1179] 
P [270] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [271] ->
Q [288] << ( LOW_SPO2_HR() iff false )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:  applied wp for assignment [serial 1178]
Solved by: The negation of a proposition is equivalent to itself being equivalent to false. (nbfal)

Theorem (28)                               [serial 1178] 
P [270] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [271] poa := false
Q [288] << ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:    normalization of [serial 1176]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 27:
Theorem (27) [serial 1179] used for:
  applied wp for assignment [serial 1178] 


Theorem (29)                               [serial 1176] 
P [270] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [271] poa := false
Q [288] << ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1175]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 28:
Theorem (28) [serial 1178] used for:
    normalization of [serial 1176] 


Theorem (30)                               [serial 1175] 
P [270] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [271] poa := false
Q [288] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1123]
Solved by: Predicate Invocation. (PI) and theorem 29:
Theorem (29) [serial 1176] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1175] 


Theorem (31)                               [serial 1123] 
P [270] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [271] poa := false
Q [288] << INV_PO() >>
Why created:    normalization of [serial 1104]
  Using: (eqcom) changeAtLeastToAtMost (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 30:
Theorem (30) [serial 1175] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1123] 


Theorem (32)                               [serial 1104] 
P [270] << hrr = HEART_RATE
  and hrr >= mhr
  and sp = SPO2
  and sp >= psp
  and INV_PO() >>
S [271] poa := false
Q [288] << INV_PO() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1099]
Solved by: Equality Commutes. (eqcom) [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 31:
Theorem (31) [serial 1123] used for:
    normalization of [serial 1104] 


Theorem (33)                               [serial 1125] 
P [267] << ( mhr <= hrr
  and psp <= sp )
  and ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() ) >>
S [271] PO_Alarm!(false)
Q [272] << INV_PO() >>
Why created:    normalization of [serial 1105]
  Using: (eqcom) changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (34)                               [serial 1105] 
P [267] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr >= mhr
  and sp >= psp ) >>
S [271] PO_Alarm!(false)
Q [272] << INV_PO() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1099]
Solved by: Equality Commutes. (eqcom) [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 33:
Theorem (33) [serial 1125] used for:
    normalization of [serial 1105] 


Theorem (35)                               [serial 1099] 
P [267] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr >= mhr
  and sp >= psp ) >>
S [270]   << hrr = HEART_RATE
    and hrr >= mhr
    and sp = SPO2
    and sp >= psp
    and INV_PO() >>
  poa := false
  &
  PO_Alarm!(false)
  << INV_PO() >> 
Q [288] << INV_PO() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1096]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 25 26 32 34:
Theorem (25) [serial 1102] used for:
  P -> P1 in concurrent composition for [serial 1099] 
Theorem (26) [serial 1103] used for:
  Qk -> Q in concurrent composition for [serial 1099] 
Theorem (32) [serial 1104] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1099] 
Theorem (34) [serial 1105] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1099] 


Theorem (36)                               [serial 1096] 
P [267] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr >= mhr
  and sp >= psp ) >>
S [269]   {
    << hrr = HEART_RATE
      and hrr >= mhr
      and sp = SPO2
      and sp >= psp
      and INV_PO() >>
    poa := false
    &
    PO_Alarm!(false)
    << INV_PO() >> 
  } 
Q [288] << INV_PO() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1094]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 35:
Theorem (35) [serial 1099] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1096] 


Theorem (37)                               [serial 1127] 
P [267] << ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() )
  and hrr < mhr >>
S [277] ->
Q [277] << hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1106]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (38)                               [serial 1106] 
P [267] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr < mhr ) >>
S [277] ->
Q [277] << hrr = HEART_RATE
  and hrr < mhr
  and sp = SPO2
  and INV_PO() >>
Why created:  P -> P1 in concurrent composition for [serial 1100]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 37:
Theorem (37) [serial 1127] used for:
    normalization of [serial 1106] 


Theorem (39)                               [serial 1107] 
P [279] << INV_PO() >>
S [279] ->
Q [288] << INV_PO() >>
Why created:  Qk -> Q in concurrent composition for [serial 1100]
Solved by: Identity (id):  P->P is tautology

Theorem (40)                               [serial 1240] 
P [277] << ( ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp )
  and hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp >>
S [278] poa := true
Q [288] << ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:    normalization of [serial 1238]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (41)                               [serial 1238] 
P [277] << hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp
  and ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
S [278] poa := true
Q [288] << ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1237]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 40:
Theorem (40) [serial 1240] used for:
    normalization of [serial 1238] 


Theorem (42)                               [serial 1237] 
P [277] << hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp
  and ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
S [278] poa := true
Q [288] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1129]
Solved by: Predicate Invocation. (PI) and theorem 41:
Theorem (41) [serial 1238] used for:
  Substituted assertions' predicates for labels  [serial 1237] 


Theorem (43)                               [serial 1129] 
P [277] << hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [278] poa := true
Q [288] << INV_PO() >>
Why created:    normalization of [serial 1108]
  Using: (eqcom) (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 42:
Theorem (42) [serial 1237] used for:
  Substituted assertions' predicates for labels  [serial 1129] 


Theorem (44)                               [serial 1108] 
P [277] << hrr = HEART_RATE
  and hrr < mhr
  and sp = SPO2
  and INV_PO() >>
S [278] poa := true
Q [288] << INV_PO() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1100]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 43:
Theorem (43) [serial 1129] used for:
    normalization of [serial 1108] 


Theorem (45)                               [serial 1131] 
P [267] << ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() )
  and hrr < mhr >>
S [278] PO_Alarm!(true)
Q [279] << INV_PO() >>
Why created:    normalization of [serial 1109]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (46)                               [serial 1109] 
P [267] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr < mhr ) >>
S [278] PO_Alarm!(true)
Q [279] << INV_PO() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1100]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 45:
Theorem (45) [serial 1131] used for:
    normalization of [serial 1109] 


Theorem (47)                               [serial 1100] 
P [267] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr < mhr ) >>
S [277]   << hrr = HEART_RATE
    and hrr < mhr
    and sp = SPO2
    and INV_PO() >>
  poa := true
  &
  PO_Alarm!(true)
  << INV_PO() >> 
Q [288] << INV_PO() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1097]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 38 39 44 46:
Theorem (38) [serial 1106] used for:
  P -> P1 in concurrent composition for [serial 1100] 
Theorem (39) [serial 1107] used for:
  Qk -> Q in concurrent composition for [serial 1100] 
Theorem (44) [serial 1108] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1100] 
Theorem (46) [serial 1109] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1100] 


Theorem (48)                               [serial 1097] 
P [267] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr < mhr ) >>
S [276]   {
    << hrr = HEART_RATE
      and hrr < mhr
      and sp = SPO2
      and INV_PO() >>
    poa := true
    &
    PO_Alarm!(true)
    << INV_PO() >> 
  } 
Q [288] << INV_PO() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1094]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 47:
Theorem (47) [serial 1100] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1097] 


Theorem (49)                               [serial 1133] 
P [267] << ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() )
  and sp < psp >>
S [283] ->
Q [283] << sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1110]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (50)                               [serial 1110] 
P [267] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( sp < psp ) >>
S [283] ->
Q [283] << hrr = HEART_RATE
  and sp < psp
  and sp = SPO2
  and INV_PO() >>
Why created:  P -> P1 in concurrent composition for [serial 1101]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 49:
Theorem (49) [serial 1133] used for:
    normalization of [serial 1110] 


Theorem (51)                               [serial 1111] 
P [285] << INV_PO() >>
S [285] ->
Q [288] << INV_PO() >>
Why created:  Qk -> Q in concurrent composition for [serial 1101]
Solved by: Identity (id):  P->P is tautology

Theorem (52)                               [serial 1260] 
P [283] << ( ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp )
  and sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp >>
S [284] ->
Q [288] << ( LOW_SPO2_HR() iff true )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:  applied wp for assignment [serial 1259]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (53)                               [serial 1259] 
P [283] << ( ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp )
  and sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp >>
S [284] poa := true
Q [288] << ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:    normalization of [serial 1257]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 52:
Theorem (52) [serial 1260] used for:
  applied wp for assignment [serial 1259] 


Theorem (54)                               [serial 1257] 
P [283] << sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp
  and ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
S [284] poa := true
Q [288] << ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1256]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 53:
Theorem (53) [serial 1259] used for:
    normalization of [serial 1257] 


Theorem (55)                               [serial 1256] 
P [283] << sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp
  and ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
S [284] poa := true
Q [288] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1135]
Solved by: Predicate Invocation. (PI) and theorem 54:
Theorem (54) [serial 1257] used for:
  Substituted assertions' predicates for labels  [serial 1256] 


Theorem (56)                               [serial 1135] 
P [283] << sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [284] poa := true
Q [288] << INV_PO() >>
Why created:    normalization of [serial 1112]
  Using: (eqcom) (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 55:
Theorem (55) [serial 1256] used for:
  Substituted assertions' predicates for labels  [serial 1135] 


Theorem (57)                               [serial 1112] 
P [283] << hrr = HEART_RATE
  and sp < psp
  and sp = SPO2
  and INV_PO() >>
S [284] poa := true
Q [288] << INV_PO() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1101]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 56:
Theorem (56) [serial 1135] used for:
    normalization of [serial 1112] 


Theorem (58)                               [serial 1137] 
P [267] << ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() )
  and sp < psp >>
S [284] PO_Alarm!(true)
Q [285] << INV_PO() >>
Why created:    normalization of [serial 1113]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (59)                               [serial 1113] 
P [267] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( sp < psp ) >>
S [284] PO_Alarm!(true)
Q [285] << INV_PO() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1101]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 58:
Theorem (58) [serial 1137] used for:
    normalization of [serial 1113] 


Theorem (60)                               [serial 1101] 
P [267] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( sp < psp ) >>
S [283]   << hrr = HEART_RATE
    and sp < psp
    and sp = SPO2
    and INV_PO() >>
  poa := true
  &
  PO_Alarm!(true)
  << INV_PO() >> 
Q [288] << INV_PO() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1098]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 50 51 57 59:
Theorem (50) [serial 1110] used for:
  P -> P1 in concurrent composition for [serial 1101] 
Theorem (51) [serial 1111] used for:
  Qk -> Q in concurrent composition for [serial 1101] 
Theorem (57) [serial 1112] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1101] 
Theorem (59) [serial 1113] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1101] 


Theorem (61)                               [serial 1098] 
P [267] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( sp < psp ) >>
S [282]   {
    << hrr = HEART_RATE
      and sp < psp
      and sp = SPO2
      and INV_PO() >>
    poa := true
    &
    PO_Alarm!(true)
    << INV_PO() >> 
  } 
Q [288] << INV_PO() >>
Why created:    <<P and B2>> S2 <<Q>> in alternative for [serial 1094]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 60:
Theorem (60) [serial 1101] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1098] 


Theorem (62)                               [serial 1094] 
P [265] << hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 >>
S [267]   if 
    (hrr >= mhr
    and sp >= psp)~> 
        {
          << hrr = HEART_RATE
            and hrr >= mhr
            and sp = SPO2
            and sp >= psp
            and INV_PO() >>
          poa := false
          &
          PO_Alarm!(false)
          << INV_PO() >> 
        }  
  []
    (hrr < mhr)~> 
        {
          << hrr = HEART_RATE
            and hrr < mhr
            and sp = SPO2
            and INV_PO() >>
          poa := true
          &
          PO_Alarm!(true)
          << INV_PO() >> 
        }  
  []
    (sp < psp)~> 
        {
          << hrr = HEART_RATE
            and sp < psp
            and sp = SPO2
            and INV_PO() >>
          poa := true
          &
          PO_Alarm!(true)
          << INV_PO() >> 
        }  
  fi
Q [288] << INV_PO() >>
Why created:  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1007]
Solved by: and theorems 23 36 48 61:
Theorem (23) [serial 1095] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1094] 
Theorem (36) [serial 1096] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1094] 
Theorem (48) [serial 1097] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1094] 
Theorem (61) [serial 1098] used for:
    <<P and B2>> S2 <<Q>> in alternative for [serial 1094] 


Theorem (63)                               [serial 1007] 
P [255] << INV_PO() >>
S [261]   << INV_PO() >>
  Heart_Rate?(hrr)
  ;
  << hrr = HEART_RATE
    and INV_PO() >>
  Spo2_Level?(sp)
  << hrr = HEART_RATE
    and INV_PO()
    and sp = SPO2 >>
  ;
    if 
      (hrr >= mhr
      and sp >= psp)~> 
          {
            << hrr = HEART_RATE
              and hrr >= mhr
              and sp = SPO2
              and sp >= psp
              and INV_PO() >>
            poa := false
            &
            PO_Alarm!(false)
            << INV_PO() >> 
          }  
    []
      (hrr < mhr)~> 
          {
            << hrr = HEART_RATE
              and hrr < mhr
              and sp = SPO2
              and INV_PO() >>
            poa := true
            &
            PO_Alarm!(true)
            << INV_PO() >> 
          }  
    []
      (sp < psp)~> 
          {
            << hrr = HEART_RATE
              and sp < psp
              and sp = SPO2
              and INV_PO() >>
            poa := true
            &
            PO_Alarm!(true)
            << INV_PO() >> 
          }  
    fi
  << INV_PO() >> 
Q [256] << INV_PO() >>
Why created:   <<M(run) and x>> A <<M(check_echo)>> for got_hrr_spo2: run-[x]->check_echo{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 9 10 14 18 62:
Theorem (9) [serial 1090] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1007] 
Theorem (10) [serial 1091] used for:
  <<Q3>> -> <<Q>> in sequential composition for [serial 1007] 
Theorem (14) [serial 1092] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1007] 
Theorem (18) [serial 1093] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1007] 
Theorem (62) [serial 1094] used for:
  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1007] 


Theorem (64)                               [serial 1355] 
P [290] << ( INV_PO() )
  and ( PO_Alarm_Echo@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [290] ->
Q [292] << INV_PO()
  and PO_Alarm_Echo@now >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1008]
Solved by: And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

Theorem (65)                               [serial 1356] 
P [302] << INV_PO() >>
S [255] ->
Q [255] << INV_PO() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1008]
Solved by: Identity (id):  P->P is tautology

Theorem (66)                               [serial 1358] 
P [292] << ( INV_PO()
  and PO_Alarm_Echo@now )
  and ( echo_val iff PO_Alarm_Echo@now ) >>
S [294] ->
Q [294] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
Why created:  <<P and v=e>> -> <<A>> in behavior action block for [serial 1357]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (67)                               [serial 1361] 
P [294] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
S [294] ->
Q [294] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1359]
Solved by: Identity (id):  P->P is tautology

Theorem (68)                               [serial 1362] 
P [300] << INV_PO() >>
S [300] ->
Q [300] << INV_PO() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1359]
Solved by: Identity (id):  P->P is tautology

Theorem (69)                               [serial 1372] 
P [294] << ( PO_Alarm_Echo iff echo_val )
  and INV_PO() >>
S [295] ->
Q [295] << ( echo_val iff poa ) or not ( echo_val iff poa ) >>
Why created:    normalization of [serial 1364]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (70)                               [serial 1364] 
P [294] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
S [295] ->
Q [295] << ( echo_val iff poa ) or ( not ( echo_val iff poa ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1363]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 69:
Theorem (69) [serial 1372] used for:
    normalization of [serial 1364] 


Theorem (71)                               [serial 1376] 
P [295] << ( ( PO_Alarm_Echo iff echo_val )
  and INV_PO() )
  and ( echo_val iff poa ) >>
S [296] ->
Q [300] << INV_PO() >>
Why created:    normalization of [serial 1374]
  Using: (bicom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (72)                               [serial 1374] 
P [295] << ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( echo_val iff poa ) >>
S [296] ->
Q [300] << INV_PO() >>
Why created:    <<P>> -> <<Q>>
  for [serial 1365]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 71:
Theorem (71) [serial 1376] used for:
    normalization of [serial 1374] 


Theorem (73)                               [serial 1365] 
P [295] << ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( echo_val iff poa ) >>
S [296] skip
Q [300] << INV_PO() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1363]
Solved by:  Skip Means Implication:  <<P>> skip <<Q>>  is  <<P>> -> <<Q>>
 and theorem 72:
Theorem (72) [serial 1374] used for:
    <<P>> -> <<Q>>
  for [serial 1365] 


Theorem (74)                               [serial 1384] 
P [295] << ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( not ( echo_val iff poa ) ) >>
S [298] ->
Q [298] << true >>
Why created:  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1366]
Solved by: Anything Implies True (a1tru): P->true

Theorem (75)                               [serial 1388] 
P [298] << ( ( ( PO_Alarm_Echo iff echo_val )
  and INV_PO() )
  and not ( echo_val iff poa ) )
  and true >>
S [298] ->
Q [300] << INV_PO() >>
Why created:    normalization of [serial 1386]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (76)                               [serial 1386] 
P [298] << ( ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( not ( echo_val iff poa ) ) )
  and true >>
S [298] ->
Q [300] << INV_PO() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1385]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 75:
Theorem (75) [serial 1388] used for:
    normalization of [serial 1386] 


Theorem (77)                               [serial 1385] 
P [298] << ( ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( not ( echo_val iff poa ) ) )
  and true@now >>
S [298] ->
Q [300] << INV_PO() >>
Why created:  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1366]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 76:
Theorem (76) [serial 1386] used for:
  Assume Present:  P = P@now = P^0   [serial 1385] 


Theorem (78)                               [serial 1366] 
P [295] << ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( not ( echo_val iff poa ) ) >>
S [298] Lost_Confirmation!
Q [300] << INV_PO() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1363]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 74 77:
Theorem (74) [serial 1384] used for:
  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1366] 
Theorem (77) [serial 1385] used for:
  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1366] 


Theorem (79)                               [serial 1363] 
P [294] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
S [295]   if 
    (echo_val iff poa)~> 
      skip 
  []
    (not ( echo_val iff poa ))~> 
      Lost_Confirmation! 
  fi
Q [300] << INV_PO() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1359]
Solved by: and theorems 70 73 78:
Theorem (70) [serial 1364] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1363] 
Theorem (73) [serial 1365] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1363] 
Theorem (78) [serial 1366] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1363] 


Theorem (80)                               [serial 1359] 
P [294] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
S [294] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
  if 
    (echo_val iff poa)~> 
      skip 
  []
    (not ( echo_val iff poa ))~> 
      Lost_Confirmation! 
  fi
<< INV_PO() >>
Q [300] << INV_PO() >>
Why created:  <<A>> S <<B>> in behavior action block for [serial 1357]
Solved by: null and theorems 67 68 79:
Theorem (67) [serial 1361] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1359] 
Theorem (68) [serial 1362] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1359] 
Theorem (79) [serial 1363] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1359] 


Theorem (81)                               [serial 1360] 
P [300] << INV_PO() >>
S [293] ->
Q [302] << INV_PO() >>
Why created:  <<B>> -> <<Q>> in behavior action block for [serial 1357]
Solved by: Identity (id):  P->P is tautology

Theorem (82)                               [serial 1357] 
P [292] << INV_PO()
  and PO_Alarm_Echo@now >>
S [293] declare 
   echo_val ~ boolean := PO_Alarm_Echo?   {
  << INV_PO()
    and ( echo_val iff PO_Alarm_Echo ) >>
    if 
      (echo_val iff poa)~> 
        skip 
    []
      (not ( echo_val iff poa ))~> 
        Lost_Confirmation! 
    fi
  << INV_PO() >>
  } 
Q [302] << INV_PO() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1008]
Solved by: Behavior Action Block (BAB): 
     <<P and x=e>> -> <<A>>
     <<A>> S <<B>> 
     <<B>> -> <<Q>>
----------------------------------------------------
<<P>> declare variable v~y:=e; { <<A>> S <<B>> } <<Q>> and theorems 66 80 81:
Theorem (66) [serial 1358] used for:
  <<P and v=e>> -> <<A>> in behavior action block for [serial 1357] 
Theorem (80) [serial 1359] used for:
  <<A>> S <<B>> in behavior action block for [serial 1357] 
Theorem (81) [serial 1360] used for:
  <<B>> -> <<Q>> in behavior action block for [serial 1357] 


Theorem (83)                               [serial 1008] 
P [290] << ( INV_PO() )
  and ( PO_Alarm_Echo@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [292] << INV_PO()
  and PO_Alarm_Echo@now >>
declare 
   echo_val ~ boolean := PO_Alarm_Echo?   {
  << INV_PO()
    and ( echo_val iff PO_Alarm_Echo ) >>
    if 
      (echo_val iff poa)~> 
        skip 
    []
      (not ( echo_val iff poa ))~> 
        Lost_Confirmation! 
    fi
  << INV_PO() >>
  } 
<< INV_PO() >>
Q [255] << INV_PO() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A};
Solved by: null and theorems 64 65 82:
Theorem (64) [serial 1355] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1008] 
Theorem (65) [serial 1356] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1008] 
Theorem (82) [serial 1357] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1008] 


Theorem (84)                               [serial 1398] 
P [304] << ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and INV_PO()
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [305] ->
Q [305] << true >>
Why created:    normalization of [serial 1394]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (85)                               [serial 1394] 
P [304] << ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [305] ->
Q [305] << true >>
Why created:  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1393]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 84:
Theorem (84) [serial 1398] used for:
    normalization of [serial 1394] 


Theorem (86)                               [serial 1400] 
P [305] << ( ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and INV_PO()
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) )
  and true >>
S [305] ->
Q [255] << INV_PO() >>
Why created:    normalization of [serial 1396]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (87)                               [serial 1396] 
P [305] << ( ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) )
  and true >>
S [305] ->
Q [255] << INV_PO() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1395]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 86:
Theorem (86) [serial 1400] used for:
    normalization of [serial 1396] 


Theorem (88)                               [serial 1395] 
P [305] << ( ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) )
  and true@now >>
S [305] ->
Q [255] << INV_PO() >>
Why created:  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1393]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 87:
Theorem (87) [serial 1396] used for:
  Assume Present:  P = P@now = P^0   [serial 1395] 


Theorem (89)                               [serial 1393] 
P [304] << ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [305] Lost_Confirmation!
Q [255] << INV_PO() >>
Why created:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1009]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 85 88:
Theorem (85) [serial 1394] used for:
  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1393] 
Theorem (88) [serial 1395] used for:
  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1393] 


Theorem (90)                               [serial 1009] 
P [304] << ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [305] Lost_Confirmation!
Q [255] << INV_PO() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A};
Solved by: null and theorem 89:
Theorem (89) [serial 1393] used for:
  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1009] 


Theorem (91)                               [serial 1002] 
P [236] <<   >>
S [242] ->
Q [236] << Pulse_Oximeter_Thread.impl proof obligations >>
Why created:  Initial proof obligations for Pulse_Oximeter_Thread.impl
Solved by:  Component verification conditions
 and theorems 3 6 7 8 63 83 90:
Theorem (3) [serial 1003] used for:
  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition. 
Theorem (6) [serial 1004] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (7) [serial 1005] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (8) [serial 1006] used for:
   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{}; 
Theorem (63) [serial 1007] used for:
   <<M(run) and x>> A <<M(check_echo)>> for got_hrr_spo2: run-[x]->check_echo{A}; 
Theorem (83) [serial 1008] used for:
   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A}; 
Theorem (90) [serial 1009] used for:
   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A}; 


Theorem (92)                               [serial 1011] 
P [407] << RA()
  and MRP_A() >>
S [397] ->
Q [397] << RA()
  and MRP_A() >>
Why created:  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition.
Solved by: Identity (id):  P->P is tautology

Theorem (93)                               [serial 1012] 
P [406] << RA()
  and MRP_A() >>
S [397] ->
Q [397] << RA()
  and MRP_A() >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by: Identity (id):  P->P is tautology

Theorem (94)                               [serial 1013] 
P [405] << RA()
  and MRP_A() >>
S [405] ->
Q [405] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by: Anything Implies True (a1tru): P->true

Theorem (95)                               [serial 1014] 
P [405] << RA()
  and MRP_A() >>
S [409] ->
Q [406] << RA()
  and MRP_A() >>
Why created:   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{};
Solved by: Identity (id):  P->P is tautology

Theorem (96)                               [serial 1445] 
P [412] << ( MRP_A()
  and RA() )
  and rpr = RESPIRATION_RATE >>
S [412] ->
Q [413] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
Why created:  applied port input of value <<pre and rpr=M(RP_Rate)>> -> <<post>> [serial 1422]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (97)                               [serial 1422] 
P [406] << MRP_A()
  and RA() >>
S [412] RP_Rate?(rpr)
Q [413] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1406]
  Using: (eqcom) (bl.ancom) 
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 96:
Theorem (96) [serial 1445] used for:
  applied port input of value <<pre and rpr=M(RP_Rate)>> -> <<post>> [serial 1422] 


Theorem (98)                               [serial 1406] 
P [406] << RA()
  and MRP_A() >>
S [412] RP_Rate?(rpr)
Q [413] << rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1015]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 97:
Theorem (97) [serial 1422] used for:
    normalization of [serial 1406] 


Theorem (99)                               [serial 1451] 
P [413] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [415] ->
Q [415] << rpr < mrp or not ( rpr < mrp ) >>
Why created:    normalization of [serial 1449]
  Using: ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (100)                               [serial 1449] 
P [413] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [415] ->
Q [415] << rpr < mrp or ( not ( rpr < mrp ) ) >>
Why created:  Replacing <= with not < of [serial 1424]
Solved by: [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 99:
Theorem (99) [serial 1451] used for:
    normalization of [serial 1449] 


Theorem (101)                               [serial 1424] 
P [413] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [415] ->
Q [415] << rpr < mrp or mrp <= rpr >>
Why created:    normalization of [serial 1408]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.orcom) 
Solved by: 'Less than' expressed in terms of 'less than or equal to'. (ltnle) and theorem 100:
Theorem (100) [serial 1449] used for:
  Replacing <= with not < of [serial 1424] 


Theorem (102)                               [serial 1408] 
P [413] << rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() >>
S [415] ->
Q [415] << ( rpr >= mrp ) or ( rpr < mrp ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1407]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Disjunction Commutes. (bl.orcom) and theorem 101:
Theorem (101) [serial 1424] used for:
    normalization of [serial 1408] 


Theorem (103)                               [serial 1426] 
P [415] << ( RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() )
  and mrp <= rpr >>
S [416] ->
Q [416] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1413]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (104)                               [serial 1413] 
P [415] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr >= mrp ) >>
S [416] ->
Q [416] << rpr = RESPIRATION_RATE
  and rpr >= mrp
  and MRP_A()
  and RA() >>
Why created:  P -> P1 in concurrent composition for [serial 1411]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 103:
Theorem (103) [serial 1426] used for:
    normalization of [serial 1413] 


Theorem (105)                               [serial 1428] 
P [418] << MRP_A()
  and RA() >>
S [418] ->
Q [407] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1414]
Solved by: Identity (id):  P->P is tautology

Theorem (106)                               [serial 1414] 
P [418] << RA()
  and MRP_A() >>
S [418] ->
Q [407] << RA()
  and MRP_A() >>
Why created:  Qk -> Q in concurrent composition for [serial 1411]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 105:
Theorem (105) [serial 1428] used for:
    normalization of [serial 1414] 


Theorem (107)                               [serial 1457] 
P [416] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE iff rma )
  and mrp <= rpr
  and MINIMUM_RESPIRATION_RATE = mrp
  and RESPIRATION_RATE = rpr >>
S [417] ->
Q [407] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE iff false )
  and MINIMUM_RESPIRATION_RATE = mrp >>
Why created:    normalization of [serial 1455]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: The negation of a proposition is equivalent to itself being equivalent to false. (nbfal)

Theorem (108)                               [serial 1455] 
P [416] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( rma iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) >>
S [417] ->
Q [407] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( false iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1454]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 107:
Theorem (107) [serial 1457] used for:
    normalization of [serial 1455] 


Theorem (109)                               [serial 1454] 
P [416] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [417] ->
Q [407] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( false iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) >>
Why created:  applied wp for assignment [serial 1453]
Solved by: Predicate Invocation. (PI) and theorem 108:
Theorem (108) [serial 1455] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1454] 


Theorem (110)                               [serial 1453] 
P [416] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [417] rma := false
Q [407] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( rma iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1430]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 109:
Theorem (109) [serial 1454] used for:
  applied wp for assignment [serial 1453] 


Theorem (111)                               [serial 1430] 
P [416] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [417] rma := false
Q [407] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1415]
  Using: (eqcom) changeAtLeastToAtMost (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 110:
Theorem (110) [serial 1453] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1430] 


Theorem (112)                               [serial 1415] 
P [416] << rpr = RESPIRATION_RATE
  and rpr >= mrp
  and MRP_A()
  and RA() >>
S [417] rma := false
Q [407] << RA()
  and MRP_A() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1411]
Solved by: Equality Commutes. (eqcom) [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 111:
Theorem (111) [serial 1430] used for:
    normalization of [serial 1415] 


Theorem (113)                               [serial 1432] 
P [415] << ( RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() )
  and mrp <= rpr >>
S [417] RM_Alarm!(false)
Q [418] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1416]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (114)                               [serial 1416] 
P [415] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr >= mrp ) >>
S [417] RM_Alarm!(false)
Q [418] << RA()
  and MRP_A() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1411]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 113:
Theorem (113) [serial 1432] used for:
    normalization of [serial 1416] 


Theorem (115)                               [serial 1411] 
P [415] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr >= mrp ) >>
S [416]   << rpr = RESPIRATION_RATE
    and rpr >= mrp
    and MRP_A()
    and RA() >>
  rma := false
  &
  RM_Alarm!(false)
  << RA()
    and MRP_A() >> 
Q [407] << RA()
  and MRP_A() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1409]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 104 106 112 114:
Theorem (104) [serial 1413] used for:
  P -> P1 in concurrent composition for [serial 1411] 
Theorem (106) [serial 1414] used for:
  Qk -> Q in concurrent composition for [serial 1411] 
Theorem (112) [serial 1415] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1411] 
Theorem (114) [serial 1416] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1411] 


Theorem (116)                               [serial 1409] 
P [415] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr >= mrp ) >>
S [416]   {
    << rpr = RESPIRATION_RATE
      and rpr >= mrp
      and MRP_A()
      and RA() >>
    rma := false
    &
    RM_Alarm!(false)
    << RA()
      and MRP_A() >> 
  } 
Q [407] << RA()
  and MRP_A() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1407]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 115:
Theorem (115) [serial 1411] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1409] 


Theorem (117)                               [serial 1434] 
P [415] << ( RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() )
  and rpr < mrp >>
S [421] ->
Q [421] << rpr < mrp
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1417]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (118)                               [serial 1417] 
P [415] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr < mrp ) >>
S [421] ->
Q [421] << rpr = RESPIRATION_RATE
  and rpr < mrp
  and MRP_A()
  and RA() >>
Why created:  P -> P1 in concurrent composition for [serial 1412]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 117:
Theorem (117) [serial 1434] used for:
    normalization of [serial 1417] 


Theorem (119)                               [serial 1436] 
P [423] << MRP_A()
  and RA() >>
S [423] ->
Q [407] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1418]
Solved by: Identity (id):  P->P is tautology

Theorem (120)                               [serial 1418] 
P [423] << RA()
  and MRP_A() >>
S [423] ->
Q [407] << RA()
  and MRP_A() >>
Why created:  Qk -> Q in concurrent composition for [serial 1412]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 119:
Theorem (119) [serial 1436] used for:
    normalization of [serial 1418] 


Theorem (121)                               [serial 1467] 
P [421] << rpr < mrp
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [422] ->
Q [407] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( true iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) >>
Why created:  applied wp for assignment [serial 1466]
Solved by: Superfluity of Equivalence. (bl.seq)

Theorem (122)                               [serial 1466] 
P [421] << rpr < mrp
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [422] rma := true
Q [407] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( rma iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1438]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 121:
Theorem (121) [serial 1467] used for:
  applied wp for assignment [serial 1466] 


Theorem (123)                               [serial 1438] 
P [421] << rpr < mrp
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [422] rma := true
Q [407] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1419]
  Using: (eqcom) (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 122:
Theorem (122) [serial 1466] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1438] 


Theorem (124)                               [serial 1419] 
P [421] << rpr = RESPIRATION_RATE
  and rpr < mrp
  and MRP_A()
  and RA() >>
S [422] rma := true
Q [407] << RA()
  and MRP_A() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1412]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 123:
Theorem (123) [serial 1438] used for:
    normalization of [serial 1419] 


Theorem (125)                               [serial 1440] 
P [415] << ( RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() )
  and rpr < mrp >>
S [422] RM_Alarm!(true)
Q [423] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1420]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (126)                               [serial 1420] 
P [415] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr < mrp ) >>
S [422] RM_Alarm!(true)
Q [423] << RA()
  and MRP_A() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1412]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 125:
Theorem (125) [serial 1440] used for:
    normalization of [serial 1420] 


Theorem (127)                               [serial 1412] 
P [415] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr < mrp ) >>
S [421]   << rpr = RESPIRATION_RATE
    and rpr < mrp
    and MRP_A()
    and RA() >>
  rma := true
  &
  RM_Alarm!(true)
  << RA()
    and MRP_A() >> 
Q [407] << RA()
  and MRP_A() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1410]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 118 120 124 126:
Theorem (118) [serial 1417] used for:
  P -> P1 in concurrent composition for [serial 1412] 
Theorem (120) [serial 1418] used for:
  Qk -> Q in concurrent composition for [serial 1412] 
Theorem (124) [serial 1419] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1412] 
Theorem (126) [serial 1420] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1412] 


Theorem (128)                               [serial 1410] 
P [415] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr < mrp ) >>
S [421]   {
    << rpr = RESPIRATION_RATE
      and rpr < mrp
      and MRP_A()
      and RA() >>
    rma := true
    &
    RM_Alarm!(true)
    << RA()
      and MRP_A() >> 
  } 
Q [407] << RA()
  and MRP_A() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1407]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 127:
Theorem (127) [serial 1412] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1410] 


Theorem (129)                               [serial 1407] 
P [413] << rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() >>
S [415]   if 
    (rpr >= mrp)~> 
        {
          << rpr = RESPIRATION_RATE
            and rpr >= mrp
            and MRP_A()
            and RA() >>
          rma := false
          &
          RM_Alarm!(false)
          << RA()
            and MRP_A() >> 
        }  
  []
    (rpr < mrp)~> 
        {
          << rpr = RESPIRATION_RATE
            and rpr < mrp
            and MRP_A()
            and RA() >>
          rma := true
          &
          RM_Alarm!(true)
          << RA()
            and MRP_A() >> 
        }  
  fi
Q [407] << RA()
  and MRP_A() >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1015]
Solved by: and theorems 102 116 128:
Theorem (102) [serial 1408] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1407] 
Theorem (116) [serial 1409] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1407] 
Theorem (128) [serial 1410] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1407] 


Theorem (130)                               [serial 1015] 
P [406] << RA()
  and MRP_A() >>
S [412]   RP_Rate?(rpr)
  << rpr = RESPIRATION_RATE
    and MRP_A()
    and RA() >>
  ;
    if 
      (rpr >= mrp)~> 
          {
            << rpr = RESPIRATION_RATE
              and rpr >= mrp
              and MRP_A()
              and RA() >>
            rma := false
            &
            RM_Alarm!(false)
            << RA()
              and MRP_A() >> 
          }  
    []
      (rpr < mrp)~> 
          {
            << rpr = RESPIRATION_RATE
              and rpr < mrp
              and MRP_A()
              and RA() >>
            rma := true
            &
            RM_Alarm!(true)
            << RA()
              and MRP_A() >> 
          }  
    fi 
Q [407] << RA()
  and MRP_A() >>
Why created:   <<M(run) and x>> A <<M(check_echo)>> for got_rp: run-[x]->check_echo{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 98 129:
Theorem (98) [serial 1406] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1015] 
Theorem (129) [serial 1407] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1015] 


Theorem (131)                               [serial 1511] 
P [426] << ( MRP_A()
  and RA() )
  and RM_Alarm_Echo@now
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [426] ->
Q [427] << RM_Alarm_Echo@now
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1498]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (132)                               [serial 1498] 
P [426] << ( RA()
  and MRP_A() )
  and ( RM_Alarm_Echo@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [426] ->
Q [427] << RA()
  and MRP_A()
  and RM_Alarm_Echo@now >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1016]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 131:
Theorem (131) [serial 1511] used for:
    normalization of [serial 1498] 


Theorem (133)                               [serial 1513] 
P [436] << MRP_A()
  and RA() >>
S [406] ->
Q [406] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1499]
Solved by: Identity (id):  P->P is tautology

Theorem (134)                               [serial 1499] 
P [436] << RA()
  and MRP_A() >>
S [406] ->
Q [406] << RA()
  and MRP_A() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1016]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 133:
Theorem (133) [serial 1513] used for:
    normalization of [serial 1499] 


Theorem (135)                               [serial 1515] 
P [427] << ( RM_Alarm_Echo@now
  and MRP_A()
  and RA() )
  and ( RM_Alarm_Echo@now iff echo_val ) >>
S [429] ->
Q [429] << ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1501]
  Using: (bl.ancom) (bicom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (136)                               [serial 1501] 
P [427] << ( RA()
  and MRP_A()
  and RM_Alarm_Echo@now )
  and ( echo_val iff RM_Alarm_Echo@now ) >>
S [429] ->
Q [429] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
Why created:  <<P and v=e>> -> <<A>> in behavior action block for [serial 1500]
Solved by: Conjunction Commutes. (bl.ancom) Biconditional (iff) Commutes. (bicom) and theorem 135:
Theorem (135) [serial 1515] used for:
    normalization of [serial 1501] 


Theorem (137)                               [serial 1517] 
P [429] << ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() >>
S [429] ->
Q [429] << ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1504]
  Using: (bicom) (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (138)                               [serial 1504] 
P [429] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
S [429] ->
Q [429] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1502]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 137:
Theorem (137) [serial 1517] used for:
    normalization of [serial 1504] 


Theorem (139)                               [serial 1519] 
P [434] << MRP_A()
  and RA() >>
S [434] ->
Q [434] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1505]
Solved by: Identity (id):  P->P is tautology

Theorem (140)                               [serial 1505] 
P [434] << RA()
  and MRP_A() >>
S [434] ->
Q [434] << RA()
  and MRP_A() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1502]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 139:
Theorem (139) [serial 1519] used for:
    normalization of [serial 1505] 


Theorem (141)                               [serial 1521] 
P [429] << ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() >>
S [430] ->
Q [430] << ( echo_val iff rma ) or not ( echo_val iff rma ) >>
Why created:    normalization of [serial 1507]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (142)                               [serial 1507] 
P [429] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
S [430] ->
Q [430] << ( echo_val iff rma ) or ( not ( echo_val iff rma ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1506]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 141:
Theorem (141) [serial 1521] used for:
    normalization of [serial 1507] 


Theorem (143)                               [serial 1523] 
P [430] << ( ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() )
  and ( echo_val iff rma ) >>
S [430] skip
Q [434] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1508]
  Using: (bicom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (144)                               [serial 1508] 
P [430] << ( RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) )
  and ( echo_val iff rma ) >>
S [430] skip
Q [434] << RA()
  and MRP_A() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1506]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 143:
Theorem (143) [serial 1523] used for:
    normalization of [serial 1508] 


Theorem (145)                               [serial 1525] 
P [430] << ( ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() )
  and not ( echo_val iff rma ) >>
S [432] Lost_Confirmation!
Q [434] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1509]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (146)                               [serial 1509] 
P [430] << ( RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) )
  and ( not ( echo_val iff rma ) ) >>
S [432] Lost_Confirmation!
Q [434] << RA()
  and MRP_A() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1506]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 145:
Theorem (145) [serial 1525] used for:
    normalization of [serial 1509] 


Theorem (147)                               [serial 1506] 
P [429] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
S [430]   if 
    (echo_val iff rma)~> 
      skip 
  []
    (not ( echo_val iff rma ))~> 
      Lost_Confirmation! 
  fi
Q [434] << RA()
  and MRP_A() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1502]
Solved by: and theorems 142 144 146:
Theorem (142) [serial 1507] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1506] 
Theorem (144) [serial 1508] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1506] 
Theorem (146) [serial 1509] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1506] 


Theorem (148)                               [serial 1502] 
P [429] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
S [429] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
  if 
    (echo_val iff rma)~> 
      skip 
  []
    (not ( echo_val iff rma ))~> 
      Lost_Confirmation! 
  fi
<< RA()
  and MRP_A() >>
Q [434] << RA()
  and MRP_A() >>
Why created:  <<A>> S <<B>> in behavior action block for [serial 1500]
Solved by: null and theorems 138 140 147:
Theorem (138) [serial 1504] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1502] 
Theorem (140) [serial 1505] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1502] 
Theorem (147) [serial 1506] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1502] 


Theorem (149)                               [serial 1527] 
P [434] << MRP_A()
  and RA() >>
S [428] ->
Q [436] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1503]
Solved by: Identity (id):  P->P is tautology

Theorem (150)                               [serial 1503] 
P [434] << RA()
  and MRP_A() >>
S [428] ->
Q [436] << RA()
  and MRP_A() >>
Why created:  <<B>> -> <<Q>> in behavior action block for [serial 1500]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 149:
Theorem (149) [serial 1527] used for:
    normalization of [serial 1503] 


Theorem (151)                               [serial 1500] 
P [427] << RA()
  and MRP_A()
  and RM_Alarm_Echo@now >>
S [428] declare 
   echo_val ~ boolean := RM_Alarm_Echo?   {
  << RA()
    and MRP_A()
    and ( echo_val iff RM_Alarm_Echo ) >>
    if 
      (echo_val iff rma)~> 
        skip 
    []
      (not ( echo_val iff rma ))~> 
        Lost_Confirmation! 
    fi
  << RA()
    and MRP_A() >>
  } 
Q [436] << RA()
  and MRP_A() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1016]
Solved by: Behavior Action Block (BAB): 
     <<P and x=e>> -> <<A>>
     <<A>> S <<B>> 
     <<B>> -> <<Q>>
----------------------------------------------------
<<P>> declare variable v~y:=e; { <<A>> S <<B>> } <<Q>> and theorems 136 148 150:
Theorem (136) [serial 1501] used for:
  <<P and v=e>> -> <<A>> in behavior action block for [serial 1500] 
Theorem (148) [serial 1502] used for:
  <<A>> S <<B>> in behavior action block for [serial 1500] 
Theorem (150) [serial 1503] used for:
  <<B>> -> <<Q>> in behavior action block for [serial 1500] 


Theorem (152)                               [serial 1016] 
P [426] << ( RA()
  and MRP_A() )
  and ( RM_Alarm_Echo@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [427] << RA()
  and MRP_A()
  and RM_Alarm_Echo@now >>
declare 
   echo_val ~ boolean := RM_Alarm_Echo?   {
  << RA()
    and MRP_A()
    and ( echo_val iff RM_Alarm_Echo ) >>
    if 
      (echo_val iff rma)~> 
        skip 
    []
      (not ( echo_val iff rma ))~> 
        Lost_Confirmation! 
    fi
  << RA()
    and MRP_A() >>
  } 
<< RA()
  and MRP_A() >>
Q [406] << RA()
  and MRP_A() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A};
Solved by: null and theorems 132 134 151:
Theorem (132) [serial 1498] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1016] 
Theorem (134) [serial 1499] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1016] 
Theorem (151) [serial 1500] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1016] 


Theorem (153)                               [serial 1556] 
P [438] << ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and ( MRP_A()
  and RA() )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [439] ->
Q [439] << true >>
Why created:    normalization of [serial 1552]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (154)                               [serial 1552] 
P [438] << ( RA()
  and MRP_A() )
  and ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [439] ->
Q [439] << true >>
Why created:  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1017]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 153:
Theorem (153) [serial 1556] used for:
    normalization of [serial 1552] 


Theorem (155)                               [serial 1558] 
P [439] << ( ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and ( MRP_A()
  and RA() )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) )
  and true >>
S [439] ->
Q [406] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1554]
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (156)                               [serial 1554] 
P [439] << ( ( RA()
  and MRP_A() )
  and ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) )
  and true >>
S [439] ->
Q [406] << RA()
  and MRP_A() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1553]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  Conjunction Commutes. (bl.ancom) and theorem 155:
Theorem (155) [serial 1558] used for:
    normalization of [serial 1554] 


Theorem (157)                               [serial 1553] 
P [439] << ( ( RA()
  and MRP_A() )
  and ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) )
  and true@now >>
S [439] ->
Q [406] << RA()
  and MRP_A() >>
Why created:  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1017]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 156:
Theorem (156) [serial 1554] used for:
  Assume Present:  P = P@now = P^0   [serial 1553] 


Theorem (158)                               [serial 1017] 
P [438] << ( RA()
  and MRP_A() )
  and ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [439] Lost_Confirmation!
Q [406] << RA()
  and MRP_A() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A};
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 154 157:
Theorem (154) [serial 1552] used for:
  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1017] 
Theorem (157) [serial 1553] used for:
  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1017] 


Theorem (159)                               [serial 1010] 
P [396] <<   >>
S [397] ->
Q [396] << Respiration_Monitor_Thread.impl proof obligations >>
Why created:  Initial proof obligations for Respiration_Monitor_Thread.impl
Solved by:  Component verification conditions
 and theorems 92 93 94 95 130 152 158:
Theorem (92) [serial 1011] used for:
  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition. 
Theorem (93) [serial 1012] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (94) [serial 1013] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (95) [serial 1014] used for:
   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{}; 
Theorem (130) [serial 1015] used for:
   <<M(run) and x>> A <<M(check_echo)>> for got_rp: run-[x]->check_echo{A}; 
Theorem (152) [serial 1016] used for:
   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A}; 
Theorem (158) [serial 1017] used for:
   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A}; 


Theorem (160)                               [serial 1572] 
P [590] << ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff Pause_Infusion )
  and ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff pause_inf )
  and ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) iff po_alarm_active )
  and ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE iff rm_alarm_active ) >>
S [590] ->
Q [579] << ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff PAUSE_INFUSION >>
Why created:    normalization of [serial 1570]
  Using: ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Absorb parentheses, middle term in disjunction (bl.orabpm)

Theorem (161)                               [serial 1570] 
P [590] << ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff Pause_Infusion )
  and ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff pause_inf )
  and ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) iff po_alarm_active )
  and ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE iff rm_alarm_active ) >>
S [590] ->
Q [579] << ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) iff PAUSE_INFUSION >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1569]
Solved by: [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 160:
Theorem (160) [serial 1572] used for:
    normalization of [serial 1570] 


Theorem (162)                               [serial 1569] 
P [590] << ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff Pause_Infusion )
  and ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff pause_inf )
  and ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) iff po_alarm_active )
  and ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE iff rm_alarm_active ) >>
S [590] ->
Q [579] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:    normalization of [serial 1567]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) (bl.orcom) 
Solved by: Predicate Invocation. (PI) and theorem 161:
Theorem (161) [serial 1570] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1569] 


Theorem (163)                               [serial 1567] 
P [590] << ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) iff Pause_Infusion )
  and ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) iff pause_inf )
  and ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) iff po_alarm_active )
  and ( ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff rm_alarm_active ) >>
S [590] ->
Q [579] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1566]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 162:
Theorem (162) [serial 1569] used for:
    normalization of [serial 1567] 


Theorem (164)                               [serial 1566] 
P [590] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [590] ->
Q [579] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:    normalization of [serial 1564]
  Using: (bicom) (bl.ancom) (bl.orcom) 
Solved by: Predicate Invocation. (PI) and theorem 163:
Theorem (163) [serial 1567] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1566] 


Theorem (165)                               [serial 1564] 
P [590] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) >>
S [590] ->
Q [579] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1019]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 164:
Theorem (164) [serial 1566] used for:
    normalization of [serial 1564] 


Theorem (166)                               [serial 1019] 
P [590] << INV()
  and POA()
  and RMA()
  and PI() >>
S [590] ->
Q [579] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:  <<I>> -> BLESS::Invariant of thread Coordinator_Thread.echo
Solved by: Predicate Invocation. (PI) and theorem 165:
Theorem (165) [serial 1564] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1019] 


Theorem (167)                               [serial 1577] 
P [604] << INV()
  and PI()
  and POA()
  and RMA() >>
S [590] ->
Q [590] << INV()
  and PI()
  and POA()
  and RMA() >>
Why created:    normalization of [serial 1575]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (168)                               [serial 1575] 
P [604] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
S [590] ->
Q [590] << INV()
  and POA()
  and RMA()
  and PI() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1020]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 167:
Theorem (167) [serial 1577] used for:
    normalization of [serial 1575] 


Theorem (169)                               [serial 1020] 
P [604] << INV_E() >>
S [590] ->
Q [590] << INV()
  and POA()
  and RMA()
  and PI() >>
Why created:  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 168:
Theorem (168) [serial 1575] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1020] 


Theorem (170)                               [serial 1580] 
P [603] << INV()
  and PI()
  and POA()
  and RMA() >>
S [590] ->
Q [590] << INV()
  and PI()
  and POA()
  and RMA() >>
Why created:    normalization of [serial 1578]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (171)                               [serial 1578] 
P [603] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
S [590] ->
Q [590] << INV()
  and POA()
  and RMA()
  and PI() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1021]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 170:
Theorem (170) [serial 1580] used for:
    normalization of [serial 1578] 


Theorem (172)                               [serial 1021] 
P [603] << INV_E() >>
S [590] ->
Q [590] << INV()
  and POA()
  and RMA()
  and PI() >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 171:
Theorem (171) [serial 1578] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1021] 


Theorem (173)                               [serial 1022] 
P [602] << INV_E() >>
S [602] ->
Q [602] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by: Anything Implies True (a1tru): P->true

Theorem (174)                               [serial 1023] 
P [602] << INV_E() >>
S [606] ->
Q [603] << INV_E() >>
Why created:   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{};
Solved by: Identity (id):  P->P is tautology

Theorem (175)                               [serial 1608] 
P [607] << ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 )@now
  and ( INV()
  and POA()
  and RMA()
  and PI() )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 )@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE )@u  ) >>
S [607] ->
Q [608] << INV()
  and RMA() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1587]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (176)                               [serial 1587] 
P [607] << PO_ALARM()@now
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [607] ->
Q [608] << INV()
  and RMA() >>
Why created:    normalization of [serial 1581]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 175:
Theorem (175) [serial 1608] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1587] 


Theorem (177)                               [serial 1581] 
P [607] << ( INV_E() )
  and ( PO_ALARM()@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [607] ->
Q [608] << INV()
  and RMA() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1024]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 176:
Theorem (176) [serial 1587] used for:
    normalization of [serial 1581] 


Theorem (178)                               [serial 1613] 
P [609] << ( INV()
  and RMA() )
  and ( PO_ALARM() iff po_alarm_active ) >>
S [609] ->
Q [610] << ( PO_ALARM() iff po_alarm_active )
  and INV()
  and RMA()
  and true >>
Why created:    normalization of [serial 1611]
  Using: (bicom) (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (179)                               [serial 1611] 
P [609] << ( INV()
  and RMA() )
  and ( po_alarm_active iff PO_ALARM() ) >>
S [609] ->
Q [610] << ( PO_ALARM() iff po_alarm_active )
  and true
  and INV()
  and RMA() >>
Why created:   add user-defined "givens" to postcondition
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 178:
Theorem (178) [serial 1613] used for:
    normalization of [serial 1611] 


Theorem (180)                               [serial 1613] 
P [609] << ( INV()
  and RMA() )
  and ( PO_ALARM() iff po_alarm_active ) >>
S [609] ->
Q [610] << ( PO_ALARM() iff po_alarm_active )
  and INV()
  and RMA()
  and true >>
Why created:    normalization of [serial 1611]
  Using: (bicom) (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (181)                               [serial 1611] 
P [609] << ( INV()
  and RMA() )
  and ( po_alarm_active iff PO_ALARM() ) >>
S [609] ->
Q [610] << ( PO_ALARM() iff po_alarm_active )
  and true
  and INV()
  and RMA() >>
Why created:   add user-defined "givens" to postcondition
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 180:
Theorem (180) [serial 1613] used for:
    normalization of [serial 1611] 


Theorem (182)                               [serial 1610] 
P [609] << ( INV()
  and RMA() )
  and ( po_alarm_active iff PO_ALARM() ) >>
S [609] ->
Q [610] << ( PO_ALARM() iff po_alarm_active )
  and GIVEN_POA()
  and INV()
  and RMA() >>
Why created:  applied port input of value <<pre and po_alarm_active=M(PO_Alarm)>> -> <<post>> [serial 1589]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 181 181:
Theorem (181) [serial 1611] used for:
   add user-defined "givens" to postcondition 
Theorem (181) [serial 1611] used for:
   add user-defined "givens" to postcondition 


Theorem (183)                               [serial 1589] 
P [608] << INV()
  and RMA() >>
S [609] PO_Alarm?(po_alarm_active)
Q [610] << ( PO_ALARM() iff po_alarm_active )
  and GIVEN_POA()
  and INV()
  and RMA() >>
Why created:    normalization of [serial 1582]
  Using: (bicom) (bl.ancom) 
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 182:
Theorem (182) [serial 1610] used for:
  applied port input of value <<pre and po_alarm_active=M(PO_Alarm)>> -> <<post>> [serial 1589] 


Theorem (184)                               [serial 1582] 
P [608] << INV()
  and RMA() >>
S [609] PO_Alarm?(po_alarm_active)
Q [610] << INV()
  and RMA()
  and ( po_alarm_active iff PO_ALARM() )
  and GIVEN_POA() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1024]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 183:
Theorem (183) [serial 1589] used for:
    normalization of [serial 1582] 


Theorem (185)                               [serial 1629] 
P [610] << ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) iff po_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff PO_ALARM_ECHO )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [611] ->
Q [611] << PO_ALARM() iff PO_ALARM_ECHO >>
Why created:    normalization of [serial 1627]
  Using: (bicom) (bl.ancom) 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (186)                               [serial 1627] 
P [610] << ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) iff po_alarm_active )
  and ( PO_ALARM() iff PO_ALARM_ECHO )
  and ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( rm_alarm_active iff RM_ALARM() ) >>
S [611] ->
Q [611] << PO_ALARM_ECHO iff PO_ALARM() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1626]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 185:
Theorem (185) [serial 1629] used for:
    normalization of [serial 1627] 


Theorem (187)                               [serial 1626] 
P [610] << ( PO_ALARM() iff po_alarm_active )
  and GIVEN_POA()
  and INV()
  and RMA() >>
S [611] ->
Q [611] << PO_ALARM_ECHO iff PO_ALARM() >>
Why created:  Guided Substitution of Equals 
 replacing "po_alarm_active" with its iff "PO_ALARM()" in its postcondition [serial 1616]
Solved by: Predicate Invocation. (PI) and theorem 186:
Theorem (186) [serial 1627] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1626] 


Theorem (188)                               [serial 1616] 
P [610] << ( PO_ALARM() iff po_alarm_active )
  and GIVEN_POA()
  and INV()
  and RMA() >>
S [611] ->
Q [611] << PO_ALARM_ECHO iff po_alarm_active >>
Why created:  applied port output of value <<pre>> -> <<M(PO_Alarm_Echo)[PO_Alarm_Echo|po_alarm_active]>> [serial 1591]
Solved by:  Guided Substitution of Equals
 and theorem 187:
Theorem (187) [serial 1626] used for:
  Guided Substitution of Equals 
 replacing "po_alarm_active" with its iff "PO_ALARM()" in its postcondition [serial 1616] 


Theorem (189)                               [serial 1617] 
P [611] << ( ( PO_ALARM() iff po_alarm_active )
  and GIVEN_POA()
  and INV()
  and RMA() )
  and ( PO_ALARM_ECHO iff po_alarm_active )@now >>
S [611] ->
Q [612] << INV()
  and POA()
  and RMA() >>
Why created:  applied port output <<pre and (PO_ALARM_ECHO iff po_alarm_active)@now>> -> <<post>> [serial 1591]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (190)                               [serial 1591] 
P [610] << ( PO_ALARM() iff po_alarm_active )
  and GIVEN_POA()
  and INV()
  and RMA() >>
S [611] PO_Alarm_Echo!(po_alarm_active)
Q [612] << INV()
  and POA()
  and RMA() >>
Why created:    normalization of [serial 1583]
  Using: (bicom) (bl.ancom) 
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 188 189:
Theorem (188) [serial 1616] used for:
  applied port output of value <<pre>> -> <<M(PO_Alarm_Echo)[PO_Alarm_Echo|po_alarm_active]>> [serial 1591] 
Theorem (189) [serial 1617] used for:
  applied port output <<pre and (PO_ALARM_ECHO iff po_alarm_active)@now>> -> <<post>> [serial 1591] 


Theorem (191)                               [serial 1583] 
P [610] << INV()
  and RMA()
  and ( po_alarm_active iff PO_ALARM() )
  and GIVEN_POA() >>
S [611] PO_Alarm_Echo!(po_alarm_active)
Q [612] << INV()
  and RMA()
  and POA() >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1024]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 190:
Theorem (190) [serial 1591] used for:
    normalization of [serial 1583] 


Theorem (192)                               [serial 1641] 
P [612] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [613] ->
Q [597] << ( ( PO_ALARM() or RM_ALARM() ) iff ( PO_ALARM() or RM_ALARM() ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "rm_alarm_active" with its iff "RM_ALARM()" in its postcondition [serial 1640]
Solved by: Principle of identity for logical equivalence. (biid) 

Theorem (193)                               [serial 1640] 
P [612] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [613] ->
Q [597] << ( ( PO_ALARM() or RM_ALARM() ) iff ( PO_ALARM() or rm_alarm_active ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "po_alarm_active" with its iff "PO_ALARM()" in its postcondition [serial 1636]
Solved by:  Guided Substitution of Equals
 and theorem 192:
Theorem (192) [serial 1641] used for:
  Guided Substitution of Equals 
 replacing "rm_alarm_active" with its iff "RM_ALARM()" in its postcondition [serial 1640] 


Theorem (194)                               [serial 1636] 
P [612] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [613] ->
Q [597] << ( ( PO_ALARM() or RM_ALARM() ) iff ( po_alarm_active or rm_alarm_active ) ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1635]
Solved by:  Guided Substitution of Equals
 and theorem 193:
Theorem (193) [serial 1640] used for:
  Guided Substitution of Equals 
 replacing "po_alarm_active" with its iff "PO_ALARM()" in its postcondition [serial 1636] 


Theorem (195)                               [serial 1637] 
P [612] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [613] ->
Q [585] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1635]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (196)                               [serial 1638] 
P [612] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [613] ->
Q [593] << ( PO_ALARM() iff po_alarm_active ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1635]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (197)                               [serial 1639] 
P [612] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [613] ->
Q [595] << ( RM_ALARM() iff rm_alarm_active ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1635]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (198)                               [serial 1635] 
P [612] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [613] ->
Q [614] << ( ( PO_ALARM() or RM_ALARM() ) iff ( po_alarm_active or rm_alarm_active ) )
  and ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
Why created:    normalization of [serial 1633]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 194 195 196 197:
Theorem (194) [serial 1636] used for:
  Join consequents with conjunction. (3jca)
   [serial 1635] 
Theorem (195) [serial 1637] used for:
  Join consequents with conjunction. (3jca)
   [serial 1635] 
Theorem (196) [serial 1638] used for:
  Join consequents with conjunction. (3jca)
   [serial 1635] 
Theorem (197) [serial 1639] used for:
  Join consequents with conjunction. (3jca)
   [serial 1635] 


Theorem (199)                               [serial 1633] 
P [612] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() ) >>
S [613] ->
Q [614] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( ( po_alarm_active or rm_alarm_active ) iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1632]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 198:
Theorem (198) [serial 1635] used for:
    normalization of [serial 1633] 


Theorem (200)                               [serial 1632] 
P [612] << INV()
  and POA()
  and RMA() >>
S [613] ->
Q [614] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( ( po_alarm_active or rm_alarm_active ) iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  applied wp for assignment [serial 1631]
Solved by: Predicate Invocation. (PI) and theorem 199:
Theorem (199) [serial 1633] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1632] 


Theorem (201)                               [serial 1631] 
P [612] << INV()
  and POA()
  and RMA() >>
S [613] pause_inf := po_alarm_active or rm_alarm_active
Q [614] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1630]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 200:
Theorem (200) [serial 1632] used for:
  applied wp for assignment [serial 1631] 


Theorem (202)                               [serial 1630] 
P [612] << INV()
  and POA()
  and RMA() >>
S [613] pause_inf := po_alarm_active or rm_alarm_active
Q [614] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1593]
Solved by: Predicate Invocation. (PI) and theorem 201:
Theorem (201) [serial 1631] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1630] 


Theorem (203)                               [serial 1593] 
P [612] << INV()
  and POA()
  and RMA() >>
S [613] pause_inf := po_alarm_active or rm_alarm_active
Q [614] << INV_E() >>
Why created:    normalization of [serial 1584]
Solved by: Predicate Invocation. (PI) and theorem 202:
Theorem (202) [serial 1630] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1593] 


Theorem (204)                               [serial 1584] 
P [612] << INV()
  and RMA()
  and POA() >>
S [613] pause_inf := po_alarm_active or rm_alarm_active
Q [614] << INV_E() >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1024]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 203:
Theorem (203) [serial 1593] used for:
    normalization of [serial 1584] 


Theorem (205)                               [serial 1607] 
P [614] << ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [615] ->
Q [615] << ( PO_ALARM() or RM_ALARM() ) iff pause_inf >>
Why created:    normalization of [serial 1605]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (206)                               [serial 1605] 
P [614] << ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [615] ->
Q [615] << ( ( PO_ALARM() or RM_ALARM() ) ) iff pause_inf >>
Why created:  Guided Substitution of Equals 
 replacing "PAUSE_INFUSION" with its iff "( ( PO_ALARM() or RM_ALARM() ) )" in its postcondition [serial 1604]
Solved by: [Add unnecessary parentheses] and theorem 205:
Theorem (205) [serial 1607] used for:
    normalization of [serial 1605] 


Theorem (207)                               [serial 1604] 
P [614] << ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [615] ->
Q [615] << PAUSE_INFUSION iff pause_inf >>
Why created:  Replacing port names with BLESS::Assertion properties  [serial 1603]
Solved by:  Guided Substitution of Equals
 and theorem 206:
Theorem (206) [serial 1605] used for:
  Guided Substitution of Equals 
 replacing "PAUSE_INFUSION" with its iff "( ( PO_ALARM() or RM_ALARM() ) )" in its postcondition [serial 1604] 


Theorem (208)                               [serial 1603] 
P [614] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [615] ->
Q [615] << PAUSE_INFUSION iff pause_inf >>
Why created:    normalization of [serial 1601]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by:  Replacing port names with BLESS::Assertion properties
 and theorem 207:
Theorem (207) [serial 1604] used for:
  Replacing port names with BLESS::Assertion properties  [serial 1603] 


Theorem (209)                               [serial 1601] 
P [614] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
S [615] ->
Q [615] << PAUSE_INFUSION iff pause_inf >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1600]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 208:
Theorem (208) [serial 1603] used for:
    normalization of [serial 1601] 


Theorem (210)                               [serial 1600] 
P [614] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
S [615] ->
Q [615] << PAUSE_INFUSION iff pause_inf >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1595]
Solved by: Predicate Invocation. (PI) and theorem 209:
Theorem (209) [serial 1601] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1600] 


Theorem (211)                               [serial 1595] 
P [614] << INV_E() >>
S [615] ->
Q [615] << PAUSE_INFUSION iff pause_inf >>
Why created:  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|pause_inf]>> [serial 1585]
Solved by: Predicate Invocation. (PI) and theorem 210:
Theorem (210) [serial 1600] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1595] 


Theorem (212)                               [serial 1599] 
P [615] << ( PAUSE_INFUSION iff pause_inf )@now
  and INV_E() >>
S [615] ->
Q [604] << INV_E() >>
Why created:    normalization of [serial 1596]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (213)                               [serial 1596] 
P [615] << ( INV_E() )
  and ( PAUSE_INFUSION iff pause_inf )@now >>
S [615] ->
Q [604] << INV_E() >>
Why created:  applied port output <<pre and (PAUSE_INFUSION iff pause_inf)@now>> -> <<post>> [serial 1585]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 212:
Theorem (212) [serial 1599] used for:
    normalization of [serial 1596] 


Theorem (214)                               [serial 1585] 
P [614] << INV_E() >>
S [615] Pause_Infusion!(pause_inf)
Q [604] << INV_E() >>
Why created:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1024]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 211 213:
Theorem (211) [serial 1595] used for:
  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|pause_inf]>> [serial 1585] 
Theorem (213) [serial 1596] used for:
  applied port output <<pre and (PAUSE_INFUSION iff pause_inf)@now>> -> <<post>> [serial 1585] 


Theorem (215)                               [serial 1024] 
P [607] << ( INV_E() )
  and ( PO_ALARM()@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [608]   << INV()
    and RMA() >>
  PO_Alarm?(po_alarm_active)
  ;
  << INV()
    and RMA()
    and ( po_alarm_active iff PO_ALARM() )
    and GIVEN_POA() >>
  PO_Alarm_Echo!(po_alarm_active)
  ;
  << INV()
    and RMA()
    and POA() >>
  pause_inf := po_alarm_active or rm_alarm_active
  ;
  << INV_E() >>
  Pause_Infusion!(pause_inf) 
Q [604] << INV_E() >>
Why created:   <<M(run) and x>> A <<M(check_echo)>> for got_po: run-[x]->check_echo{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 177 184 191 204 214:
Theorem (177) [serial 1581] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1024] 
Theorem (184) [serial 1582] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1024] 
Theorem (191) [serial 1583] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1024] 
Theorem (204) [serial 1584] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1024] 
Theorem (214) [serial 1585] used for:
  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1024] 


Theorem (216)                               [serial 1652] 
P [617] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE )@now
  and ( INV()
  and POA()
  and RMA()
  and PI() )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 )@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE )@u  ) >>
S [617] ->
Q [618] << INV()
  and POA() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1651]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (217)                               [serial 1651] 
P [617] << RM_ALARM()@now
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [617] ->
Q [618] << INV()
  and POA() >>
Why created:    normalization of [serial 1645]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 216:
Theorem (216) [serial 1652] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1651] 


Theorem (218)                               [serial 1645] 
P [617] << ( INV_E() )
  and ( RM_ALARM()@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [617] ->
Q [618] << INV()
  and POA() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1025]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 217:
Theorem (217) [serial 1651] used for:
    normalization of [serial 1645] 


Theorem (219)                               [serial 1654] 
P [618] << INV()
  and POA() >>
S [619] RM_Alarm?(rm_alarm_active)
Q [620] << INV()
  and POA()
  and ( rm_alarm_active iff RM_ALARM() )
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (220)                               [serial 1654] 
P [618] << INV()
  and POA() >>
S [619] RM_Alarm?(rm_alarm_active)
Q [620] << INV()
  and POA()
  and ( rm_alarm_active iff RM_ALARM() )
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (221)                               [serial 1646] 
P [618] << INV()
  and POA() >>
S [619] RM_Alarm?(rm_alarm_active)
Q [620] << INV()
  and POA()
  and ( rm_alarm_active iff RM_ALARM() )
  and GIVEN_RMA() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1025]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 220 220:
Theorem (220) [serial 1654] used for:
   add user-defined "givens" to postcondition 
Theorem (220) [serial 1654] used for:
   add user-defined "givens" to postcondition 


Theorem (222)                               [serial 1668] 
P [620] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) )
  and ( RM_ALARM() iff RM_ALARM_ECHO ) >>
S [621] ->
Q [621] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff ( ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1667]
Solved by: Principle of identity for logical equivalence. (biid) 

Theorem (223)                               [serial 1667] 
P [620] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) )
  and ( RM_ALARM() iff RM_ALARM_ECHO ) >>
S [621] ->
Q [621] << RM_ALARM() iff ( ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "RM_ALARM_ECHO" with its iff "RM_ALARM()" in its postcondition [serial 1666]
Solved by: Predicate Invocation. (PI) and theorem 222:
Theorem (222) [serial 1668] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1667] 


Theorem (224)                               [serial 1666] 
P [620] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) )
  and ( RM_ALARM() iff RM_ALARM_ECHO ) >>
S [621] ->
Q [621] << RM_ALARM_ECHO iff ( ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "rm_alarm_active" with its iff "( ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) )" in its postcondition [serial 1665]
Solved by:  Guided Substitution of Equals
 and theorem 223:
Theorem (223) [serial 1667] used for:
  Guided Substitution of Equals 
 replacing "RM_ALARM_ECHO" with its iff "RM_ALARM()" in its postcondition [serial 1666] 


Theorem (225)                               [serial 1665] 
P [620] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) )
  and ( RM_ALARM() iff RM_ALARM_ECHO ) >>
S [621] ->
Q [621] << RM_ALARM_ECHO iff rm_alarm_active >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1658]
Solved by:  Guided Substitution of Equals
 and theorem 224:
Theorem (224) [serial 1666] used for:
  Guided Substitution of Equals 
 replacing "rm_alarm_active" with its iff "( ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) )" in its postcondition [serial 1665] 


Theorem (226)                               [serial 1658] 
P [620] << INV()
  and POA()
  and ( rm_alarm_active iff RM_ALARM() )
  and GIVEN_RMA() >>
S [621] ->
Q [621] << RM_ALARM_ECHO iff rm_alarm_active >>
Why created:  applied port output of value <<pre>> -> <<M(RM_Alarm_Echo)[RM_Alarm_Echo|rm_alarm_active]>> [serial 1647]
Solved by: Predicate Invocation. (PI) and theorem 225:
Theorem (225) [serial 1665] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1658] 


Theorem (227)                               [serial 1659] 
P [621] << ( INV()
  and POA()
  and ( rm_alarm_active iff RM_ALARM() )
  and GIVEN_RMA() )
  and ( RM_ALARM_ECHO iff rm_alarm_active )@now >>
S [621] ->
Q [622] << INV()
  and RMA()
  and POA() >>
Why created:  applied port output <<pre and (RM_ALARM_ECHO iff rm_alarm_active)@now>> -> <<post>> [serial 1647]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (228)                               [serial 1647] 
P [620] << INV()
  and POA()
  and ( rm_alarm_active iff RM_ALARM() )
  and GIVEN_RMA() >>
S [621] RM_Alarm_Echo!(rm_alarm_active)
Q [622] << INV()
  and RMA()
  and POA() >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1025]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 226 227:
Theorem (226) [serial 1658] used for:
  applied port output of value <<pre>> -> <<M(RM_Alarm_Echo)[RM_Alarm_Echo|rm_alarm_active]>> [serial 1647] 
Theorem (227) [serial 1659] used for:
  applied port output <<pre and (RM_ALARM_ECHO iff rm_alarm_active)@now>> -> <<post>> [serial 1647] 


Theorem (229)                               [serial 1681] 
P [622] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [623] ->
Q [597] << ( ( PO_ALARM() or RM_ALARM() ) iff ( PO_ALARM() or RM_ALARM() ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "rm_alarm_active" with its iff "RM_ALARM()" in its postcondition [serial 1680]
Solved by: Principle of identity for logical equivalence. (biid) 

Theorem (230)                               [serial 1680] 
P [622] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [623] ->
Q [597] << ( ( PO_ALARM() or RM_ALARM() ) iff ( PO_ALARM() or rm_alarm_active ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "po_alarm_active" with its iff "PO_ALARM()" in its postcondition [serial 1676]
Solved by:  Guided Substitution of Equals
 and theorem 229:
Theorem (229) [serial 1681] used for:
  Guided Substitution of Equals 
 replacing "rm_alarm_active" with its iff "RM_ALARM()" in its postcondition [serial 1680] 


Theorem (231)                               [serial 1676] 
P [622] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [623] ->
Q [597] << ( ( PO_ALARM() or RM_ALARM() ) iff ( po_alarm_active or rm_alarm_active ) ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1675]
Solved by:  Guided Substitution of Equals
 and theorem 230:
Theorem (230) [serial 1680] used for:
  Guided Substitution of Equals 
 replacing "po_alarm_active" with its iff "PO_ALARM()" in its postcondition [serial 1676] 


Theorem (232)                               [serial 1677] 
P [622] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [623] ->
Q [585] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1675]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (233)                               [serial 1678] 
P [622] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [623] ->
Q [593] << ( PO_ALARM() iff po_alarm_active ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1675]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (234)                               [serial 1679] 
P [622] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [623] ->
Q [595] << ( RM_ALARM() iff rm_alarm_active ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1675]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (235)                               [serial 1675] 
P [622] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [623] ->
Q [624] << ( ( PO_ALARM() or RM_ALARM() ) iff ( po_alarm_active or rm_alarm_active ) )
  and ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
Why created:    normalization of [serial 1673]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 231 232 233 234:
Theorem (231) [serial 1676] used for:
  Join consequents with conjunction. (3jca)
   [serial 1675] 
Theorem (232) [serial 1677] used for:
  Join consequents with conjunction. (3jca)
   [serial 1675] 
Theorem (233) [serial 1678] used for:
  Join consequents with conjunction. (3jca)
   [serial 1675] 
Theorem (234) [serial 1679] used for:
  Join consequents with conjunction. (3jca)
   [serial 1675] 


Theorem (236)                               [serial 1673] 
P [622] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( po_alarm_active iff PO_ALARM() ) >>
S [623] ->
Q [624] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( ( po_alarm_active or rm_alarm_active ) iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1672]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 235:
Theorem (235) [serial 1675] used for:
    normalization of [serial 1673] 


Theorem (237)                               [serial 1672] 
P [622] << INV()
  and RMA()
  and POA() >>
S [623] ->
Q [624] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( ( po_alarm_active or rm_alarm_active ) iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  applied wp for assignment [serial 1671]
Solved by: Predicate Invocation. (PI) and theorem 236:
Theorem (236) [serial 1673] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1672] 


Theorem (238)                               [serial 1671] 
P [622] << INV()
  and RMA()
  and POA() >>
S [623] pause_inf := po_alarm_active or rm_alarm_active
Q [624] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1670]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 237:
Theorem (237) [serial 1672] used for:
  applied wp for assignment [serial 1671] 


Theorem (239)                               [serial 1670] 
P [622] << INV()
  and RMA()
  and POA() >>
S [623] pause_inf := po_alarm_active or rm_alarm_active
Q [624] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1648]
Solved by: Predicate Invocation. (PI) and theorem 238:
Theorem (238) [serial 1671] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1670] 


Theorem (240)                               [serial 1648] 
P [622] << INV()
  and RMA()
  and POA() >>
S [623] pause_inf := po_alarm_active or rm_alarm_active
Q [624] << INV_E() >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1025]
Solved by: Predicate Invocation. (PI) and theorem 239:
Theorem (239) [serial 1670] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1648] 


Theorem (241)                               [serial 1695] 
P [624] << ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [625] ->
Q [625] << ( ( PO_ALARM() or RM_ALARM() ) ) iff ( ( PO_ALARM() or RM_ALARM() ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "pause_inf" with its iff "( ( PO_ALARM() or RM_ALARM() ) )" in its postcondition [serial 1694]
Solved by: Principle of identity for logical equivalence. (biid) 

Theorem (242)                               [serial 1694] 
P [624] << ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [625] ->
Q [625] << ( ( PO_ALARM() or RM_ALARM() ) ) iff pause_inf >>
Why created:  Guided Substitution of Equals 
 replacing "PAUSE_INFUSION" with its iff "( ( PO_ALARM() or RM_ALARM() ) )" in its postcondition [serial 1693]
Solved by:  Guided Substitution of Equals
 and theorem 241:
Theorem (241) [serial 1695] used for:
  Guided Substitution of Equals 
 replacing "pause_inf" with its iff "( ( PO_ALARM() or RM_ALARM() ) )" in its postcondition [serial 1694] 


Theorem (243)                               [serial 1693] 
P [624] << ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [625] ->
Q [625] << PAUSE_INFUSION iff pause_inf >>
Why created:  Replacing port names with BLESS::Assertion properties  [serial 1690]
Solved by:  Guided Substitution of Equals
 and theorem 242:
Theorem (242) [serial 1694] used for:
  Guided Substitution of Equals 
 replacing "PAUSE_INFUSION" with its iff "( ( PO_ALARM() or RM_ALARM() ) )" in its postcondition [serial 1693] 


Theorem (244)                               [serial 1690] 
P [624] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [625] ->
Q [625] << PAUSE_INFUSION iff pause_inf >>
Why created:    normalization of [serial 1687]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by:  Replacing port names with BLESS::Assertion properties
 and theorem 243:
Theorem (243) [serial 1693] used for:
  Replacing port names with BLESS::Assertion properties  [serial 1690] 


Theorem (245)                               [serial 1687] 
P [624] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
S [625] ->
Q [625] << PAUSE_INFUSION iff pause_inf >>
Why created:  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|pause_inf]>> [serial 1686]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 244:
Theorem (244) [serial 1690] used for:
    normalization of [serial 1687] 


Theorem (246)                               [serial 1692] 
P [625] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) )
  and ( PAUSE_INFUSION iff pause_inf )@now >>
S [625] ->
Q [604] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
Why created:    normalization of [serial 1688]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (247)                               [serial 1688] 
P [625] << ( ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) )
  and ( PAUSE_INFUSION iff pause_inf )@now >>
S [625] ->
Q [604] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  applied port output <<pre and (PAUSE_INFUSION iff pause_inf)@now>> -> <<post>> [serial 1686]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 246:
Theorem (246) [serial 1692] used for:
    normalization of [serial 1688] 


Theorem (248)                               [serial 1686] 
P [624] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
S [625] Pause_Infusion!(pause_inf)
Q [604] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1685]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 245 247:
Theorem (245) [serial 1687] used for:
  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|pause_inf]>> [serial 1686] 
Theorem (247) [serial 1688] used for:
  applied port output <<pre and (PAUSE_INFUSION iff pause_inf)@now>> -> <<post>> [serial 1686] 


Theorem (249)                               [serial 1685] 
P [624] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
S [625] Pause_Infusion!(pause_inf)
Q [604] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1649]
Solved by: Predicate Invocation. (PI) and theorem 248:
Theorem (248) [serial 1686] used for:
  Substituted assertions' predicates for labels  [serial 1685] 


Theorem (250)                               [serial 1649] 
P [624] << INV_E() >>
S [625] Pause_Infusion!(pause_inf)
Q [604] << INV_E() >>
Why created:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1025]
Solved by: Predicate Invocation. (PI) and theorem 249:
Theorem (249) [serial 1685] used for:
  Substituted assertions' predicates for labels  [serial 1649] 


Theorem (251)                               [serial 1025] 
P [617] << ( INV_E() )
  and ( RM_ALARM()@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [618]   << INV()
    and POA() >>
  RM_Alarm?(rm_alarm_active)
  ;
  << INV()
    and POA()
    and ( rm_alarm_active iff RM_ALARM() )
    and GIVEN_RMA() >>
  RM_Alarm_Echo!(rm_alarm_active)
  ;
  << INV()
    and RMA()
    and POA() >>
  pause_inf := po_alarm_active or rm_alarm_active
  ;
  << INV_E() >>
  Pause_Infusion!(pause_inf) 
Q [604] << INV_E() >>
Why created:   <<M(run) and x>> A <<M(check_echo)>> for got_rm: run-[x]->check_echo{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 218 221 228 240 250:
Theorem (218) [serial 1645] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1025] 
Theorem (221) [serial 1646] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1025] 
Theorem (228) [serial 1647] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1025] 
Theorem (240) [serial 1648] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1025] 
Theorem (250) [serial 1649] used for:
  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1025] 


Theorem (252)                               [serial 1708] 
P [627] << ( PAUSE_INFUSION_ECHO@now
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) )
  and ( PAUSE_INFUSION_ECHO@now iff echo_val ) >>
S [630] ->
Q [630] << ( PAUSE_INFUSION_ECHO iff echo_val )
  and INV_E() >>
Why created:    normalization of [serial 1698]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) (bicom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (253)                               [serial 1698] 
P [627] << ( ( INV_E() )
  and ( PAUSE_INFUSION_ECHO@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) )
  and ( echo_val iff PAUSE_INFUSION_ECHO@now ) >>
S [630] ->
Q [630] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
Why created:  <<P and v=e>> -> <<A>> in behavior action block for [serial 1697]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) Biconditional (iff) Commutes. (bicom) and theorem 252:
Theorem (252) [serial 1708] used for:
    normalization of [serial 1698] 


Theorem (254)                               [serial 1701] 
P [630] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
S [630] ->
Q [630] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1699]
Solved by: Identity (id):  P->P is tautology

Theorem (255)                               [serial 1702] 
P [635] << INV_E() >>
S [635] ->
Q [635] << INV_E() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1699]
Solved by: Identity (id):  P->P is tautology

Theorem (256)                               [serial 1710] 
P [630] << ( PAUSE_INFUSION_ECHO iff echo_val )
  and INV_E() >>
S [631] ->
Q [631] << ( echo_val iff pause_inf ) or not ( echo_val iff pause_inf ) >>
Why created:    normalization of [serial 1704]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (257)                               [serial 1704] 
P [630] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
S [631] ->
Q [631] << ( echo_val iff pause_inf ) or ( not ( echo_val iff pause_inf ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1703]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) and theorem 256:
Theorem (256) [serial 1710] used for:
    normalization of [serial 1704] 


Theorem (258)                               [serial 1712] 
P [631] << ( ( PAUSE_INFUSION_ECHO iff echo_val )
  and INV_E() )
  and ( echo_val iff pause_inf ) >>
S [631] skip
Q [635] << INV_E() >>
Why created:    normalization of [serial 1705]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (259)                               [serial 1705] 
P [631] << ( ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() )
  and ( echo_val iff pause_inf ) >>
S [631] skip
Q [635] << INV_E() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1703]
Solved by: Biconditional (iff) Commutes. (bicom) and theorem 258:
Theorem (258) [serial 1712] used for:
    normalization of [serial 1705] 


Theorem (260)                               [serial 1714] 
P [631] << ( ( PAUSE_INFUSION_ECHO iff echo_val )
  and INV_E() )
  and not ( echo_val iff pause_inf ) >>
S [633] Lost_Confirmation!
Q [635] << INV_E() >>
Why created:    normalization of [serial 1706]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (261)                               [serial 1706] 
P [631] << ( ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() )
  and ( not ( echo_val iff pause_inf ) ) >>
S [633] Lost_Confirmation!
Q [635] << INV_E() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1703]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) and theorem 260:
Theorem (260) [serial 1714] used for:
    normalization of [serial 1706] 


Theorem (262)                               [serial 1703] 
P [630] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
S [631]   if 
    (echo_val iff pause_inf)~> 
      skip 
  []
    (not ( echo_val iff pause_inf ))~> 
      Lost_Confirmation! 
  fi
Q [635] << INV_E() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1699]
Solved by: and theorems 257 259 261:
Theorem (257) [serial 1704] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1703] 
Theorem (259) [serial 1705] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1703] 
Theorem (261) [serial 1706] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1703] 


Theorem (263)                               [serial 1699] 
P [630] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
S [630] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
  if 
    (echo_val iff pause_inf)~> 
      skip 
  []
    (not ( echo_val iff pause_inf ))~> 
      Lost_Confirmation! 
  fi
<< INV_E() >>
Q [635] << INV_E() >>
Why created:  <<A>> S <<B>> in behavior action block for [serial 1697]
Solved by: null and theorems 254 255 262:
Theorem (254) [serial 1701] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1699] 
Theorem (255) [serial 1702] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1699] 
Theorem (262) [serial 1703] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1699] 


Theorem (264)                               [serial 1700] 
P [635] << INV_E() >>
S [629] ->
Q [603] << INV_E() >>
Why created:  <<B>> -> <<Q>> in behavior action block for [serial 1697]
Solved by: Identity (id):  P->P is tautology

Theorem (265)                               [serial 1697] 
P [627] << ( INV_E() )
  and ( PAUSE_INFUSION_ECHO@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [629] declare 
   echo_val ~ boolean := Pause_Infusion_Echo?   {
  << ( echo_val iff PAUSE_INFUSION_ECHO )
    and INV_E() >>
    if 
      (echo_val iff pause_inf)~> 
        skip 
    []
      (not ( echo_val iff pause_inf ))~> 
        Lost_Confirmation! 
    fi
  << INV_E() >>
  } 
Q [603] << INV_E() >>
Why created:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1026]
Solved by: Behavior Action Block (BAB): 
     <<P and x=e>> -> <<A>>
     <<A>> S <<B>> 
     <<B>> -> <<Q>>
----------------------------------------------------
<<P>> declare variable v~y:=e; { <<A>> S <<B>> } <<Q>> and theorems 253 263 264:
Theorem (253) [serial 1698] used for:
  <<P and v=e>> -> <<A>> in behavior action block for [serial 1697] 
Theorem (263) [serial 1699] used for:
  <<A>> S <<B>> in behavior action block for [serial 1697] 
Theorem (264) [serial 1700] used for:
  <<B>> -> <<Q>> in behavior action block for [serial 1697] 


Theorem (266)                               [serial 1026] 
P [627] << ( INV_E() )
  and ( PAUSE_INFUSION_ECHO@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [629] declare 
   echo_val ~ boolean := Pause_Infusion_Echo?   {
  << ( echo_val iff PAUSE_INFUSION_ECHO )
    and INV_E() >>
    if 
      (echo_val iff pause_inf)~> 
        skip 
    []
      (not ( echo_val iff pause_inf ))~> 
        Lost_Confirmation! 
    fi
  << INV_E() >>
  } 
Q [603] << INV_E() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A};
Solved by: null and theorem 265:
Theorem (265) [serial 1697] used for:
  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1026] 


Theorem (267)                               [serial 1733] 
P [639] << ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [640] ->
Q [640] << true >>
Why created:    normalization of [serial 1730]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Anything Implies True (a1tru): P->true

Theorem (268)                               [serial 1730] 
P [639] << ( INV_E() )
  and ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [640] ->
Q [640] << true >>
Why created:  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1027]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 267:
Theorem (267) [serial 1733] used for:
    normalization of [serial 1730] 


Theorem (269)                               [serial 1735] 
P [640] << ( ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) )
  and true >>
S [640] ->
Q [603] << INV_E() >>
Why created:    normalization of [serial 1731]
  Using: (bl.atintro) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (270)                               [serial 1731] 
P [640] << ( ( INV_E() )
  and ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) )
  and true@now >>
S [640] ->
Q [603] << INV_E() >>
Why created:  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1027]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 269:
Theorem (269) [serial 1735] used for:
    normalization of [serial 1731] 


Theorem (271)                               [serial 1027] 
P [639] << ( INV_E() )
  and ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [640] Lost_Confirmation!
Q [603] << INV_E() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A};
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 268 270:
Theorem (268) [serial 1730] used for:
  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1027] 
Theorem (270) [serial 1731] used for:
  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1027] 


Theorem (272)                               [serial 1018] 
P [584] <<   >>
S [590] ->
Q [584] << Coordinator_Thread.echo proof obligations >>
Why created:  Initial proof obligations for Coordinator_Thread.echo
Solved by:  Component verification conditions
 and theorems 166 169 172 173 174 215 251 266 271:
Theorem (166) [serial 1019] used for:
  <<I>> -> BLESS::Invariant of thread Coordinator_Thread.echo 
Theorem (169) [serial 1020] used for:
  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition. 
Theorem (172) [serial 1021] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (173) [serial 1022] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (174) [serial 1023] used for:
   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{}; 
Theorem (215) [serial 1024] used for:
   <<M(run) and x>> A <<M(check_echo)>> for got_po: run-[x]->check_echo{A}; 
Theorem (251) [serial 1025] used for:
   <<M(run) and x>> A <<M(check_echo)>> for got_rm: run-[x]->check_echo{A}; 
Theorem (266) [serial 1026] used for:
   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A}; 
Theorem (271) [serial 1027] used for:
   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A}; 


Theorem (273)                               [serial 1741] 
P [1] << ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff PAUSE_INFUSION )
  and ( PAUSE_INFUSION implies KVO_RATE_property = PUMP_RATE$() ) >>
S    ->
Q [2] << ( ( HEART_RATE < MINIMUM_HEART_RATE or RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE or 
SPO2 < PROGRAMMED_SPO2 ) implies KVO_RATE_property = PUMP_RATE$() ) or HALT() >>
Why created:    normalization of [serial 1739]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) (bl.orcom) 
Solved by: Absorb parentheses, middle term in disjunction (bl.orabpm)

Theorem (274)                               [serial 1739] 
P [1] << ( PAUSE_INFUSION implies PUMP_RATE$() = KVO_RATE_property )
  and ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) iff PAUSE_INFUSION ) >>
S    ->
Q [2] << ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 or RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) implies PUMP_RATE$() = KVO_RATE_property ) or 
HALT() ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1028]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 273:
Theorem (273) [serial 1741] used for:
    normalization of [serial 1739] 


Theorem (275)                               [serial 1028] 
P [1] << ( PAUSE_INFUSION implies PUMP_RATE$() = KVO_RATE_property )
  and ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION ) >>
S    ->
Q [2] << IS_SAFE() >>
Why created:  Conjunction of Subcomponents' Invariants imply SysIoMT.impl's Invariant
Solved by: Predicate Invocation. (PI) and theorem 274:
Theorem (274) [serial 1739] used for:
  Substituted assertions' predicates for labels  [serial 1028] 


Theorem (276)                               [serial 1747] 
P [1] << PAUSE_INFUSION implies KVO_RATE_property = PUMP_RATE$() >>
S    ->
Q [2] << PAUSE_INFUSION implies KVO_RATE_property = PUMP_RATE$() >>
Why created:    normalization of [serial 1029]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Identity (id):  P->P is tautology

Theorem (277)                               [serial 1029] 
P [1] << ( PAUSE_INFUSION implies PUMP_RATE$() = KVO_RATE_property ) >>
S    ->
Q [2] << PAUSE_INFUSION implies PUMP_RATE$() = KVO_RATE_property >>
Why created:  Subcomponent's Invariant implies PCA_Pump.impl's Invariant
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 276:
Theorem (276) [serial 1747] used for:
    normalization of [serial 1029] 


Theorem (278)                               [serial 1749] 
P [1] << PAUSE_INFUSION implies KVO_RATE_property = PUMP_RATE$() >>
S    ->
Q [2] << PAUSE_INFUSION implies KVO_RATE_property = PUMP_RATE$() >>
Why created:    normalization of [serial 1030]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Identity (id):  P->P is tautology

Theorem (279)                               [serial 1030] 
P [1] << ( PAUSE_INFUSION implies PUMP_RATE$() = KVO_RATE_property ) >>
S    ->
Q [2] << PAUSE_INFUSION implies PUMP_RATE$() = KVO_RATE_property >>
Why created:  Subcomponent's Invariant implies PCA_Pump_Process.impl's Invariant
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 278:
Theorem (278) [serial 1749] used for:
    normalization of [serial 1030] 


Theorem (280)                               [serial 1751] 
P [1] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
S    ->
Q [2] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:    normalization of [serial 1031]
Solved by: Identity (id):  P->P is tautology

Theorem (281)                               [serial 1031] 
P [1] << ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION ) >>
S    ->
Q [2] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:  Subcomponent's Invariant implies Coordinator.impl's Invariant
Solved by: [Add unnecessary parentheses] and theorem 280:
Theorem (280) [serial 1751] used for:
    normalization of [serial 1031] 


Theorem (282)                               [serial 1753] 
P [1] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
S    ->
Q [2] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:    normalization of [serial 1032]
Solved by: Identity (id):  P->P is tautology

Theorem (283)                               [serial 1032] 
P [1] << ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION ) >>
S    ->
Q [2] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:  Subcomponent's Invariant implies Coordinator_Process.impl's Invariant
Solved by: [Add unnecessary parentheses] and theorem 282:
Theorem (282) [serial 1753] used for:
    normalization of [serial 1032] 


Theorem (284)                               [serial 1033] 
P [1] << PAUSE_INFUSION >>
S [2] ->
Q [1] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection pcc.pause_infusion -> pct.pause_infusion:
 pause_infusion -> pause_infusion
Solved by: Identity (id):  P->P is tautology

Theorem (285)                               [serial 1034] 
P [1] << pump_rate = PUMP_RATE$() >>
S [2] ->
Q [1] << pump_rate = PUMP_RATE$() >>
Why created:  Composition of Subcomponents via Directional Connection pcp.pct.pump_rate -> pmp.pump_rate:
 pump_rate -> pump_rate
Solved by: Identity (id):  P->P is tautology

Theorem (286)                               [serial 1035] 
P [1] << PO_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection pot.PO_Alarm -> poc.poa:
 PO_Alarm -> poa
Solved by: Identity (id):  P->P is tautology

Theorem (287)                               [serial 1757] 
P [1] << RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE >>
S [2] ->
Q [1] << RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE >>
Why created:    normalization of [serial 1755]
Solved by: Identity (id):  P->P is tautology

Theorem (288)                               [serial 1755] 
P [1] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) >>
S [2] ->
Q [1] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1754]
Solved by: [Add unnecessary parentheses] and theorem 287:
Theorem (287) [serial 1757] used for:
    normalization of [serial 1755] 


Theorem (289)                               [serial 1754] 
P [1] << RM_ALARM() >>
S [2] ->
Q [1] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1036]
Solved by: Predicate Invocation. (PI) and theorem 288:
Theorem (288) [serial 1755] used for:
  Substituted assertions' predicates for labels  [serial 1754] 


Theorem (290)                               [serial 1036] 
P [1] << RM_ALARM() >>
S [2] ->
Q [1] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection rmt.RM_Alarm -> rmc.rma:
 RM_Alarm -> rma
Solved by: Predicate Invocation. (PI) and theorem 289:
Theorem (289) [serial 1754] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1036] 


Theorem (291)                               [serial 1759] 
P [1] << RESPIRATION_RATE = RP_Rate >>
S [2] ->
Q [1] << RESPIRATION_RATE = RP_Rate >>
Why created:    normalization of [serial 1037]
Solved by: Identity (id):  P->P is tautology

Theorem (292)                               [serial 1037] 
P [1] << RP_Rate = RESPIRATION_RATE >>
S [2] ->
Q [1] << RP_Rate = RESPIRATION_RATE >>
Why created:  Composition of Subcomponents via Directional Connection rss.RP_Rate -> rmp.rmt.RP_Rate:
 RP_Rate -> RP_Rate
Solved by: Equality Commutes. (eqcom) and theorem 291:
Theorem (291) [serial 1759] used for:
    normalization of [serial 1037] 


Theorem (293)                               [serial 1038] 
P [1] << RM_ALARM_ECHO >>
S [2] ->
Q [1] << RM_ALARM_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection spt.RM_Alarm_Echo -> spc.rmae:
 RM_Alarm_Echo -> rmae
Solved by: Identity (id):  P->P is tautology

Theorem (294)                               [serial 1039] 
P [1] << PO_ALARM_ECHO >>
S [2] ->
Q [1] << PO_ALARM_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection spt.PO_Alarm_Echo -> spc.poae:
 PO_Alarm_Echo -> poae
Solved by: Identity (id):  P->P is tautology

Theorem (295)                               [serial 1040] 
P [1] << PAUSE_INFUSION >>
S [2] ->
Q [1] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection spt.Pause_Infusion -> spc.pi:
 Pause_Infusion -> pi
Solved by: Identity (id):  P->P is tautology

Theorem (296)                               [serial 1041] 
P [1] << PO_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection spc.PO_Alarm -> spt.PO_Alarm:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (297)                               [serial 1042] 
P [1] << RM_ALARM() >>
S [2] ->
Q [1] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection spc.RM_Alarm -> spt.RM_Alarm:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (298)                               [serial 1043] 
P [1] << PAUSE_INFUSION_ECHO >>
S [2] ->
Q [1] << PAUSE_INFUSION_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection spc.Pause_Infusion_Echo -> spt.Pause_Infusion_Echo:
 Pause_Infusion_Echo -> Pause_Infusion_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (299)                               [serial 1044] 
P [1] << infused_drug = PUMP_RATE$() >>
S [2] ->
Q [1] << infused_drug = PUMP_RATE$() >>
Why created:  Composition of Subcomponents via Directional Connection pca_pump.pmp.infused_drug -> patient.Infused_Drug:
 infused_drug -> Infused_Drug
Solved by: Identity (id):  P->P is tautology

Theorem (300)                               [serial 1045] 
P [1] << PO_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection pulse_oximeter.pop.poc.PO_Alarm -> coordinator.spp.spc.poa:
 PO_Alarm -> poa
Solved by: Identity (id):  P->P is tautology

Theorem (301)                               [serial 1046] 
P [1] << RM_ALARM() >>
S [2] ->
Q [1] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection resp_monitor.rmp.rmc.RM_Alarm -> coordinator.spp.spc.rma:
 RM_Alarm -> rma
Solved by: Identity (id):  P->P is tautology

Theorem (302)                               [serial 1047] 
P [1] << PAUSE_INFUSION >>
S [2] ->
Q [1] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection coordinator.spp.spc.Pause_Infusion -> pca_pump.pcp.pcc.pi:
 Pause_Infusion -> pi
Solved by: Identity (id):  P->P is tautology

Theorem (303)                               [serial 1048] 
P [67] << infused_drug = PUMP_RATE$() >>
S [38] ->
Q [691] << infused_drug = PUMP_RATE$() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.infusion_set:
 infused_drug -> Infused_Drug
Solved by: Identity (id):  P->P is tautology

Theorem (304)                               [serial 1049] 
P [485] << PAUSE_INFUSION >>
S [24] ->
Q [65] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.pause_infusion:
 Pause_Infusion -> pause_infusion
Solved by: Identity (id):  P->P is tautology

Theorem (305)                               [serial 1050] 
P [166] << PO_ALARM() >>
S [26] ->
Q [481] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.po_alarm:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (306)                               [serial 1051] 
P [338] << RM_ALARM() >>
S [28] ->
Q [477] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.rm_alarm:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (307)                               [serial 1052] 
P [69] << PAUSE_INFUSION_ECHO >>
S [31] ->
Q [487] << PAUSE_INFUSION_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.pause_infusion_echo:
 pause_infusion_echo -> Pause_Infusion_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (308)                               [serial 1053] 
P [140] << infused_drug = PUMP_RATE$() >>
S [86] ->
Q [67] << infused_drug = PUMP_RATE$() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pd:
 infused_drug -> infused_drug
Solved by: Identity (id):  P->P is tautology

Theorem (309)                               [serial 1054] 
P [65] << PAUSE_INFUSION >>
S [82] ->
Q [93] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pif:
 pause_infusion -> pause_infusion
Solved by: Identity (id):  P->P is tautology

Theorem (310)                               [serial 1055] 
P [97] << PAUSE_INFUSION_ECHO >>
S [83] ->
Q [69] << PAUSE_INFUSION_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pie:
 pause_infusion_echo -> pause_infusion_echo
Solved by: Identity (id):  P->P is tautology

Theorem (311)                               [serial 1056] 
P [95] << pump_rate = PUMP_RATE$() >>
S [84] ->
Q [145] << pump_rate = PUMP_RATE$() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pr:
 pump_rate -> pump_rate
Solved by: Identity (id):  P->P is tautology

Theorem (312)                               [serial 1057] 
P [93] << PAUSE_INFUSION >>
S [108] ->
Q [151] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.pi1:
 pause_infusion -> pi
Solved by: Identity (id):  P->P is tautology

Theorem (313)                               [serial 1058] 
P [153] << PAUSE_INFUSION >>
S [109] ->
Q [122] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.pi2:
 pause_infusion -> pause_infusion
Solved by: Identity (id):  P->P is tautology

Theorem (314)                               [serial 1059] 
P [119] << pump_rate = PUMP_RATE$() >>
S [113] ->
Q [95] << pump_rate = PUMP_RATE$() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.PCA_Pump_Process_impl_new_connection:
 pump_rate -> pump_rate
Solved by: Identity (id):  P->P is tautology

Theorem (315)                               [serial 1060] 
P [192] << PO_ALARM() >>
S [178] ->
Q [166] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter.impl.poa:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (316)                               [serial 1061] 
P [223] << PO_ALARM() >>
S [207] ->
Q [317] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter_Process.impl.pol1:
 PO_Alarm -> poa
Solved by: Identity (id):  P->P is tautology

Theorem (317)                               [serial 1062] 
P [319] << PO_ALARM() >>
S [208] ->
Q [192] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter_Process.impl.pol2:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (318)                               [serial 1063] 
P [358] << RM_ALARM() >>
S [349] ->
Q [338] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor.impl.rma:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (319)                               [serial 1064] 
P [383] << RM_ALARM() >>
S [372] ->
Q [455] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor_Process.impl.rma1:
 RM_Alarm -> rma
Solved by: Identity (id):  P->P is tautology

Theorem (320)                               [serial 1065] 
P [457] << RM_ALARM() >>
S [373] ->
Q [358] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor_Process.impl.rma2:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (321)                               [serial 1066] 
P [481] << PO_ALARM() >>
S [500] ->
Q [518] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.poa:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (322)                               [serial 1067] 
P [477] << RM_ALARM() >>
S [501] ->
Q [514] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.rma:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (323)                               [serial 1068] 
P [522] << PAUSE_INFUSION >>
S [502] ->
Q [485] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.pi:
 Pause_Infusion -> Pause_Infusion
Solved by: Identity (id):  P->P is tautology

Theorem (324)                               [serial 1069] 
P [487] << PAUSE_INFUSION_ECHO >>
S [503] ->
Q [524] << PAUSE_INFUSION_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.pie:
 Pause_Infusion_Echo -> Pause_Infusion_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (325)                               [serial 1070] 
P [520] << PO_ALARM_ECHO >>
S [505] ->
Q [483] << PO_ALARM_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.icp:
 PO_Alarm_Echo -> PO_Alarm_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (326)                               [serial 1071] 
P [516] << RM_ALARM_ECHO >>
S [506] ->
Q [479] << RM_ALARM_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.icr:
 RM_Alarm_Echo -> RM_Alarm_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (327)                               [serial 1072] 
P [518] << PO_ALARM() >>
S [537] ->
Q [650] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poa1:
 PO_Alarm -> poa
Solved by: Identity (id):  P->P is tautology

Theorem (328)                               [serial 1073] 
P [652] << PO_ALARM() >>
S [538] ->
Q [562] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poa2:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (329)                               [serial 1074] 
P [514] << RM_ALARM() >>
S [539] ->
Q [658] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rma1:
 RM_Alarm -> rma
Solved by: Identity (id):  P->P is tautology

Theorem (330)                               [serial 1075] 
P [660] << RM_ALARM() >>
S [540] ->
Q [558] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rma2:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (331)                               [serial 1076] 
P [524] << PAUSE_INFUSION_ECHO >>
S [541] ->
Q [670] << PAUSE_INFUSION_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pie1:
 Pause_Infusion_Echo -> pie
Solved by: Identity (id):  P->P is tautology

Theorem (332)                               [serial 1077] 
P [672] << PAUSE_INFUSION_ECHO >>
S [542] ->
Q [568] << PAUSE_INFUSION_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pie2:
 Pause_Infusion_Echo -> Pause_Infusion_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (333)                               [serial 1078] 
P [566] << PAUSE_INFUSION >>
S [543] ->
Q [666] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pi1:
 Pause_Infusion -> pi
Solved by: Identity (id):  P->P is tautology

Theorem (334)                               [serial 1079] 
P [668] << PAUSE_INFUSION >>
S [544] ->
Q [522] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pi2:
 Pause_Infusion -> Pause_Infusion
Solved by: Identity (id):  P->P is tautology

Theorem (335)                               [serial 1080] 
P [560] << RM_ALARM_ECHO >>
S [545] ->
Q [662] << RM_ALARM_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rme1:
 RM_Alarm_Echo -> rmae
Solved by: Identity (id):  P->P is tautology

Theorem (336)                               [serial 1081] 
P [664] << RM_ALARM_ECHO >>
S [546] ->
Q [516] << RM_ALARM_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rme2:
 RM_Alarm_Echo -> RM_Alarm_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (337)                               [serial 1082] 
P [564] << PO_ALARM_ECHO >>
S [547] ->
Q [654] << PO_ALARM_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poe1:
 PO_Alarm_Echo -> poae
Solved by: Identity (id):  P->P is tautology

Theorem (338)                               [serial 1083] 
P [656] << PO_ALARM_ECHO >>
S [548] ->
Q [520] << PO_ALARM_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poe2:
 PO_Alarm_Echo -> PO_Alarm_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (339)                               [serial 1001] 
Why created:  All verification conditions have been proved correct. 
Solved by:  Component and Connection Proofs
 and theorems 91 159 272 275 277 279 281 283 284 285 286 290 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338:
Theorem (91) [serial 1002] used for:
  Initial proof obligations for Pulse_Oximeter_Thread.impl 
Theorem (159) [serial 1010] used for:
  Initial proof obligations for Respiration_Monitor_Thread.impl 
Theorem (272) [serial 1018] used for:
  Initial proof obligations for Coordinator_Thread.echo 
Theorem (275) [serial 1028] used for:
  Conjunction of Subcomponents' Invariants imply SysIoMT.impl's Invariant 
Theorem (277) [serial 1029] used for:
  Subcomponent's Invariant implies PCA_Pump.impl's Invariant 
Theorem (279) [serial 1030] used for:
  Subcomponent's Invariant implies PCA_Pump_Process.impl's Invariant 
Theorem (281) [serial 1031] used for:
  Subcomponent's Invariant implies Coordinator.impl's Invariant 
Theorem (283) [serial 1032] used for:
  Subcomponent's Invariant implies Coordinator_Process.impl's Invariant 
Theorem (284) [serial 1033] used for:
  Composition of Subcomponents via Directional Connection pcc.pause_infusion -> pct.pause_infusion:
 pause_infusion -> pause_infusion 
Theorem (285) [serial 1034] used for:
  Composition of Subcomponents via Directional Connection pcp.pct.pump_rate -> pmp.pump_rate:
 pump_rate -> pump_rate 
Theorem (286) [serial 1035] used for:
  Composition of Subcomponents via Directional Connection pot.PO_Alarm -> poc.poa:
 PO_Alarm -> poa 
Theorem (290) [serial 1036] used for:
  Composition of Subcomponents via Directional Connection rmt.RM_Alarm -> rmc.rma:
 RM_Alarm -> rma 
Theorem (292) [serial 1037] used for:
  Composition of Subcomponents via Directional Connection rss.RP_Rate -> rmp.rmt.RP_Rate:
 RP_Rate -> RP_Rate 
Theorem (293) [serial 1038] used for:
  Composition of Subcomponents via Directional Connection spt.RM_Alarm_Echo -> spc.rmae:
 RM_Alarm_Echo -> rmae 
Theorem (294) [serial 1039] used for:
  Composition of Subcomponents via Directional Connection spt.PO_Alarm_Echo -> spc.poae:
 PO_Alarm_Echo -> poae 
Theorem (295) [serial 1040] used for:
  Composition of Subcomponents via Directional Connection spt.Pause_Infusion -> spc.pi:
 Pause_Infusion -> pi 
Theorem (296) [serial 1041] used for:
  Composition of Subcomponents via Directional Connection spc.PO_Alarm -> spt.PO_Alarm:
 PO_Alarm -> PO_Alarm 
Theorem (297) [serial 1042] used for:
  Composition of Subcomponents via Directional Connection spc.RM_Alarm -> spt.RM_Alarm:
 RM_Alarm -> RM_Alarm 
Theorem (298) [serial 1043] used for:
  Composition of Subcomponents via Directional Connection spc.Pause_Infusion_Echo -> spt.Pause_Infusion_Echo:
 Pause_Infusion_Echo -> Pause_Infusion_Echo 
Theorem (299) [serial 1044] used for:
  Composition of Subcomponents via Directional Connection pca_pump.pmp.infused_drug -> patient.Infused_Drug:
 infused_drug -> Infused_Drug 
Theorem (300) [serial 1045] used for:
  Composition of Subcomponents via Directional Connection pulse_oximeter.pop.poc.PO_Alarm -> coordinator.spp.spc.poa:
 PO_Alarm -> poa 
Theorem (301) [serial 1046] used for:
  Composition of Subcomponents via Directional Connection resp_monitor.rmp.rmc.RM_Alarm -> coordinator.spp.spc.rma:
 RM_Alarm -> rma 
Theorem (302) [serial 1047] used for:
  Composition of Subcomponents via Directional Connection coordinator.spp.spc.Pause_Infusion -> pca_pump.pcp.pcc.pi:
 Pause_Infusion -> pi 
Theorem (303) [serial 1048] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.infusion_set:
 infused_drug -> Infused_Drug 
Theorem (304) [serial 1049] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.pause_infusion:
 Pause_Infusion -> pause_infusion 
Theorem (305) [serial 1050] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.po_alarm:
 PO_Alarm -> PO_Alarm 
Theorem (306) [serial 1051] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.rm_alarm:
 RM_Alarm -> RM_Alarm 
Theorem (307) [serial 1052] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.pause_infusion_echo:
 pause_infusion_echo -> Pause_Infusion_Echo 
Theorem (308) [serial 1053] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pd:
 infused_drug -> infused_drug 
Theorem (309) [serial 1054] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pif:
 pause_infusion -> pause_infusion 
Theorem (310) [serial 1055] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pie:
 pause_infusion_echo -> pause_infusion_echo 
Theorem (311) [serial 1056] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pr:
 pump_rate -> pump_rate 
Theorem (312) [serial 1057] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.pi1:
 pause_infusion -> pi 
Theorem (313) [serial 1058] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.pi2:
 pause_infusion -> pause_infusion 
Theorem (314) [serial 1059] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.PCA_Pump_Process_impl_new_connection:
 pump_rate -> pump_rate 
Theorem (315) [serial 1060] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter.impl.poa:
 PO_Alarm -> PO_Alarm 
Theorem (316) [serial 1061] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter_Process.impl.pol1:
 PO_Alarm -> poa 
Theorem (317) [serial 1062] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter_Process.impl.pol2:
 PO_Alarm -> PO_Alarm 
Theorem (318) [serial 1063] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor.impl.rma:
 RM_Alarm -> RM_Alarm 
Theorem (319) [serial 1064] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor_Process.impl.rma1:
 RM_Alarm -> rma 
Theorem (320) [serial 1065] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor_Process.impl.rma2:
 RM_Alarm -> RM_Alarm 
Theorem (321) [serial 1066] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.poa:
 PO_Alarm -> PO_Alarm 
Theorem (322) [serial 1067] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.rma:
 RM_Alarm -> RM_Alarm 
Theorem (323) [serial 1068] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.pi:
 Pause_Infusion -> Pause_Infusion 
Theorem (324) [serial 1069] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.pie:
 Pause_Infusion_Echo -> Pause_Infusion_Echo 
Theorem (325) [serial 1070] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.icp:
 PO_Alarm_Echo -> PO_Alarm_Echo 
Theorem (326) [serial 1071] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.icr:
 RM_Alarm_Echo -> RM_Alarm_Echo 
Theorem (327) [serial 1072] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poa1:
 PO_Alarm -> poa 
Theorem (328) [serial 1073] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poa2:
 PO_Alarm -> PO_Alarm 
Theorem (329) [serial 1074] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rma1:
 RM_Alarm -> rma 
Theorem (330) [serial 1075] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rma2:
 RM_Alarm -> RM_Alarm 
Theorem (331) [serial 1076] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pie1:
 Pause_Infusion_Echo -> pie 
Theorem (332) [serial 1077] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pie2:
 Pause_Infusion_Echo -> Pause_Infusion_Echo 
Theorem (333) [serial 1078] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pi1:
 Pause_Infusion -> pi 
Theorem (334) [serial 1079] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pi2:
 Pause_Infusion -> Pause_Infusion 
Theorem (335) [serial 1080] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rme1:
 RM_Alarm_Echo -> rmae 
Theorem (336) [serial 1081] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rme2:
 RM_Alarm_Echo -> RM_Alarm_Echo 
Theorem (337) [serial 1082] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poe1:
 PO_Alarm_Echo -> poae 
Theorem (338) [serial 1083] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poe2:
 PO_Alarm_Echo -> PO_Alarm_Echo 


closing proof file "/Applications/osate2_2023-12-master/Eclipse.app/Contents/MacOS/proof.txt" 