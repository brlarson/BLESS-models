This file, proof.txt, was produced the BLESS Proof Assistant v3.2.4
  at Fri Apr 19 16:10:17 AST 2024 by ehsanahmad

Theorem (1)                               [serial 1084] 
P [267] << MHR_A()
  and POA_A()
  and PSPO2_A() >>
S [252] ->
Q [252] << MHR_A()
  and POA_A()
  and PSPO2_A() >>
Why created:    normalization of [serial 1082]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (2)                               [serial 1082] 
P [267] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
S [252] ->
Q [252] << MHR_A()
  and PSPO2_A()
  and POA_A() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1003]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 1:
Theorem (1) [serial 1084] used for:
    normalization of [serial 1082] 


Theorem (3)                               [serial 1003] 
P [267] << INV_PO() >>
S [252] ->
Q [252] << MHR_A()
  and PSPO2_A()
  and POA_A() >>
Why created:  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 2:
Theorem (2) [serial 1082] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1003] 


Theorem (4)                               [serial 1087] 
P [266] << MHR_A()
  and POA_A()
  and PSPO2_A() >>
S [252] ->
Q [252] << MHR_A()
  and POA_A()
  and PSPO2_A() >>
Why created:    normalization of [serial 1085]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (5)                               [serial 1085] 
P [266] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
S [252] ->
Q [252] << MHR_A()
  and PSPO2_A()
  and POA_A() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1004]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 4:
Theorem (4) [serial 1087] used for:
    normalization of [serial 1085] 


Theorem (6)                               [serial 1004] 
P [266] << INV_PO() >>
S [252] ->
Q [252] << MHR_A()
  and PSPO2_A()
  and POA_A() >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 5:
Theorem (5) [serial 1085] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1004] 


Theorem (7)                               [serial 1005] 
P [265] << INV_PO() >>
S [265] ->
Q [265] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by: Anything Implies True (a1tru): P->true

Theorem (8)                               [serial 1006] 
P [265] << INV_PO() >>
S [270] ->
Q [266] << INV_PO() >>
Why created:   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{};
Solved by: Identity (id):  P->P is tautology

Theorem (9)                               [serial 1088] 
P [266] << INV_PO() >>
S [266] ->
Q [274] << INV_PO() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1007]
Solved by: Identity (id):  P->P is tautology

Theorem (10)                               [serial 1089] 
P [299] << INV_PO() >>
S [267] ->
Q [267] << INV_PO() >>
Why created:  <<Q3>> -> <<Q>> in sequential composition for [serial 1007]
Solved by: Identity (id):  P->P is tautology

Theorem (11)                               [serial 1160] 
P [275] << HEART_RATE = hrr
  and INV_PO() >>
S [275] ->
Q [276] << HEART_RATE = hrr
  and INV_PO() >>
Why created:    normalization of [serial 1158]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (12)                               [serial 1158] 
P [275] << ( INV_PO() )
  and hrr = HEART_RATE >>
S [275] ->
Q [276] << HEART_RATE = hrr
  and INV_PO() >>
Why created:  applied port input of value <<pre and hrr=M(Heart_Rate)>> -> <<post>> [serial 1113]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 11:
Theorem (11) [serial 1160] used for:
    normalization of [serial 1158] 


Theorem (13)                               [serial 1113] 
P [274] << INV_PO() >>
S [275] Heart_Rate?(hrr)
Q [276] << HEART_RATE = hrr
  and INV_PO() >>
Why created:    normalization of [serial 1090]
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 12:
Theorem (12) [serial 1158] used for:
  applied port input of value <<pre and hrr=M(Heart_Rate)>> -> <<post>> [serial 1113] 


Theorem (14)                               [serial 1090] 
P [274] << INV_PO() >>
S [275] Heart_Rate?(hrr)
Q [276] << hrr = HEART_RATE
  and INV_PO() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1007]
Solved by: Equality Commutes. (eqcom) and theorem 13:
Theorem (13) [serial 1113] used for:
    normalization of [serial 1090] 


Theorem (15)                               [serial 1163] 
P [277] << ( HEART_RATE = hrr
  and INV_PO() )
  and SPO2 = sp >>
S [277] ->
Q [278] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1161]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (16)                               [serial 1161] 
P [277] << ( HEART_RATE = hrr
  and INV_PO() )
  and sp = SPO2 >>
S [277] ->
Q [278] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:  applied port input of value <<pre and sp=M(Spo2_Level)>> -> <<post>> [serial 1115]
Solved by: Equality Commutes. (eqcom) and theorem 15:
Theorem (15) [serial 1163] used for:
    normalization of [serial 1161] 


Theorem (17)                               [serial 1115] 
P [276] << HEART_RATE = hrr
  and INV_PO() >>
S [277] Spo2_Level?(sp)
Q [278] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1091]
  Using: (eqcom) (bl.ancom) 
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 16:
Theorem (16) [serial 1161] used for:
  applied port input of value <<pre and sp=M(Spo2_Level)>> -> <<post>> [serial 1115] 


Theorem (18)                               [serial 1091] 
P [276] << hrr = HEART_RATE
  and INV_PO() >>
S [277] Spo2_Level?(sp)
Q [278] << hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1007]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 17:
Theorem (17) [serial 1115] used for:
    normalization of [serial 1091] 


Theorem (19)                               [serial 1168] 
P [278] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [280] ->
Q [280] << ( not ( hrr < mhr ) or hrr < mhr or sp < psp )
  and ( not ( sp < psp ) or hrr < mhr or sp < psp ) >>
Why created:  Distributing Postcondition Or-Over-And [serial 1167]
Solved by: Law of Excluded middle. (exmid)

Theorem (20)                               [serial 1167] 
P [278] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [280] ->
Q [280] << ( not ( hrr < mhr )
  and not ( sp < psp ) ) or hrr < mhr or sp < psp >>
Why created:    normalization of [serial 1165]
Solved by: Distribution and-over-or with wff lists. (bl.dba2owl) and theorem 19:
Theorem (19) [serial 1168] used for:
  Distributing Postcondition Or-Over-And [serial 1167] 


Theorem (21)                               [serial 1165] 
P [278] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [280] ->
Q [280] << ( ( not ( hrr < mhr ) )
  and ( not ( sp < psp ) ) ) or hrr < mhr or sp < psp >>
Why created:  Replacing <= with not < of [serial 1117]
Solved by: [Add unnecessary parentheses] and theorem 20:
Theorem (20) [serial 1167] used for:
    normalization of [serial 1165] 


Theorem (22)                               [serial 1117] 
P [278] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [280] ->
Q [280] << ( mhr <= hrr
  and psp <= sp ) or hrr < mhr or sp < psp >>
Why created:    normalization of [serial 1093]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) (bl.orcom) 
Solved by: 'Less than' expressed in terms of 'less than or equal to'. (ltnle) and theorem 21:
Theorem (21) [serial 1165] used for:
  Replacing <= with not < of [serial 1117] 


Theorem (23)                               [serial 1093] 
P [278] << hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 >>
S [280] ->
Q [280] << ( hrr >= mhr
  and sp >= psp ) or ( hrr < mhr ) or ( sp < psp ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1092]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 22:
Theorem (22) [serial 1117] used for:
    normalization of [serial 1093] 


Theorem (24)                               [serial 1119] 
P [280] << ( mhr <= hrr
  and psp <= sp )
  and ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() ) >>
S [282] ->
Q [282] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1100]
  Using: (eqcom) changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (25)                               [serial 1100] 
P [280] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr >= mhr
  and sp >= psp ) >>
S [282] ->
Q [282] << hrr = HEART_RATE
  and hrr >= mhr
  and sp = SPO2
  and sp >= psp
  and INV_PO() >>
Why created:  P -> P1 in concurrent composition for [serial 1097]
Solved by: Equality Commutes. (eqcom) [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 24:
Theorem (24) [serial 1119] used for:
    normalization of [serial 1100] 


Theorem (26)                               [serial 1101] 
P [284] << INV_PO() >>
S [284] ->
Q [299] << INV_PO() >>
Why created:  Qk -> Q in concurrent composition for [serial 1097]
Solved by: Identity (id):  P->P is tautology

Theorem (27)                               [serial 1177] 
P [282] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [283] ->
Q [299] << ( LOW_SPO2_HR() iff false )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:  applied wp for assignment [serial 1176]
Solved by: The negation of a proposition is equivalent to itself being equivalent to false. (nbfal)

Theorem (28)                               [serial 1176] 
P [282] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [283] poa := false
Q [299] << ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:    normalization of [serial 1174]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 27:
Theorem (27) [serial 1177] used for:
  applied wp for assignment [serial 1176] 


Theorem (29)                               [serial 1174] 
P [282] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [283] poa := false
Q [299] << ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1173]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 28:
Theorem (28) [serial 1176] used for:
    normalization of [serial 1174] 


Theorem (30)                               [serial 1173] 
P [282] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [283] poa := false
Q [299] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1121]
Solved by: Predicate Invocation. (PI) and theorem 29:
Theorem (29) [serial 1174] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1173] 


Theorem (31)                               [serial 1121] 
P [282] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [283] poa := false
Q [299] << INV_PO() >>
Why created:    normalization of [serial 1102]
  Using: (eqcom) changeAtLeastToAtMost (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 30:
Theorem (30) [serial 1173] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1121] 


Theorem (32)                               [serial 1102] 
P [282] << hrr = HEART_RATE
  and hrr >= mhr
  and sp = SPO2
  and sp >= psp
  and INV_PO() >>
S [283] poa := false
Q [299] << INV_PO() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1097]
Solved by: Equality Commutes. (eqcom) [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 31:
Theorem (31) [serial 1121] used for:
    normalization of [serial 1102] 


Theorem (33)                               [serial 1123] 
P [280] << ( mhr <= hrr
  and psp <= sp )
  and ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() ) >>
S [283] PO_Alarm!(false)
Q [284] << INV_PO() >>
Why created:    normalization of [serial 1103]
  Using: (eqcom) changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (34)                               [serial 1103] 
P [280] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr >= mhr
  and sp >= psp ) >>
S [283] PO_Alarm!(false)
Q [284] << INV_PO() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1097]
Solved by: Equality Commutes. (eqcom) [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 33:
Theorem (33) [serial 1123] used for:
    normalization of [serial 1103] 


Theorem (35)                               [serial 1097] 
P [280] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr >= mhr
  and sp >= psp ) >>
S [282]   << hrr = HEART_RATE
    and hrr >= mhr
    and sp = SPO2
    and sp >= psp
    and INV_PO() >>
  poa := false
  &
  PO_Alarm!(false)
  << INV_PO() >> 
Q [299] << INV_PO() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1094]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 25 26 32 34:
Theorem (25) [serial 1100] used for:
  P -> P1 in concurrent composition for [serial 1097] 
Theorem (26) [serial 1101] used for:
  Qk -> Q in concurrent composition for [serial 1097] 
Theorem (32) [serial 1102] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1097] 
Theorem (34) [serial 1103] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1097] 


Theorem (36)                               [serial 1094] 
P [280] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr >= mhr
  and sp >= psp ) >>
S [281]   {
    << hrr = HEART_RATE
      and hrr >= mhr
      and sp = SPO2
      and sp >= psp
      and INV_PO() >>
    poa := false
    &
    PO_Alarm!(false)
    << INV_PO() >> 
  } 
Q [299] << INV_PO() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1092]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 35:
Theorem (35) [serial 1097] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1094] 


Theorem (37)                               [serial 1125] 
P [280] << ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() )
  and hrr < mhr >>
S [288] ->
Q [288] << hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1104]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (38)                               [serial 1104] 
P [280] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr < mhr ) >>
S [288] ->
Q [288] << hrr = HEART_RATE
  and hrr < mhr
  and sp = SPO2
  and INV_PO() >>
Why created:  P -> P1 in concurrent composition for [serial 1098]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 37:
Theorem (37) [serial 1125] used for:
    normalization of [serial 1104] 


Theorem (39)                               [serial 1105] 
P [290] << INV_PO() >>
S [290] ->
Q [299] << INV_PO() >>
Why created:  Qk -> Q in concurrent composition for [serial 1098]
Solved by: Identity (id):  P->P is tautology

Theorem (40)                               [serial 1238] 
P [288] << ( ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp )
  and hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp >>
S [289] poa := true
Q [299] << ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:    normalization of [serial 1236]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (41)                               [serial 1236] 
P [288] << hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp
  and ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
S [289] poa := true
Q [299] << ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1235]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 40:
Theorem (40) [serial 1238] used for:
    normalization of [serial 1236] 


Theorem (42)                               [serial 1235] 
P [288] << hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp
  and ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
S [289] poa := true
Q [299] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1127]
Solved by: Predicate Invocation. (PI) and theorem 41:
Theorem (41) [serial 1236] used for:
  Substituted assertions' predicates for labels  [serial 1235] 


Theorem (43)                               [serial 1127] 
P [288] << hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [289] poa := true
Q [299] << INV_PO() >>
Why created:    normalization of [serial 1106]
  Using: (eqcom) (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 42:
Theorem (42) [serial 1235] used for:
  Substituted assertions' predicates for labels  [serial 1127] 


Theorem (44)                               [serial 1106] 
P [288] << hrr = HEART_RATE
  and hrr < mhr
  and sp = SPO2
  and INV_PO() >>
S [289] poa := true
Q [299] << INV_PO() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1098]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 43:
Theorem (43) [serial 1127] used for:
    normalization of [serial 1106] 


Theorem (45)                               [serial 1129] 
P [280] << ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() )
  and hrr < mhr >>
S [289] PO_Alarm!(true)
Q [290] << INV_PO() >>
Why created:    normalization of [serial 1107]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (46)                               [serial 1107] 
P [280] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr < mhr ) >>
S [289] PO_Alarm!(true)
Q [290] << INV_PO() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1098]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 45:
Theorem (45) [serial 1129] used for:
    normalization of [serial 1107] 


Theorem (47)                               [serial 1098] 
P [280] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr < mhr ) >>
S [288]   << hrr = HEART_RATE
    and hrr < mhr
    and sp = SPO2
    and INV_PO() >>
  poa := true
  &
  PO_Alarm!(true)
  << INV_PO() >> 
Q [299] << INV_PO() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1095]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 38 39 44 46:
Theorem (38) [serial 1104] used for:
  P -> P1 in concurrent composition for [serial 1098] 
Theorem (39) [serial 1105] used for:
  Qk -> Q in concurrent composition for [serial 1098] 
Theorem (44) [serial 1106] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1098] 
Theorem (46) [serial 1107] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1098] 


Theorem (48)                               [serial 1095] 
P [280] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr < mhr ) >>
S [287]   {
    << hrr = HEART_RATE
      and hrr < mhr
      and sp = SPO2
      and INV_PO() >>
    poa := true
    &
    PO_Alarm!(true)
    << INV_PO() >> 
  } 
Q [299] << INV_PO() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1092]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 47:
Theorem (47) [serial 1098] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1095] 


Theorem (49)                               [serial 1131] 
P [280] << ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() )
  and sp < psp >>
S [294] ->
Q [294] << sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1108]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (50)                               [serial 1108] 
P [280] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( sp < psp ) >>
S [294] ->
Q [294] << hrr = HEART_RATE
  and sp < psp
  and sp = SPO2
  and INV_PO() >>
Why created:  P -> P1 in concurrent composition for [serial 1099]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 49:
Theorem (49) [serial 1131] used for:
    normalization of [serial 1108] 


Theorem (51)                               [serial 1109] 
P [296] << INV_PO() >>
S [296] ->
Q [299] << INV_PO() >>
Why created:  Qk -> Q in concurrent composition for [serial 1099]
Solved by: Identity (id):  P->P is tautology

Theorem (52)                               [serial 1258] 
P [294] << ( ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp )
  and sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp >>
S [295] ->
Q [299] << ( LOW_SPO2_HR() iff true )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:  applied wp for assignment [serial 1257]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (53)                               [serial 1257] 
P [294] << ( ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp )
  and sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp >>
S [295] poa := true
Q [299] << ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:    normalization of [serial 1255]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 52:
Theorem (52) [serial 1258] used for:
  applied wp for assignment [serial 1257] 


Theorem (54)                               [serial 1255] 
P [294] << sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp
  and ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
S [295] poa := true
Q [299] << ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1254]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 53:
Theorem (53) [serial 1257] used for:
    normalization of [serial 1255] 


Theorem (55)                               [serial 1254] 
P [294] << sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp
  and ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
S [295] poa := true
Q [299] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1133]
Solved by: Predicate Invocation. (PI) and theorem 54:
Theorem (54) [serial 1255] used for:
  Substituted assertions' predicates for labels  [serial 1254] 


Theorem (56)                               [serial 1133] 
P [294] << sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [295] poa := true
Q [299] << INV_PO() >>
Why created:    normalization of [serial 1110]
  Using: (eqcom) (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 55:
Theorem (55) [serial 1254] used for:
  Substituted assertions' predicates for labels  [serial 1133] 


Theorem (57)                               [serial 1110] 
P [294] << hrr = HEART_RATE
  and sp < psp
  and sp = SPO2
  and INV_PO() >>
S [295] poa := true
Q [299] << INV_PO() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1099]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 56:
Theorem (56) [serial 1133] used for:
    normalization of [serial 1110] 


Theorem (58)                               [serial 1135] 
P [280] << ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() )
  and sp < psp >>
S [295] PO_Alarm!(true)
Q [296] << INV_PO() >>
Why created:    normalization of [serial 1111]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (59)                               [serial 1111] 
P [280] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( sp < psp ) >>
S [295] PO_Alarm!(true)
Q [296] << INV_PO() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1099]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 58:
Theorem (58) [serial 1135] used for:
    normalization of [serial 1111] 


Theorem (60)                               [serial 1099] 
P [280] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( sp < psp ) >>
S [294]   << hrr = HEART_RATE
    and sp < psp
    and sp = SPO2
    and INV_PO() >>
  poa := true
  &
  PO_Alarm!(true)
  << INV_PO() >> 
Q [299] << INV_PO() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1096]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 50 51 57 59:
Theorem (50) [serial 1108] used for:
  P -> P1 in concurrent composition for [serial 1099] 
Theorem (51) [serial 1109] used for:
  Qk -> Q in concurrent composition for [serial 1099] 
Theorem (57) [serial 1110] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1099] 
Theorem (59) [serial 1111] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1099] 


Theorem (61)                               [serial 1096] 
P [280] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( sp < psp ) >>
S [293]   {
    << hrr = HEART_RATE
      and sp < psp
      and sp = SPO2
      and INV_PO() >>
    poa := true
    &
    PO_Alarm!(true)
    << INV_PO() >> 
  } 
Q [299] << INV_PO() >>
Why created:    <<P and B2>> S2 <<Q>> in alternative for [serial 1092]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 60:
Theorem (60) [serial 1099] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1096] 


Theorem (62)                               [serial 1092] 
P [278] << hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 >>
S [280]   if 
    (hrr >= mhr
    and sp >= psp)~> 
        {
          << hrr = HEART_RATE
            and hrr >= mhr
            and sp = SPO2
            and sp >= psp
            and INV_PO() >>
          poa := false
          &
          PO_Alarm!(false)
          << INV_PO() >> 
        }  
  []
    (hrr < mhr)~> 
        {
          << hrr = HEART_RATE
            and hrr < mhr
            and sp = SPO2
            and INV_PO() >>
          poa := true
          &
          PO_Alarm!(true)
          << INV_PO() >> 
        }  
  []
    (sp < psp)~> 
        {
          << hrr = HEART_RATE
            and sp < psp
            and sp = SPO2
            and INV_PO() >>
          poa := true
          &
          PO_Alarm!(true)
          << INV_PO() >> 
        }  
  fi
Q [299] << INV_PO() >>
Why created:  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1007]
Solved by: and theorems 23 36 48 61:
Theorem (23) [serial 1093] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1092] 
Theorem (36) [serial 1094] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1092] 
Theorem (48) [serial 1095] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1092] 
Theorem (61) [serial 1096] used for:
    <<P and B2>> S2 <<Q>> in alternative for [serial 1092] 


Theorem (63)                               [serial 1007] 
P [266] << INV_PO() >>
S [274]   << INV_PO() >>
  Heart_Rate?(hrr)
  ;
  << hrr = HEART_RATE
    and INV_PO() >>
  Spo2_Level?(sp)
  << hrr = HEART_RATE
    and INV_PO()
    and sp = SPO2 >>
  ;
    if 
      (hrr >= mhr
      and sp >= psp)~> 
          {
            << hrr = HEART_RATE
              and hrr >= mhr
              and sp = SPO2
              and sp >= psp
              and INV_PO() >>
            poa := false
            &
            PO_Alarm!(false)
            << INV_PO() >> 
          }  
    []
      (hrr < mhr)~> 
          {
            << hrr = HEART_RATE
              and hrr < mhr
              and sp = SPO2
              and INV_PO() >>
            poa := true
            &
            PO_Alarm!(true)
            << INV_PO() >> 
          }  
    []
      (sp < psp)~> 
          {
            << hrr = HEART_RATE
              and sp < psp
              and sp = SPO2
              and INV_PO() >>
            poa := true
            &
            PO_Alarm!(true)
            << INV_PO() >> 
          }  
    fi
  << INV_PO() >> 
Q [267] << INV_PO() >>
Why created:   <<M(run) and x>> A <<M(check_echo)>> for got_hrr_spo2: run-[x]->check_echo{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 9 10 14 18 62:
Theorem (9) [serial 1088] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1007] 
Theorem (10) [serial 1089] used for:
  <<Q3>> -> <<Q>> in sequential composition for [serial 1007] 
Theorem (14) [serial 1090] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1007] 
Theorem (18) [serial 1091] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1007] 
Theorem (62) [serial 1092] used for:
  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1007] 


Theorem (64)                               [serial 1353] 
P [303] << ( INV_PO() )
  and ( PO_Alarm_Echo@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [303] ->
Q [305] << INV_PO()
  and PO_Alarm_Echo@now >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1008]
Solved by: And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

Theorem (65)                               [serial 1354] 
P [315] << INV_PO() >>
S [266] ->
Q [266] << INV_PO() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1008]
Solved by: Identity (id):  P->P is tautology

Theorem (66)                               [serial 1356] 
P [305] << ( INV_PO()
  and PO_Alarm_Echo@now )
  and ( echo_val iff PO_Alarm_Echo@now ) >>
S [308] ->
Q [308] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
Why created:  <<P and v=e>> -> <<A>> in behavior action block for [serial 1355]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (67)                               [serial 1359] 
P [308] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
S [308] ->
Q [308] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1357]
Solved by: Identity (id):  P->P is tautology

Theorem (68)                               [serial 1360] 
P [313] << INV_PO() >>
S [313] ->
Q [313] << INV_PO() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1357]
Solved by: Identity (id):  P->P is tautology

Theorem (69)                               [serial 1370] 
P [308] << ( PO_Alarm_Echo iff echo_val )
  and INV_PO() >>
S [309] ->
Q [309] << ( echo_val iff poa ) or not ( echo_val iff poa ) >>
Why created:    normalization of [serial 1362]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (70)                               [serial 1362] 
P [308] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
S [309] ->
Q [309] << ( echo_val iff poa ) or ( not ( echo_val iff poa ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1361]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 69:
Theorem (69) [serial 1370] used for:
    normalization of [serial 1362] 


Theorem (71)                               [serial 1374] 
P [309] << ( ( PO_Alarm_Echo iff echo_val )
  and INV_PO() )
  and ( echo_val iff poa ) >>
S [309] ->
Q [313] << INV_PO() >>
Why created:    normalization of [serial 1372]
  Using: (bicom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (72)                               [serial 1372] 
P [309] << ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( echo_val iff poa ) >>
S [309] ->
Q [313] << INV_PO() >>
Why created:    <<P>> -> <<Q>>
  for [serial 1363]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 71:
Theorem (71) [serial 1374] used for:
    normalization of [serial 1372] 


Theorem (73)                               [serial 1363] 
P [309] << ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( echo_val iff poa ) >>
S [309] skip
Q [313] << INV_PO() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1361]
Solved by:  Skip Means Implication:  <<P>> skip <<Q>>  is  <<P>> -> <<Q>>
 and theorem 72:
Theorem (72) [serial 1372] used for:
    <<P>> -> <<Q>>
  for [serial 1363] 


Theorem (74)                               [serial 1382] 
P [309] << ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( not ( echo_val iff poa ) ) >>
S [311] ->
Q [311] << true >>
Why created:  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1364]
Solved by: Anything Implies True (a1tru): P->true

Theorem (75)                               [serial 1386] 
P [311] << ( ( ( PO_Alarm_Echo iff echo_val )
  and INV_PO() )
  and not ( echo_val iff poa ) )
  and true >>
S [311] ->
Q [313] << INV_PO() >>
Why created:    normalization of [serial 1384]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (76)                               [serial 1384] 
P [311] << ( ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( not ( echo_val iff poa ) ) )
  and true >>
S [311] ->
Q [313] << INV_PO() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1383]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 75:
Theorem (75) [serial 1386] used for:
    normalization of [serial 1384] 


Theorem (77)                               [serial 1383] 
P [311] << ( ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( not ( echo_val iff poa ) ) )
  and true@now >>
S [311] ->
Q [313] << INV_PO() >>
Why created:  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1364]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 76:
Theorem (76) [serial 1384] used for:
  Assume Present:  P = P@now = P^0   [serial 1383] 


Theorem (78)                               [serial 1364] 
P [309] << ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( not ( echo_val iff poa ) ) >>
S [311] Lost_Confirmation!
Q [313] << INV_PO() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1361]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 74 77:
Theorem (74) [serial 1382] used for:
  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1364] 
Theorem (77) [serial 1383] used for:
  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1364] 


Theorem (79)                               [serial 1361] 
P [308] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
S [309]   if 
    (echo_val iff poa)~> 
      skip 
  []
    (not ( echo_val iff poa ))~> 
      Lost_Confirmation! 
  fi
Q [313] << INV_PO() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1357]
Solved by: and theorems 70 73 78:
Theorem (70) [serial 1362] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1361] 
Theorem (73) [serial 1363] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1361] 
Theorem (78) [serial 1364] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1361] 


Theorem (80)                               [serial 1357] 
P [308] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
S [308] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
  if 
    (echo_val iff poa)~> 
      skip 
  []
    (not ( echo_val iff poa ))~> 
      Lost_Confirmation! 
  fi
<< INV_PO() >>
Q [313] << INV_PO() >>
Why created:  <<A>> S <<B>> in behavior action block for [serial 1355]
Solved by: null and theorems 67 68 79:
Theorem (67) [serial 1359] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1357] 
Theorem (68) [serial 1360] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1357] 
Theorem (79) [serial 1361] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1357] 


Theorem (81)                               [serial 1358] 
P [313] << INV_PO() >>
S [306] ->
Q [315] << INV_PO() >>
Why created:  <<B>> -> <<Q>> in behavior action block for [serial 1355]
Solved by: Identity (id):  P->P is tautology

Theorem (82)                               [serial 1355] 
P [305] << INV_PO()
  and PO_Alarm_Echo@now >>
S [306] declare 
   echo_val ~ boolean := PO_Alarm_Echo?   {
  << INV_PO()
    and ( echo_val iff PO_Alarm_Echo ) >>
    if 
      (echo_val iff poa)~> 
        skip 
    []
      (not ( echo_val iff poa ))~> 
        Lost_Confirmation! 
    fi
  << INV_PO() >>
  } 
Q [315] << INV_PO() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1008]
Solved by: Behavior Action Block (BAB): 
     <<P and x=e>> -> <<A>>
     <<A>> S <<B>> 
     <<B>> -> <<Q>>
----------------------------------------------------
<<P>> declare variable v~y:=e; { <<A>> S <<B>> } <<Q>> and theorems 66 80 81:
Theorem (66) [serial 1356] used for:
  <<P and v=e>> -> <<A>> in behavior action block for [serial 1355] 
Theorem (80) [serial 1357] used for:
  <<A>> S <<B>> in behavior action block for [serial 1355] 
Theorem (81) [serial 1358] used for:
  <<B>> -> <<Q>> in behavior action block for [serial 1355] 


Theorem (83)                               [serial 1008] 
P [303] << ( INV_PO() )
  and ( PO_Alarm_Echo@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [305] << INV_PO()
  and PO_Alarm_Echo@now >>
declare 
   echo_val ~ boolean := PO_Alarm_Echo?   {
  << INV_PO()
    and ( echo_val iff PO_Alarm_Echo ) >>
    if 
      (echo_val iff poa)~> 
        skip 
    []
      (not ( echo_val iff poa ))~> 
        Lost_Confirmation! 
    fi
  << INV_PO() >>
  } 
<< INV_PO() >>
Q [266] << INV_PO() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A};
Solved by: null and theorems 64 65 82:
Theorem (64) [serial 1353] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1008] 
Theorem (65) [serial 1354] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1008] 
Theorem (82) [serial 1355] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1008] 


Theorem (84)                               [serial 1396] 
P [318] << ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and INV_PO()
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [319] ->
Q [319] << true >>
Why created:    normalization of [serial 1392]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (85)                               [serial 1392] 
P [318] << ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [319] ->
Q [319] << true >>
Why created:  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1391]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 84:
Theorem (84) [serial 1396] used for:
    normalization of [serial 1392] 


Theorem (86)                               [serial 1398] 
P [319] << ( ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and INV_PO()
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) )
  and true >>
S [319] ->
Q [266] << INV_PO() >>
Why created:    normalization of [serial 1394]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (87)                               [serial 1394] 
P [319] << ( ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) )
  and true >>
S [319] ->
Q [266] << INV_PO() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1393]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 86:
Theorem (86) [serial 1398] used for:
    normalization of [serial 1394] 


Theorem (88)                               [serial 1393] 
P [319] << ( ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) )
  and true@now >>
S [319] ->
Q [266] << INV_PO() >>
Why created:  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1391]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 87:
Theorem (87) [serial 1394] used for:
  Assume Present:  P = P@now = P^0   [serial 1393] 


Theorem (89)                               [serial 1391] 
P [318] << ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [319] Lost_Confirmation!
Q [266] << INV_PO() >>
Why created:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1009]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 85 88:
Theorem (85) [serial 1392] used for:
  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1391] 
Theorem (88) [serial 1393] used for:
  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1391] 


Theorem (90)                               [serial 1009] 
P [318] << ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [319] Lost_Confirmation!
Q [266] << INV_PO() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A};
Solved by: null and theorem 89:
Theorem (89) [serial 1391] used for:
  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1009] 


Theorem (91)                               [serial 1002] 
P [246] <<   >>
S [252] ->
Q [246] << Pulse_Oximeter_Thread.impl proof obligations >>
Why created:  Initial proof obligations for Pulse_Oximeter_Thread.impl
Solved by:  Component verification conditions
 and theorems 3 6 7 8 63 83 90:
Theorem (3) [serial 1003] used for:
  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition. 
Theorem (6) [serial 1004] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (7) [serial 1005] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (8) [serial 1006] used for:
   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{}; 
Theorem (63) [serial 1007] used for:
   <<M(run) and x>> A <<M(check_echo)>> for got_hrr_spo2: run-[x]->check_echo{A}; 
Theorem (83) [serial 1008] used for:
   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A}; 
Theorem (90) [serial 1009] used for:
   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A}; 


Theorem (92)                               [serial 1011] 
P [428] << RA()
  and MRP_A() >>
S [418] ->
Q [418] << RA()
  and MRP_A() >>
Why created:  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition.
Solved by: Identity (id):  P->P is tautology

Theorem (93)                               [serial 1012] 
P [427] << RA()
  and MRP_A() >>
S [418] ->
Q [418] << RA()
  and MRP_A() >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by: Identity (id):  P->P is tautology

Theorem (94)                               [serial 1013] 
P [426] << RA()
  and MRP_A() >>
S [426] ->
Q [426] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by: Anything Implies True (a1tru): P->true

Theorem (95)                               [serial 1014] 
P [426] << RA()
  and MRP_A() >>
S [431] ->
Q [427] << RA()
  and MRP_A() >>
Why created:   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{};
Solved by: Identity (id):  P->P is tautology

Theorem (96)                               [serial 1443] 
P [435] << ( MRP_A()
  and RA() )
  and rpr = RESPIRATION_RATE >>
S [435] ->
Q [436] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
Why created:  applied port input of value <<pre and rpr=M(RP_Rate)>> -> <<post>> [serial 1420]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (97)                               [serial 1420] 
P [427] << MRP_A()
  and RA() >>
S [435] RP_Rate?(rpr)
Q [436] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1404]
  Using: (eqcom) (bl.ancom) 
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 96:
Theorem (96) [serial 1443] used for:
  applied port input of value <<pre and rpr=M(RP_Rate)>> -> <<post>> [serial 1420] 


Theorem (98)                               [serial 1404] 
P [427] << RA()
  and MRP_A() >>
S [435] RP_Rate?(rpr)
Q [436] << rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1015]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 97:
Theorem (97) [serial 1420] used for:
    normalization of [serial 1404] 


Theorem (99)                               [serial 1449] 
P [436] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [438] ->
Q [438] << rpr < mrp or not ( rpr < mrp ) >>
Why created:    normalization of [serial 1447]
  Using: ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (100)                               [serial 1447] 
P [436] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [438] ->
Q [438] << rpr < mrp or ( not ( rpr < mrp ) ) >>
Why created:  Replacing <= with not < of [serial 1422]
Solved by: [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 99:
Theorem (99) [serial 1449] used for:
    normalization of [serial 1447] 


Theorem (101)                               [serial 1422] 
P [436] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [438] ->
Q [438] << rpr < mrp or mrp <= rpr >>
Why created:    normalization of [serial 1406]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.orcom) 
Solved by: 'Less than' expressed in terms of 'less than or equal to'. (ltnle) and theorem 100:
Theorem (100) [serial 1447] used for:
  Replacing <= with not < of [serial 1422] 


Theorem (102)                               [serial 1406] 
P [436] << rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() >>
S [438] ->
Q [438] << ( rpr >= mrp ) or ( rpr < mrp ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1405]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Disjunction Commutes. (bl.orcom) and theorem 101:
Theorem (101) [serial 1422] used for:
    normalization of [serial 1406] 


Theorem (103)                               [serial 1424] 
P [438] << ( RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() )
  and mrp <= rpr >>
S [440] ->
Q [440] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1411]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (104)                               [serial 1411] 
P [438] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr >= mrp ) >>
S [440] ->
Q [440] << rpr = RESPIRATION_RATE
  and rpr >= mrp
  and MRP_A()
  and RA() >>
Why created:  P -> P1 in concurrent composition for [serial 1409]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 103:
Theorem (103) [serial 1424] used for:
    normalization of [serial 1411] 


Theorem (105)                               [serial 1426] 
P [442] << MRP_A()
  and RA() >>
S [442] ->
Q [428] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1412]
Solved by: Identity (id):  P->P is tautology

Theorem (106)                               [serial 1412] 
P [442] << RA()
  and MRP_A() >>
S [442] ->
Q [428] << RA()
  and MRP_A() >>
Why created:  Qk -> Q in concurrent composition for [serial 1409]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 105:
Theorem (105) [serial 1426] used for:
    normalization of [serial 1412] 


Theorem (107)                               [serial 1456] 
P [440] << ( LOW_RP() iff rma )
  and mrp <= rpr
  and MINIMUM_RESPIRATION_RATE = mrp
  and RESPIRATION_RATE = rpr >>
S [441] ->
Q [428] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE iff false )
  and MINIMUM_RESPIRATION_RATE = mrp >>
Why created:    normalization of [serial 1454]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: The negation of a proposition is equivalent to itself being equivalent to false. (nbfal)

Theorem (108)                               [serial 1454] 
P [440] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( rma iff LOW_RP() ) >>
S [441] ->
Q [428] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( false iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1453]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 107:
Theorem (107) [serial 1456] used for:
    normalization of [serial 1454] 


Theorem (109)                               [serial 1453] 
P [440] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [441] ->
Q [428] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( false iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) >>
Why created:  applied wp for assignment [serial 1452]
Solved by: Predicate Invocation. (PI) and theorem 108:
Theorem (108) [serial 1454] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1453] 


Theorem (110)                               [serial 1452] 
P [440] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [441] rma := false
Q [428] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( rma iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1451]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 109:
Theorem (109) [serial 1453] used for:
  applied wp for assignment [serial 1452] 


Theorem (111)                               [serial 1451] 
P [440] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [441] rma := false
Q [428] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( rma iff LOW_RP() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1428]
Solved by: Predicate Invocation. (PI) and theorem 110:
Theorem (110) [serial 1452] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1451] 


Theorem (112)                               [serial 1428] 
P [440] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [441] rma := false
Q [428] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1413]
  Using: (eqcom) changeAtLeastToAtMost (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 111:
Theorem (111) [serial 1451] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1428] 


Theorem (113)                               [serial 1413] 
P [440] << rpr = RESPIRATION_RATE
  and rpr >= mrp
  and MRP_A()
  and RA() >>
S [441] rma := false
Q [428] << RA()
  and MRP_A() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1409]
Solved by: Equality Commutes. (eqcom) [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 112:
Theorem (112) [serial 1428] used for:
    normalization of [serial 1413] 


Theorem (114)                               [serial 1430] 
P [438] << ( RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() )
  and mrp <= rpr >>
S [441] RM_Alarm!(false)
Q [442] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1414]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (115)                               [serial 1414] 
P [438] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr >= mrp ) >>
S [441] RM_Alarm!(false)
Q [442] << RA()
  and MRP_A() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1409]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 114:
Theorem (114) [serial 1430] used for:
    normalization of [serial 1414] 


Theorem (116)                               [serial 1409] 
P [438] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr >= mrp ) >>
S [440]   << rpr = RESPIRATION_RATE
    and rpr >= mrp
    and MRP_A()
    and RA() >>
  rma := false
  &
  RM_Alarm!(false)
  << RA()
    and MRP_A() >> 
Q [428] << RA()
  and MRP_A() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1407]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 104 106 113 115:
Theorem (104) [serial 1411] used for:
  P -> P1 in concurrent composition for [serial 1409] 
Theorem (106) [serial 1412] used for:
  Qk -> Q in concurrent composition for [serial 1409] 
Theorem (113) [serial 1413] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1409] 
Theorem (115) [serial 1414] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1409] 


Theorem (117)                               [serial 1407] 
P [438] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr >= mrp ) >>
S [439]   {
    << rpr = RESPIRATION_RATE
      and rpr >= mrp
      and MRP_A()
      and RA() >>
    rma := false
    &
    RM_Alarm!(false)
    << RA()
      and MRP_A() >> 
  } 
Q [428] << RA()
  and MRP_A() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1405]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 116:
Theorem (116) [serial 1409] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1407] 


Theorem (118)                               [serial 1432] 
P [438] << ( RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() )
  and rpr < mrp >>
S [447] ->
Q [447] << rpr < mrp
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1415]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (119)                               [serial 1415] 
P [438] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr < mrp ) >>
S [447] ->
Q [447] << rpr = RESPIRATION_RATE
  and rpr < mrp
  and MRP_A()
  and RA() >>
Why created:  P -> P1 in concurrent composition for [serial 1410]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 118:
Theorem (118) [serial 1432] used for:
    normalization of [serial 1415] 


Theorem (120)                               [serial 1434] 
P [449] << MRP_A()
  and RA() >>
S [449] ->
Q [428] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1416]
Solved by: Identity (id):  P->P is tautology

Theorem (121)                               [serial 1416] 
P [449] << RA()
  and MRP_A() >>
S [449] ->
Q [428] << RA()
  and MRP_A() >>
Why created:  Qk -> Q in concurrent composition for [serial 1410]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 120:
Theorem (120) [serial 1434] used for:
    normalization of [serial 1416] 


Theorem (122)                               [serial 1466] 
P [447] << rpr < mrp
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [448] ->
Q [428] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( true iff LOW_RP() ) >>
Why created:  applied wp for assignment [serial 1465]
Solved by: Superfluity of Equivalence. (bl.seq)

Theorem (123)                               [serial 1465] 
P [447] << rpr < mrp
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [448] rma := true
Q [428] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( rma iff LOW_RP() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1436]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 122:
Theorem (122) [serial 1466] used for:
  applied wp for assignment [serial 1465] 


Theorem (124)                               [serial 1436] 
P [447] << rpr < mrp
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [448] rma := true
Q [428] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1417]
  Using: (eqcom) (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 123:
Theorem (123) [serial 1465] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1436] 


Theorem (125)                               [serial 1417] 
P [447] << rpr = RESPIRATION_RATE
  and rpr < mrp
  and MRP_A()
  and RA() >>
S [448] rma := true
Q [428] << RA()
  and MRP_A() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1410]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 124:
Theorem (124) [serial 1436] used for:
    normalization of [serial 1417] 


Theorem (126)                               [serial 1438] 
P [438] << ( RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() )
  and rpr < mrp >>
S [448] RM_Alarm!(true)
Q [449] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1418]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (127)                               [serial 1418] 
P [438] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr < mrp ) >>
S [448] RM_Alarm!(true)
Q [449] << RA()
  and MRP_A() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1410]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 126:
Theorem (126) [serial 1438] used for:
    normalization of [serial 1418] 


Theorem (128)                               [serial 1410] 
P [438] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr < mrp ) >>
S [447]   << rpr = RESPIRATION_RATE
    and rpr < mrp
    and MRP_A()
    and RA() >>
  rma := true
  &
  RM_Alarm!(true)
  << RA()
    and MRP_A() >> 
Q [428] << RA()
  and MRP_A() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1408]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 119 121 125 127:
Theorem (119) [serial 1415] used for:
  P -> P1 in concurrent composition for [serial 1410] 
Theorem (121) [serial 1416] used for:
  Qk -> Q in concurrent composition for [serial 1410] 
Theorem (125) [serial 1417] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1410] 
Theorem (127) [serial 1418] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1410] 


Theorem (129)                               [serial 1408] 
P [438] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr < mrp ) >>
S [446]   {
    << rpr = RESPIRATION_RATE
      and rpr < mrp
      and MRP_A()
      and RA() >>
    rma := true
    &
    RM_Alarm!(true)
    << RA()
      and MRP_A() >> 
  } 
Q [428] << RA()
  and MRP_A() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1405]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 128:
Theorem (128) [serial 1410] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1408] 


Theorem (130)                               [serial 1405] 
P [436] << rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() >>
S [438]   if 
    (rpr >= mrp)~> 
        {
          << rpr = RESPIRATION_RATE
            and rpr >= mrp
            and MRP_A()
            and RA() >>
          rma := false
          &
          RM_Alarm!(false)
          << RA()
            and MRP_A() >> 
        }  
  []
    (rpr < mrp)~> 
        {
          << rpr = RESPIRATION_RATE
            and rpr < mrp
            and MRP_A()
            and RA() >>
          rma := true
          &
          RM_Alarm!(true)
          << RA()
            and MRP_A() >> 
        }  
  fi
Q [428] << RA()
  and MRP_A() >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1015]
Solved by: and theorems 102 117 129:
Theorem (102) [serial 1406] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1405] 
Theorem (117) [serial 1407] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1405] 
Theorem (129) [serial 1408] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1405] 


Theorem (131)                               [serial 1015] 
P [427] << RA()
  and MRP_A() >>
S [435]   RP_Rate?(rpr)
  << rpr = RESPIRATION_RATE
    and MRP_A()
    and RA() >>
  ;
    if 
      (rpr >= mrp)~> 
          {
            << rpr = RESPIRATION_RATE
              and rpr >= mrp
              and MRP_A()
              and RA() >>
            rma := false
            &
            RM_Alarm!(false)
            << RA()
              and MRP_A() >> 
          }  
    []
      (rpr < mrp)~> 
          {
            << rpr = RESPIRATION_RATE
              and rpr < mrp
              and MRP_A()
              and RA() >>
            rma := true
            &
            RM_Alarm!(true)
            << RA()
              and MRP_A() >> 
          }  
    fi 
Q [428] << RA()
  and MRP_A() >>
Why created:   <<M(run) and x>> A <<M(check_echo)>> for got_rp: run-[x]->check_echo{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 98 130:
Theorem (98) [serial 1404] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1015] 
Theorem (130) [serial 1405] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1015] 


Theorem (132)                               [serial 1510] 
P [454] << ( MRP_A()
  and RA() )
  and RM_Alarm_Echo@now
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [454] ->
Q [456] << RM_Alarm_Echo@now
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1497]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (133)                               [serial 1497] 
P [454] << ( RA()
  and MRP_A() )
  and ( RM_Alarm_Echo@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [454] ->
Q [456] << RA()
  and MRP_A()
  and RM_Alarm_Echo@now >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1016]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 132:
Theorem (132) [serial 1510] used for:
    normalization of [serial 1497] 


Theorem (134)                               [serial 1512] 
P [465] << MRP_A()
  and RA() >>
S [427] ->
Q [427] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1498]
Solved by: Identity (id):  P->P is tautology

Theorem (135)                               [serial 1498] 
P [465] << RA()
  and MRP_A() >>
S [427] ->
Q [427] << RA()
  and MRP_A() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1016]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 134:
Theorem (134) [serial 1512] used for:
    normalization of [serial 1498] 


Theorem (136)                               [serial 1514] 
P [456] << ( RM_Alarm_Echo@now
  and MRP_A()
  and RA() )
  and ( RM_Alarm_Echo@now iff echo_val ) >>
S [458] ->
Q [458] << ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1500]
  Using: (bl.ancom) (bicom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (137)                               [serial 1500] 
P [456] << ( RA()
  and MRP_A()
  and RM_Alarm_Echo@now )
  and ( echo_val iff RM_Alarm_Echo@now ) >>
S [458] ->
Q [458] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
Why created:  <<P and v=e>> -> <<A>> in behavior action block for [serial 1499]
Solved by: Conjunction Commutes. (bl.ancom) Biconditional (iff) Commutes. (bicom) and theorem 136:
Theorem (136) [serial 1514] used for:
    normalization of [serial 1500] 


Theorem (138)                               [serial 1516] 
P [458] << ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() >>
S [458] ->
Q [458] << ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1503]
  Using: (bicom) (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (139)                               [serial 1503] 
P [458] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
S [458] ->
Q [458] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1501]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 138:
Theorem (138) [serial 1516] used for:
    normalization of [serial 1503] 


Theorem (140)                               [serial 1518] 
P [463] << MRP_A()
  and RA() >>
S [463] ->
Q [463] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1504]
Solved by: Identity (id):  P->P is tautology

Theorem (141)                               [serial 1504] 
P [463] << RA()
  and MRP_A() >>
S [463] ->
Q [463] << RA()
  and MRP_A() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1501]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 140:
Theorem (140) [serial 1518] used for:
    normalization of [serial 1504] 


Theorem (142)                               [serial 1520] 
P [458] << ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() >>
S [459] ->
Q [459] << ( echo_val iff rma ) or not ( echo_val iff rma ) >>
Why created:    normalization of [serial 1506]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (143)                               [serial 1506] 
P [458] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
S [459] ->
Q [459] << ( echo_val iff rma ) or ( not ( echo_val iff rma ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1505]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 142:
Theorem (142) [serial 1520] used for:
    normalization of [serial 1506] 


Theorem (144)                               [serial 1522] 
P [459] << ( ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() )
  and ( echo_val iff rma ) >>
S [459] skip
Q [463] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1507]
  Using: (bicom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (145)                               [serial 1507] 
P [459] << ( RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) )
  and ( echo_val iff rma ) >>
S [459] skip
Q [463] << RA()
  and MRP_A() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1505]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 144:
Theorem (144) [serial 1522] used for:
    normalization of [serial 1507] 


Theorem (146)                               [serial 1524] 
P [459] << ( ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() )
  and not ( echo_val iff rma ) >>
S [461] Lost_Confirmation!
Q [463] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1508]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (147)                               [serial 1508] 
P [459] << ( RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) )
  and ( not ( echo_val iff rma ) ) >>
S [461] Lost_Confirmation!
Q [463] << RA()
  and MRP_A() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1505]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 146:
Theorem (146) [serial 1524] used for:
    normalization of [serial 1508] 


Theorem (148)                               [serial 1505] 
P [458] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
S [459]   if 
    (echo_val iff rma)~> 
      skip 
  []
    (not ( echo_val iff rma ))~> 
      Lost_Confirmation! 
  fi
Q [463] << RA()
  and MRP_A() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1501]
Solved by: and theorems 143 145 147:
Theorem (143) [serial 1506] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1505] 
Theorem (145) [serial 1507] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1505] 
Theorem (147) [serial 1508] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1505] 


Theorem (149)                               [serial 1501] 
P [458] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
S [458] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
  if 
    (echo_val iff rma)~> 
      skip 
  []
    (not ( echo_val iff rma ))~> 
      Lost_Confirmation! 
  fi
<< RA()
  and MRP_A() >>
Q [463] << RA()
  and MRP_A() >>
Why created:  <<A>> S <<B>> in behavior action block for [serial 1499]
Solved by: null and theorems 139 141 148:
Theorem (139) [serial 1503] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1501] 
Theorem (141) [serial 1504] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1501] 
Theorem (148) [serial 1505] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1501] 


Theorem (150)                               [serial 1526] 
P [463] << MRP_A()
  and RA() >>
S [457] ->
Q [465] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1502]
Solved by: Identity (id):  P->P is tautology

Theorem (151)                               [serial 1502] 
P [463] << RA()
  and MRP_A() >>
S [457] ->
Q [465] << RA()
  and MRP_A() >>
Why created:  <<B>> -> <<Q>> in behavior action block for [serial 1499]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 150:
Theorem (150) [serial 1526] used for:
    normalization of [serial 1502] 


Theorem (152)                               [serial 1499] 
P [456] << RA()
  and MRP_A()
  and RM_Alarm_Echo@now >>
S [457] declare 
   echo_val ~ boolean := RM_Alarm_Echo?   {
  << RA()
    and MRP_A()
    and ( echo_val iff RM_Alarm_Echo ) >>
    if 
      (echo_val iff rma)~> 
        skip 
    []
      (not ( echo_val iff rma ))~> 
        Lost_Confirmation! 
    fi
  << RA()
    and MRP_A() >>
  } 
Q [465] << RA()
  and MRP_A() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1016]
Solved by: Behavior Action Block (BAB): 
     <<P and x=e>> -> <<A>>
     <<A>> S <<B>> 
     <<B>> -> <<Q>>
----------------------------------------------------
<<P>> declare variable v~y:=e; { <<A>> S <<B>> } <<Q>> and theorems 137 149 151:
Theorem (137) [serial 1500] used for:
  <<P and v=e>> -> <<A>> in behavior action block for [serial 1499] 
Theorem (149) [serial 1501] used for:
  <<A>> S <<B>> in behavior action block for [serial 1499] 
Theorem (151) [serial 1502] used for:
  <<B>> -> <<Q>> in behavior action block for [serial 1499] 


Theorem (153)                               [serial 1016] 
P [454] << ( RA()
  and MRP_A() )
  and ( RM_Alarm_Echo@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [456] << RA()
  and MRP_A()
  and RM_Alarm_Echo@now >>
declare 
   echo_val ~ boolean := RM_Alarm_Echo?   {
  << RA()
    and MRP_A()
    and ( echo_val iff RM_Alarm_Echo ) >>
    if 
      (echo_val iff rma)~> 
        skip 
    []
      (not ( echo_val iff rma ))~> 
        Lost_Confirmation! 
    fi
  << RA()
    and MRP_A() >>
  } 
<< RA()
  and MRP_A() >>
Q [427] << RA()
  and MRP_A() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A};
Solved by: null and theorems 133 135 152:
Theorem (133) [serial 1497] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1016] 
Theorem (135) [serial 1498] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1016] 
Theorem (152) [serial 1499] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1016] 


Theorem (154)                               [serial 1557] 
P [468] << ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and ( MRP_A()
  and RA() )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [469] ->
Q [469] << true >>
Why created:    normalization of [serial 1553]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (155)                               [serial 1553] 
P [468] << ( RA()
  and MRP_A() )
  and ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [469] ->
Q [469] << true >>
Why created:  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1017]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 154:
Theorem (154) [serial 1557] used for:
    normalization of [serial 1553] 


Theorem (156)                               [serial 1559] 
P [469] << ( ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and ( MRP_A()
  and RA() )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) )
  and true >>
S [469] ->
Q [427] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1555]
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (157)                               [serial 1555] 
P [469] << ( ( RA()
  and MRP_A() )
  and ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) )
  and true >>
S [469] ->
Q [427] << RA()
  and MRP_A() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1554]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  Conjunction Commutes. (bl.ancom) and theorem 156:
Theorem (156) [serial 1559] used for:
    normalization of [serial 1555] 


Theorem (158)                               [serial 1554] 
P [469] << ( ( RA()
  and MRP_A() )
  and ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) )
  and true@now >>
S [469] ->
Q [427] << RA()
  and MRP_A() >>
Why created:  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1017]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 157:
Theorem (157) [serial 1555] used for:
  Assume Present:  P = P@now = P^0   [serial 1554] 


Theorem (159)                               [serial 1017] 
P [468] << ( RA()
  and MRP_A() )
  and ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [469] Lost_Confirmation!
Q [427] << RA()
  and MRP_A() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A};
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 155 158:
Theorem (155) [serial 1553] used for:
  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1017] 
Theorem (158) [serial 1554] used for:
  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1017] 


Theorem (160)                               [serial 1010] 
P [415] <<   >>
S [418] ->
Q [415] << Respiration_Monitor_Thread.impl proof obligations >>
Why created:  Initial proof obligations for Respiration_Monitor_Thread.impl
Solved by:  Component verification conditions
 and theorems 92 93 94 95 131 153 159:
Theorem (92) [serial 1011] used for:
  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition. 
Theorem (93) [serial 1012] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (94) [serial 1013] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (95) [serial 1014] used for:
   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{}; 
Theorem (131) [serial 1015] used for:
   <<M(run) and x>> A <<M(check_echo)>> for got_rp: run-[x]->check_echo{A}; 
Theorem (153) [serial 1016] used for:
   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A}; 
Theorem (159) [serial 1017] used for:
   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A}; 


Theorem (161)                               [serial 1573] 
P [619] << ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff Pause_Infusion )
  and ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff pause_inf )
  and ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) iff po_alarm_active )
  and ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE iff rm_alarm_active ) >>
S [619] ->
Q [611] << ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff PAUSE_INFUSION >>
Why created:    normalization of [serial 1571]
  Using: ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Absorb parentheses, middle term in disjunction (bl.orabpm)

Theorem (162)                               [serial 1571] 
P [619] << ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff Pause_Infusion )
  and ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff pause_inf )
  and ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) iff po_alarm_active )
  and ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE iff rm_alarm_active ) >>
S [619] ->
Q [611] << ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) iff PAUSE_INFUSION >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1570]
Solved by: [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 161:
Theorem (161) [serial 1573] used for:
    normalization of [serial 1571] 


Theorem (163)                               [serial 1570] 
P [619] << ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff Pause_Infusion )
  and ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff pause_inf )
  and ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) iff po_alarm_active )
  and ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE iff rm_alarm_active ) >>
S [619] ->
Q [611] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:    normalization of [serial 1568]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) (bl.orcom) 
Solved by: Predicate Invocation. (PI) and theorem 162:
Theorem (162) [serial 1571] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1570] 


Theorem (164)                               [serial 1568] 
P [619] << ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) iff Pause_Infusion )
  and ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) iff pause_inf )
  and ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) iff po_alarm_active )
  and ( ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff rm_alarm_active ) >>
S [619] ->
Q [611] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1567]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 163:
Theorem (163) [serial 1570] used for:
    normalization of [serial 1568] 


Theorem (165)                               [serial 1567] 
P [619] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [619] ->
Q [611] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:    normalization of [serial 1565]
  Using: (bicom) (bl.ancom) (bl.orcom) 
Solved by: Predicate Invocation. (PI) and theorem 164:
Theorem (164) [serial 1568] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1567] 


Theorem (166)                               [serial 1565] 
P [619] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) >>
S [619] ->
Q [611] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1019]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 165:
Theorem (165) [serial 1567] used for:
    normalization of [serial 1565] 


Theorem (167)                               [serial 1019] 
P [619] << INV()
  and POA()
  and RMA()
  and PI() >>
S [619] ->
Q [611] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:  <<I>> -> BLESS::Invariant of thread Coordinator_Thread.echo
Solved by: Predicate Invocation. (PI) and theorem 166:
Theorem (166) [serial 1565] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1019] 


Theorem (168)                               [serial 1578] 
P [635] << INV()
  and PI()
  and POA()
  and RMA() >>
S [619] ->
Q [619] << INV()
  and PI()
  and POA()
  and RMA() >>
Why created:    normalization of [serial 1576]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (169)                               [serial 1576] 
P [635] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
S [619] ->
Q [619] << INV()
  and POA()
  and RMA()
  and PI() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1020]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 168:
Theorem (168) [serial 1578] used for:
    normalization of [serial 1576] 


Theorem (170)                               [serial 1020] 
P [635] << INV_E() >>
S [619] ->
Q [619] << INV()
  and POA()
  and RMA()
  and PI() >>
Why created:  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 169:
Theorem (169) [serial 1576] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1020] 


Theorem (171)                               [serial 1581] 
P [633] << INV()
  and PI()
  and POA()
  and RMA() >>
S [619] ->
Q [619] << INV()
  and PI()
  and POA()
  and RMA() >>
Why created:    normalization of [serial 1579]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (172)                               [serial 1579] 
P [633] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
S [619] ->
Q [619] << INV()
  and POA()
  and RMA()
  and PI() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1021]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 171:
Theorem (171) [serial 1581] used for:
    normalization of [serial 1579] 


Theorem (173)                               [serial 1021] 
P [633] << INV_E() >>
S [619] ->
Q [619] << INV()
  and POA()
  and RMA()
  and PI() >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 172:
Theorem (172) [serial 1579] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1021] 


Theorem (174)                               [serial 1022] 
P [632] << INV_E() >>
S [632] ->
Q [632] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by: Anything Implies True (a1tru): P->true

Theorem (175)                               [serial 1023] 
P [632] << INV_E() >>
S [639] ->
Q [633] << INV_E() >>
Why created:   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{};
Solved by: Identity (id):  P->P is tautology

Theorem (176)                               [serial 1609] 
P [641] << ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 )@now
  and ( INV()
  and POA()
  and RMA()
  and PI() )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 )@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE )@u  ) >>
S [641] ->
Q [643] << INV()
  and RMA() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1588]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (177)                               [serial 1588] 
P [641] << PO_ALARM()@now
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [641] ->
Q [643] << INV()
  and RMA() >>
Why created:    normalization of [serial 1582]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 176:
Theorem (176) [serial 1609] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1588] 


Theorem (178)                               [serial 1582] 
P [641] << ( INV_E() )
  and ( PO_ALARM()@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [641] ->
Q [643] << INV()
  and RMA() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1024]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 177:
Theorem (177) [serial 1588] used for:
    normalization of [serial 1582] 


Theorem (179)                               [serial 1613] 
P [644] << ( INV()
  and RMA() )
  and ( PO_ALARM() iff po_alarm_active ) >>
S [644] ->
Q [645] << ( PO_ALARM() iff po_alarm_active )
  and INV()
  and RMA() >>
Why created:    normalization of [serial 1611]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (180)                               [serial 1611] 
P [644] << ( INV()
  and RMA() )
  and ( po_alarm_active iff PO_ALARM() ) >>
S [644] ->
Q [645] << ( PO_ALARM() iff po_alarm_active )
  and INV()
  and RMA() >>
Why created:  applied port input of value <<pre and po_alarm_active=M(PO_Alarm)>> -> <<post>> [serial 1590]
Solved by: Biconditional (iff) Commutes. (bicom) and theorem 179:
Theorem (179) [serial 1613] used for:
    normalization of [serial 1611] 


Theorem (181)                               [serial 1590] 
P [643] << INV()
  and RMA() >>
S [644] PO_Alarm?(po_alarm_active)
Q [645] << ( PO_ALARM() iff po_alarm_active )
  and INV()
  and RMA() >>
Why created:    normalization of [serial 1583]
  Using: (bicom) (bl.ancom) 
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 180:
Theorem (180) [serial 1611] used for:
  applied port input of value <<pre and po_alarm_active=M(PO_Alarm)>> -> <<post>> [serial 1590] 


Theorem (182)                               [serial 1583] 
P [643] << INV()
  and RMA() >>
S [644] PO_Alarm?(po_alarm_active)
Q [645] << INV()
  and RMA()
  and ( po_alarm_active iff PO_ALARM() ) >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1024]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 181:
Theorem (181) [serial 1590] used for:
    normalization of [serial 1583] 


Theorem (183)                               [serial 1615] 
P [645] << ( PO_ALARM() iff po_alarm_active )
  and INV()
  and RMA() >>
S [646] ->
Q [646] << PO_ALARM() iff po_alarm_active >>
Why created:  applied port output of value <<pre>> -> <<M(PO_Alarm_Echo)[PO_Alarm_Echo|po_alarm_active]>> [serial 1592]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (184)                               [serial 1616] 
P [646] << ( ( PO_ALARM() iff po_alarm_active )
  and INV()
  and RMA() )
  and ( PO_ALARM() iff po_alarm_active )@now >>
S [646] ->
Q [647] << INV()
  and POA()
  and RMA() >>
Why created:  applied port output <<pre and (PO_ALARM() iff po_alarm_active)@now>> -> <<post>> [serial 1592]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (185)                               [serial 1592] 
P [645] << ( PO_ALARM() iff po_alarm_active )
  and INV()
  and RMA() >>
S [646] PO_Alarm_Echo!(po_alarm_active)
Q [647] << INV()
  and POA()
  and RMA() >>
Why created:    normalization of [serial 1584]
  Using: (bicom) (bl.ancom) 
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 183 184:
Theorem (183) [serial 1615] used for:
  applied port output of value <<pre>> -> <<M(PO_Alarm_Echo)[PO_Alarm_Echo|po_alarm_active]>> [serial 1592] 
Theorem (184) [serial 1616] used for:
  applied port output <<pre and (PO_ALARM() iff po_alarm_active)@now>> -> <<post>> [serial 1592] 


Theorem (186)                               [serial 1584] 
P [645] << INV()
  and RMA()
  and ( po_alarm_active iff PO_ALARM() ) >>
S [646] PO_Alarm_Echo!(po_alarm_active)
Q [647] << INV()
  and RMA()
  and POA() >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1024]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 185:
Theorem (185) [serial 1592] used for:
    normalization of [serial 1584] 


Theorem (187)                               [serial 1635] 
P [647] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [648] ->
Q [627] << ( ( PO_ALARM() or RM_ALARM() ) iff ( PO_ALARM() or RM_ALARM() ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "rm_alarm_active" with its iff "RM_ALARM()" in its postcondition [serial 1634]
Solved by: Principle of identity for logical equivalence. (biid) 

Theorem (188)                               [serial 1634] 
P [647] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [648] ->
Q [627] << ( ( PO_ALARM() or RM_ALARM() ) iff ( PO_ALARM() or rm_alarm_active ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "po_alarm_active" with its iff "PO_ALARM()" in its postcondition [serial 1630]
Solved by:  Guided Substitution of Equals
 and theorem 187:
Theorem (187) [serial 1635] used for:
  Guided Substitution of Equals 
 replacing "rm_alarm_active" with its iff "RM_ALARM()" in its postcondition [serial 1634] 


Theorem (189)                               [serial 1630] 
P [647] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [648] ->
Q [627] << ( ( PO_ALARM() or RM_ALARM() ) iff ( po_alarm_active or rm_alarm_active ) ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1629]
Solved by:  Guided Substitution of Equals
 and theorem 188:
Theorem (188) [serial 1634] used for:
  Guided Substitution of Equals 
 replacing "po_alarm_active" with its iff "PO_ALARM()" in its postcondition [serial 1630] 


Theorem (190)                               [serial 1631] 
P [647] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [648] ->
Q [617] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1629]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (191)                               [serial 1632] 
P [647] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [648] ->
Q [623] << ( PO_ALARM() iff po_alarm_active ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1629]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (192)                               [serial 1633] 
P [647] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [648] ->
Q [625] << ( RM_ALARM() iff rm_alarm_active ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1629]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (193)                               [serial 1629] 
P [647] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [648] ->
Q [649] << ( ( PO_ALARM() or RM_ALARM() ) iff ( po_alarm_active or rm_alarm_active ) )
  and ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
Why created:    normalization of [serial 1627]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 189 190 191 192:
Theorem (189) [serial 1630] used for:
  Join consequents with conjunction. (3jca)
   [serial 1629] 
Theorem (190) [serial 1631] used for:
  Join consequents with conjunction. (3jca)
   [serial 1629] 
Theorem (191) [serial 1632] used for:
  Join consequents with conjunction. (3jca)
   [serial 1629] 
Theorem (192) [serial 1633] used for:
  Join consequents with conjunction. (3jca)
   [serial 1629] 


Theorem (194)                               [serial 1627] 
P [647] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() ) >>
S [648] ->
Q [649] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( ( po_alarm_active or rm_alarm_active ) iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1626]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 193:
Theorem (193) [serial 1629] used for:
    normalization of [serial 1627] 


Theorem (195)                               [serial 1626] 
P [647] << INV()
  and POA()
  and RMA() >>
S [648] ->
Q [649] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( ( po_alarm_active or rm_alarm_active ) iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  applied wp for assignment [serial 1625]
Solved by: Predicate Invocation. (PI) and theorem 194:
Theorem (194) [serial 1627] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1626] 


Theorem (196)                               [serial 1625] 
P [647] << INV()
  and POA()
  and RMA() >>
S [648] pause_inf := po_alarm_active or rm_alarm_active
Q [649] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1624]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 195:
Theorem (195) [serial 1626] used for:
  applied wp for assignment [serial 1625] 


Theorem (197)                               [serial 1624] 
P [647] << INV()
  and POA()
  and RMA() >>
S [648] pause_inf := po_alarm_active or rm_alarm_active
Q [649] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1594]
Solved by: Predicate Invocation. (PI) and theorem 196:
Theorem (196) [serial 1625] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1624] 


Theorem (198)                               [serial 1594] 
P [647] << INV()
  and POA()
  and RMA() >>
S [648] pause_inf := po_alarm_active or rm_alarm_active
Q [649] << INV_E() >>
Why created:    normalization of [serial 1585]
Solved by: Predicate Invocation. (PI) and theorem 197:
Theorem (197) [serial 1624] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1594] 


Theorem (199)                               [serial 1585] 
P [647] << INV()
  and RMA()
  and POA() >>
S [648] pause_inf := po_alarm_active or rm_alarm_active
Q [649] << INV_E() >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1024]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 198:
Theorem (198) [serial 1594] used for:
    normalization of [serial 1585] 


Theorem (200)                               [serial 1608] 
P [649] << ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [650] ->
Q [650] << ( PO_ALARM() or RM_ALARM() ) iff pause_inf >>
Why created:    normalization of [serial 1606]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (201)                               [serial 1606] 
P [649] << ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [650] ->
Q [650] << ( ( PO_ALARM() or RM_ALARM() ) ) iff pause_inf >>
Why created:  Guided Substitution of Equals 
 replacing "PAUSE_INFUSION" with its iff "( ( PO_ALARM() or RM_ALARM() ) )" in its postcondition [serial 1605]
Solved by: [Add unnecessary parentheses] and theorem 200:
Theorem (200) [serial 1608] used for:
    normalization of [serial 1606] 


Theorem (202)                               [serial 1605] 
P [649] << ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [650] ->
Q [650] << PAUSE_INFUSION iff pause_inf >>
Why created:  Replacing port names with BLESS::Assertion properties  [serial 1604]
Solved by:  Guided Substitution of Equals
 and theorem 201:
Theorem (201) [serial 1606] used for:
  Guided Substitution of Equals 
 replacing "PAUSE_INFUSION" with its iff "( ( PO_ALARM() or RM_ALARM() ) )" in its postcondition [serial 1605] 


Theorem (203)                               [serial 1604] 
P [649] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [650] ->
Q [650] << PAUSE_INFUSION iff pause_inf >>
Why created:    normalization of [serial 1602]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by:  Replacing port names with BLESS::Assertion properties
 and theorem 202:
Theorem (202) [serial 1605] used for:
  Replacing port names with BLESS::Assertion properties  [serial 1604] 


Theorem (204)                               [serial 1602] 
P [649] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
S [650] ->
Q [650] << PAUSE_INFUSION iff pause_inf >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1601]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 203:
Theorem (203) [serial 1604] used for:
    normalization of [serial 1602] 


Theorem (205)                               [serial 1601] 
P [649] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
S [650] ->
Q [650] << PAUSE_INFUSION iff pause_inf >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1596]
Solved by: Predicate Invocation. (PI) and theorem 204:
Theorem (204) [serial 1602] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1601] 


Theorem (206)                               [serial 1596] 
P [649] << INV_E() >>
S [650] ->
Q [650] << PAUSE_INFUSION iff pause_inf >>
Why created:  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|pause_inf]>> [serial 1586]
Solved by: Predicate Invocation. (PI) and theorem 205:
Theorem (205) [serial 1601] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1596] 


Theorem (207)                               [serial 1600] 
P [650] << ( PAUSE_INFUSION iff pause_inf )@now
  and INV_E() >>
S [650] ->
Q [635] << INV_E() >>
Why created:    normalization of [serial 1597]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (208)                               [serial 1597] 
P [650] << ( INV_E() )
  and ( PAUSE_INFUSION iff pause_inf )@now >>
S [650] ->
Q [635] << INV_E() >>
Why created:  applied port output <<pre and (PAUSE_INFUSION iff pause_inf)@now>> -> <<post>> [serial 1586]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 207:
Theorem (207) [serial 1600] used for:
    normalization of [serial 1597] 


Theorem (209)                               [serial 1586] 
P [649] << INV_E() >>
S [650] Pause_Infusion!(pause_inf)
Q [635] << INV_E() >>
Why created:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1024]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 206 208:
Theorem (206) [serial 1596] used for:
  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|pause_inf]>> [serial 1586] 
Theorem (208) [serial 1597] used for:
  applied port output <<pre and (PAUSE_INFUSION iff pause_inf)@now>> -> <<post>> [serial 1586] 


Theorem (210)                               [serial 1024] 
P [641] << ( INV_E() )
  and ( PO_ALARM()@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [643]   << INV()
    and RMA() >>
  PO_Alarm?(po_alarm_active)
  ;
  << INV()
    and RMA()
    and ( po_alarm_active iff PO_ALARM() ) >>
  PO_Alarm_Echo!(po_alarm_active)
  ;
  << INV()
    and RMA()
    and POA() >>
  pause_inf := po_alarm_active or rm_alarm_active
  ;
  << INV_E() >>
  Pause_Infusion!(pause_inf) 
Q [635] << INV_E() >>
Why created:   <<M(run) and x>> A <<M(check_echo)>> for got_po: run-[x]->check_echo{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 178 182 186 199 209:
Theorem (178) [serial 1582] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1024] 
Theorem (182) [serial 1583] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1024] 
Theorem (186) [serial 1584] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1024] 
Theorem (199) [serial 1585] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1024] 
Theorem (209) [serial 1586] used for:
  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1024] 


Theorem (211)                               [serial 1646] 
P [653] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE )@now
  and ( INV()
  and POA()
  and RMA()
  and PI() )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 )@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE )@u  ) >>
S [653] ->
Q [654] << INV()
  and POA() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1641]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (212)                               [serial 1641] 
P [653] << RM_ALARM()@now
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [653] ->
Q [654] << INV()
  and POA() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1640]
Solved by: Predicate Invocation. (PI) and theorem 211:
Theorem (211) [serial 1646] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1641] 


Theorem (213)                               [serial 1650] 
P [655] << ( INV()
  and POA() )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [655] ->
Q [656] << ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() >>
Why created:    normalization of [serial 1648]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (214)                               [serial 1648] 
P [655] << ( INV()
  and POA() )
  and ( rm_alarm_active iff RM_ALARM() ) >>
S [655] ->
Q [656] << ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() >>
Why created:  applied port input of value <<pre and rm_alarm_active=M(RM_Alarm)>> -> <<post>> [serial 1642]
Solved by: Biconditional (iff) Commutes. (bicom) and theorem 213:
Theorem (213) [serial 1650] used for:
    normalization of [serial 1648] 


Theorem (215)                               [serial 1642] 
P [654] << INV()
  and POA() >>
S [655] RM_Alarm?(rm_alarm_active)
Q [656] << ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1640]
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 214:
Theorem (214) [serial 1648] used for:
  applied port input of value <<pre and rm_alarm_active=M(RM_Alarm)>> -> <<post>> [serial 1642] 


Theorem (216)                               [serial 1652] 
P [656] << ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() >>
S [657] ->
Q [657] << RM_ALARM() iff rm_alarm_active >>
Why created:  applied port output of value <<pre>> -> <<M(RM_Alarm_Echo)[RM_Alarm_Echo|rm_alarm_active]>> [serial 1643]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (217)                               [serial 1654] 
P [657] << ( ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() )
  and ( RM_ALARM() iff rm_alarm_active )@now >>
S [657] ->
Q [658] << INV() >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1653]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (218)                               [serial 1655] 
P [657] << ( ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() )
  and ( RM_ALARM() iff rm_alarm_active )@now >>
S [657] ->
Q [658] << POA() >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1653]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (219)                               [serial 1656] 
P [657] << ( ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() )
  and ( RM_ALARM() iff rm_alarm_active )@now >>
S [657] ->
Q [658] << RMA() >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1653]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (220)                               [serial 1653] 
P [657] << ( ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() )
  and ( RM_ALARM() iff rm_alarm_active )@now >>
S [657] ->
Q [658] << INV()
  and POA()
  and RMA() >>
Why created:  applied port output <<pre and (RM_ALARM() iff rm_alarm_active)@now>> -> <<post>> [serial 1643]
Solved by: Join consequents with conjunction. (3jca) and theorems 217 218 219:
Theorem (217) [serial 1654] used for:
  Join consequents with conjunction. (3jca)
   [serial 1653] 
Theorem (218) [serial 1655] used for:
  Join consequents with conjunction. (3jca)
   [serial 1653] 
Theorem (219) [serial 1656] used for:
  Join consequents with conjunction. (3jca)
   [serial 1653] 


Theorem (221)                               [serial 1643] 
P [656] << ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() >>
S [657] RM_Alarm_Echo!(rm_alarm_active)
Q [658] << INV()
  and POA()
  and RMA() >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1640]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 216 220:
Theorem (216) [serial 1652] used for:
  applied port output of value <<pre>> -> <<M(RM_Alarm_Echo)[RM_Alarm_Echo|rm_alarm_active]>> [serial 1643] 
Theorem (220) [serial 1653] used for:
  applied port output <<pre and (RM_ALARM() iff rm_alarm_active)@now>> -> <<post>> [serial 1643] 


Theorem (222)                               [serial 1674] 
P [658] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [659] ->
Q [627] << ( ( PO_ALARM() or RM_ALARM() ) iff ( PO_ALARM() or RM_ALARM() ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "po_alarm_active" with its iff "PO_ALARM()" in its postcondition [serial 1673]
Solved by: Principle of identity for logical equivalence. (biid) 

Theorem (223)                               [serial 1673] 
P [658] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [659] ->
Q [627] << ( ( PO_ALARM() or RM_ALARM() ) iff ( po_alarm_active or RM_ALARM() ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "rm_alarm_active" with its iff "RM_ALARM()" in its postcondition [serial 1669]
Solved by:  Guided Substitution of Equals
 and theorem 222:
Theorem (222) [serial 1674] used for:
  Guided Substitution of Equals 
 replacing "po_alarm_active" with its iff "PO_ALARM()" in its postcondition [serial 1673] 


Theorem (224)                               [serial 1669] 
P [658] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [659] ->
Q [627] << ( ( PO_ALARM() or RM_ALARM() ) iff ( po_alarm_active or rm_alarm_active ) ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1668]
Solved by:  Guided Substitution of Equals
 and theorem 223:
Theorem (223) [serial 1673] used for:
  Guided Substitution of Equals 
 replacing "rm_alarm_active" with its iff "RM_ALARM()" in its postcondition [serial 1669] 


Theorem (225)                               [serial 1670] 
P [658] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [659] ->
Q [617] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1668]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (226)                               [serial 1671] 
P [658] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [659] ->
Q [623] << ( PO_ALARM() iff po_alarm_active ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1668]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (227)                               [serial 1672] 
P [658] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [659] ->
Q [625] << ( RM_ALARM() iff rm_alarm_active ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1668]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (228)                               [serial 1668] 
P [658] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [659] ->
Q [660] << ( ( PO_ALARM() or RM_ALARM() ) iff ( po_alarm_active or rm_alarm_active ) )
  and ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
Why created:    normalization of [serial 1666]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 224 225 226 227:
Theorem (224) [serial 1669] used for:
  Join consequents with conjunction. (3jca)
   [serial 1668] 
Theorem (225) [serial 1670] used for:
  Join consequents with conjunction. (3jca)
   [serial 1668] 
Theorem (226) [serial 1671] used for:
  Join consequents with conjunction. (3jca)
   [serial 1668] 
Theorem (227) [serial 1672] used for:
  Join consequents with conjunction. (3jca)
   [serial 1668] 


Theorem (229)                               [serial 1666] 
P [658] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() ) >>
S [659] ->
Q [660] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( ( po_alarm_active or rm_alarm_active ) iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1665]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 228:
Theorem (228) [serial 1668] used for:
    normalization of [serial 1666] 


Theorem (230)                               [serial 1665] 
P [658] << INV()
  and POA()
  and RMA() >>
S [659] ->
Q [660] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( ( po_alarm_active or rm_alarm_active ) iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  applied wp for assignment [serial 1664]
Solved by: Predicate Invocation. (PI) and theorem 229:
Theorem (229) [serial 1666] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1665] 


Theorem (231)                               [serial 1664] 
P [658] << INV()
  and POA()
  and RMA() >>
S [659] pause_inf := po_alarm_active or rm_alarm_active
Q [660] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1663]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 230:
Theorem (230) [serial 1665] used for:
  applied wp for assignment [serial 1664] 


Theorem (232)                               [serial 1663] 
P [658] << INV()
  and POA()
  and RMA() >>
S [659] pause_inf := po_alarm_active or rm_alarm_active
Q [660] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1644]
Solved by: Predicate Invocation. (PI) and theorem 231:
Theorem (231) [serial 1664] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1663] 


Theorem (233)                               [serial 1644] 
P [658] << INV()
  and POA()
  and RMA() >>
S [659] pause_inf := po_alarm_active or rm_alarm_active
Q [660] << INV_E() >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1640]
Solved by: Predicate Invocation. (PI) and theorem 232:
Theorem (232) [serial 1663] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1644] 


Theorem (234)                               [serial 1690] 
P [660] << ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [661] ->
Q [661] << ( PO_ALARM() or RM_ALARM() ) iff pause_inf >>
Why created:    normalization of [serial 1688]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (235)                               [serial 1688] 
P [660] << ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [661] ->
Q [661] << ( ( PO_ALARM() or RM_ALARM() ) ) iff pause_inf >>
Why created:  Guided Substitution of Equals 
 replacing "PAUSE_INFUSION" with its iff "( ( PO_ALARM() or RM_ALARM() ) )" in its postcondition [serial 1687]
Solved by: [Add unnecessary parentheses] and theorem 234:
Theorem (234) [serial 1690] used for:
    normalization of [serial 1688] 


Theorem (236)                               [serial 1687] 
P [660] << ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [661] ->
Q [661] << PAUSE_INFUSION iff pause_inf >>
Why created:  Replacing port names with BLESS::Assertion properties  [serial 1686]
Solved by:  Guided Substitution of Equals
 and theorem 235:
Theorem (235) [serial 1688] used for:
  Guided Substitution of Equals 
 replacing "PAUSE_INFUSION" with its iff "( ( PO_ALARM() or RM_ALARM() ) )" in its postcondition [serial 1687] 


Theorem (237)                               [serial 1686] 
P [660] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [661] ->
Q [661] << PAUSE_INFUSION iff pause_inf >>
Why created:    normalization of [serial 1684]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by:  Replacing port names with BLESS::Assertion properties
 and theorem 236:
Theorem (236) [serial 1687] used for:
  Replacing port names with BLESS::Assertion properties  [serial 1686] 


Theorem (238)                               [serial 1684] 
P [660] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
S [661] ->
Q [661] << PAUSE_INFUSION iff pause_inf >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1683]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 237:
Theorem (237) [serial 1686] used for:
    normalization of [serial 1684] 


Theorem (239)                               [serial 1683] 
P [660] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
S [661] ->
Q [661] << PAUSE_INFUSION iff pause_inf >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1678]
Solved by: Predicate Invocation. (PI) and theorem 238:
Theorem (238) [serial 1684] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1683] 


Theorem (240)                               [serial 1678] 
P [660] << INV_E() >>
S [661] ->
Q [661] << PAUSE_INFUSION iff pause_inf >>
Why created:  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|pause_inf]>> [serial 1645]
Solved by: Predicate Invocation. (PI) and theorem 239:
Theorem (239) [serial 1683] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1678] 


Theorem (241)                               [serial 1682] 
P [661] << ( PAUSE_INFUSION iff pause_inf )@now
  and INV_E() >>
S [661] ->
Q [635] << INV_E() >>
Why created:    normalization of [serial 1679]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (242)                               [serial 1679] 
P [661] << ( INV_E() )
  and ( PAUSE_INFUSION iff pause_inf )@now >>
S [661] ->
Q [635] << INV_E() >>
Why created:  applied port output <<pre and (PAUSE_INFUSION iff pause_inf)@now>> -> <<post>> [serial 1645]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 241:
Theorem (241) [serial 1682] used for:
    normalization of [serial 1679] 


Theorem (243)                               [serial 1645] 
P [660] << INV_E() >>
S [661] Pause_Infusion!(pause_inf)
Q [635] << INV_E() >>
Why created:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1640]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 240 242:
Theorem (240) [serial 1678] used for:
  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|pause_inf]>> [serial 1645] 
Theorem (242) [serial 1679] used for:
  applied port output <<pre and (PAUSE_INFUSION iff pause_inf)@now>> -> <<post>> [serial 1645] 


Theorem (244)                               [serial 1640] 
P [653] << RM_ALARM()@now
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [654]   << INV()
    and POA() >>
  RM_Alarm?(rm_alarm_active)
  ;
  << ( RM_ALARM() iff rm_alarm_active )
    and INV()
    and POA() >>
  RM_Alarm_Echo!(rm_alarm_active)
  ;
  << INV()
    and POA()
    and RMA() >>
  pause_inf := po_alarm_active or rm_alarm_active
  ;
  << INV_E() >>
  Pause_Infusion!(pause_inf) 
Q [635] << INV_E() >>
Why created:    normalization of [serial 1025]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) (bicom) 
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 212 215 221 233 243:
Theorem (212) [serial 1641] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1640] 
Theorem (215) [serial 1642] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1640] 
Theorem (221) [serial 1643] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1640] 
Theorem (233) [serial 1644] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1640] 
Theorem (243) [serial 1645] used for:
  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1640] 


Theorem (245)                               [serial 1025] 
P [653] << ( INV_E() )
  and ( RM_ALARM()@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [654]   << INV()
    and POA() >>
  RM_Alarm?(rm_alarm_active)
  ;
  << INV()
    and POA()
    and ( rm_alarm_active iff RM_ALARM() ) >>
  RM_Alarm_Echo!(rm_alarm_active)
  ;
  << INV()
    and RMA()
    and POA() >>
  pause_inf := po_alarm_active or rm_alarm_active
  ;
  << INV_E() >>
  Pause_Infusion!(pause_inf) 
Q [635] << INV_E() >>
Why created:   <<M(run) and x>> A <<M(check_echo)>> for got_rm: run-[x]->check_echo{A};
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) Biconditional (iff) Commutes. (bicom) and theorem 244:
Theorem (244) [serial 1640] used for:
    normalization of [serial 1025] 


Theorem (246)                               [serial 1702] 
P [664] << ( PAUSE_INFUSION_ECHO@now
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) )
  and ( PAUSE_INFUSION_ECHO@now iff echo_val ) >>
S [667] ->
Q [667] << ( PAUSE_INFUSION_ECHO iff echo_val )
  and INV_E() >>
Why created:    normalization of [serial 1692]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) (bicom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (247)                               [serial 1692] 
P [664] << ( ( INV_E() )
  and ( PAUSE_INFUSION_ECHO@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) )
  and ( echo_val iff PAUSE_INFUSION_ECHO@now ) >>
S [667] ->
Q [667] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
Why created:  <<P and v=e>> -> <<A>> in behavior action block for [serial 1691]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) Biconditional (iff) Commutes. (bicom) and theorem 246:
Theorem (246) [serial 1702] used for:
    normalization of [serial 1692] 


Theorem (248)                               [serial 1695] 
P [667] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
S [667] ->
Q [667] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1693]
Solved by: Identity (id):  P->P is tautology

Theorem (249)                               [serial 1696] 
P [672] << INV_E() >>
S [672] ->
Q [672] << INV_E() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1693]
Solved by: Identity (id):  P->P is tautology

Theorem (250)                               [serial 1704] 
P [667] << ( PAUSE_INFUSION_ECHO iff echo_val )
  and INV_E() >>
S [668] ->
Q [668] << ( echo_val iff pause_inf ) or not ( echo_val iff pause_inf ) >>
Why created:    normalization of [serial 1698]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (251)                               [serial 1698] 
P [667] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
S [668] ->
Q [668] << ( echo_val iff pause_inf ) or ( not ( echo_val iff pause_inf ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1697]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) and theorem 250:
Theorem (250) [serial 1704] used for:
    normalization of [serial 1698] 


Theorem (252)                               [serial 1706] 
P [668] << ( ( PAUSE_INFUSION_ECHO iff echo_val )
  and INV_E() )
  and ( echo_val iff pause_inf ) >>
S [668] skip
Q [672] << INV_E() >>
Why created:    normalization of [serial 1699]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (253)                               [serial 1699] 
P [668] << ( ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() )
  and ( echo_val iff pause_inf ) >>
S [668] skip
Q [672] << INV_E() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1697]
Solved by: Biconditional (iff) Commutes. (bicom) and theorem 252:
Theorem (252) [serial 1706] used for:
    normalization of [serial 1699] 


Theorem (254)                               [serial 1708] 
P [668] << ( ( PAUSE_INFUSION_ECHO iff echo_val )
  and INV_E() )
  and not ( echo_val iff pause_inf ) >>
S [670] Lost_Confirmation!
Q [672] << INV_E() >>
Why created:    normalization of [serial 1700]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (255)                               [serial 1700] 
P [668] << ( ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() )
  and ( not ( echo_val iff pause_inf ) ) >>
S [670] Lost_Confirmation!
Q [672] << INV_E() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1697]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) and theorem 254:
Theorem (254) [serial 1708] used for:
    normalization of [serial 1700] 


Theorem (256)                               [serial 1697] 
P [667] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
S [668]   if 
    (echo_val iff pause_inf)~> 
      skip 
  []
    (not ( echo_val iff pause_inf ))~> 
      Lost_Confirmation! 
  fi
Q [672] << INV_E() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1693]
Solved by: and theorems 251 253 255:
Theorem (251) [serial 1698] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1697] 
Theorem (253) [serial 1699] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1697] 
Theorem (255) [serial 1700] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1697] 


Theorem (257)                               [serial 1693] 
P [667] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
S [667] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
  if 
    (echo_val iff pause_inf)~> 
      skip 
  []
    (not ( echo_val iff pause_inf ))~> 
      Lost_Confirmation! 
  fi
<< INV_E() >>
Q [672] << INV_E() >>
Why created:  <<A>> S <<B>> in behavior action block for [serial 1691]
Solved by: null and theorems 248 249 256:
Theorem (248) [serial 1695] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1693] 
Theorem (249) [serial 1696] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1693] 
Theorem (256) [serial 1697] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1693] 


Theorem (258)                               [serial 1694] 
P [672] << INV_E() >>
S [666] ->
Q [633] << INV_E() >>
Why created:  <<B>> -> <<Q>> in behavior action block for [serial 1691]
Solved by: Identity (id):  P->P is tautology

Theorem (259)                               [serial 1691] 
P [664] << ( INV_E() )
  and ( PAUSE_INFUSION_ECHO@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [666] declare 
   echo_val ~ boolean := Pause_Infusion_Echo?   {
  << ( echo_val iff PAUSE_INFUSION_ECHO )
    and INV_E() >>
    if 
      (echo_val iff pause_inf)~> 
        skip 
    []
      (not ( echo_val iff pause_inf ))~> 
        Lost_Confirmation! 
    fi
  << INV_E() >>
  } 
Q [633] << INV_E() >>
Why created:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1026]
Solved by: Behavior Action Block (BAB): 
     <<P and x=e>> -> <<A>>
     <<A>> S <<B>> 
     <<B>> -> <<Q>>
----------------------------------------------------
<<P>> declare variable v~y:=e; { <<A>> S <<B>> } <<Q>> and theorems 247 257 258:
Theorem (247) [serial 1692] used for:
  <<P and v=e>> -> <<A>> in behavior action block for [serial 1691] 
Theorem (257) [serial 1693] used for:
  <<A>> S <<B>> in behavior action block for [serial 1691] 
Theorem (258) [serial 1694] used for:
  <<B>> -> <<Q>> in behavior action block for [serial 1691] 


Theorem (260)                               [serial 1026] 
P [664] << ( INV_E() )
  and ( PAUSE_INFUSION_ECHO@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [666] declare 
   echo_val ~ boolean := Pause_Infusion_Echo?   {
  << ( echo_val iff PAUSE_INFUSION_ECHO )
    and INV_E() >>
    if 
      (echo_val iff pause_inf)~> 
        skip 
    []
      (not ( echo_val iff pause_inf ))~> 
        Lost_Confirmation! 
    fi
  << INV_E() >>
  } 
Q [633] << INV_E() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A};
Solved by: null and theorem 259:
Theorem (259) [serial 1691] used for:
  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1026] 


Theorem (261)                               [serial 1731] 
P [677] << ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [678] ->
Q [678] << true >>
Why created:    normalization of [serial 1727]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (262)                               [serial 1727] 
P [677] << ( INV_E() )
  and ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [678] ->
Q [678] << true >>
Why created:  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1027]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 261:
Theorem (261) [serial 1731] used for:
    normalization of [serial 1727] 


Theorem (263)                               [serial 1733] 
P [678] << ( ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) )
  and true >>
S [678] ->
Q [633] << INV_E() >>
Why created:    normalization of [serial 1729]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (264)                               [serial 1729] 
P [678] << ( ( INV_E() )
  and ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) )
  and true >>
S [678] ->
Q [633] << INV_E() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1728]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 263:
Theorem (263) [serial 1733] used for:
    normalization of [serial 1729] 


Theorem (265)                               [serial 1728] 
P [678] << ( ( INV_E() )
  and ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) )
  and true@now >>
S [678] ->
Q [633] << INV_E() >>
Why created:  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1027]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 264:
Theorem (264) [serial 1729] used for:
  Assume Present:  P = P@now = P^0   [serial 1728] 


Theorem (266)                               [serial 1027] 
P [677] << ( INV_E() )
  and ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [678] Lost_Confirmation!
Q [633] << INV_E() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A};
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 262 265:
Theorem (262) [serial 1727] used for:
  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1027] 
Theorem (265) [serial 1728] used for:
  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1027] 


Theorem (267)                               [serial 1018] 
P [616] <<   >>
S [619] ->
Q [616] << Coordinator_Thread.echo proof obligations >>
Why created:  Initial proof obligations for Coordinator_Thread.echo
Solved by:  Component verification conditions
 and theorems 167 170 173 174 175 210 245 260 266:
Theorem (167) [serial 1019] used for:
  <<I>> -> BLESS::Invariant of thread Coordinator_Thread.echo 
Theorem (170) [serial 1020] used for:
  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition. 
Theorem (173) [serial 1021] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (174) [serial 1022] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (175) [serial 1023] used for:
   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{}; 
Theorem (210) [serial 1024] used for:
   <<M(run) and x>> A <<M(check_echo)>> for got_po: run-[x]->check_echo{A}; 
Theorem (245) [serial 1025] used for:
   <<M(run) and x>> A <<M(check_echo)>> for got_rm: run-[x]->check_echo{A}; 
Theorem (260) [serial 1026] used for:
   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A}; 
Theorem (266) [serial 1027] used for:
   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A}; 


Theorem (268)                               [serial 1741] 
P [1] << ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff PAUSE_INFUSION )
  and ( PAUSE_INFUSION implies KVO_RATE_property = PUMP_RATE$() ) >>
S    ->
Q [2] << ( ( HEART_RATE < MINIMUM_HEART_RATE or RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE or 
SPO2 < PROGRAMMED_SPO2 ) implies KVO_RATE_property = PUMP_RATE$() ) or HALT() >>
Why created:    normalization of [serial 1739]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) (bl.orcom) 
Solved by: Absorb parentheses, middle term in disjunction (bl.orabpm)

Theorem (269)                               [serial 1739] 
P [1] << ( PAUSE_INFUSION implies PUMP_RATE$() = KVO_RATE_property )
  and ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) iff PAUSE_INFUSION ) >>
S    ->
Q [2] << ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 or RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) implies PUMP_RATE$() = KVO_RATE_property ) or 
HALT() ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1028]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 268:
Theorem (268) [serial 1741] used for:
    normalization of [serial 1739] 


Theorem (270)                               [serial 1028] 
P [1] << ( PAUSE_INFUSION implies PUMP_RATE$() = KVO_RATE_property )
  and ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION ) >>
S    ->
Q [2] << IS_SAFE() >>
Why created:  Conjunction of Subcomponents' Invariants imply SysIoMT.impl's Invariant
Solved by: Predicate Invocation. (PI) and theorem 269:
Theorem (269) [serial 1739] used for:
  Substituted assertions' predicates for labels  [serial 1028] 


Theorem (271)                               [serial 1747] 
P [1] << PAUSE_INFUSION implies KVO_RATE_property = PUMP_RATE$() >>
S    ->
Q [2] << PAUSE_INFUSION implies KVO_RATE_property = PUMP_RATE$() >>
Why created:    normalization of [serial 1029]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Identity (id):  P->P is tautology

Theorem (272)                               [serial 1029] 
P [1] << ( PAUSE_INFUSION implies PUMP_RATE$() = KVO_RATE_property ) >>
S    ->
Q [2] << PAUSE_INFUSION implies PUMP_RATE$() = KVO_RATE_property >>
Why created:  Subcomponent's Invariant implies PCA_Pump.impl's Invariant
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 271:
Theorem (271) [serial 1747] used for:
    normalization of [serial 1029] 


Theorem (273)                               [serial 1749] 
P [1] << PAUSE_INFUSION implies KVO_RATE_property = PUMP_RATE$() >>
S    ->
Q [2] << PAUSE_INFUSION implies KVO_RATE_property = PUMP_RATE$() >>
Why created:    normalization of [serial 1030]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Identity (id):  P->P is tautology

Theorem (274)                               [serial 1030] 
P [1] << ( PAUSE_INFUSION implies PUMP_RATE$() = KVO_RATE_property ) >>
S    ->
Q [2] << PAUSE_INFUSION implies PUMP_RATE$() = KVO_RATE_property >>
Why created:  Subcomponent's Invariant implies PCA_Pump_Process.impl's Invariant
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 273:
Theorem (273) [serial 1749] used for:
    normalization of [serial 1030] 


Theorem (275)                               [serial 1751] 
P [1] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
S    ->
Q [2] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:    normalization of [serial 1031]
Solved by: Identity (id):  P->P is tautology

Theorem (276)                               [serial 1031] 
P [1] << ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION ) >>
S    ->
Q [2] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:  Subcomponent's Invariant implies Coordinator.impl's Invariant
Solved by: [Add unnecessary parentheses] and theorem 275:
Theorem (275) [serial 1751] used for:
    normalization of [serial 1031] 


Theorem (277)                               [serial 1753] 
P [1] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
S    ->
Q [2] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:    normalization of [serial 1032]
Solved by: Identity (id):  P->P is tautology

Theorem (278)                               [serial 1032] 
P [1] << ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION ) >>
S    ->
Q [2] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:  Subcomponent's Invariant implies Coordinator_Process.impl's Invariant
Solved by: [Add unnecessary parentheses] and theorem 277:
Theorem (277) [serial 1753] used for:
    normalization of [serial 1032] 


Theorem (279)                               [serial 1033] 
P [1] << PAUSE_INFUSION >>
S [2] ->
Q [1] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection pcc.pause_infusion -> pct.pause_infusion:
 pause_infusion -> pause_infusion
Solved by: Identity (id):  P->P is tautology

Theorem (280)                               [serial 1034] 
P [1] << pump_rate = PUMP_RATE$() >>
S [2] ->
Q [1] << pump_rate = PUMP_RATE$() >>
Why created:  Composition of Subcomponents via Directional Connection pcp.pct.pump_rate -> pmp.pump_rate:
 pump_rate -> pump_rate
Solved by: Identity (id):  P->P is tautology

Theorem (281)                               [serial 1035] 
P [1] << PO_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection pot.PO_Alarm -> poc.poa:
 PO_Alarm -> poa
Solved by: Identity (id):  P->P is tautology

Theorem (282)                               [serial 1757] 
P [1] << RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE >>
S [2] ->
Q [1] << RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE >>
Why created:    normalization of [serial 1755]
Solved by: Identity (id):  P->P is tautology

Theorem (283)                               [serial 1755] 
P [1] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) >>
S [2] ->
Q [1] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1754]
Solved by: [Add unnecessary parentheses] and theorem 282:
Theorem (282) [serial 1757] used for:
    normalization of [serial 1755] 


Theorem (284)                               [serial 1754] 
P [1] << RM_ALARM() >>
S [2] ->
Q [1] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1036]
Solved by: Predicate Invocation. (PI) and theorem 283:
Theorem (283) [serial 1755] used for:
  Substituted assertions' predicates for labels  [serial 1754] 


Theorem (285)                               [serial 1036] 
P [1] << RM_ALARM() >>
S [2] ->
Q [1] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection rmt.RM_Alarm -> rmc.rma:
 RM_Alarm -> rma
Solved by: Predicate Invocation. (PI) and theorem 284:
Theorem (284) [serial 1754] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1036] 


Theorem (286)                               [serial 1759] 
P [1] << RESPIRATION_RATE = RP_Rate >>
S [2] ->
Q [1] << RESPIRATION_RATE = RP_Rate >>
Why created:    normalization of [serial 1037]
Solved by: Identity (id):  P->P is tautology

Theorem (287)                               [serial 1037] 
P [1] << RP_Rate = RESPIRATION_RATE >>
S [2] ->
Q [1] << RP_Rate = RESPIRATION_RATE >>
Why created:  Composition of Subcomponents via Directional Connection rss.RP_Rate -> rmp.rmt.RP_Rate:
 RP_Rate -> RP_Rate
Solved by: Equality Commutes. (eqcom) and theorem 286:
Theorem (286) [serial 1759] used for:
    normalization of [serial 1037] 


Theorem (288)                               [serial 1763] 
P [1] << RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE >>
S [2] ->
Q [1] << RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE >>
Why created:    normalization of [serial 1761]
Solved by: Identity (id):  P->P is tautology

Theorem (289)                               [serial 1761] 
P [1] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) >>
S [2] ->
Q [1] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1760]
Solved by: [Add unnecessary parentheses] and theorem 288:
Theorem (288) [serial 1763] used for:
    normalization of [serial 1761] 


Theorem (290)                               [serial 1760] 
P [1] << RM_ALARM() >>
S [2] ->
Q [1] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1038]
Solved by: Predicate Invocation. (PI) and theorem 289:
Theorem (289) [serial 1761] used for:
  Substituted assertions' predicates for labels  [serial 1760] 


Theorem (291)                               [serial 1038] 
P [1] << RM_ALARM() >>
S [2] ->
Q [1] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection spt.RM_Alarm_Echo -> spc.rmae:
 RM_Alarm_Echo -> rmae
Solved by: Predicate Invocation. (PI) and theorem 290:
Theorem (290) [serial 1760] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1038] 


Theorem (292)                               [serial 1039] 
P [1] << PAUSE_INFUSION >>
S [2] ->
Q [1] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection spt.Pause_Infusion -> spc.pi:
 Pause_Infusion -> pi
Solved by: Identity (id):  P->P is tautology

Theorem (293)                               [serial 1040] 
P [1] << PO_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection spt.PO_Alarm_Echo -> spc.poae:
 PO_Alarm_Echo -> poae
Solved by: Identity (id):  P->P is tautology

Theorem (294)                               [serial 1041] 
P [1] << PO_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection spc.PO_Alarm -> spt.PO_Alarm:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (295)                               [serial 1042] 
P [1] << RM_ALARM() >>
S [2] ->
Q [1] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection spc.RM_Alarm -> spt.RM_Alarm:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (296)                               [serial 1043] 
P [1] << PAUSE_INFUSION_ECHO >>
S [2] ->
Q [1] << PAUSE_INFUSION_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection spc.Pause_Infusion_Echo -> spt.Pause_Infusion_Echo:
 Pause_Infusion_Echo -> Pause_Infusion_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (297)                               [serial 1044] 
P [1] << infused_drug = PUMP_RATE$() >>
S [2] ->
Q [1] << infused_drug = PUMP_RATE$() >>
Why created:  Composition of Subcomponents via Directional Connection pca_pump.pmp.infused_drug -> patient.Infused_Drug:
 infused_drug -> Infused_Drug
Solved by: Identity (id):  P->P is tautology

Theorem (298)                               [serial 1045] 
P [1] << PO_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection pulse_oximeter.pop.poc.PO_Alarm -> coordinator.spp.spc.poa:
 PO_Alarm -> poa
Solved by: Identity (id):  P->P is tautology

Theorem (299)                               [serial 1046] 
P [1] << RM_ALARM() >>
S [2] ->
Q [1] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection resp_monitor.rmp.rmc.RM_Alarm -> coordinator.spp.spc.rma:
 RM_Alarm -> rma
Solved by: Identity (id):  P->P is tautology

Theorem (300)                               [serial 1047] 
P [1] << PAUSE_INFUSION >>
S [2] ->
Q [1] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection coordinator.spp.spc.Pause_Infusion -> pca_pump.pcp.pcc.pi:
 Pause_Infusion -> pi
Solved by: Identity (id):  P->P is tautology

Theorem (301)                               [serial 1048] 
P [67] << infused_drug = PUMP_RATE$() >>
S [38] ->
Q [738] << infused_drug = PUMP_RATE$() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.infusion_set:
 infused_drug -> Infused_Drug
Solved by: Identity (id):  P->P is tautology

Theorem (302)                               [serial 1049] 
P [517] << PAUSE_INFUSION >>
S [24] ->
Q [65] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.pause_infusion:
 Pause_Infusion -> pause_infusion
Solved by: Identity (id):  P->P is tautology

Theorem (303)                               [serial 1050] 
P [176] << PO_ALARM() >>
S [26] ->
Q [513] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.po_alarm:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (304)                               [serial 1051] 
P [357] << RM_ALARM() >>
S [28] ->
Q [515] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.rm_alarm:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (305)                               [serial 1052] 
P [144] << infused_drug = PUMP_RATE$() >>
S [85] ->
Q [67] << infused_drug = PUMP_RATE$() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pd:
 infused_drug -> infused_drug
Solved by: Identity (id):  P->P is tautology

Theorem (306)                               [serial 1053] 
P [65] << PAUSE_INFUSION >>
S [81] ->
Q [92] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pif:
 pause_infusion -> pause_infusion
Solved by: Identity (id):  P->P is tautology

Theorem (307)                               [serial 1054] 
P [94] << pump_rate = PUMP_RATE$() >>
S [83] ->
Q [149] << pump_rate = PUMP_RATE$() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pr:
 pump_rate -> pump_rate
Solved by: Identity (id):  P->P is tautology

Theorem (308)                               [serial 1055] 
P [92] << PAUSE_INFUSION >>
S [107] ->
Q [157] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.pi1:
 pause_infusion -> pi
Solved by: Identity (id):  P->P is tautology

Theorem (309)                               [serial 1056] 
P [159] << PAUSE_INFUSION >>
S [108] ->
Q [123] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.pi2:
 pause_infusion -> pause_infusion
Solved by: Identity (id):  P->P is tautology

Theorem (310)                               [serial 1057] 
P [120] << pump_rate = PUMP_RATE$() >>
S [114] ->
Q [94] << pump_rate = PUMP_RATE$() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.PCA_Pump_Process_impl_new_connection:
 pump_rate -> pump_rate
Solved by: Identity (id):  P->P is tautology

Theorem (311)                               [serial 1058] 
P [202] << PO_ALARM() >>
S [188] ->
Q [176] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter.impl.poa:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (312)                               [serial 1059] 
P [233] << PO_ALARM() >>
S [217] ->
Q [335] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter_Process.impl.pol1:
 PO_Alarm -> poa
Solved by: Identity (id):  P->P is tautology

Theorem (313)                               [serial 1060] 
P [337] << PO_ALARM() >>
S [218] ->
Q [202] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter_Process.impl.pol2:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (314)                               [serial 1061] 
P [377] << RM_ALARM() >>
S [368] ->
Q [357] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor.impl.rma:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (315)                               [serial 1062] 
P [402] << RM_ALARM() >>
S [391] ->
Q [486] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor_Process.impl.rma1:
 RM_Alarm -> rma
Solved by: Identity (id):  P->P is tautology

Theorem (316)                               [serial 1063] 
P [488] << RM_ALARM() >>
S [392] ->
Q [377] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor_Process.impl.rma2:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (317)                               [serial 1064] 
P [513] << PO_ALARM() >>
S [532] ->
Q [549] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.poa:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (318)                               [serial 1065] 
P [515] << RM_ALARM() >>
S [533] ->
Q [551] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.rma:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (319)                               [serial 1066] 
P [553] << PAUSE_INFUSION >>
S [534] ->
Q [517] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.pi:
 Pause_Infusion -> Pause_Infusion
Solved by: Identity (id):  P->P is tautology

Theorem (320)                               [serial 1067] 
P [521] << PAUSE_INFUSION_ECHO >>
S [535] ->
Q [557] << PAUSE_INFUSION_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.pie:
 Pause_Infusion_Echo -> Pause_Infusion_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (321)                               [serial 1068] 
P [555] << PO_ALARM() >>
S [537] ->
Q [519] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.icp:
 PO_Alarm_Echo -> PO_Alarm_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (322)                               [serial 1069] 
P [546] << RM_ALARM() >>
S [538] ->
Q [509] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.icr:
 RM_Alarm_Echo -> RM_Alarm_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (323)                               [serial 1070] 
P [549] << PO_ALARM() >>
S [569] ->
Q [696] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poa1:
 PO_Alarm -> poa
Solved by: Identity (id):  P->P is tautology

Theorem (324)                               [serial 1071] 
P [698] << PO_ALARM() >>
S [570] ->
Q [593] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poa2:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (325)                               [serial 1072] 
P [551] << RM_ALARM() >>
S [571] ->
Q [700] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rma1:
 RM_Alarm -> rma
Solved by: Identity (id):  P->P is tautology

Theorem (326)                               [serial 1073] 
P [702] << RM_ALARM() >>
S [572] ->
Q [595] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rma2:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (327)                               [serial 1074] 
P [557] << PAUSE_INFUSION_ECHO >>
S [573] ->
Q [704] << PAUSE_INFUSION_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pie1:
 Pause_Infusion_Echo -> pie
Solved by: Identity (id):  P->P is tautology

Theorem (328)                               [serial 1075] 
P [706] << PAUSE_INFUSION_ECHO >>
S [574] ->
Q [601] << PAUSE_INFUSION_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pie2:
 Pause_Infusion_Echo -> Pause_Infusion_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (329)                               [serial 1076] 
P [597] << PAUSE_INFUSION >>
S [575] ->
Q [708] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pi1:
 Pause_Infusion -> pi
Solved by: Identity (id):  P->P is tautology

Theorem (330)                               [serial 1077] 
P [710] << PAUSE_INFUSION >>
S [576] ->
Q [553] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pi2:
 Pause_Infusion -> Pause_Infusion
Solved by: Identity (id):  P->P is tautology

Theorem (331)                               [serial 1078] 
P [591] << RM_ALARM() >>
S [577] ->
Q [712] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rme1:
 RM_Alarm_Echo -> rmae
Solved by: Identity (id):  P->P is tautology

Theorem (332)                               [serial 1079] 
P [714] << RM_ALARM() >>
S [578] ->
Q [546] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rme2:
 RM_Alarm_Echo -> RM_Alarm_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (333)                               [serial 1080] 
P [599] << PO_ALARM() >>
S [579] ->
Q [716] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poe1:
 PO_Alarm_Echo -> poae
Solved by: Identity (id):  P->P is tautology

Theorem (334)                               [serial 1081] 
P [718] << PO_ALARM() >>
S [580] ->
Q [555] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poe2:
 PO_Alarm_Echo -> PO_Alarm_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (335)                               [serial 1001] 
Why created:  All verification conditions have been proved correct. 
Solved by:  Component and Connection Proofs
 and theorems 91 160 267 270 272 274 276 278 279 280 281 285 287 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334:
Theorem (91) [serial 1002] used for:
  Initial proof obligations for Pulse_Oximeter_Thread.impl 
Theorem (160) [serial 1010] used for:
  Initial proof obligations for Respiration_Monitor_Thread.impl 
Theorem (267) [serial 1018] used for:
  Initial proof obligations for Coordinator_Thread.echo 
Theorem (270) [serial 1028] used for:
  Conjunction of Subcomponents' Invariants imply SysIoMT.impl's Invariant 
Theorem (272) [serial 1029] used for:
  Subcomponent's Invariant implies PCA_Pump.impl's Invariant 
Theorem (274) [serial 1030] used for:
  Subcomponent's Invariant implies PCA_Pump_Process.impl's Invariant 
Theorem (276) [serial 1031] used for:
  Subcomponent's Invariant implies Coordinator.impl's Invariant 
Theorem (278) [serial 1032] used for:
  Subcomponent's Invariant implies Coordinator_Process.impl's Invariant 
Theorem (279) [serial 1033] used for:
  Composition of Subcomponents via Directional Connection pcc.pause_infusion -> pct.pause_infusion:
 pause_infusion -> pause_infusion 
Theorem (280) [serial 1034] used for:
  Composition of Subcomponents via Directional Connection pcp.pct.pump_rate -> pmp.pump_rate:
 pump_rate -> pump_rate 
Theorem (281) [serial 1035] used for:
  Composition of Subcomponents via Directional Connection pot.PO_Alarm -> poc.poa:
 PO_Alarm -> poa 
Theorem (285) [serial 1036] used for:
  Composition of Subcomponents via Directional Connection rmt.RM_Alarm -> rmc.rma:
 RM_Alarm -> rma 
Theorem (287) [serial 1037] used for:
  Composition of Subcomponents via Directional Connection rss.RP_Rate -> rmp.rmt.RP_Rate:
 RP_Rate -> RP_Rate 
Theorem (291) [serial 1038] used for:
  Composition of Subcomponents via Directional Connection spt.RM_Alarm_Echo -> spc.rmae:
 RM_Alarm_Echo -> rmae 
Theorem (292) [serial 1039] used for:
  Composition of Subcomponents via Directional Connection spt.Pause_Infusion -> spc.pi:
 Pause_Infusion -> pi 
Theorem (293) [serial 1040] used for:
  Composition of Subcomponents via Directional Connection spt.PO_Alarm_Echo -> spc.poae:
 PO_Alarm_Echo -> poae 
Theorem (294) [serial 1041] used for:
  Composition of Subcomponents via Directional Connection spc.PO_Alarm -> spt.PO_Alarm:
 PO_Alarm -> PO_Alarm 
Theorem (295) [serial 1042] used for:
  Composition of Subcomponents via Directional Connection spc.RM_Alarm -> spt.RM_Alarm:
 RM_Alarm -> RM_Alarm 
Theorem (296) [serial 1043] used for:
  Composition of Subcomponents via Directional Connection spc.Pause_Infusion_Echo -> spt.Pause_Infusion_Echo:
 Pause_Infusion_Echo -> Pause_Infusion_Echo 
Theorem (297) [serial 1044] used for:
  Composition of Subcomponents via Directional Connection pca_pump.pmp.infused_drug -> patient.Infused_Drug:
 infused_drug -> Infused_Drug 
Theorem (298) [serial 1045] used for:
  Composition of Subcomponents via Directional Connection pulse_oximeter.pop.poc.PO_Alarm -> coordinator.spp.spc.poa:
 PO_Alarm -> poa 
Theorem (299) [serial 1046] used for:
  Composition of Subcomponents via Directional Connection resp_monitor.rmp.rmc.RM_Alarm -> coordinator.spp.spc.rma:
 RM_Alarm -> rma 
Theorem (300) [serial 1047] used for:
  Composition of Subcomponents via Directional Connection coordinator.spp.spc.Pause_Infusion -> pca_pump.pcp.pcc.pi:
 Pause_Infusion -> pi 
Theorem (301) [serial 1048] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.infusion_set:
 infused_drug -> Infused_Drug 
Theorem (302) [serial 1049] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.pause_infusion:
 Pause_Infusion -> pause_infusion 
Theorem (303) [serial 1050] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.po_alarm:
 PO_Alarm -> PO_Alarm 
Theorem (304) [serial 1051] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.rm_alarm:
 RM_Alarm -> RM_Alarm 
Theorem (305) [serial 1052] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pd:
 infused_drug -> infused_drug 
Theorem (306) [serial 1053] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pif:
 pause_infusion -> pause_infusion 
Theorem (307) [serial 1054] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pr:
 pump_rate -> pump_rate 
Theorem (308) [serial 1055] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.pi1:
 pause_infusion -> pi 
Theorem (309) [serial 1056] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.pi2:
 pause_infusion -> pause_infusion 
Theorem (310) [serial 1057] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.PCA_Pump_Process_impl_new_connection:
 pump_rate -> pump_rate 
Theorem (311) [serial 1058] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter.impl.poa:
 PO_Alarm -> PO_Alarm 
Theorem (312) [serial 1059] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter_Process.impl.pol1:
 PO_Alarm -> poa 
Theorem (313) [serial 1060] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter_Process.impl.pol2:
 PO_Alarm -> PO_Alarm 
Theorem (314) [serial 1061] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor.impl.rma:
 RM_Alarm -> RM_Alarm 
Theorem (315) [serial 1062] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor_Process.impl.rma1:
 RM_Alarm -> rma 
Theorem (316) [serial 1063] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor_Process.impl.rma2:
 RM_Alarm -> RM_Alarm 
Theorem (317) [serial 1064] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.poa:
 PO_Alarm -> PO_Alarm 
Theorem (318) [serial 1065] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.rma:
 RM_Alarm -> RM_Alarm 
Theorem (319) [serial 1066] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.pi:
 Pause_Infusion -> Pause_Infusion 
Theorem (320) [serial 1067] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.pie:
 Pause_Infusion_Echo -> Pause_Infusion_Echo 
Theorem (321) [serial 1068] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.icp:
 PO_Alarm_Echo -> PO_Alarm_Echo 
Theorem (322) [serial 1069] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.icr:
 RM_Alarm_Echo -> RM_Alarm_Echo 
Theorem (323) [serial 1070] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poa1:
 PO_Alarm -> poa 
Theorem (324) [serial 1071] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poa2:
 PO_Alarm -> PO_Alarm 
Theorem (325) [serial 1072] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rma1:
 RM_Alarm -> rma 
Theorem (326) [serial 1073] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rma2:
 RM_Alarm -> RM_Alarm 
Theorem (327) [serial 1074] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pie1:
 Pause_Infusion_Echo -> pie 
Theorem (328) [serial 1075] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pie2:
 Pause_Infusion_Echo -> Pause_Infusion_Echo 
Theorem (329) [serial 1076] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pi1:
 Pause_Infusion -> pi 
Theorem (330) [serial 1077] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pi2:
 Pause_Infusion -> Pause_Infusion 
Theorem (331) [serial 1078] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rme1:
 RM_Alarm_Echo -> rmae 
Theorem (332) [serial 1079] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rme2:
 RM_Alarm_Echo -> RM_Alarm_Echo 
Theorem (333) [serial 1080] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poe1:
 PO_Alarm_Echo -> poae 
Theorem (334) [serial 1081] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poe2:
 PO_Alarm_Echo -> PO_Alarm_Echo 


closing proof file "/Users/ehsanahmad/OSATE2_User/osate2130vf/osate2.app/Contents/MacOS/proof.txt" 