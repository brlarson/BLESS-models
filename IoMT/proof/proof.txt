This file, proof.txt, was produced the BLESS Proof Assistant v3.2.4
  at Mon Apr 15 14:09:43 CDT 2024 by brianlarson

Theorem (1)                               [serial 1079] 
P [275] << MHR_A()
  and POA_A()
  and PSPO2_A() >>
S [260] ->
Q [260] << MHR_A()
  and POA_A()
  and PSPO2_A() >>
Why created:    normalization of [serial 1077]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (2)                               [serial 1077] 
P [275] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
S [260] ->
Q [260] << MHR_A()
  and PSPO2_A()
  and POA_A() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1003]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 1:
Theorem (1) [serial 1079] used for:
    normalization of [serial 1077] 


Theorem (3)                               [serial 1003] 
P [275] << INV_PO() >>
S [260] ->
Q [260] << MHR_A()
  and PSPO2_A()
  and POA_A() >>
Why created:  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 2:
Theorem (2) [serial 1077] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1003] 


Theorem (4)                               [serial 1082] 
P [274] << MHR_A()
  and POA_A()
  and PSPO2_A() >>
S [260] ->
Q [260] << MHR_A()
  and POA_A()
  and PSPO2_A() >>
Why created:    normalization of [serial 1080]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (5)                               [serial 1080] 
P [274] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
S [260] ->
Q [260] << MHR_A()
  and PSPO2_A()
  and POA_A() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1004]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 4:
Theorem (4) [serial 1082] used for:
    normalization of [serial 1080] 


Theorem (6)                               [serial 1004] 
P [274] << INV_PO() >>
S [260] ->
Q [260] << MHR_A()
  and PSPO2_A()
  and POA_A() >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 5:
Theorem (5) [serial 1080] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1004] 


Theorem (7)                               [serial 1005] 
P [273] << INV_PO() >>
S [273] ->
Q [273] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by: Anything Implies True (a1tru): P->true

Theorem (8)                               [serial 1006] 
P [273] << INV_PO() >>
S [278] ->
Q [274] << INV_PO() >>
Why created:   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{};
Solved by: Identity (id):  P->P is tautology

Theorem (9)                               [serial 1083] 
P [274] << INV_PO() >>
S [274] ->
Q [282] << INV_PO() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1007]
Solved by: Identity (id):  P->P is tautology

Theorem (10)                               [serial 1084] 
P [307] << INV_PO() >>
S [275] ->
Q [275] << INV_PO() >>
Why created:  <<Q3>> -> <<Q>> in sequential composition for [serial 1007]
Solved by: Identity (id):  P->P is tautology

Theorem (11)                               [serial 1155] 
P [283] << HEART_RATE = hrr
  and INV_PO() >>
S [283] ->
Q [284] << HEART_RATE = hrr
  and INV_PO() >>
Why created:    normalization of [serial 1153]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (12)                               [serial 1153] 
P [283] << ( INV_PO() )
  and hrr = HEART_RATE >>
S [283] ->
Q [284] << HEART_RATE = hrr
  and INV_PO() >>
Why created:  applied port input of value <<pre and hrr=M(Heart_Rate)>> -> <<post>> [serial 1108]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 11:
Theorem (11) [serial 1155] used for:
    normalization of [serial 1153] 


Theorem (13)                               [serial 1108] 
P [282] << INV_PO() >>
S [283] Heart_Rate?(hrr)
Q [284] << HEART_RATE = hrr
  and INV_PO() >>
Why created:    normalization of [serial 1085]
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 12:
Theorem (12) [serial 1153] used for:
  applied port input of value <<pre and hrr=M(Heart_Rate)>> -> <<post>> [serial 1108] 


Theorem (14)                               [serial 1085] 
P [282] << INV_PO() >>
S [283] Heart_Rate?(hrr)
Q [284] << hrr = HEART_RATE
  and INV_PO() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1007]
Solved by: Equality Commutes. (eqcom) and theorem 13:
Theorem (13) [serial 1108] used for:
    normalization of [serial 1085] 


Theorem (15)                               [serial 1158] 
P [285] << ( HEART_RATE = hrr
  and INV_PO() )
  and SPO2 = sp >>
S [285] ->
Q [286] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1156]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (16)                               [serial 1156] 
P [285] << ( HEART_RATE = hrr
  and INV_PO() )
  and sp = SPO2 >>
S [285] ->
Q [286] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:  applied port input of value <<pre and sp=M(Spo2_Level)>> -> <<post>> [serial 1110]
Solved by: Equality Commutes. (eqcom) and theorem 15:
Theorem (15) [serial 1158] used for:
    normalization of [serial 1156] 


Theorem (17)                               [serial 1110] 
P [284] << HEART_RATE = hrr
  and INV_PO() >>
S [285] Spo2_Level?(sp)
Q [286] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1086]
  Using: (eqcom) (bl.ancom) 
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 16:
Theorem (16) [serial 1156] used for:
  applied port input of value <<pre and sp=M(Spo2_Level)>> -> <<post>> [serial 1110] 


Theorem (18)                               [serial 1086] 
P [284] << hrr = HEART_RATE
  and INV_PO() >>
S [285] Spo2_Level?(sp)
Q [286] << hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1007]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 17:
Theorem (17) [serial 1110] used for:
    normalization of [serial 1086] 


Theorem (19)                               [serial 1163] 
P [286] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [288] ->
Q [288] << ( not ( hrr < mhr ) or hrr < mhr or sp < psp )
  and ( not ( sp < psp ) or hrr < mhr or sp < psp ) >>
Why created:  Distributing Postcondition Or-Over-And [serial 1162]
Solved by: Law of Excluded middle. (exmid)

Theorem (20)                               [serial 1162] 
P [286] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [288] ->
Q [288] << ( not ( hrr < mhr )
  and not ( sp < psp ) ) or hrr < mhr or sp < psp >>
Why created:    normalization of [serial 1160]
Solved by: Distribution and-over-or with wff lists. (bl.dba2owl) and theorem 19:
Theorem (19) [serial 1163] used for:
  Distributing Postcondition Or-Over-And [serial 1162] 


Theorem (21)                               [serial 1160] 
P [286] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [288] ->
Q [288] << ( ( not ( hrr < mhr ) )
  and ( not ( sp < psp ) ) ) or hrr < mhr or sp < psp >>
Why created:  Replacing <= with not < of [serial 1112]
Solved by: [Add unnecessary parentheses] and theorem 20:
Theorem (20) [serial 1162] used for:
    normalization of [serial 1160] 


Theorem (22)                               [serial 1112] 
P [286] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [288] ->
Q [288] << ( mhr <= hrr
  and psp <= sp ) or hrr < mhr or sp < psp >>
Why created:    normalization of [serial 1088]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) (bl.orcom) 
Solved by: 'Less than' expressed in terms of 'less than or equal to'. (ltnle) and theorem 21:
Theorem (21) [serial 1160] used for:
  Replacing <= with not < of [serial 1112] 


Theorem (23)                               [serial 1088] 
P [286] << hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 >>
S [288] ->
Q [288] << ( hrr >= mhr
  and sp >= psp ) or ( hrr < mhr ) or ( sp < psp ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1087]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 22:
Theorem (22) [serial 1112] used for:
    normalization of [serial 1088] 


Theorem (24)                               [serial 1114] 
P [288] << ( mhr <= hrr
  and psp <= sp )
  and ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() ) >>
S [290] ->
Q [290] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1095]
  Using: (eqcom) changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (25)                               [serial 1095] 
P [288] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr >= mhr
  and sp >= psp ) >>
S [290] ->
Q [290] << hrr = HEART_RATE
  and hrr >= mhr
  and sp = SPO2
  and sp >= psp
  and INV_PO() >>
Why created:  P -> P1 in concurrent composition for [serial 1092]
Solved by: Equality Commutes. (eqcom) [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 24:
Theorem (24) [serial 1114] used for:
    normalization of [serial 1095] 


Theorem (26)                               [serial 1096] 
P [292] << INV_PO() >>
S [292] ->
Q [307] << INV_PO() >>
Why created:  Qk -> Q in concurrent composition for [serial 1092]
Solved by: Identity (id):  P->P is tautology

Theorem (27)                               [serial 1172] 
P [290] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [291] ->
Q [307] << ( LOW_SPO2_HR() iff false )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:  applied wp for assignment [serial 1171]
Solved by: The negation of a proposition is equivalent to itself being equivalent to false. (nbfal)

Theorem (28)                               [serial 1171] 
P [290] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [291] poa := false
Q [307] << ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:    normalization of [serial 1169]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 27:
Theorem (27) [serial 1172] used for:
  applied wp for assignment [serial 1171] 


Theorem (29)                               [serial 1169] 
P [290] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [291] poa := false
Q [307] << ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1168]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 28:
Theorem (28) [serial 1171] used for:
    normalization of [serial 1169] 


Theorem (30)                               [serial 1168] 
P [290] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [291] poa := false
Q [307] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1116]
Solved by: Predicate Invocation. (PI) and theorem 29:
Theorem (29) [serial 1169] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1168] 


Theorem (31)                               [serial 1116] 
P [290] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [291] poa := false
Q [307] << INV_PO() >>
Why created:    normalization of [serial 1097]
  Using: (eqcom) changeAtLeastToAtMost (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 30:
Theorem (30) [serial 1168] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1116] 


Theorem (32)                               [serial 1097] 
P [290] << hrr = HEART_RATE
  and hrr >= mhr
  and sp = SPO2
  and sp >= psp
  and INV_PO() >>
S [291] poa := false
Q [307] << INV_PO() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1092]
Solved by: Equality Commutes. (eqcom) [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 31:
Theorem (31) [serial 1116] used for:
    normalization of [serial 1097] 


Theorem (33)                               [serial 1118] 
P [288] << ( mhr <= hrr
  and psp <= sp )
  and ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() ) >>
S [291] PO_Alarm!(false)
Q [292] << INV_PO() >>
Why created:    normalization of [serial 1098]
  Using: (eqcom) changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (34)                               [serial 1098] 
P [288] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr >= mhr
  and sp >= psp ) >>
S [291] PO_Alarm!(false)
Q [292] << INV_PO() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1092]
Solved by: Equality Commutes. (eqcom) [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 33:
Theorem (33) [serial 1118] used for:
    normalization of [serial 1098] 


Theorem (35)                               [serial 1092] 
P [288] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr >= mhr
  and sp >= psp ) >>
S [290]   << hrr = HEART_RATE
    and hrr >= mhr
    and sp = SPO2
    and sp >= psp
    and INV_PO() >>
  poa := false
  &
  PO_Alarm!(false)
  << INV_PO() >> 
Q [307] << INV_PO() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1089]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 25 26 32 34:
Theorem (25) [serial 1095] used for:
  P -> P1 in concurrent composition for [serial 1092] 
Theorem (26) [serial 1096] used for:
  Qk -> Q in concurrent composition for [serial 1092] 
Theorem (32) [serial 1097] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1092] 
Theorem (34) [serial 1098] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1092] 


Theorem (36)                               [serial 1089] 
P [288] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr >= mhr
  and sp >= psp ) >>
S [289]   {
    << hrr = HEART_RATE
      and hrr >= mhr
      and sp = SPO2
      and sp >= psp
      and INV_PO() >>
    poa := false
    &
    PO_Alarm!(false)
    << INV_PO() >> 
  } 
Q [307] << INV_PO() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1087]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 35:
Theorem (35) [serial 1092] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1089] 


Theorem (37)                               [serial 1120] 
P [288] << ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() )
  and hrr < mhr >>
S [296] ->
Q [296] << hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1099]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (38)                               [serial 1099] 
P [288] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr < mhr ) >>
S [296] ->
Q [296] << hrr = HEART_RATE
  and hrr < mhr
  and sp = SPO2
  and INV_PO() >>
Why created:  P -> P1 in concurrent composition for [serial 1093]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 37:
Theorem (37) [serial 1120] used for:
    normalization of [serial 1099] 


Theorem (39)                               [serial 1100] 
P [298] << INV_PO() >>
S [298] ->
Q [307] << INV_PO() >>
Why created:  Qk -> Q in concurrent composition for [serial 1093]
Solved by: Identity (id):  P->P is tautology

Theorem (40)                               [serial 1233] 
P [296] << ( ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp )
  and hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp >>
S [297] poa := true
Q [307] << ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:    normalization of [serial 1231]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (41)                               [serial 1231] 
P [296] << hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp
  and ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
S [297] poa := true
Q [307] << ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1230]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 40:
Theorem (40) [serial 1233] used for:
    normalization of [serial 1231] 


Theorem (42)                               [serial 1230] 
P [296] << hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp
  and ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
S [297] poa := true
Q [307] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1122]
Solved by: Predicate Invocation. (PI) and theorem 41:
Theorem (41) [serial 1231] used for:
  Substituted assertions' predicates for labels  [serial 1230] 


Theorem (43)                               [serial 1122] 
P [296] << hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [297] poa := true
Q [307] << INV_PO() >>
Why created:    normalization of [serial 1101]
  Using: (eqcom) (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 42:
Theorem (42) [serial 1230] used for:
  Substituted assertions' predicates for labels  [serial 1122] 


Theorem (44)                               [serial 1101] 
P [296] << hrr = HEART_RATE
  and hrr < mhr
  and sp = SPO2
  and INV_PO() >>
S [297] poa := true
Q [307] << INV_PO() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1093]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 43:
Theorem (43) [serial 1122] used for:
    normalization of [serial 1101] 


Theorem (45)                               [serial 1124] 
P [288] << ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() )
  and hrr < mhr >>
S [297] PO_Alarm!(true)
Q [298] << INV_PO() >>
Why created:    normalization of [serial 1102]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (46)                               [serial 1102] 
P [288] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr < mhr ) >>
S [297] PO_Alarm!(true)
Q [298] << INV_PO() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1093]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 45:
Theorem (45) [serial 1124] used for:
    normalization of [serial 1102] 


Theorem (47)                               [serial 1093] 
P [288] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr < mhr ) >>
S [296]   << hrr = HEART_RATE
    and hrr < mhr
    and sp = SPO2
    and INV_PO() >>
  poa := true
  &
  PO_Alarm!(true)
  << INV_PO() >> 
Q [307] << INV_PO() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1090]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 38 39 44 46:
Theorem (38) [serial 1099] used for:
  P -> P1 in concurrent composition for [serial 1093] 
Theorem (39) [serial 1100] used for:
  Qk -> Q in concurrent composition for [serial 1093] 
Theorem (44) [serial 1101] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1093] 
Theorem (46) [serial 1102] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1093] 


Theorem (48)                               [serial 1090] 
P [288] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr < mhr ) >>
S [295]   {
    << hrr = HEART_RATE
      and hrr < mhr
      and sp = SPO2
      and INV_PO() >>
    poa := true
    &
    PO_Alarm!(true)
    << INV_PO() >> 
  } 
Q [307] << INV_PO() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1087]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 47:
Theorem (47) [serial 1093] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1090] 


Theorem (49)                               [serial 1126] 
P [288] << ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() )
  and sp < psp >>
S [302] ->
Q [302] << sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1103]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (50)                               [serial 1103] 
P [288] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( sp < psp ) >>
S [302] ->
Q [302] << hrr = HEART_RATE
  and sp < psp
  and sp = SPO2
  and INV_PO() >>
Why created:  P -> P1 in concurrent composition for [serial 1094]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 49:
Theorem (49) [serial 1126] used for:
    normalization of [serial 1103] 


Theorem (51)                               [serial 1104] 
P [304] << INV_PO() >>
S [304] ->
Q [307] << INV_PO() >>
Why created:  Qk -> Q in concurrent composition for [serial 1094]
Solved by: Identity (id):  P->P is tautology

Theorem (52)                               [serial 1253] 
P [302] << ( ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp )
  and sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp >>
S [303] ->
Q [307] << ( LOW_SPO2_HR() iff true )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:  applied wp for assignment [serial 1252]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (53)                               [serial 1252] 
P [302] << ( ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp )
  and sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp >>
S [303] poa := true
Q [307] << ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:    normalization of [serial 1250]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 52:
Theorem (52) [serial 1253] used for:
  applied wp for assignment [serial 1252] 


Theorem (54)                               [serial 1250] 
P [302] << sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp
  and ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
S [303] poa := true
Q [307] << ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1249]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 53:
Theorem (53) [serial 1252] used for:
    normalization of [serial 1250] 


Theorem (55)                               [serial 1249] 
P [302] << sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp
  and ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
S [303] poa := true
Q [307] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1128]
Solved by: Predicate Invocation. (PI) and theorem 54:
Theorem (54) [serial 1250] used for:
  Substituted assertions' predicates for labels  [serial 1249] 


Theorem (56)                               [serial 1128] 
P [302] << sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [303] poa := true
Q [307] << INV_PO() >>
Why created:    normalization of [serial 1105]
  Using: (eqcom) (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 55:
Theorem (55) [serial 1249] used for:
  Substituted assertions' predicates for labels  [serial 1128] 


Theorem (57)                               [serial 1105] 
P [302] << hrr = HEART_RATE
  and sp < psp
  and sp = SPO2
  and INV_PO() >>
S [303] poa := true
Q [307] << INV_PO() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1094]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 56:
Theorem (56) [serial 1128] used for:
    normalization of [serial 1105] 


Theorem (58)                               [serial 1130] 
P [288] << ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() )
  and sp < psp >>
S [303] PO_Alarm!(true)
Q [304] << INV_PO() >>
Why created:    normalization of [serial 1106]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (59)                               [serial 1106] 
P [288] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( sp < psp ) >>
S [303] PO_Alarm!(true)
Q [304] << INV_PO() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1094]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 58:
Theorem (58) [serial 1130] used for:
    normalization of [serial 1106] 


Theorem (60)                               [serial 1094] 
P [288] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( sp < psp ) >>
S [302]   << hrr = HEART_RATE
    and sp < psp
    and sp = SPO2
    and INV_PO() >>
  poa := true
  &
  PO_Alarm!(true)
  << INV_PO() >> 
Q [307] << INV_PO() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1091]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 50 51 57 59:
Theorem (50) [serial 1103] used for:
  P -> P1 in concurrent composition for [serial 1094] 
Theorem (51) [serial 1104] used for:
  Qk -> Q in concurrent composition for [serial 1094] 
Theorem (57) [serial 1105] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1094] 
Theorem (59) [serial 1106] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1094] 


Theorem (61)                               [serial 1091] 
P [288] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( sp < psp ) >>
S [301]   {
    << hrr = HEART_RATE
      and sp < psp
      and sp = SPO2
      and INV_PO() >>
    poa := true
    &
    PO_Alarm!(true)
    << INV_PO() >> 
  } 
Q [307] << INV_PO() >>
Why created:    <<P and B2>> S2 <<Q>> in alternative for [serial 1087]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 60:
Theorem (60) [serial 1094] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1091] 


Theorem (62)                               [serial 1087] 
P [286] << hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 >>
S [288]   if 
    (hrr >= mhr
    and sp >= psp)~> 
        {
          << hrr = HEART_RATE
            and hrr >= mhr
            and sp = SPO2
            and sp >= psp
            and INV_PO() >>
          poa := false
          &
          PO_Alarm!(false)
          << INV_PO() >> 
        }  
  []
    (hrr < mhr)~> 
        {
          << hrr = HEART_RATE
            and hrr < mhr
            and sp = SPO2
            and INV_PO() >>
          poa := true
          &
          PO_Alarm!(true)
          << INV_PO() >> 
        }  
  []
    (sp < psp)~> 
        {
          << hrr = HEART_RATE
            and sp < psp
            and sp = SPO2
            and INV_PO() >>
          poa := true
          &
          PO_Alarm!(true)
          << INV_PO() >> 
        }  
  fi
Q [307] << INV_PO() >>
Why created:  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1007]
Solved by: and theorems 23 36 48 61:
Theorem (23) [serial 1088] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1087] 
Theorem (36) [serial 1089] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1087] 
Theorem (48) [serial 1090] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1087] 
Theorem (61) [serial 1091] used for:
    <<P and B2>> S2 <<Q>> in alternative for [serial 1087] 


Theorem (63)                               [serial 1007] 
P [274] << INV_PO() >>
S [282]   << INV_PO() >>
  Heart_Rate?(hrr)
  ;
  << hrr = HEART_RATE
    and INV_PO() >>
  Spo2_Level?(sp)
  << hrr = HEART_RATE
    and INV_PO()
    and sp = SPO2 >>
  ;
    if 
      (hrr >= mhr
      and sp >= psp)~> 
          {
            << hrr = HEART_RATE
              and hrr >= mhr
              and sp = SPO2
              and sp >= psp
              and INV_PO() >>
            poa := false
            &
            PO_Alarm!(false)
            << INV_PO() >> 
          }  
    []
      (hrr < mhr)~> 
          {
            << hrr = HEART_RATE
              and hrr < mhr
              and sp = SPO2
              and INV_PO() >>
            poa := true
            &
            PO_Alarm!(true)
            << INV_PO() >> 
          }  
    []
      (sp < psp)~> 
          {
            << hrr = HEART_RATE
              and sp < psp
              and sp = SPO2
              and INV_PO() >>
            poa := true
            &
            PO_Alarm!(true)
            << INV_PO() >> 
          }  
    fi
  << INV_PO() >> 
Q [275] << INV_PO() >>
Why created:   <<M(run) and x>> A <<M(check_echo)>> for got_hrr_spo2: run-[x]->check_echo{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 9 10 14 18 62:
Theorem (9) [serial 1083] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1007] 
Theorem (10) [serial 1084] used for:
  <<Q3>> -> <<Q>> in sequential composition for [serial 1007] 
Theorem (14) [serial 1085] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1007] 
Theorem (18) [serial 1086] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1007] 
Theorem (62) [serial 1087] used for:
  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1007] 


Theorem (64)                               [serial 1348] 
P [311] << ( INV_PO() )
  and ( PO_Alarm_Echo@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [311] ->
Q [313] << INV_PO()
  and PO_Alarm_Echo@now >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1008]
Solved by: And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

Theorem (65)                               [serial 1349] 
P [323] << INV_PO() >>
S [274] ->
Q [274] << INV_PO() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1008]
Solved by: Identity (id):  P->P is tautology

Theorem (66)                               [serial 1351] 
P [313] << ( INV_PO()
  and PO_Alarm_Echo@now )
  and ( echo_val iff PO_Alarm_Echo@now ) >>
S [316] ->
Q [316] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
Why created:  <<P and v=e>> -> <<A>> in behavior action block for [serial 1350]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (67)                               [serial 1354] 
P [316] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
S [316] ->
Q [316] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1352]
Solved by: Identity (id):  P->P is tautology

Theorem (68)                               [serial 1355] 
P [321] << INV_PO() >>
S [321] ->
Q [321] << INV_PO() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1352]
Solved by: Identity (id):  P->P is tautology

Theorem (69)                               [serial 1365] 
P [316] << ( PO_Alarm_Echo iff echo_val )
  and INV_PO() >>
S [317] ->
Q [317] << ( echo_val iff poa ) or not ( echo_val iff poa ) >>
Why created:    normalization of [serial 1357]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (70)                               [serial 1357] 
P [316] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
S [317] ->
Q [317] << ( echo_val iff poa ) or ( not ( echo_val iff poa ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1356]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 69:
Theorem (69) [serial 1365] used for:
    normalization of [serial 1357] 


Theorem (71)                               [serial 1369] 
P [317] << ( ( PO_Alarm_Echo iff echo_val )
  and INV_PO() )
  and ( echo_val iff poa ) >>
S [317] ->
Q [321] << INV_PO() >>
Why created:    normalization of [serial 1367]
  Using: (bicom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (72)                               [serial 1367] 
P [317] << ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( echo_val iff poa ) >>
S [317] ->
Q [321] << INV_PO() >>
Why created:    <<P>> -> <<Q>>
  for [serial 1358]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 71:
Theorem (71) [serial 1369] used for:
    normalization of [serial 1367] 


Theorem (73)                               [serial 1358] 
P [317] << ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( echo_val iff poa ) >>
S [317] skip
Q [321] << INV_PO() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1356]
Solved by:  Skip Means Implication:  <<P>> skip <<Q>>  is  <<P>> -> <<Q>>
 and theorem 72:
Theorem (72) [serial 1367] used for:
    <<P>> -> <<Q>>
  for [serial 1358] 


Theorem (74)                               [serial 1377] 
P [317] << ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( not ( echo_val iff poa ) ) >>
S [319] ->
Q [319] << true >>
Why created:  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1359]
Solved by: Anything Implies True (a1tru): P->true

Theorem (75)                               [serial 1381] 
P [319] << ( ( ( PO_Alarm_Echo iff echo_val )
  and INV_PO() )
  and not ( echo_val iff poa ) )
  and true >>
S [319] ->
Q [321] << INV_PO() >>
Why created:    normalization of [serial 1379]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (76)                               [serial 1379] 
P [319] << ( ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( not ( echo_val iff poa ) ) )
  and true >>
S [319] ->
Q [321] << INV_PO() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1378]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 75:
Theorem (75) [serial 1381] used for:
    normalization of [serial 1379] 


Theorem (77)                               [serial 1378] 
P [319] << ( ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( not ( echo_val iff poa ) ) )
  and true@now >>
S [319] ->
Q [321] << INV_PO() >>
Why created:  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1359]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 76:
Theorem (76) [serial 1379] used for:
  Assume Present:  P = P@now = P^0   [serial 1378] 


Theorem (78)                               [serial 1359] 
P [317] << ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( not ( echo_val iff poa ) ) >>
S [319] Lost_Confirmation!
Q [321] << INV_PO() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1356]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 74 77:
Theorem (74) [serial 1377] used for:
  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1359] 
Theorem (77) [serial 1378] used for:
  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1359] 


Theorem (79)                               [serial 1356] 
P [316] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
S [317]   if 
    (echo_val iff poa)~> 
      skip 
  []
    (not ( echo_val iff poa ))~> 
      Lost_Confirmation! 
  fi
Q [321] << INV_PO() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1352]
Solved by: and theorems 70 73 78:
Theorem (70) [serial 1357] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1356] 
Theorem (73) [serial 1358] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1356] 
Theorem (78) [serial 1359] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1356] 


Theorem (80)                               [serial 1352] 
P [316] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
S [316] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
  if 
    (echo_val iff poa)~> 
      skip 
  []
    (not ( echo_val iff poa ))~> 
      Lost_Confirmation! 
  fi
<< INV_PO() >>
Q [321] << INV_PO() >>
Why created:  <<A>> S <<B>> in behavior action block for [serial 1350]
Solved by: null and theorems 67 68 79:
Theorem (67) [serial 1354] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1352] 
Theorem (68) [serial 1355] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1352] 
Theorem (79) [serial 1356] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1352] 


Theorem (81)                               [serial 1353] 
P [321] << INV_PO() >>
S [314] ->
Q [323] << INV_PO() >>
Why created:  <<B>> -> <<Q>> in behavior action block for [serial 1350]
Solved by: Identity (id):  P->P is tautology

Theorem (82)                               [serial 1350] 
P [313] << INV_PO()
  and PO_Alarm_Echo@now >>
S [314] declare 
   echo_val ~ boolean := PO_Alarm_Echo?   {
  << INV_PO()
    and ( echo_val iff PO_Alarm_Echo ) >>
    if 
      (echo_val iff poa)~> 
        skip 
    []
      (not ( echo_val iff poa ))~> 
        Lost_Confirmation! 
    fi
  << INV_PO() >>
  } 
Q [323] << INV_PO() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1008]
Solved by: Behavior Action Block (BAB): 
     <<P and x=e>> -> <<A>>
     <<A>> S <<B>> 
     <<B>> -> <<Q>>
----------------------------------------------------
<<P>> declare variable v~y:=e; { <<A>> S <<B>> } <<Q>> and theorems 66 80 81:
Theorem (66) [serial 1351] used for:
  <<P and v=e>> -> <<A>> in behavior action block for [serial 1350] 
Theorem (80) [serial 1352] used for:
  <<A>> S <<B>> in behavior action block for [serial 1350] 
Theorem (81) [serial 1353] used for:
  <<B>> -> <<Q>> in behavior action block for [serial 1350] 


Theorem (83)                               [serial 1008] 
P [311] << ( INV_PO() )
  and ( PO_Alarm_Echo@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [313] << INV_PO()
  and PO_Alarm_Echo@now >>
declare 
   echo_val ~ boolean := PO_Alarm_Echo?   {
  << INV_PO()
    and ( echo_val iff PO_Alarm_Echo ) >>
    if 
      (echo_val iff poa)~> 
        skip 
    []
      (not ( echo_val iff poa ))~> 
        Lost_Confirmation! 
    fi
  << INV_PO() >>
  } 
<< INV_PO() >>
Q [274] << INV_PO() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A};
Solved by: null and theorems 64 65 82:
Theorem (64) [serial 1348] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1008] 
Theorem (65) [serial 1349] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1008] 
Theorem (82) [serial 1350] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1008] 


Theorem (84)                               [serial 1391] 
P [326] << ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and INV_PO()
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [327] ->
Q [327] << true >>
Why created:    normalization of [serial 1387]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (85)                               [serial 1387] 
P [326] << ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [327] ->
Q [327] << true >>
Why created:  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1386]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 84:
Theorem (84) [serial 1391] used for:
    normalization of [serial 1387] 


Theorem (86)                               [serial 1393] 
P [327] << ( ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and INV_PO()
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) )
  and true >>
S [327] ->
Q [274] << INV_PO() >>
Why created:    normalization of [serial 1389]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (87)                               [serial 1389] 
P [327] << ( ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) )
  and true >>
S [327] ->
Q [274] << INV_PO() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1388]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 86:
Theorem (86) [serial 1393] used for:
    normalization of [serial 1389] 


Theorem (88)                               [serial 1388] 
P [327] << ( ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) )
  and true@now >>
S [327] ->
Q [274] << INV_PO() >>
Why created:  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1386]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 87:
Theorem (87) [serial 1389] used for:
  Assume Present:  P = P@now = P^0   [serial 1388] 


Theorem (89)                               [serial 1386] 
P [326] << ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [327] Lost_Confirmation!
Q [274] << INV_PO() >>
Why created:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1009]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 85 88:
Theorem (85) [serial 1387] used for:
  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1386] 
Theorem (88) [serial 1388] used for:
  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1386] 


Theorem (90)                               [serial 1009] 
P [326] << ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [327] Lost_Confirmation!
Q [274] << INV_PO() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A};
Solved by: null and theorem 89:
Theorem (89) [serial 1386] used for:
  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1009] 


Theorem (91)                               [serial 1002] 
P [254] <<   >>
S [260] ->
Q [254] << Pulse_Oximeter_Thread.impl proof obligations >>
Why created:  Initial proof obligations for Pulse_Oximeter_Thread.impl
Solved by:  Component verification conditions
 and theorems 3 6 7 8 63 83 90:
Theorem (3) [serial 1003] used for:
  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition. 
Theorem (6) [serial 1004] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (7) [serial 1005] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (8) [serial 1006] used for:
   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{}; 
Theorem (63) [serial 1007] used for:
   <<M(run) and x>> A <<M(check_echo)>> for got_hrr_spo2: run-[x]->check_echo{A}; 
Theorem (83) [serial 1008] used for:
   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A}; 
Theorem (90) [serial 1009] used for:
   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A}; 


Theorem (92)                               [serial 1011] 
P [438] << RA()
  and MRP_A() >>
S [428] ->
Q [428] << RA()
  and MRP_A() >>
Why created:  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition.
Solved by: Identity (id):  P->P is tautology

Theorem (93)                               [serial 1012] 
P [437] << RA()
  and MRP_A() >>
S [428] ->
Q [428] << RA()
  and MRP_A() >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by: Identity (id):  P->P is tautology

Theorem (94)                               [serial 1013] 
P [436] << RA()
  and MRP_A() >>
S [436] ->
Q [436] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by: Anything Implies True (a1tru): P->true

Theorem (95)                               [serial 1014] 
P [436] << RA()
  and MRP_A() >>
S [441] ->
Q [437] << RA()
  and MRP_A() >>
Why created:   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{};
Solved by: Identity (id):  P->P is tautology

Theorem (96)                               [serial 1438] 
P [445] << ( MRP_A()
  and RA() )
  and rpr = RESPIRATION_RATE >>
S [445] ->
Q [446] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
Why created:  applied port input of value <<pre and rpr=M(RP_Rate)>> -> <<post>> [serial 1415]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (97)                               [serial 1415] 
P [437] << MRP_A()
  and RA() >>
S [445] RP_Rate?(rpr)
Q [446] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1399]
  Using: (eqcom) (bl.ancom) 
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 96:
Theorem (96) [serial 1438] used for:
  applied port input of value <<pre and rpr=M(RP_Rate)>> -> <<post>> [serial 1415] 


Theorem (98)                               [serial 1399] 
P [437] << RA()
  and MRP_A() >>
S [445] RP_Rate?(rpr)
Q [446] << rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1015]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 97:
Theorem (97) [serial 1415] used for:
    normalization of [serial 1399] 


Theorem (99)                               [serial 1444] 
P [446] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [448] ->
Q [448] << rpr < mrp or not ( rpr < mrp ) >>
Why created:    normalization of [serial 1442]
  Using: ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (100)                               [serial 1442] 
P [446] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [448] ->
Q [448] << rpr < mrp or ( not ( rpr < mrp ) ) >>
Why created:  Replacing <= with not < of [serial 1417]
Solved by: [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 99:
Theorem (99) [serial 1444] used for:
    normalization of [serial 1442] 


Theorem (101)                               [serial 1417] 
P [446] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [448] ->
Q [448] << rpr < mrp or mrp <= rpr >>
Why created:    normalization of [serial 1401]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.orcom) 
Solved by: 'Less than' expressed in terms of 'less than or equal to'. (ltnle) and theorem 100:
Theorem (100) [serial 1442] used for:
  Replacing <= with not < of [serial 1417] 


Theorem (102)                               [serial 1401] 
P [446] << rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() >>
S [448] ->
Q [448] << ( rpr >= mrp ) or ( rpr < mrp ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1400]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Disjunction Commutes. (bl.orcom) and theorem 101:
Theorem (101) [serial 1417] used for:
    normalization of [serial 1401] 


Theorem (103)                               [serial 1419] 
P [448] << ( RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() )
  and mrp <= rpr >>
S [450] ->
Q [450] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1406]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (104)                               [serial 1406] 
P [448] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr >= mrp ) >>
S [450] ->
Q [450] << rpr = RESPIRATION_RATE
  and rpr >= mrp
  and MRP_A()
  and RA() >>
Why created:  P -> P1 in concurrent composition for [serial 1404]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 103:
Theorem (103) [serial 1419] used for:
    normalization of [serial 1406] 


Theorem (105)                               [serial 1421] 
P [452] << MRP_A()
  and RA() >>
S [452] ->
Q [438] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1407]
Solved by: Identity (id):  P->P is tautology

Theorem (106)                               [serial 1407] 
P [452] << RA()
  and MRP_A() >>
S [452] ->
Q [438] << RA()
  and MRP_A() >>
Why created:  Qk -> Q in concurrent composition for [serial 1404]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 105:
Theorem (105) [serial 1421] used for:
    normalization of [serial 1407] 


Theorem (107)                               [serial 1451] 
P [450] << ( LOW_RP() iff rma )
  and mrp <= rpr
  and MINIMUM_RESPIRATION_RATE = mrp
  and RESPIRATION_RATE = rpr >>
S [451] ->
Q [438] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE iff false )
  and MINIMUM_RESPIRATION_RATE = mrp >>
Why created:    normalization of [serial 1449]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: The negation of a proposition is equivalent to itself being equivalent to false. (nbfal)

Theorem (108)                               [serial 1449] 
P [450] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( rma iff LOW_RP() ) >>
S [451] ->
Q [438] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( false iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1448]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 107:
Theorem (107) [serial 1451] used for:
    normalization of [serial 1449] 


Theorem (109)                               [serial 1448] 
P [450] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [451] ->
Q [438] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( false iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) >>
Why created:  applied wp for assignment [serial 1447]
Solved by: Predicate Invocation. (PI) and theorem 108:
Theorem (108) [serial 1449] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1448] 


Theorem (110)                               [serial 1447] 
P [450] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [451] rma := false
Q [438] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( rma iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1446]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 109:
Theorem (109) [serial 1448] used for:
  applied wp for assignment [serial 1447] 


Theorem (111)                               [serial 1446] 
P [450] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [451] rma := false
Q [438] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( rma iff LOW_RP() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1423]
Solved by: Predicate Invocation. (PI) and theorem 110:
Theorem (110) [serial 1447] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1446] 


Theorem (112)                               [serial 1423] 
P [450] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [451] rma := false
Q [438] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1408]
  Using: (eqcom) changeAtLeastToAtMost (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 111:
Theorem (111) [serial 1446] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1423] 


Theorem (113)                               [serial 1408] 
P [450] << rpr = RESPIRATION_RATE
  and rpr >= mrp
  and MRP_A()
  and RA() >>
S [451] rma := false
Q [438] << RA()
  and MRP_A() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1404]
Solved by: Equality Commutes. (eqcom) [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 112:
Theorem (112) [serial 1423] used for:
    normalization of [serial 1408] 


Theorem (114)                               [serial 1425] 
P [448] << ( RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() )
  and mrp <= rpr >>
S [451] RM_Alarm!(false)
Q [452] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1409]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (115)                               [serial 1409] 
P [448] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr >= mrp ) >>
S [451] RM_Alarm!(false)
Q [452] << RA()
  and MRP_A() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1404]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 114:
Theorem (114) [serial 1425] used for:
    normalization of [serial 1409] 


Theorem (116)                               [serial 1404] 
P [448] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr >= mrp ) >>
S [450]   << rpr = RESPIRATION_RATE
    and rpr >= mrp
    and MRP_A()
    and RA() >>
  rma := false
  &
  RM_Alarm!(false)
  << RA()
    and MRP_A() >> 
Q [438] << RA()
  and MRP_A() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1402]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 104 106 113 115:
Theorem (104) [serial 1406] used for:
  P -> P1 in concurrent composition for [serial 1404] 
Theorem (106) [serial 1407] used for:
  Qk -> Q in concurrent composition for [serial 1404] 
Theorem (113) [serial 1408] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1404] 
Theorem (115) [serial 1409] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1404] 


Theorem (117)                               [serial 1402] 
P [448] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr >= mrp ) >>
S [449]   {
    << rpr = RESPIRATION_RATE
      and rpr >= mrp
      and MRP_A()
      and RA() >>
    rma := false
    &
    RM_Alarm!(false)
    << RA()
      and MRP_A() >> 
  } 
Q [438] << RA()
  and MRP_A() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1400]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 116:
Theorem (116) [serial 1404] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1402] 


Theorem (118)                               [serial 1427] 
P [448] << ( RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() )
  and rpr < mrp >>
S [457] ->
Q [457] << rpr < mrp
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1410]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (119)                               [serial 1410] 
P [448] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr < mrp ) >>
S [457] ->
Q [457] << rpr = RESPIRATION_RATE
  and rpr < mrp
  and MRP_A()
  and RA() >>
Why created:  P -> P1 in concurrent composition for [serial 1405]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 118:
Theorem (118) [serial 1427] used for:
    normalization of [serial 1410] 


Theorem (120)                               [serial 1429] 
P [459] << MRP_A()
  and RA() >>
S [459] ->
Q [438] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1411]
Solved by: Identity (id):  P->P is tautology

Theorem (121)                               [serial 1411] 
P [459] << RA()
  and MRP_A() >>
S [459] ->
Q [438] << RA()
  and MRP_A() >>
Why created:  Qk -> Q in concurrent composition for [serial 1405]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 120:
Theorem (120) [serial 1429] used for:
    normalization of [serial 1411] 


Theorem (122)                               [serial 1461] 
P [457] << rpr < mrp
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [458] ->
Q [438] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( true iff LOW_RP() ) >>
Why created:  applied wp for assignment [serial 1460]
Solved by: Superfluity of Equivalence. (bl.seq)

Theorem (123)                               [serial 1460] 
P [457] << rpr < mrp
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [458] rma := true
Q [438] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( rma iff LOW_RP() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1431]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 122:
Theorem (122) [serial 1461] used for:
  applied wp for assignment [serial 1460] 


Theorem (124)                               [serial 1431] 
P [457] << rpr < mrp
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [458] rma := true
Q [438] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1412]
  Using: (eqcom) (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 123:
Theorem (123) [serial 1460] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1431] 


Theorem (125)                               [serial 1412] 
P [457] << rpr = RESPIRATION_RATE
  and rpr < mrp
  and MRP_A()
  and RA() >>
S [458] rma := true
Q [438] << RA()
  and MRP_A() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1405]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 124:
Theorem (124) [serial 1431] used for:
    normalization of [serial 1412] 


Theorem (126)                               [serial 1433] 
P [448] << ( RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() )
  and rpr < mrp >>
S [458] RM_Alarm!(true)
Q [459] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1413]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (127)                               [serial 1413] 
P [448] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr < mrp ) >>
S [458] RM_Alarm!(true)
Q [459] << RA()
  and MRP_A() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1405]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 126:
Theorem (126) [serial 1433] used for:
    normalization of [serial 1413] 


Theorem (128)                               [serial 1405] 
P [448] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr < mrp ) >>
S [457]   << rpr = RESPIRATION_RATE
    and rpr < mrp
    and MRP_A()
    and RA() >>
  rma := true
  &
  RM_Alarm!(true)
  << RA()
    and MRP_A() >> 
Q [438] << RA()
  and MRP_A() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1403]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 119 121 125 127:
Theorem (119) [serial 1410] used for:
  P -> P1 in concurrent composition for [serial 1405] 
Theorem (121) [serial 1411] used for:
  Qk -> Q in concurrent composition for [serial 1405] 
Theorem (125) [serial 1412] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1405] 
Theorem (127) [serial 1413] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1405] 


Theorem (129)                               [serial 1403] 
P [448] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr < mrp ) >>
S [456]   {
    << rpr = RESPIRATION_RATE
      and rpr < mrp
      and MRP_A()
      and RA() >>
    rma := true
    &
    RM_Alarm!(true)
    << RA()
      and MRP_A() >> 
  } 
Q [438] << RA()
  and MRP_A() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1400]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 128:
Theorem (128) [serial 1405] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1403] 


Theorem (130)                               [serial 1400] 
P [446] << rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() >>
S [448]   if 
    (rpr >= mrp)~> 
        {
          << rpr = RESPIRATION_RATE
            and rpr >= mrp
            and MRP_A()
            and RA() >>
          rma := false
          &
          RM_Alarm!(false)
          << RA()
            and MRP_A() >> 
        }  
  []
    (rpr < mrp)~> 
        {
          << rpr = RESPIRATION_RATE
            and rpr < mrp
            and MRP_A()
            and RA() >>
          rma := true
          &
          RM_Alarm!(true)
          << RA()
            and MRP_A() >> 
        }  
  fi
Q [438] << RA()
  and MRP_A() >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1015]
Solved by: and theorems 102 117 129:
Theorem (102) [serial 1401] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1400] 
Theorem (117) [serial 1402] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1400] 
Theorem (129) [serial 1403] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1400] 


Theorem (131)                               [serial 1015] 
P [437] << RA()
  and MRP_A() >>
S [445]   RP_Rate?(rpr)
  << rpr = RESPIRATION_RATE
    and MRP_A()
    and RA() >>
  ;
    if 
      (rpr >= mrp)~> 
          {
            << rpr = RESPIRATION_RATE
              and rpr >= mrp
              and MRP_A()
              and RA() >>
            rma := false
            &
            RM_Alarm!(false)
            << RA()
              and MRP_A() >> 
          }  
    []
      (rpr < mrp)~> 
          {
            << rpr = RESPIRATION_RATE
              and rpr < mrp
              and MRP_A()
              and RA() >>
            rma := true
            &
            RM_Alarm!(true)
            << RA()
              and MRP_A() >> 
          }  
    fi 
Q [438] << RA()
  and MRP_A() >>
Why created:   <<M(run) and x>> A <<M(check_echo)>> for got_rp: run-[x]->check_echo{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 98 130:
Theorem (98) [serial 1399] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1015] 
Theorem (130) [serial 1400] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1015] 


Theorem (132)                               [serial 1505] 
P [464] << ( MRP_A()
  and RA() )
  and RM_Alarm_Echo@now
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [464] ->
Q [466] << RM_Alarm_Echo@now
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1492]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (133)                               [serial 1492] 
P [464] << ( RA()
  and MRP_A() )
  and ( RM_Alarm_Echo@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [464] ->
Q [466] << RA()
  and MRP_A()
  and RM_Alarm_Echo@now >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1016]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 132:
Theorem (132) [serial 1505] used for:
    normalization of [serial 1492] 


Theorem (134)                               [serial 1507] 
P [475] << MRP_A()
  and RA() >>
S [437] ->
Q [437] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1493]
Solved by: Identity (id):  P->P is tautology

Theorem (135)                               [serial 1493] 
P [475] << RA()
  and MRP_A() >>
S [437] ->
Q [437] << RA()
  and MRP_A() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1016]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 134:
Theorem (134) [serial 1507] used for:
    normalization of [serial 1493] 


Theorem (136)                               [serial 1509] 
P [466] << ( RM_Alarm_Echo@now
  and MRP_A()
  and RA() )
  and ( RM_Alarm_Echo@now iff echo_val ) >>
S [468] ->
Q [468] << ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1495]
  Using: (bl.ancom) (bicom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (137)                               [serial 1495] 
P [466] << ( RA()
  and MRP_A()
  and RM_Alarm_Echo@now )
  and ( echo_val iff RM_Alarm_Echo@now ) >>
S [468] ->
Q [468] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
Why created:  <<P and v=e>> -> <<A>> in behavior action block for [serial 1494]
Solved by: Conjunction Commutes. (bl.ancom) Biconditional (iff) Commutes. (bicom) and theorem 136:
Theorem (136) [serial 1509] used for:
    normalization of [serial 1495] 


Theorem (138)                               [serial 1511] 
P [468] << ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() >>
S [468] ->
Q [468] << ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1498]
  Using: (bicom) (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (139)                               [serial 1498] 
P [468] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
S [468] ->
Q [468] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1496]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 138:
Theorem (138) [serial 1511] used for:
    normalization of [serial 1498] 


Theorem (140)                               [serial 1513] 
P [473] << MRP_A()
  and RA() >>
S [473] ->
Q [473] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1499]
Solved by: Identity (id):  P->P is tautology

Theorem (141)                               [serial 1499] 
P [473] << RA()
  and MRP_A() >>
S [473] ->
Q [473] << RA()
  and MRP_A() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1496]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 140:
Theorem (140) [serial 1513] used for:
    normalization of [serial 1499] 


Theorem (142)                               [serial 1515] 
P [468] << ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() >>
S [469] ->
Q [469] << ( echo_val iff rma ) or not ( echo_val iff rma ) >>
Why created:    normalization of [serial 1501]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (143)                               [serial 1501] 
P [468] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
S [469] ->
Q [469] << ( echo_val iff rma ) or ( not ( echo_val iff rma ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1500]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 142:
Theorem (142) [serial 1515] used for:
    normalization of [serial 1501] 


Theorem (144)                               [serial 1517] 
P [469] << ( ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() )
  and ( echo_val iff rma ) >>
S [469] skip
Q [473] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1502]
  Using: (bicom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (145)                               [serial 1502] 
P [469] << ( RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) )
  and ( echo_val iff rma ) >>
S [469] skip
Q [473] << RA()
  and MRP_A() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1500]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 144:
Theorem (144) [serial 1517] used for:
    normalization of [serial 1502] 


Theorem (146)                               [serial 1519] 
P [469] << ( ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() )
  and not ( echo_val iff rma ) >>
S [471] Lost_Confirmation!
Q [473] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1503]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (147)                               [serial 1503] 
P [469] << ( RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) )
  and ( not ( echo_val iff rma ) ) >>
S [471] Lost_Confirmation!
Q [473] << RA()
  and MRP_A() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1500]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 146:
Theorem (146) [serial 1519] used for:
    normalization of [serial 1503] 


Theorem (148)                               [serial 1500] 
P [468] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
S [469]   if 
    (echo_val iff rma)~> 
      skip 
  []
    (not ( echo_val iff rma ))~> 
      Lost_Confirmation! 
  fi
Q [473] << RA()
  and MRP_A() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1496]
Solved by: and theorems 143 145 147:
Theorem (143) [serial 1501] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1500] 
Theorem (145) [serial 1502] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1500] 
Theorem (147) [serial 1503] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1500] 


Theorem (149)                               [serial 1496] 
P [468] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
S [468] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
  if 
    (echo_val iff rma)~> 
      skip 
  []
    (not ( echo_val iff rma ))~> 
      Lost_Confirmation! 
  fi
<< RA()
  and MRP_A() >>
Q [473] << RA()
  and MRP_A() >>
Why created:  <<A>> S <<B>> in behavior action block for [serial 1494]
Solved by: null and theorems 139 141 148:
Theorem (139) [serial 1498] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1496] 
Theorem (141) [serial 1499] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1496] 
Theorem (148) [serial 1500] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1496] 


Theorem (150)                               [serial 1521] 
P [473] << MRP_A()
  and RA() >>
S [467] ->
Q [475] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1497]
Solved by: Identity (id):  P->P is tautology

Theorem (151)                               [serial 1497] 
P [473] << RA()
  and MRP_A() >>
S [467] ->
Q [475] << RA()
  and MRP_A() >>
Why created:  <<B>> -> <<Q>> in behavior action block for [serial 1494]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 150:
Theorem (150) [serial 1521] used for:
    normalization of [serial 1497] 


Theorem (152)                               [serial 1494] 
P [466] << RA()
  and MRP_A()
  and RM_Alarm_Echo@now >>
S [467] declare 
   echo_val ~ boolean := RM_Alarm_Echo?   {
  << RA()
    and MRP_A()
    and ( echo_val iff RM_Alarm_Echo ) >>
    if 
      (echo_val iff rma)~> 
        skip 
    []
      (not ( echo_val iff rma ))~> 
        Lost_Confirmation! 
    fi
  << RA()
    and MRP_A() >>
  } 
Q [475] << RA()
  and MRP_A() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1016]
Solved by: Behavior Action Block (BAB): 
     <<P and x=e>> -> <<A>>
     <<A>> S <<B>> 
     <<B>> -> <<Q>>
----------------------------------------------------
<<P>> declare variable v~y:=e; { <<A>> S <<B>> } <<Q>> and theorems 137 149 151:
Theorem (137) [serial 1495] used for:
  <<P and v=e>> -> <<A>> in behavior action block for [serial 1494] 
Theorem (149) [serial 1496] used for:
  <<A>> S <<B>> in behavior action block for [serial 1494] 
Theorem (151) [serial 1497] used for:
  <<B>> -> <<Q>> in behavior action block for [serial 1494] 


Theorem (153)                               [serial 1016] 
P [464] << ( RA()
  and MRP_A() )
  and ( RM_Alarm_Echo@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [466] << RA()
  and MRP_A()
  and RM_Alarm_Echo@now >>
declare 
   echo_val ~ boolean := RM_Alarm_Echo?   {
  << RA()
    and MRP_A()
    and ( echo_val iff RM_Alarm_Echo ) >>
    if 
      (echo_val iff rma)~> 
        skip 
    []
      (not ( echo_val iff rma ))~> 
        Lost_Confirmation! 
    fi
  << RA()
    and MRP_A() >>
  } 
<< RA()
  and MRP_A() >>
Q [437] << RA()
  and MRP_A() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A};
Solved by: null and theorems 133 135 152:
Theorem (133) [serial 1492] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1016] 
Theorem (135) [serial 1493] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1016] 
Theorem (152) [serial 1494] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1016] 


Theorem (154)                               [serial 1552] 
P [478] << ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and ( MRP_A()
  and RA() )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [479] ->
Q [479] << true >>
Why created:    normalization of [serial 1548]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (155)                               [serial 1548] 
P [478] << ( RA()
  and MRP_A() )
  and ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [479] ->
Q [479] << true >>
Why created:  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1017]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 154:
Theorem (154) [serial 1552] used for:
    normalization of [serial 1548] 


Theorem (156)                               [serial 1554] 
P [479] << ( ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and ( MRP_A()
  and RA() )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) )
  and true >>
S [479] ->
Q [437] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1550]
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (157)                               [serial 1550] 
P [479] << ( ( RA()
  and MRP_A() )
  and ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) )
  and true >>
S [479] ->
Q [437] << RA()
  and MRP_A() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1549]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  Conjunction Commutes. (bl.ancom) and theorem 156:
Theorem (156) [serial 1554] used for:
    normalization of [serial 1550] 


Theorem (158)                               [serial 1549] 
P [479] << ( ( RA()
  and MRP_A() )
  and ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) )
  and true@now >>
S [479] ->
Q [437] << RA()
  and MRP_A() >>
Why created:  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1017]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 157:
Theorem (157) [serial 1550] used for:
  Assume Present:  P = P@now = P^0   [serial 1549] 


Theorem (159)                               [serial 1017] 
P [478] << ( RA()
  and MRP_A() )
  and ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [479] Lost_Confirmation!
Q [437] << RA()
  and MRP_A() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A};
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 155 158:
Theorem (155) [serial 1548] used for:
  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1017] 
Theorem (158) [serial 1549] used for:
  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1017] 


Theorem (160)                               [serial 1010] 
P [425] <<   >>
S [428] ->
Q [425] << Respiration_Monitor_Thread.impl proof obligations >>
Why created:  Initial proof obligations for Respiration_Monitor_Thread.impl
Solved by:  Component verification conditions
 and theorems 92 93 94 95 131 153 159:
Theorem (92) [serial 1011] used for:
  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition. 
Theorem (93) [serial 1012] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (94) [serial 1013] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (95) [serial 1014] used for:
   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{}; 
Theorem (131) [serial 1015] used for:
   <<M(run) and x>> A <<M(check_echo)>> for got_rp: run-[x]->check_echo{A}; 
Theorem (153) [serial 1016] used for:
   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A}; 
Theorem (159) [serial 1017] used for:
   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A}; 


Theorem (161)                               [serial 1562] 
P [637] << INV()
  and PI()
  and POA()
  and RMA() >>
S [620] ->
Q [620] << INV()
  and PI()
  and POA()
  and RMA() >>
Why created:    normalization of [serial 1560]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (162)                               [serial 1560] 
P [637] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
S [620] ->
Q [620] << INV()
  and POA()
  and RMA()
  and PI() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1019]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 161:
Theorem (161) [serial 1562] used for:
    normalization of [serial 1560] 


Theorem (163)                               [serial 1019] 
P [637] << INV_E() >>
S [620] ->
Q [620] << INV()
  and POA()
  and RMA()
  and PI() >>
Why created:  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 162:
Theorem (162) [serial 1560] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1019] 


Theorem (164)                               [serial 1565] 
P [635] << INV()
  and PI()
  and POA()
  and RMA() >>
S [620] ->
Q [620] << INV()
  and PI()
  and POA()
  and RMA() >>
Why created:    normalization of [serial 1563]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (165)                               [serial 1563] 
P [635] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
S [620] ->
Q [620] << INV()
  and POA()
  and RMA()
  and PI() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1020]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 164:
Theorem (164) [serial 1565] used for:
    normalization of [serial 1563] 


Theorem (166)                               [serial 1020] 
P [635] << INV_E() >>
S [620] ->
Q [620] << INV()
  and POA()
  and RMA()
  and PI() >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 165:
Theorem (165) [serial 1563] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1020] 


Theorem (167)                               [serial 1021] 
P [634] << INV_E() >>
S [634] ->
Q [634] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by: Anything Implies True (a1tru): P->true

Theorem (168)                               [serial 1022] 
P [634] << INV_E() >>
S [641] ->
Q [635] << INV_E() >>
Why created:   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{};
Solved by: Identity (id):  P->P is tautology

Theorem (169)                               [serial 1589] 
P [643] << ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 )@now
  and ( INV()
  and POA()
  and RMA()
  and PI() )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 )@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE )@u  ) >>
S [643] ->
Q [645] << INV()
  and RMA() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1572]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (170)                               [serial 1572] 
P [643] << PO_ALARM()@now
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [643] ->
Q [645] << INV()
  and RMA() >>
Why created:    normalization of [serial 1566]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 169:
Theorem (169) [serial 1589] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1572] 


Theorem (171)                               [serial 1566] 
P [643] << ( INV_E() )
  and ( PO_ALARM()@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [643] ->
Q [645] << INV()
  and RMA() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1023]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 170:
Theorem (170) [serial 1572] used for:
    normalization of [serial 1566] 


Theorem (172)                               [serial 1593] 
P [646] << ( INV()
  and RMA() )
  and ( PO_ALARM() iff po_alarm_active ) >>
S [646] ->
Q [647] << ( PO_ALARM() iff po_alarm_active )
  and INV()
  and RMA() >>
Why created:    normalization of [serial 1591]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (173)                               [serial 1591] 
P [646] << ( INV()
  and RMA() )
  and ( po_alarm_active iff PO_ALARM() ) >>
S [646] ->
Q [647] << ( PO_ALARM() iff po_alarm_active )
  and INV()
  and RMA() >>
Why created:  applied port input of value <<pre and po_alarm_active=M(PO_Alarm)>> -> <<post>> [serial 1574]
Solved by: Biconditional (iff) Commutes. (bicom) and theorem 172:
Theorem (172) [serial 1593] used for:
    normalization of [serial 1591] 


Theorem (174)                               [serial 1574] 
P [645] << INV()
  and RMA() >>
S [646] PO_Alarm?(po_alarm_active)
Q [647] << ( PO_ALARM() iff po_alarm_active )
  and INV()
  and RMA() >>
Why created:    normalization of [serial 1567]
  Using: (bicom) (bl.ancom) 
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 173:
Theorem (173) [serial 1591] used for:
  applied port input of value <<pre and po_alarm_active=M(PO_Alarm)>> -> <<post>> [serial 1574] 


Theorem (175)                               [serial 1567] 
P [645] << INV()
  and RMA() >>
S [646] PO_Alarm?(po_alarm_active)
Q [647] << INV()
  and RMA()
  and ( po_alarm_active iff PO_ALARM() ) >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1023]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 174:
Theorem (174) [serial 1574] used for:
    normalization of [serial 1567] 


Theorem (176)                               [serial 1595] 
P [647] << ( PO_ALARM() iff po_alarm_active )
  and INV()
  and RMA() >>
S [648] ->
Q [648] << PO_ALARM() iff po_alarm_active >>
Why created:  applied port output of value <<pre>> -> <<M(PO_Alarm_Echo)[PO_Alarm_Echo|po_alarm_active]>> [serial 1576]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (177)                               [serial 1596] 
P [648] << ( ( PO_ALARM() iff po_alarm_active )
  and INV()
  and RMA() )
  and ( PO_ALARM() iff po_alarm_active )@now >>
S [648] ->
Q [649] << INV()
  and POA()
  and RMA() >>
Why created:  applied port output <<pre and (PO_ALARM() iff po_alarm_active)@now>> -> <<post>> [serial 1576]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (178)                               [serial 1576] 
P [647] << ( PO_ALARM() iff po_alarm_active )
  and INV()
  and RMA() >>
S [648] PO_Alarm_Echo!(po_alarm_active)
Q [649] << INV()
  and POA()
  and RMA() >>
Why created:    normalization of [serial 1568]
  Using: (bicom) (bl.ancom) 
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 176 177:
Theorem (176) [serial 1595] used for:
  applied port output of value <<pre>> -> <<M(PO_Alarm_Echo)[PO_Alarm_Echo|po_alarm_active]>> [serial 1576] 
Theorem (177) [serial 1596] used for:
  applied port output <<pre and (PO_ALARM() iff po_alarm_active)@now>> -> <<post>> [serial 1576] 


Theorem (179)                               [serial 1568] 
P [647] << INV()
  and RMA()
  and ( po_alarm_active iff PO_ALARM() ) >>
S [648] PO_Alarm_Echo!(po_alarm_active)
Q [649] << INV()
  and RMA()
  and POA() >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1023]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 178:
Theorem (178) [serial 1576] used for:
    normalization of [serial 1568] 


Theorem (180)                               [serial 1615] 
P [649] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [650] ->
Q [628] << ( ( PO_ALARM() or RM_ALARM() ) iff ( PO_ALARM() or RM_ALARM() ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "rm_alarm_active" with its iff "RM_ALARM()" in its postcondition [serial 1614]
Solved by: Principle of identity for logical equivalence. (biid) 

Theorem (181)                               [serial 1614] 
P [649] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [650] ->
Q [628] << ( ( PO_ALARM() or RM_ALARM() ) iff ( PO_ALARM() or rm_alarm_active ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "po_alarm_active" with its iff "PO_ALARM()" in its postcondition [serial 1610]
Solved by:  Guided Substitution of Equals
 and theorem 180:
Theorem (180) [serial 1615] used for:
  Guided Substitution of Equals 
 replacing "rm_alarm_active" with its iff "RM_ALARM()" in its postcondition [serial 1614] 


Theorem (182)                               [serial 1610] 
P [649] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [650] ->
Q [628] << ( ( PO_ALARM() or RM_ALARM() ) iff ( po_alarm_active or rm_alarm_active ) ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1609]
Solved by:  Guided Substitution of Equals
 and theorem 181:
Theorem (181) [serial 1614] used for:
  Guided Substitution of Equals 
 replacing "po_alarm_active" with its iff "PO_ALARM()" in its postcondition [serial 1610] 


Theorem (183)                               [serial 1611] 
P [649] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [650] ->
Q [624] << ( PO_ALARM() iff po_alarm_active ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1609]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (184)                               [serial 1612] 
P [649] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [650] ->
Q [626] << ( RM_ALARM() iff rm_alarm_active ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1609]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (185)                               [serial 1613] 
P [649] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [650] ->
Q [618] << ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1609]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (186)                               [serial 1609] 
P [649] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [650] ->
Q [651] << ( ( PO_ALARM() or RM_ALARM() ) iff ( po_alarm_active or rm_alarm_active ) )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
Why created:    normalization of [serial 1607]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 182 183 184 185:
Theorem (182) [serial 1610] used for:
  Join consequents with conjunction. (3jca)
   [serial 1609] 
Theorem (183) [serial 1611] used for:
  Join consequents with conjunction. (3jca)
   [serial 1609] 
Theorem (184) [serial 1612] used for:
  Join consequents with conjunction. (3jca)
   [serial 1609] 
Theorem (185) [serial 1613] used for:
  Join consequents with conjunction. (3jca)
   [serial 1609] 


Theorem (187)                               [serial 1607] 
P [649] << ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() ) >>
S [650] ->
Q [651] << ( ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( ( po_alarm_active or rm_alarm_active ) iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1606]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 186:
Theorem (186) [serial 1609] used for:
    normalization of [serial 1607] 


Theorem (188)                               [serial 1606] 
P [649] << INV()
  and POA()
  and RMA() >>
S [650] ->
Q [651] << ( ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( ( po_alarm_active or rm_alarm_active ) iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  applied wp for assignment [serial 1605]
Solved by: Predicate Invocation. (PI) and theorem 187:
Theorem (187) [serial 1607] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1606] 


Theorem (189)                               [serial 1605] 
P [649] << INV()
  and POA()
  and RMA() >>
S [650] pause_inf := po_alarm_active or rm_alarm_active
Q [651] << ( ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1604]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 188:
Theorem (188) [serial 1606] used for:
  applied wp for assignment [serial 1605] 


Theorem (190)                               [serial 1604] 
P [649] << INV()
  and POA()
  and RMA() >>
S [650] pause_inf := po_alarm_active or rm_alarm_active
Q [651] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1578]
Solved by: Predicate Invocation. (PI) and theorem 189:
Theorem (189) [serial 1605] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1604] 


Theorem (191)                               [serial 1578] 
P [649] << INV()
  and POA()
  and RMA() >>
S [650] pause_inf := po_alarm_active or rm_alarm_active
Q [651] << INV_E() >>
Why created:    normalization of [serial 1569]
Solved by: Predicate Invocation. (PI) and theorem 190:
Theorem (190) [serial 1604] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1578] 


Theorem (192)                               [serial 1569] 
P [649] << INV()
  and RMA()
  and POA() >>
S [650] pause_inf := po_alarm_active or rm_alarm_active
Q [651] << INV_E() >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1023]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 191:
Theorem (191) [serial 1578] used for:
    normalization of [serial 1569] 


Theorem (193)                               [serial 1588] 
P [651] << ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [652] ->
Q [652] << ( PO_ALARM() or RM_ALARM() ) iff pause_inf >>
Why created:    normalization of [serial 1586]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (194)                               [serial 1586] 
P [651] << ( ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
S [652] ->
Q [652] << ( PO_ALARM() or RM_ALARM() ) iff pause_inf >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1585]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 193:
Theorem (193) [serial 1588] used for:
    normalization of [serial 1586] 


Theorem (195)                               [serial 1585] 
P [651] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
S [652] ->
Q [652] << ( PO_ALARM() or RM_ALARM() ) iff pause_inf >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1580]
Solved by: Predicate Invocation. (PI) and theorem 194:
Theorem (194) [serial 1586] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1585] 


Theorem (196)                               [serial 1580] 
P [651] << INV_E() >>
S [652] ->
Q [652] << ( PO_ALARM() or RM_ALARM() ) iff pause_inf >>
Why created:  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|pause_inf]>> [serial 1570]
Solved by: Predicate Invocation. (PI) and theorem 195:
Theorem (195) [serial 1585] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1580] 


Theorem (197)                               [serial 1584] 
P [652] << ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )@now
  and INV_E() >>
S [652] ->
Q [637] << INV_E() >>
Why created:    normalization of [serial 1581]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (198)                               [serial 1581] 
P [652] << ( INV_E() )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )@now >>
S [652] ->
Q [637] << INV_E() >>
Why created:  applied port output <<pre and (( PO_ALARM() or RM_ALARM() ) iff pause_inf)@now>> -> <<post>> [serial 1570]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 197:
Theorem (197) [serial 1584] used for:
    normalization of [serial 1581] 


Theorem (199)                               [serial 1570] 
P [651] << INV_E() >>
S [652] Pause_Infusion!(pause_inf)
Q [637] << INV_E() >>
Why created:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1023]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 196 198:
Theorem (196) [serial 1580] used for:
  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|pause_inf]>> [serial 1570] 
Theorem (198) [serial 1581] used for:
  applied port output <<pre and (( PO_ALARM() or RM_ALARM() ) iff pause_inf)@now>> -> <<post>> [serial 1570] 


Theorem (200)                               [serial 1023] 
P [643] << ( INV_E() )
  and ( PO_ALARM()@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [645]   << INV()
    and RMA() >>
  PO_Alarm?(po_alarm_active)
  ;
  << INV()
    and RMA()
    and ( po_alarm_active iff PO_ALARM() ) >>
  PO_Alarm_Echo!(po_alarm_active)
  ;
  << INV()
    and RMA()
    and POA() >>
  pause_inf := po_alarm_active or rm_alarm_active
  ;
  << INV_E() >>
  Pause_Infusion!(pause_inf) 
Q [637] << INV_E() >>
Why created:   <<M(run) and x>> A <<M(check_echo)>> for got_po: run-[x]->check_echo{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 171 175 179 192 199:
Theorem (171) [serial 1566] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1023] 
Theorem (175) [serial 1567] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1023] 
Theorem (179) [serial 1568] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1023] 
Theorem (192) [serial 1569] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1023] 
Theorem (199) [serial 1570] used for:
  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1023] 


Theorem (201)                               [serial 1626] 
P [655] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE )@now
  and ( INV()
  and POA()
  and RMA()
  and PI() )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 )@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE )@u  ) >>
S [655] ->
Q [656] << INV()
  and POA() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1621]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (202)                               [serial 1621] 
P [655] << RM_ALARM()@now
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [655] ->
Q [656] << INV()
  and POA() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1620]
Solved by: Predicate Invocation. (PI) and theorem 201:
Theorem (201) [serial 1626] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1621] 


Theorem (203)                               [serial 1630] 
P [657] << ( INV()
  and POA() )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [657] ->
Q [658] << ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() >>
Why created:    normalization of [serial 1628]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (204)                               [serial 1628] 
P [657] << ( INV()
  and POA() )
  and ( rm_alarm_active iff RM_ALARM() ) >>
S [657] ->
Q [658] << ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() >>
Why created:  applied port input of value <<pre and rm_alarm_active=M(RM_Alarm)>> -> <<post>> [serial 1622]
Solved by: Biconditional (iff) Commutes. (bicom) and theorem 203:
Theorem (203) [serial 1630] used for:
    normalization of [serial 1628] 


Theorem (205)                               [serial 1622] 
P [656] << INV()
  and POA() >>
S [657] RM_Alarm?(rm_alarm_active)
Q [658] << ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1620]
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 204:
Theorem (204) [serial 1628] used for:
  applied port input of value <<pre and rm_alarm_active=M(RM_Alarm)>> -> <<post>> [serial 1622] 


Theorem (206)                               [serial 1632] 
P [658] << ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() >>
S [659] ->
Q [659] << RM_ALARM() iff rm_alarm_active >>
Why created:  applied port output of value <<pre>> -> <<M(RM_Alarm_Echo)[RM_Alarm_Echo|rm_alarm_active]>> [serial 1623]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (207)                               [serial 1634] 
P [659] << ( ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() )
  and ( RM_ALARM() iff rm_alarm_active )@now >>
S [659] ->
Q [660] << INV() >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1633]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (208)                               [serial 1635] 
P [659] << ( ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() )
  and ( RM_ALARM() iff rm_alarm_active )@now >>
S [659] ->
Q [660] << POA() >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1633]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (209)                               [serial 1636] 
P [659] << ( ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() )
  and ( RM_ALARM() iff rm_alarm_active )@now >>
S [659] ->
Q [660] << RMA() >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1633]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (210)                               [serial 1633] 
P [659] << ( ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() )
  and ( RM_ALARM() iff rm_alarm_active )@now >>
S [659] ->
Q [660] << INV()
  and POA()
  and RMA() >>
Why created:  applied port output <<pre and (RM_ALARM() iff rm_alarm_active)@now>> -> <<post>> [serial 1623]
Solved by: Join consequents with conjunction. (3jca) and theorems 207 208 209:
Theorem (207) [serial 1634] used for:
  Join consequents with conjunction. (3jca)
   [serial 1633] 
Theorem (208) [serial 1635] used for:
  Join consequents with conjunction. (3jca)
   [serial 1633] 
Theorem (209) [serial 1636] used for:
  Join consequents with conjunction. (3jca)
   [serial 1633] 


Theorem (211)                               [serial 1623] 
P [658] << ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() >>
S [659] RM_Alarm_Echo!(rm_alarm_active)
Q [660] << INV()
  and POA()
  and RMA() >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1620]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 206 210:
Theorem (206) [serial 1632] used for:
  applied port output of value <<pre>> -> <<M(RM_Alarm_Echo)[RM_Alarm_Echo|rm_alarm_active]>> [serial 1623] 
Theorem (210) [serial 1633] used for:
  applied port output <<pre and (RM_ALARM() iff rm_alarm_active)@now>> -> <<post>> [serial 1623] 


Theorem (212)                               [serial 1654] 
P [660] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [661] ->
Q [628] << ( ( PO_ALARM() or RM_ALARM() ) iff ( PO_ALARM() or RM_ALARM() ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "po_alarm_active" with its iff "PO_ALARM()" in its postcondition [serial 1653]
Solved by: Principle of identity for logical equivalence. (biid) 

Theorem (213)                               [serial 1653] 
P [660] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [661] ->
Q [628] << ( ( PO_ALARM() or RM_ALARM() ) iff ( po_alarm_active or RM_ALARM() ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "rm_alarm_active" with its iff "RM_ALARM()" in its postcondition [serial 1649]
Solved by:  Guided Substitution of Equals
 and theorem 212:
Theorem (212) [serial 1654] used for:
  Guided Substitution of Equals 
 replacing "po_alarm_active" with its iff "PO_ALARM()" in its postcondition [serial 1653] 


Theorem (214)                               [serial 1649] 
P [660] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [661] ->
Q [628] << ( ( PO_ALARM() or RM_ALARM() ) iff ( po_alarm_active or rm_alarm_active ) ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1648]
Solved by:  Guided Substitution of Equals
 and theorem 213:
Theorem (213) [serial 1653] used for:
  Guided Substitution of Equals 
 replacing "rm_alarm_active" with its iff "RM_ALARM()" in its postcondition [serial 1649] 


Theorem (215)                               [serial 1650] 
P [660] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [661] ->
Q [624] << ( PO_ALARM() iff po_alarm_active ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1648]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (216)                               [serial 1651] 
P [660] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [661] ->
Q [626] << ( RM_ALARM() iff rm_alarm_active ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1648]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (217)                               [serial 1652] 
P [660] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [661] ->
Q [618] << ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1648]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (218)                               [serial 1648] 
P [660] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [661] ->
Q [662] << ( ( PO_ALARM() or RM_ALARM() ) iff ( po_alarm_active or rm_alarm_active ) )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
Why created:    normalization of [serial 1646]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 214 215 216 217:
Theorem (214) [serial 1649] used for:
  Join consequents with conjunction. (3jca)
   [serial 1648] 
Theorem (215) [serial 1650] used for:
  Join consequents with conjunction. (3jca)
   [serial 1648] 
Theorem (216) [serial 1651] used for:
  Join consequents with conjunction. (3jca)
   [serial 1648] 
Theorem (217) [serial 1652] used for:
  Join consequents with conjunction. (3jca)
   [serial 1648] 


Theorem (219)                               [serial 1646] 
P [660] << ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() ) >>
S [661] ->
Q [662] << ( ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( ( po_alarm_active or rm_alarm_active ) iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1645]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 218:
Theorem (218) [serial 1648] used for:
    normalization of [serial 1646] 


Theorem (220)                               [serial 1645] 
P [660] << INV()
  and POA()
  and RMA() >>
S [661] ->
Q [662] << ( ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( ( po_alarm_active or rm_alarm_active ) iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  applied wp for assignment [serial 1644]
Solved by: Predicate Invocation. (PI) and theorem 219:
Theorem (219) [serial 1646] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1645] 


Theorem (221)                               [serial 1644] 
P [660] << INV()
  and POA()
  and RMA() >>
S [661] pause_inf := po_alarm_active or rm_alarm_active
Q [662] << ( ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1643]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 220:
Theorem (220) [serial 1645] used for:
  applied wp for assignment [serial 1644] 


Theorem (222)                               [serial 1643] 
P [660] << INV()
  and POA()
  and RMA() >>
S [661] pause_inf := po_alarm_active or rm_alarm_active
Q [662] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1624]
Solved by: Predicate Invocation. (PI) and theorem 221:
Theorem (221) [serial 1644] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1643] 


Theorem (223)                               [serial 1624] 
P [660] << INV()
  and POA()
  and RMA() >>
S [661] pause_inf := po_alarm_active or rm_alarm_active
Q [662] << INV_E() >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1620]
Solved by: Predicate Invocation. (PI) and theorem 222:
Theorem (222) [serial 1643] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1624] 


Theorem (224)                               [serial 1666] 
P [662] << ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [663] ->
Q [663] << ( PO_ALARM() or RM_ALARM() ) iff pause_inf >>
Why created:    normalization of [serial 1664]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (225)                               [serial 1664] 
P [662] << ( ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
S [663] ->
Q [663] << ( PO_ALARM() or RM_ALARM() ) iff pause_inf >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1663]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 224:
Theorem (224) [serial 1666] used for:
    normalization of [serial 1664] 


Theorem (226)                               [serial 1663] 
P [662] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
S [663] ->
Q [663] << ( PO_ALARM() or RM_ALARM() ) iff pause_inf >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1658]
Solved by: Predicate Invocation. (PI) and theorem 225:
Theorem (225) [serial 1664] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1663] 


Theorem (227)                               [serial 1658] 
P [662] << INV_E() >>
S [663] ->
Q [663] << ( PO_ALARM() or RM_ALARM() ) iff pause_inf >>
Why created:  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|pause_inf]>> [serial 1625]
Solved by: Predicate Invocation. (PI) and theorem 226:
Theorem (226) [serial 1663] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1658] 


Theorem (228)                               [serial 1662] 
P [663] << ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )@now
  and INV_E() >>
S [663] ->
Q [637] << INV_E() >>
Why created:    normalization of [serial 1659]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (229)                               [serial 1659] 
P [663] << ( INV_E() )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )@now >>
S [663] ->
Q [637] << INV_E() >>
Why created:  applied port output <<pre and (( PO_ALARM() or RM_ALARM() ) iff pause_inf)@now>> -> <<post>> [serial 1625]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 228:
Theorem (228) [serial 1662] used for:
    normalization of [serial 1659] 


Theorem (230)                               [serial 1625] 
P [662] << INV_E() >>
S [663] Pause_Infusion!(pause_inf)
Q [637] << INV_E() >>
Why created:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1620]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 227 229:
Theorem (227) [serial 1658] used for:
  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|pause_inf]>> [serial 1625] 
Theorem (229) [serial 1659] used for:
  applied port output <<pre and (( PO_ALARM() or RM_ALARM() ) iff pause_inf)@now>> -> <<post>> [serial 1625] 


Theorem (231)                               [serial 1620] 
P [655] << RM_ALARM()@now
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [656]   << INV()
    and POA() >>
  RM_Alarm?(rm_alarm_active)
  ;
  << ( RM_ALARM() iff rm_alarm_active )
    and INV()
    and POA() >>
  RM_Alarm_Echo!(rm_alarm_active)
  ;
  << INV()
    and POA()
    and RMA() >>
  pause_inf := po_alarm_active or rm_alarm_active
  ;
  << INV_E() >>
  Pause_Infusion!(pause_inf) 
Q [637] << INV_E() >>
Why created:    normalization of [serial 1024]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) (bicom) 
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 202 205 211 223 230:
Theorem (202) [serial 1621] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1620] 
Theorem (205) [serial 1622] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1620] 
Theorem (211) [serial 1623] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1620] 
Theorem (223) [serial 1624] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1620] 
Theorem (230) [serial 1625] used for:
  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1620] 


Theorem (232)                               [serial 1024] 
P [655] << ( INV_E() )
  and ( RM_ALARM()@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [656]   << INV()
    and POA() >>
  RM_Alarm?(rm_alarm_active)
  ;
  << INV()
    and POA()
    and ( rm_alarm_active iff RM_ALARM() ) >>
  RM_Alarm_Echo!(rm_alarm_active)
  ;
  << INV()
    and RMA()
    and POA() >>
  pause_inf := po_alarm_active or rm_alarm_active
  ;
  << INV_E() >>
  Pause_Infusion!(pause_inf) 
Q [637] << INV_E() >>
Why created:   <<M(run) and x>> A <<M(check_echo)>> for got_rm: run-[x]->check_echo{A};
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) Biconditional (iff) Commutes. (bicom) and theorem 231:
Theorem (231) [serial 1620] used for:
    normalization of [serial 1024] 


Theorem (233)                               [serial 1678] 
P [666] << ( PAUSE_INFUSION_ECHO@now
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) )
  and ( PAUSE_INFUSION_ECHO@now iff echo_val ) >>
S [669] ->
Q [669] << ( PAUSE_INFUSION_ECHO iff echo_val )
  and INV_E() >>
Why created:    normalization of [serial 1668]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) (bicom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (234)                               [serial 1668] 
P [666] << ( ( INV_E() )
  and ( PAUSE_INFUSION_ECHO@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) )
  and ( echo_val iff PAUSE_INFUSION_ECHO@now ) >>
S [669] ->
Q [669] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
Why created:  <<P and v=e>> -> <<A>> in behavior action block for [serial 1667]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) Biconditional (iff) Commutes. (bicom) and theorem 233:
Theorem (233) [serial 1678] used for:
    normalization of [serial 1668] 


Theorem (235)                               [serial 1671] 
P [669] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
S [669] ->
Q [669] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1669]
Solved by: Identity (id):  P->P is tautology

Theorem (236)                               [serial 1672] 
P [674] << INV_E() >>
S [674] ->
Q [674] << INV_E() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1669]
Solved by: Identity (id):  P->P is tautology

Theorem (237)                               [serial 1680] 
P [669] << ( PAUSE_INFUSION_ECHO iff echo_val )
  and INV_E() >>
S [670] ->
Q [670] << ( echo_val iff pause_inf ) or not ( echo_val iff pause_inf ) >>
Why created:    normalization of [serial 1674]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (238)                               [serial 1674] 
P [669] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
S [670] ->
Q [670] << ( echo_val iff pause_inf ) or ( not ( echo_val iff pause_inf ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1673]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) and theorem 237:
Theorem (237) [serial 1680] used for:
    normalization of [serial 1674] 


Theorem (239)                               [serial 1682] 
P [670] << ( ( PAUSE_INFUSION_ECHO iff echo_val )
  and INV_E() )
  and ( echo_val iff pause_inf ) >>
S [670] skip
Q [674] << INV_E() >>
Why created:    normalization of [serial 1675]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (240)                               [serial 1675] 
P [670] << ( ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() )
  and ( echo_val iff pause_inf ) >>
S [670] skip
Q [674] << INV_E() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1673]
Solved by: Biconditional (iff) Commutes. (bicom) and theorem 239:
Theorem (239) [serial 1682] used for:
    normalization of [serial 1675] 


Theorem (241)                               [serial 1684] 
P [670] << ( ( PAUSE_INFUSION_ECHO iff echo_val )
  and INV_E() )
  and not ( echo_val iff pause_inf ) >>
S [672] Lost_Confirmation!
Q [674] << INV_E() >>
Why created:    normalization of [serial 1676]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (242)                               [serial 1676] 
P [670] << ( ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() )
  and ( not ( echo_val iff pause_inf ) ) >>
S [672] Lost_Confirmation!
Q [674] << INV_E() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1673]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) and theorem 241:
Theorem (241) [serial 1684] used for:
    normalization of [serial 1676] 


Theorem (243)                               [serial 1673] 
P [669] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
S [670]   if 
    (echo_val iff pause_inf)~> 
      skip 
  []
    (not ( echo_val iff pause_inf ))~> 
      Lost_Confirmation! 
  fi
Q [674] << INV_E() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1669]
Solved by: and theorems 238 240 242:
Theorem (238) [serial 1674] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1673] 
Theorem (240) [serial 1675] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1673] 
Theorem (242) [serial 1676] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1673] 


Theorem (244)                               [serial 1669] 
P [669] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
S [669] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
  if 
    (echo_val iff pause_inf)~> 
      skip 
  []
    (not ( echo_val iff pause_inf ))~> 
      Lost_Confirmation! 
  fi
<< INV_E() >>
Q [674] << INV_E() >>
Why created:  <<A>> S <<B>> in behavior action block for [serial 1667]
Solved by: null and theorems 235 236 243:
Theorem (235) [serial 1671] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1669] 
Theorem (236) [serial 1672] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1669] 
Theorem (243) [serial 1673] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1669] 


Theorem (245)                               [serial 1670] 
P [674] << INV_E() >>
S [668] ->
Q [635] << INV_E() >>
Why created:  <<B>> -> <<Q>> in behavior action block for [serial 1667]
Solved by: Identity (id):  P->P is tautology

Theorem (246)                               [serial 1667] 
P [666] << ( INV_E() )
  and ( PAUSE_INFUSION_ECHO@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [668] declare 
   echo_val ~ boolean := Pause_Infusion_Echo?   {
  << ( echo_val iff PAUSE_INFUSION_ECHO )
    and INV_E() >>
    if 
      (echo_val iff pause_inf)~> 
        skip 
    []
      (not ( echo_val iff pause_inf ))~> 
        Lost_Confirmation! 
    fi
  << INV_E() >>
  } 
Q [635] << INV_E() >>
Why created:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1025]
Solved by: Behavior Action Block (BAB): 
     <<P and x=e>> -> <<A>>
     <<A>> S <<B>> 
     <<B>> -> <<Q>>
----------------------------------------------------
<<P>> declare variable v~y:=e; { <<A>> S <<B>> } <<Q>> and theorems 234 244 245:
Theorem (234) [serial 1668] used for:
  <<P and v=e>> -> <<A>> in behavior action block for [serial 1667] 
Theorem (244) [serial 1669] used for:
  <<A>> S <<B>> in behavior action block for [serial 1667] 
Theorem (245) [serial 1670] used for:
  <<B>> -> <<Q>> in behavior action block for [serial 1667] 


Theorem (247)                               [serial 1025] 
P [666] << ( INV_E() )
  and ( PAUSE_INFUSION_ECHO@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [668] declare 
   echo_val ~ boolean := Pause_Infusion_Echo?   {
  << ( echo_val iff PAUSE_INFUSION_ECHO )
    and INV_E() >>
    if 
      (echo_val iff pause_inf)~> 
        skip 
    []
      (not ( echo_val iff pause_inf ))~> 
        Lost_Confirmation! 
    fi
  << INV_E() >>
  } 
Q [635] << INV_E() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A};
Solved by: null and theorem 246:
Theorem (246) [serial 1667] used for:
  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1025] 


Theorem (248)                               [serial 1707] 
P [679] << ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [680] ->
Q [680] << true >>
Why created:    normalization of [serial 1703]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (249)                               [serial 1703] 
P [679] << ( INV_E() )
  and ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [680] ->
Q [680] << true >>
Why created:  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1026]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 248:
Theorem (248) [serial 1707] used for:
    normalization of [serial 1703] 


Theorem (250)                               [serial 1709] 
P [680] << ( ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) )
  and true >>
S [680] ->
Q [635] << INV_E() >>
Why created:    normalization of [serial 1705]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (251)                               [serial 1705] 
P [680] << ( ( INV_E() )
  and ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) )
  and true >>
S [680] ->
Q [635] << INV_E() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1704]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 250:
Theorem (250) [serial 1709] used for:
    normalization of [serial 1705] 


Theorem (252)                               [serial 1704] 
P [680] << ( ( INV_E() )
  and ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) )
  and true@now >>
S [680] ->
Q [635] << INV_E() >>
Why created:  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1026]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 251:
Theorem (251) [serial 1705] used for:
  Assume Present:  P = P@now = P^0   [serial 1704] 


Theorem (253)                               [serial 1026] 
P [679] << ( INV_E() )
  and ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [680] Lost_Confirmation!
Q [635] << INV_E() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A};
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 249 252:
Theorem (249) [serial 1703] used for:
  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1026] 
Theorem (252) [serial 1704] used for:
  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1026] 


Theorem (254)                               [serial 1018] 
P [617] <<   >>
S [620] ->
Q [617] << Coordinator_Thread.echo proof obligations >>
Why created:  Initial proof obligations for Coordinator_Thread.echo
Solved by:  Component verification conditions
 and theorems 163 166 167 168 200 232 247 253:
Theorem (163) [serial 1019] used for:
  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition. 
Theorem (166) [serial 1020] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (167) [serial 1021] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (168) [serial 1022] used for:
   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{}; 
Theorem (200) [serial 1023] used for:
   <<M(run) and x>> A <<M(check_echo)>> for got_po: run-[x]->check_echo{A}; 
Theorem (232) [serial 1024] used for:
   <<M(run) and x>> A <<M(check_echo)>> for got_rm: run-[x]->check_echo{A}; 
Theorem (247) [serial 1025] used for:
   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A}; 
Theorem (253) [serial 1026] used for:
   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A}; 


Theorem (255)                               [serial 1719] 
P [1] << ( ( ( last_action'EndPriming = LAST_ACTION_A or last_action'SafetyStopPump = LAST_ACTION_A or 
last_action'StopButton = LAST_ACTION_A ) or KVO_RATE_property = PUMP_RATE$() ) iff Pause_Infusion )
  and ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) iff PO_Alarm )
  and ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE iff RM_Alarm )
  and ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) implies ( ( last_action'EndPriming = LAST_ACTION_A or 
last_action'SafetyStopPump = LAST_ACTION_A or last_action'StopButton = LAST_ACTION_A ) or 
KVO_RATE_property = PUMP_RATE$() ) ) >>
S    ->
Q [2] << ( HEART_RATE < MINIMUM_HEART_RATE or RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE or 
SPO2 < PROGRAMMED_SPO2 ) implies ( ( last_action'EndPriming = LAST_ACTION_A or 
last_action'SafetyStopPump = LAST_ACTION_A or last_action'StopButton = LAST_ACTION_A ) or 
KVO_RATE_property = PUMP_RATE$() ) >>
Why created:    normalization of [serial 1717]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by: Absorb parentheses, middle term in disjunction (bl.orabpm)

Theorem (256)                               [serial 1717] 
P [1] << ( Pause_Infusion iff ( PUMP_RATE$() = KVO_RATE_property or ( ( LAST_ACTION_A = last_action'SafetyStopPump ) or 
( LAST_ACTION_A = last_action'StopButton ) or ( LAST_ACTION_A = last_action'EndPriming ) ) ) )
  and ( PO_Alarm iff ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) )
  and ( RM_Alarm iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) )
  and ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) implies ( PUMP_RATE$() = KVO_RATE_property or 
( ( LAST_ACTION_A = last_action'SafetyStopPump ) or ( LAST_ACTION_A = last_action'StopButton ) or 
( LAST_ACTION_A = last_action'EndPriming ) ) ) ) >>
S    ->
Q [2] << ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 or RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) implies ( 
PUMP_RATE$() = KVO_RATE_property or ( ( LAST_ACTION_A = last_action'SafetyStopPump ) or 
( LAST_ACTION_A = last_action'StopButton ) or ( LAST_ACTION_A = last_action'EndPriming ) ) ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1716]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 255:
Theorem (255) [serial 1719] used for:
    normalization of [serial 1717] 


Theorem (257)                               [serial 1716] 
P [1] << ( Pause_Infusion iff ( PUMP_RATE$() = KVO_RATE_property or HALT() ) )
  and ( PO_Alarm iff PO_ALARM() )
  and ( RM_Alarm iff RM_ALARM() )
  and ( ( PO_ALARM() or RM_ALARM() ) implies ( PUMP_RATE$() = KVO_RATE_property or 
HALT() ) ) >>
S    ->
Q [2] << ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 or RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) implies ( 
PUMP_RATE$() = KVO_RATE_property or HALT() ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1715]
Solved by: Predicate Invocation. (PI) and theorem 256:
Theorem (256) [serial 1717] used for:
  Substituted assertions' predicates for labels  [serial 1716] 


Theorem (258)                               [serial 1715] 
P [1] << ( Pause_Infusion iff ( PUMP_RATE$() = KVO_RATE_property or HALT() ) )
  and ( PO_Alarm iff PO_ALARM() )
  and ( RM_Alarm iff RM_ALARM() )
  and ( ( PO_ALARM() or RM_ALARM() ) implies ( PUMP_RATE$() = KVO_RATE_property or 
HALT() ) ) >>
S    ->
Q [2] << IS_SAFE() >>
Why created:  Substituting Equals Within Conjunction [serial 1027]
Solved by: Predicate Invocation. (PI) and theorem 257:
Theorem (257) [serial 1716] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1715] 


Theorem (259)                               [serial 1027] 
P [1] << ( Pause_Infusion iff ( PUMP_RATE$() = KVO_RATE_property or HALT() ) )
  and ( PO_Alarm iff PO_ALARM() )
  and ( RM_Alarm iff RM_ALARM() )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S    ->
Q [2] << IS_SAFE() >>
Why created:  Conjunction of Subcomponents' Invariants imply SysIoMT.impl's Invariant
Solved by: A equality theorem for substitution. (subequ12a) and theorem 258:
Theorem (258) [serial 1715] used for:
  Substituting Equals Within Conjunction [serial 1027] 


Theorem (260)                               [serial 1724] 
P [1] << ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion >>
S    ->
Q [2] << ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion >>
Why created:    normalization of [serial 1028]
Solved by: Identity (id):  P->P is tautology

Theorem (261)                               [serial 1028] 
P [1] << ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S    ->
Q [2] << ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion >>
Why created:  Subcomponent's Invariant implies Coordinator.impl's Invariant
Solved by: [Add unnecessary parentheses] and theorem 260:
Theorem (260) [serial 1724] used for:
    normalization of [serial 1028] 


Theorem (262)                               [serial 1728] 
P [1] << ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE >>
S [2] ->
Q [1] << ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE >>
Why created:    normalization of [serial 1726]
  Using: ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Absorb parentheses, middle term in disjunction (bl.orabpm)

Theorem (263)                               [serial 1726] 
P [1] << ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) >>
S [2] ->
Q [1] << ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1725]
Solved by: [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 262:
Theorem (262) [serial 1728] used for:
    normalization of [serial 1726] 


Theorem (264)                               [serial 1725] 
P [1] << PO_ALARM() or RM_ALARM() >>
S [2] ->
Q [1] << ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1029]
Solved by: Predicate Invocation. (PI) and theorem 263:
Theorem (263) [serial 1726] used for:
  Substituted assertions' predicates for labels  [serial 1725] 


Theorem (265)                               [serial 1029] 
P [1] << PO_ALARM() or RM_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() or RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection pcc.pause_infusion -> pct.pause_infusion:
 pause_infusion -> pause_infusion
Solved by: Predicate Invocation. (PI) and theorem 264:
Theorem (264) [serial 1725] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1029] 


Theorem (266)                               [serial 1733] 
P [1] << PUMP_RATE() = pump_rate >>
S [2] ->
Q [1] << PUMP_RATE() = pump_rate >>
Why created:    normalization of [serial 1030]
Solved by: Identity (id):  P->P is tautology

Theorem (267)                               [serial 1030] 
P [1] << pump_rate = PUMP_RATE() >>
S [2] ->
Q [1] << pump_rate = PUMP_RATE() >>
Why created:  Composition of Subcomponents via Directional Connection pcp.pct.pump_rate -> pmp.pump_rate:
 pump_rate -> pump_rate
Solved by: Equality Commutes. (eqcom) and theorem 266:
Theorem (266) [serial 1733] used for:
    normalization of [serial 1030] 


Theorem (268)                               [serial 1031] 
P [1] << PO_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection pot.PO_Alarm -> poc.poa:
 PO_Alarm -> poa
Solved by: Identity (id):  P->P is tautology

Theorem (269)                               [serial 1032] 
P [1] << RM_ALARM() >>
S [2] ->
Q [1] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection rmt.RM_Alarm -> rmc.rma:
 RM_Alarm -> rma
Solved by: Identity (id):  P->P is tautology

Theorem (270)                               [serial 1033] 
P [1] << RM_ALARM() >>
S [2] ->
Q [1] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection spt.RM_Alarm_Echo -> spc.rmae:
 RM_Alarm_Echo -> rmae
Solved by: Identity (id):  P->P is tautology

Theorem (271)                               [serial 1034] 
P [1] << PO_ALARM() or RM_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() or RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection spt.Pause_Infusion -> spc.pi:
 Pause_Infusion -> pi
Solved by: Identity (id):  P->P is tautology

Theorem (272)                               [serial 1035] 
P [1] << PO_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection spt.PO_Alarm_Echo -> spc.poae:
 PO_Alarm_Echo -> poae
Solved by: Identity (id):  P->P is tautology

Theorem (273)                               [serial 1036] 
P [1] << PO_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection spc.PO_Alarm -> spt.PO_Alarm:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (274)                               [serial 1037] 
P [1] << RM_ALARM() >>
S [2] ->
Q [1] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection spc.RM_Alarm -> spt.RM_Alarm:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (275)                               [serial 1038] 
P [1] << PAUSE_INFUSION_ECHO >>
S [2] ->
Q [1] << PAUSE_INFUSION_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection spc.Pause_Infusion_Echo -> spt.Pause_Infusion_Echo:
 Pause_Infusion_Echo -> Pause_Infusion_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (276)                               [serial 1039] 
P [1] << infused_drug = PUMP_RATE() >>
S [2] ->
Q [1] << infused_drug = PUMP_RATE() >>
Why created:  Composition of Subcomponents via Directional Connection pca_pump.pmp.infused_drug -> patient.Infused_Drug:
 infused_drug -> Infused_Drug
Solved by: Identity (id):  P->P is tautology

Theorem (277)                               [serial 1040] 
P [1] << PO_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection pulse_oximeter.pop.poc.PO_Alarm -> coordinator.spp.spc.poa:
 PO_Alarm -> poa
Solved by: Identity (id):  P->P is tautology

Theorem (278)                               [serial 1041] 
P [1] << RM_ALARM() >>
S [2] ->
Q [1] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection resp_monitor.rmp.rmc.RM_Alarm -> coordinator.spp.spc.rma:
 RM_Alarm -> rma
Solved by: Identity (id):  P->P is tautology

Theorem (279)                               [serial 1042] 
P [1] << PO_ALARM() or RM_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() or RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection coordinator.spp.spc.Pause_Infusion -> pca_pump.pcp.pcc.pi:
 Pause_Infusion -> pi
Solved by: Identity (id):  P->P is tautology

Theorem (280)                               [serial 1043] 
P [85] << infused_drug = PUMP_RATE() >>
S [49] ->
Q [735] << infused_drug = PUMP_RATE() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.infusion_set:
 infused_drug -> Infused_Drug
Solved by: Identity (id):  P->P is tautology

Theorem (281)                               [serial 1044] 
P [522] << PO_ALARM() or RM_ALARM() >>
S [33] ->
Q [84] << PO_ALARM() or RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.pause_infusion:
 Pause_Infusion -> pause_infusion
Solved by: Identity (id):  P->P is tautology

Theorem (282)                               [serial 1045] 
P [185] << PO_ALARM() >>
S [35] ->
Q [520] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.po_alarm:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (283)                               [serial 1046] 
P [364] << RM_ALARM() >>
S [37] ->
Q [521] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.rm_alarm:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (284)                               [serial 1047] 
P [155] << infused_drug = PUMP_RATE() >>
S [103] ->
Q [85] << infused_drug = PUMP_RATE() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pd:
 infused_drug -> infused_drug
Solved by: Identity (id):  P->P is tautology

Theorem (285)                               [serial 1048] 
P [84] << PO_ALARM() or RM_ALARM() >>
S [99] ->
Q [110] << PO_ALARM() or RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pif:
 pause_infusion -> pause_infusion
Solved by: Identity (id):  P->P is tautology

Theorem (286)                               [serial 1049] 
P [111] << pump_rate = PUMP_RATE() >>
S [101] ->
Q [160] << pump_rate = PUMP_RATE() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pr:
 pump_rate -> pump_rate
Solved by: Identity (id):  P->P is tautology

Theorem (287)                               [serial 1050] 
P [110] << PO_ALARM() or RM_ALARM() >>
S [122] ->
Q [168] << PO_ALARM() or RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.pi1:
 pause_infusion -> pi
Solved by: Identity (id):  P->P is tautology

Theorem (288)                               [serial 1051] 
P [169] << PO_ALARM() or RM_ALARM() >>
S [123] ->
Q [138] << PO_ALARM() or RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.pi2:
 pause_infusion -> pause_infusion
Solved by: Identity (id):  P->P is tautology

Theorem (289)                               [serial 1052] 
P [136] << pump_rate = PUMP_RATE() >>
S [130] ->
Q [111] << pump_rate = PUMP_RATE() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.PCA_Pump_Process_impl_new_connection:
 pump_rate -> pump_rate
Solved by: Identity (id):  P->P is tautology

Theorem (290)                               [serial 1053] 
P [210] << PO_ALARM() >>
S [197] ->
Q [185] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter.impl.poa:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (291)                               [serial 1054] 
P [243] << PO_ALARM() >>
S [227] ->
Q [343] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter_Process.impl.pol1:
 PO_Alarm -> poa
Solved by: Identity (id):  P->P is tautology

Theorem (292)                               [serial 1055] 
P [344] << PO_ALARM() >>
S [228] ->
Q [210] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter_Process.impl.pol2:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (293)                               [serial 1056] 
P [385] << RM_ALARM() >>
S [376] ->
Q [364] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor.impl.rma:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (294)                               [serial 1057] 
P [414] << RM_ALARM() >>
S [402] ->
Q [495] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor_Process.impl.rma1:
 RM_Alarm -> rma
Solved by: Identity (id):  P->P is tautology

Theorem (295)                               [serial 1058] 
P [496] << RM_ALARM() >>
S [403] ->
Q [385] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor_Process.impl.rma2:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (296)                               [serial 1059] 
P [520] << PO_ALARM() >>
S [535] ->
Q [550] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.poa:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (297)                               [serial 1060] 
P [521] << RM_ALARM() >>
S [536] ->
Q [551] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.rma:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (298)                               [serial 1061] 
P [552] << PO_ALARM() or RM_ALARM() >>
S [537] ->
Q [522] << PO_ALARM() or RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.pi:
 Pause_Infusion -> Pause_Infusion
Solved by: Identity (id):  P->P is tautology

Theorem (299)                               [serial 1062] 
P [526] << PAUSE_INFUSION_ECHO >>
S [538] ->
Q [556] << PAUSE_INFUSION_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.pie:
 Pause_Infusion_Echo -> Pause_Infusion_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (300)                               [serial 1063] 
P [554] << PO_ALARM() >>
S [540] ->
Q [524] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.icp:
 PO_Alarm_Echo -> PO_Alarm_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (301)                               [serial 1064] 
P [547] << RM_ALARM() >>
S [541] ->
Q [516] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.icr:
 RM_Alarm_Echo -> RM_Alarm_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (302)                               [serial 1065] 
P [550] << PO_ALARM() >>
S [567] ->
Q [698] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poa1:
 PO_Alarm -> poa
Solved by: Identity (id):  P->P is tautology

Theorem (303)                               [serial 1066] 
P [699] << PO_ALARM() >>
S [568] ->
Q [599] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poa2:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (304)                               [serial 1067] 
P [551] << RM_ALARM() >>
S [571] ->
Q [701] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rma1:
 RM_Alarm -> rma
Solved by: Identity (id):  P->P is tautology

Theorem (305)                               [serial 1068] 
P [702] << RM_ALARM() >>
S [572] ->
Q [600] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rma2:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (306)                               [serial 1069] 
P [556] << PAUSE_INFUSION_ECHO >>
S [575] ->
Q [704] << PAUSE_INFUSION_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pie1:
 Pause_Infusion_Echo -> pie
Solved by: Identity (id):  P->P is tautology

Theorem (307)                               [serial 1070] 
P [705] << PAUSE_INFUSION_ECHO >>
S [576] ->
Q [605] << PAUSE_INFUSION_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pie2:
 Pause_Infusion_Echo -> Pause_Infusion_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (308)                               [serial 1071] 
P [601] << PO_ALARM() or RM_ALARM() >>
S [578] ->
Q [706] << PO_ALARM() or RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pi1:
 Pause_Infusion -> pi
Solved by: Identity (id):  P->P is tautology

Theorem (309)                               [serial 1072] 
P [707] << PO_ALARM() or RM_ALARM() >>
S [579] ->
Q [552] << PO_ALARM() or RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pi2:
 Pause_Infusion -> Pause_Infusion
Solved by: Identity (id):  P->P is tautology

Theorem (310)                               [serial 1073] 
P [597] << RM_ALARM() >>
S [581] ->
Q [708] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rme1:
 RM_Alarm_Echo -> rmae
Solved by: Identity (id):  P->P is tautology

Theorem (311)                               [serial 1074] 
P [710] << RM_ALARM() >>
S [582] ->
Q [547] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rme2:
 RM_Alarm_Echo -> RM_Alarm_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (312)                               [serial 1075] 
P [603] << PO_ALARM() >>
S [584] ->
Q [712] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poe1:
 PO_Alarm_Echo -> poae
Solved by: Identity (id):  P->P is tautology

Theorem (313)                               [serial 1076] 
P [714] << PO_ALARM() >>
S [585] ->
Q [554] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poe2:
 PO_Alarm_Echo -> PO_Alarm_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (314)                               [serial 1001] 
Why created:  All verification conditions have been proved correct. 
Solved by:  Component and Connection Proofs
 and theorems 91 160 254 259 261 265 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313:
Theorem (91) [serial 1002] used for:
  Initial proof obligations for Pulse_Oximeter_Thread.impl 
Theorem (160) [serial 1010] used for:
  Initial proof obligations for Respiration_Monitor_Thread.impl 
Theorem (254) [serial 1018] used for:
  Initial proof obligations for Coordinator_Thread.echo 
Theorem (259) [serial 1027] used for:
  Conjunction of Subcomponents' Invariants imply SysIoMT.impl's Invariant 
Theorem (261) [serial 1028] used for:
  Subcomponent's Invariant implies Coordinator.impl's Invariant 
Theorem (265) [serial 1029] used for:
  Composition of Subcomponents via Directional Connection pcc.pause_infusion -> pct.pause_infusion:
 pause_infusion -> pause_infusion 
Theorem (267) [serial 1030] used for:
  Composition of Subcomponents via Directional Connection pcp.pct.pump_rate -> pmp.pump_rate:
 pump_rate -> pump_rate 
Theorem (268) [serial 1031] used for:
  Composition of Subcomponents via Directional Connection pot.PO_Alarm -> poc.poa:
 PO_Alarm -> poa 
Theorem (269) [serial 1032] used for:
  Composition of Subcomponents via Directional Connection rmt.RM_Alarm -> rmc.rma:
 RM_Alarm -> rma 
Theorem (270) [serial 1033] used for:
  Composition of Subcomponents via Directional Connection spt.RM_Alarm_Echo -> spc.rmae:
 RM_Alarm_Echo -> rmae 
Theorem (271) [serial 1034] used for:
  Composition of Subcomponents via Directional Connection spt.Pause_Infusion -> spc.pi:
 Pause_Infusion -> pi 
Theorem (272) [serial 1035] used for:
  Composition of Subcomponents via Directional Connection spt.PO_Alarm_Echo -> spc.poae:
 PO_Alarm_Echo -> poae 
Theorem (273) [serial 1036] used for:
  Composition of Subcomponents via Directional Connection spc.PO_Alarm -> spt.PO_Alarm:
 PO_Alarm -> PO_Alarm 
Theorem (274) [serial 1037] used for:
  Composition of Subcomponents via Directional Connection spc.RM_Alarm -> spt.RM_Alarm:
 RM_Alarm -> RM_Alarm 
Theorem (275) [serial 1038] used for:
  Composition of Subcomponents via Directional Connection spc.Pause_Infusion_Echo -> spt.Pause_Infusion_Echo:
 Pause_Infusion_Echo -> Pause_Infusion_Echo 
Theorem (276) [serial 1039] used for:
  Composition of Subcomponents via Directional Connection pca_pump.pmp.infused_drug -> patient.Infused_Drug:
 infused_drug -> Infused_Drug 
Theorem (277) [serial 1040] used for:
  Composition of Subcomponents via Directional Connection pulse_oximeter.pop.poc.PO_Alarm -> coordinator.spp.spc.poa:
 PO_Alarm -> poa 
Theorem (278) [serial 1041] used for:
  Composition of Subcomponents via Directional Connection resp_monitor.rmp.rmc.RM_Alarm -> coordinator.spp.spc.rma:
 RM_Alarm -> rma 
Theorem (279) [serial 1042] used for:
  Composition of Subcomponents via Directional Connection coordinator.spp.spc.Pause_Infusion -> pca_pump.pcp.pcc.pi:
 Pause_Infusion -> pi 
Theorem (280) [serial 1043] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.infusion_set:
 infused_drug -> Infused_Drug 
Theorem (281) [serial 1044] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.pause_infusion:
 Pause_Infusion -> pause_infusion 
Theorem (282) [serial 1045] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.po_alarm:
 PO_Alarm -> PO_Alarm 
Theorem (283) [serial 1046] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.rm_alarm:
 RM_Alarm -> RM_Alarm 
Theorem (284) [serial 1047] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pd:
 infused_drug -> infused_drug 
Theorem (285) [serial 1048] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pif:
 pause_infusion -> pause_infusion 
Theorem (286) [serial 1049] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pr:
 pump_rate -> pump_rate 
Theorem (287) [serial 1050] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.pi1:
 pause_infusion -> pi 
Theorem (288) [serial 1051] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.pi2:
 pause_infusion -> pause_infusion 
Theorem (289) [serial 1052] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.PCA_Pump_Process_impl_new_connection:
 pump_rate -> pump_rate 
Theorem (290) [serial 1053] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter.impl.poa:
 PO_Alarm -> PO_Alarm 
Theorem (291) [serial 1054] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter_Process.impl.pol1:
 PO_Alarm -> poa 
Theorem (292) [serial 1055] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter_Process.impl.pol2:
 PO_Alarm -> PO_Alarm 
Theorem (293) [serial 1056] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor.impl.rma:
 RM_Alarm -> RM_Alarm 
Theorem (294) [serial 1057] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor_Process.impl.rma1:
 RM_Alarm -> rma 
Theorem (295) [serial 1058] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor_Process.impl.rma2:
 RM_Alarm -> RM_Alarm 
Theorem (296) [serial 1059] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.poa:
 PO_Alarm -> PO_Alarm 
Theorem (297) [serial 1060] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.rma:
 RM_Alarm -> RM_Alarm 
Theorem (298) [serial 1061] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.pi:
 Pause_Infusion -> Pause_Infusion 
Theorem (299) [serial 1062] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.pie:
 Pause_Infusion_Echo -> Pause_Infusion_Echo 
Theorem (300) [serial 1063] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.icp:
 PO_Alarm_Echo -> PO_Alarm_Echo 
Theorem (301) [serial 1064] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.icr:
 RM_Alarm_Echo -> RM_Alarm_Echo 
Theorem (302) [serial 1065] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poa1:
 PO_Alarm -> poa 
Theorem (303) [serial 1066] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poa2:
 PO_Alarm -> PO_Alarm 
Theorem (304) [serial 1067] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rma1:
 RM_Alarm -> rma 
Theorem (305) [serial 1068] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rma2:
 RM_Alarm -> RM_Alarm 
Theorem (306) [serial 1069] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pie1:
 Pause_Infusion_Echo -> pie 
Theorem (307) [serial 1070] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pie2:
 Pause_Infusion_Echo -> Pause_Infusion_Echo 
Theorem (308) [serial 1071] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pi1:
 Pause_Infusion -> pi 
Theorem (309) [serial 1072] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pi2:
 Pause_Infusion -> Pause_Infusion 
Theorem (310) [serial 1073] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rme1:
 RM_Alarm_Echo -> rmae 
Theorem (311) [serial 1074] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rme2:
 RM_Alarm_Echo -> RM_Alarm_Echo 
Theorem (312) [serial 1075] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poe1:
 PO_Alarm_Echo -> poae 
Theorem (313) [serial 1076] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poe2:
 PO_Alarm_Echo -> PO_Alarm_Echo 


closing proof file "/Users/brianlarson/Downloads/osate2.14.0.app/Contents/MacOS/proof.txt" 