This file, proof.txt, was produced the BLESS Proof Assistant v3.2.4
  at Fri Apr 12 17:01:13 CDT 2024 by brianlarson

Theorem (1)                               [serial 1737] 
P [198] << ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion >>
S [194] ->
Q [194] << ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion >>
Why created:    normalization of [serial 1735]
Solved by: Identity (id):  P->P is tautology

Theorem (2)                               [serial 1735] 
P [198] << ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [194] ->
Q [194] << ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1003]
Solved by: [Add unnecessary parentheses] and theorem 1:
Theorem (1) [serial 1737] used for:
    normalization of [serial 1735] 


Theorem (3)                               [serial 1003] 
P [198] << INV() >>
S [194] ->
Q [194] << ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 2:
Theorem (2) [serial 1735] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1003] 


Theorem (4)                               [serial 1004] 
P [197] << INV() >>
S [197] ->
Q [197] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by: Anything Implies True (a1tru): P->true

Theorem (5)                               [serial 1738] 
P [199] << INV() >>
S [199] ->
Q [199] << ( not PO_ALARM()@now or PO_ALARM()@now or RM_ALARM()@now or ( PO_ALARM()@now or 
RM_ALARM()@now ) )
  and ( not RM_ALARM()@now or PO_ALARM()@now or RM_ALARM()@now or ( PO_ALARM()@now or 
RM_ALARM()@now ) ) >>
Why created:  Distributing Postcondition Or-Over-And [serial 1005]
Solved by: Law of Excluded middle. (exmid)

Theorem (6)                               [serial 1005] 
P [199] << INV() >>
S [199] ->
Q [199] << ( PO_ALARM()@now or RM_ALARM()@now ) or ( not PO_ALARM()@now
  and not RM_ALARM()@now ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state check, <<M(check)>> -> <<e1 or e2 or . . . en>>
Solved by: Distribution and-over-or with wff lists. (bl.dba2owl) and theorem 5:
Theorem (5) [serial 1738] used for:
  Distributing Postcondition Or-Over-And [serial 1005] 


Theorem (7)                               [serial 1006] 
P [197] << INV() >>
S [203] ->
Q [198] << INV() >>
Why created:   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{};
Solved by: Identity (id):  P->P is tautology

Theorem (8)                               [serial 1007] 
P [198] << INV() >>
S [204] ->
Q [199] << INV() >>
Why created:   <<M(run) and x>> -> <<M(check)>> for op: run-[x]->check{};
Solved by: Identity (id):  P->P is tautology

Theorem (9)                               [serial 1745] 
P [199] << ( INV() )
  and ( PO_ALARM() or RM_ALARM() ) >>
S [206] ->
Q [206] << ( PO_ALARM() or RM_ALARM() ) iff true >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1743]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  Superfluity of Equivalence. (bl.seq)

Theorem (10)                               [serial 1743] 
P [199] << ( INV() )
  and ( PO_ALARM()@now or RM_ALARM()@now ) >>
S [206] ->
Q [206] << ( PO_ALARM() or RM_ALARM() ) iff true >>
Why created:  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|true]>> [serial 1008]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 9:
Theorem (9) [serial 1745] used for:
  Assume Present:  P = P@now = P^0   [serial 1743] 


Theorem (11)                               [serial 1746] 
P [206] << ( ( INV() )
  and ( PO_ALARM() or RM_ALARM() ) )
  and ( ( PO_ALARM() or RM_ALARM() ) iff true ) >>
S [206] ->
Q [198] << INV() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1744]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (12)                               [serial 1744] 
P [206] << ( ( INV() )
  and ( PO_ALARM()@now or RM_ALARM()@now ) )
  and ( ( PO_ALARM() or RM_ALARM() ) iff true )@now >>
S [206] ->
Q [198] << INV() >>
Why created:  applied port output <<pre and (( PO_ALARM() or RM_ALARM() ) iff true)@now>> -> <<post>> [serial 1008]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 11:
Theorem (11) [serial 1746] used for:
  Assume Present:  P = P@now = P^0   [serial 1744] 


Theorem (13)                               [serial 1008] 
P [199] << ( INV() )
  and ( PO_ALARM()@now or RM_ALARM()@now ) >>
S [206] Pause_Infusion!(true)
Q [198] << INV() >>
Why created:   <<M(check) and x>> A <<M(run)>> for alarm: check-[x]->run{A};
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 10 12:
Theorem (10) [serial 1743] used for:
  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|true]>> [serial 1008] 
Theorem (12) [serial 1744] used for:
  applied port output <<pre and (( PO_ALARM() or RM_ALARM() ) iff true)@now>> -> <<post>> [serial 1008] 


Theorem (14)                               [serial 1759] 
P [199] << ( not PO_ALARM()
  and not RM_ALARM() )
  and INV() >>
S [208] ->
Q [208] << not ( PO_ALARM() or RM_ALARM() ) >>
Why created:    normalization of [serial 1756]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (15)                               [serial 1756] 
P [199] << ( INV() )
  and ( not PO_ALARM()
  and not RM_ALARM() ) >>
S [208] ->
Q [208] << not ( PO_ALARM() or RM_ALARM() ) >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1754]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 14:
Theorem (14) [serial 1759] used for:
    normalization of [serial 1756] 


Theorem (16)                               [serial 1754] 
P [199] << ( INV() )
  and ( not PO_ALARM()@now
  and not RM_ALARM()@now ) >>
S [208] ->
Q [208] << not ( PO_ALARM() or RM_ALARM() ) >>
Why created:  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|false]>> [serial 1009]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 15:
Theorem (15) [serial 1756] used for:
  Assume Present:  P = P@now = P^0   [serial 1754] 


Theorem (17)                               [serial 1761] 
P [208] << ( ( not PO_ALARM()
  and not RM_ALARM() )
  and INV() )
  and not ( PO_ALARM() or RM_ALARM() ) >>
S [208] ->
Q [198] << INV() >>
Why created:    normalization of [serial 1757]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (18)                               [serial 1757] 
P [208] << ( ( INV() )
  and ( not PO_ALARM()
  and not RM_ALARM() ) )
  and ( not ( PO_ALARM() or RM_ALARM() ) ) >>
S [208] ->
Q [198] << INV() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1755]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 17:
Theorem (17) [serial 1761] used for:
    normalization of [serial 1757] 


Theorem (19)                               [serial 1755] 
P [208] << ( ( INV() )
  and ( not PO_ALARM()@now
  and not RM_ALARM()@now ) )
  and ( not ( PO_ALARM() or RM_ALARM() ) )@now >>
S [208] ->
Q [198] << INV() >>
Why created:  applied port output <<pre and (not ( PO_ALARM() or RM_ALARM() ))@now>> -> <<post>> [serial 1009]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 18:
Theorem (18) [serial 1757] used for:
  Assume Present:  P = P@now = P^0   [serial 1755] 


Theorem (20)                               [serial 1009] 
P [199] << ( INV() )
  and ( not PO_ALARM()@now
  and not RM_ALARM()@now ) >>
S [208] Pause_Infusion!(false)
Q [198] << INV() >>
Why created:   <<M(check) and x>> A <<M(run)>> for ok: check-[x]->run{A};
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 16 19:
Theorem (16) [serial 1754] used for:
  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|false]>> [serial 1009] 
Theorem (19) [serial 1755] used for:
  applied port output <<pre and (not ( PO_ALARM() or RM_ALARM() ))@now>> -> <<post>> [serial 1009] 


Theorem (21)                               [serial 1002] 
P [191] <<   >>
S [194] ->
Q [191] << Coordinator_Thread.simple proof obligations >>
Why created:  Initial proof obligations for Coordinator_Thread.simple
Solved by:  Component verification conditions
 [Convert asseertion to port value.] and theorems 3 4 6 7 8 13 20:
Theorem (3) [serial 1003] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (4) [serial 1004] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (6) [serial 1005] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state check, <<M(check)>> -> <<e1 or e2 or . . . en>> 
Theorem (7) [serial 1006] used for:
   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{}; 
Theorem (8) [serial 1007] used for:
   <<M(run) and x>> -> <<M(check)>> for op: run-[x]->check{}; 
Theorem (13) [serial 1008] used for:
   <<M(check) and x>> A <<M(run)>> for alarm: check-[x]->run{A}; 
Theorem (20) [serial 1009] used for:
   <<M(check) and x>> A <<M(run)>> for ok: check-[x]->run{A}; 


Theorem (22)                               [serial 1099] 
P [262] << MHR_A()
  and POA_A()
  and PSPO2_A() >>
S [247] ->
Q [247] << MHR_A()
  and POA_A()
  and PSPO2_A() >>
Why created:    normalization of [serial 1097]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (23)                               [serial 1097] 
P [262] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
S [247] ->
Q [247] << MHR_A()
  and PSPO2_A()
  and POA_A() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1011]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 22:
Theorem (22) [serial 1099] used for:
    normalization of [serial 1097] 


Theorem (24)                               [serial 1011] 
P [262] << INV_PO() >>
S [247] ->
Q [247] << MHR_A()
  and PSPO2_A()
  and POA_A() >>
Why created:  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 23:
Theorem (23) [serial 1097] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1011] 


Theorem (25)                               [serial 1102] 
P [261] << MHR_A()
  and POA_A()
  and PSPO2_A() >>
S [247] ->
Q [247] << MHR_A()
  and POA_A()
  and PSPO2_A() >>
Why created:    normalization of [serial 1100]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (26)                               [serial 1100] 
P [261] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
S [247] ->
Q [247] << MHR_A()
  and PSPO2_A()
  and POA_A() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1012]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 25:
Theorem (25) [serial 1102] used for:
    normalization of [serial 1100] 


Theorem (27)                               [serial 1012] 
P [261] << INV_PO() >>
S [247] ->
Q [247] << MHR_A()
  and PSPO2_A()
  and POA_A() >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 26:
Theorem (26) [serial 1100] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1012] 


Theorem (28)                               [serial 1013] 
P [260] << INV_PO() >>
S [260] ->
Q [260] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by: Anything Implies True (a1tru): P->true

Theorem (29)                               [serial 1014] 
P [260] << INV_PO() >>
S [265] ->
Q [261] << INV_PO() >>
Why created:   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{};
Solved by: Identity (id):  P->P is tautology

Theorem (30)                               [serial 1103] 
P [261] << INV_PO() >>
S [261] ->
Q [269] << INV_PO() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1015]
Solved by: Identity (id):  P->P is tautology

Theorem (31)                               [serial 1104] 
P [294] << INV_PO() >>
S [262] ->
Q [262] << INV_PO() >>
Why created:  <<Q3>> -> <<Q>> in sequential composition for [serial 1015]
Solved by: Identity (id):  P->P is tautology

Theorem (32)                               [serial 1175] 
P [270] << HEART_RATE = hrr
  and INV_PO() >>
S [270] ->
Q [271] << HEART_RATE = hrr
  and INV_PO() >>
Why created:    normalization of [serial 1173]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (33)                               [serial 1173] 
P [270] << ( INV_PO() )
  and hrr = HEART_RATE >>
S [270] ->
Q [271] << HEART_RATE = hrr
  and INV_PO() >>
Why created:  applied port input of value <<pre and hrr=M(Heart_Rate)>> -> <<post>> [serial 1128]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 32:
Theorem (32) [serial 1175] used for:
    normalization of [serial 1173] 


Theorem (34)                               [serial 1128] 
P [269] << INV_PO() >>
S [270] Heart_Rate?(hrr)
Q [271] << HEART_RATE = hrr
  and INV_PO() >>
Why created:    normalization of [serial 1105]
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 33:
Theorem (33) [serial 1173] used for:
  applied port input of value <<pre and hrr=M(Heart_Rate)>> -> <<post>> [serial 1128] 


Theorem (35)                               [serial 1105] 
P [269] << INV_PO() >>
S [270] Heart_Rate?(hrr)
Q [271] << hrr = HEART_RATE
  and INV_PO() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1015]
Solved by: Equality Commutes. (eqcom) and theorem 34:
Theorem (34) [serial 1128] used for:
    normalization of [serial 1105] 


Theorem (36)                               [serial 1178] 
P [272] << ( HEART_RATE = hrr
  and INV_PO() )
  and SPO2 = sp >>
S [272] ->
Q [273] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1176]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (37)                               [serial 1176] 
P [272] << ( HEART_RATE = hrr
  and INV_PO() )
  and sp = SPO2 >>
S [272] ->
Q [273] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:  applied port input of value <<pre and sp=M(Spo2_Level)>> -> <<post>> [serial 1130]
Solved by: Equality Commutes. (eqcom) and theorem 36:
Theorem (36) [serial 1178] used for:
    normalization of [serial 1176] 


Theorem (38)                               [serial 1130] 
P [271] << HEART_RATE = hrr
  and INV_PO() >>
S [272] Spo2_Level?(sp)
Q [273] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1106]
  Using: (eqcom) (bl.ancom) 
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 37:
Theorem (37) [serial 1176] used for:
  applied port input of value <<pre and sp=M(Spo2_Level)>> -> <<post>> [serial 1130] 


Theorem (39)                               [serial 1106] 
P [271] << hrr = HEART_RATE
  and INV_PO() >>
S [272] Spo2_Level?(sp)
Q [273] << hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1015]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 38:
Theorem (38) [serial 1130] used for:
    normalization of [serial 1106] 


Theorem (40)                               [serial 1183] 
P [273] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [275] ->
Q [275] << ( not ( hrr < mhr ) or hrr < mhr or sp < psp )
  and ( not ( sp < psp ) or hrr < mhr or sp < psp ) >>
Why created:  Distributing Postcondition Or-Over-And [serial 1182]
Solved by: Law of Excluded middle. (exmid)

Theorem (41)                               [serial 1182] 
P [273] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [275] ->
Q [275] << ( not ( hrr < mhr )
  and not ( sp < psp ) ) or hrr < mhr or sp < psp >>
Why created:    normalization of [serial 1180]
Solved by: Distribution and-over-or with wff lists. (bl.dba2owl) and theorem 40:
Theorem (40) [serial 1183] used for:
  Distributing Postcondition Or-Over-And [serial 1182] 


Theorem (42)                               [serial 1180] 
P [273] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [275] ->
Q [275] << ( ( not ( hrr < mhr ) )
  and ( not ( sp < psp ) ) ) or hrr < mhr or sp < psp >>
Why created:  Replacing <= with not < of [serial 1132]
Solved by: [Add unnecessary parentheses] and theorem 41:
Theorem (41) [serial 1182] used for:
    normalization of [serial 1180] 


Theorem (43)                               [serial 1132] 
P [273] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [275] ->
Q [275] << ( mhr <= hrr
  and psp <= sp ) or hrr < mhr or sp < psp >>
Why created:    normalization of [serial 1108]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) (bl.orcom) 
Solved by: 'Less than' expressed in terms of 'less than or equal to'. (ltnle) and theorem 42:
Theorem (42) [serial 1180] used for:
  Replacing <= with not < of [serial 1132] 


Theorem (44)                               [serial 1108] 
P [273] << hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 >>
S [275] ->
Q [275] << ( hrr >= mhr
  and sp >= psp ) or ( hrr < mhr ) or ( sp < psp ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1107]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 43:
Theorem (43) [serial 1132] used for:
    normalization of [serial 1108] 


Theorem (45)                               [serial 1134] 
P [275] << ( mhr <= hrr
  and psp <= sp )
  and ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() ) >>
S [277] ->
Q [277] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1115]
  Using: (eqcom) changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (46)                               [serial 1115] 
P [275] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr >= mhr
  and sp >= psp ) >>
S [277] ->
Q [277] << hrr = HEART_RATE
  and hrr >= mhr
  and sp = SPO2
  and sp >= psp
  and INV_PO() >>
Why created:  P -> P1 in concurrent composition for [serial 1112]
Solved by: Equality Commutes. (eqcom) [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 45:
Theorem (45) [serial 1134] used for:
    normalization of [serial 1115] 


Theorem (47)                               [serial 1116] 
P [279] << INV_PO() >>
S [279] ->
Q [294] << INV_PO() >>
Why created:  Qk -> Q in concurrent composition for [serial 1112]
Solved by: Identity (id):  P->P is tautology

Theorem (48)                               [serial 1192] 
P [277] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [278] ->
Q [294] << ( LOW_SPO2_HR() iff false )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:  applied wp for assignment [serial 1191]
Solved by: The negation of a proposition is equivalent to itself being equivalent to false. (nbfal)

Theorem (49)                               [serial 1191] 
P [277] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [278] poa := false
Q [294] << ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:    normalization of [serial 1189]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 48:
Theorem (48) [serial 1192] used for:
  applied wp for assignment [serial 1191] 


Theorem (50)                               [serial 1189] 
P [277] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [278] poa := false
Q [294] << ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1188]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 49:
Theorem (49) [serial 1191] used for:
    normalization of [serial 1189] 


Theorem (51)                               [serial 1188] 
P [277] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [278] poa := false
Q [294] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1136]
Solved by: Predicate Invocation. (PI) and theorem 50:
Theorem (50) [serial 1189] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1188] 


Theorem (52)                               [serial 1136] 
P [277] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [278] poa := false
Q [294] << INV_PO() >>
Why created:    normalization of [serial 1117]
  Using: (eqcom) changeAtLeastToAtMost (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 51:
Theorem (51) [serial 1188] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1136] 


Theorem (53)                               [serial 1117] 
P [277] << hrr = HEART_RATE
  and hrr >= mhr
  and sp = SPO2
  and sp >= psp
  and INV_PO() >>
S [278] poa := false
Q [294] << INV_PO() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1112]
Solved by: Equality Commutes. (eqcom) [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 52:
Theorem (52) [serial 1136] used for:
    normalization of [serial 1117] 


Theorem (54)                               [serial 1138] 
P [275] << ( mhr <= hrr
  and psp <= sp )
  and ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() ) >>
S [278] PO_Alarm!(false)
Q [279] << INV_PO() >>
Why created:    normalization of [serial 1118]
  Using: (eqcom) changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (55)                               [serial 1118] 
P [275] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr >= mhr
  and sp >= psp ) >>
S [278] PO_Alarm!(false)
Q [279] << INV_PO() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1112]
Solved by: Equality Commutes. (eqcom) [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 54:
Theorem (54) [serial 1138] used for:
    normalization of [serial 1118] 


Theorem (56)                               [serial 1112] 
P [275] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr >= mhr
  and sp >= psp ) >>
S [277]   << hrr = HEART_RATE
    and hrr >= mhr
    and sp = SPO2
    and sp >= psp
    and INV_PO() >>
  poa := false
  &
  PO_Alarm!(false)
  << INV_PO() >> 
Q [294] << INV_PO() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1109]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 46 47 53 55:
Theorem (46) [serial 1115] used for:
  P -> P1 in concurrent composition for [serial 1112] 
Theorem (47) [serial 1116] used for:
  Qk -> Q in concurrent composition for [serial 1112] 
Theorem (53) [serial 1117] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1112] 
Theorem (55) [serial 1118] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1112] 


Theorem (57)                               [serial 1109] 
P [275] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr >= mhr
  and sp >= psp ) >>
S [276]   {
    << hrr = HEART_RATE
      and hrr >= mhr
      and sp = SPO2
      and sp >= psp
      and INV_PO() >>
    poa := false
    &
    PO_Alarm!(false)
    << INV_PO() >> 
  } 
Q [294] << INV_PO() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1107]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 56:
Theorem (56) [serial 1112] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1109] 


Theorem (58)                               [serial 1140] 
P [275] << ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() )
  and hrr < mhr >>
S [283] ->
Q [283] << hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1119]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (59)                               [serial 1119] 
P [275] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr < mhr ) >>
S [283] ->
Q [283] << hrr = HEART_RATE
  and hrr < mhr
  and sp = SPO2
  and INV_PO() >>
Why created:  P -> P1 in concurrent composition for [serial 1113]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 58:
Theorem (58) [serial 1140] used for:
    normalization of [serial 1119] 


Theorem (60)                               [serial 1120] 
P [285] << INV_PO() >>
S [285] ->
Q [294] << INV_PO() >>
Why created:  Qk -> Q in concurrent composition for [serial 1113]
Solved by: Identity (id):  P->P is tautology

Theorem (61)                               [serial 1253] 
P [283] << ( ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp )
  and hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp >>
S [284] poa := true
Q [294] << ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:    normalization of [serial 1251]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (62)                               [serial 1251] 
P [283] << hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp
  and ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
S [284] poa := true
Q [294] << ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1250]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 61:
Theorem (61) [serial 1253] used for:
    normalization of [serial 1251] 


Theorem (63)                               [serial 1250] 
P [283] << hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp
  and ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
S [284] poa := true
Q [294] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1142]
Solved by: Predicate Invocation. (PI) and theorem 62:
Theorem (62) [serial 1251] used for:
  Substituted assertions' predicates for labels  [serial 1250] 


Theorem (64)                               [serial 1142] 
P [283] << hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [284] poa := true
Q [294] << INV_PO() >>
Why created:    normalization of [serial 1121]
  Using: (eqcom) (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 63:
Theorem (63) [serial 1250] used for:
  Substituted assertions' predicates for labels  [serial 1142] 


Theorem (65)                               [serial 1121] 
P [283] << hrr = HEART_RATE
  and hrr < mhr
  and sp = SPO2
  and INV_PO() >>
S [284] poa := true
Q [294] << INV_PO() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1113]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 64:
Theorem (64) [serial 1142] used for:
    normalization of [serial 1121] 


Theorem (66)                               [serial 1144] 
P [275] << ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() )
  and hrr < mhr >>
S [284] PO_Alarm!(true)
Q [285] << INV_PO() >>
Why created:    normalization of [serial 1122]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (67)                               [serial 1122] 
P [275] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr < mhr ) >>
S [284] PO_Alarm!(true)
Q [285] << INV_PO() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1113]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 66:
Theorem (66) [serial 1144] used for:
    normalization of [serial 1122] 


Theorem (68)                               [serial 1113] 
P [275] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr < mhr ) >>
S [283]   << hrr = HEART_RATE
    and hrr < mhr
    and sp = SPO2
    and INV_PO() >>
  poa := true
  &
  PO_Alarm!(true)
  << INV_PO() >> 
Q [294] << INV_PO() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1110]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 59 60 65 67:
Theorem (59) [serial 1119] used for:
  P -> P1 in concurrent composition for [serial 1113] 
Theorem (60) [serial 1120] used for:
  Qk -> Q in concurrent composition for [serial 1113] 
Theorem (65) [serial 1121] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1113] 
Theorem (67) [serial 1122] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1113] 


Theorem (69)                               [serial 1110] 
P [275] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr < mhr ) >>
S [282]   {
    << hrr = HEART_RATE
      and hrr < mhr
      and sp = SPO2
      and INV_PO() >>
    poa := true
    &
    PO_Alarm!(true)
    << INV_PO() >> 
  } 
Q [294] << INV_PO() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1107]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 68:
Theorem (68) [serial 1113] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1110] 


Theorem (70)                               [serial 1146] 
P [275] << ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() )
  and sp < psp >>
S [289] ->
Q [289] << sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1123]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (71)                               [serial 1123] 
P [275] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( sp < psp ) >>
S [289] ->
Q [289] << hrr = HEART_RATE
  and sp < psp
  and sp = SPO2
  and INV_PO() >>
Why created:  P -> P1 in concurrent composition for [serial 1114]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 70:
Theorem (70) [serial 1146] used for:
    normalization of [serial 1123] 


Theorem (72)                               [serial 1124] 
P [291] << INV_PO() >>
S [291] ->
Q [294] << INV_PO() >>
Why created:  Qk -> Q in concurrent composition for [serial 1114]
Solved by: Identity (id):  P->P is tautology

Theorem (73)                               [serial 1273] 
P [289] << ( ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp )
  and sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp >>
S [290] ->
Q [294] << ( LOW_SPO2_HR() iff true )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:  applied wp for assignment [serial 1272]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (74)                               [serial 1272] 
P [289] << ( ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp )
  and sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp >>
S [290] poa := true
Q [294] << ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:    normalization of [serial 1270]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 73:
Theorem (73) [serial 1273] used for:
  applied wp for assignment [serial 1272] 


Theorem (75)                               [serial 1270] 
P [289] << sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp
  and ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
S [290] poa := true
Q [294] << ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1269]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 74:
Theorem (74) [serial 1272] used for:
    normalization of [serial 1270] 


Theorem (76)                               [serial 1269] 
P [289] << sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp
  and ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
S [290] poa := true
Q [294] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1148]
Solved by: Predicate Invocation. (PI) and theorem 75:
Theorem (75) [serial 1270] used for:
  Substituted assertions' predicates for labels  [serial 1269] 


Theorem (77)                               [serial 1148] 
P [289] << sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [290] poa := true
Q [294] << INV_PO() >>
Why created:    normalization of [serial 1125]
  Using: (eqcom) (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 76:
Theorem (76) [serial 1269] used for:
  Substituted assertions' predicates for labels  [serial 1148] 


Theorem (78)                               [serial 1125] 
P [289] << hrr = HEART_RATE
  and sp < psp
  and sp = SPO2
  and INV_PO() >>
S [290] poa := true
Q [294] << INV_PO() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1114]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 77:
Theorem (77) [serial 1148] used for:
    normalization of [serial 1125] 


Theorem (79)                               [serial 1150] 
P [275] << ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() )
  and sp < psp >>
S [290] PO_Alarm!(true)
Q [291] << INV_PO() >>
Why created:    normalization of [serial 1126]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (80)                               [serial 1126] 
P [275] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( sp < psp ) >>
S [290] PO_Alarm!(true)
Q [291] << INV_PO() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1114]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 79:
Theorem (79) [serial 1150] used for:
    normalization of [serial 1126] 


Theorem (81)                               [serial 1114] 
P [275] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( sp < psp ) >>
S [289]   << hrr = HEART_RATE
    and sp < psp
    and sp = SPO2
    and INV_PO() >>
  poa := true
  &
  PO_Alarm!(true)
  << INV_PO() >> 
Q [294] << INV_PO() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1111]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 71 72 78 80:
Theorem (71) [serial 1123] used for:
  P -> P1 in concurrent composition for [serial 1114] 
Theorem (72) [serial 1124] used for:
  Qk -> Q in concurrent composition for [serial 1114] 
Theorem (78) [serial 1125] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1114] 
Theorem (80) [serial 1126] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1114] 


Theorem (82)                               [serial 1111] 
P [275] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( sp < psp ) >>
S [288]   {
    << hrr = HEART_RATE
      and sp < psp
      and sp = SPO2
      and INV_PO() >>
    poa := true
    &
    PO_Alarm!(true)
    << INV_PO() >> 
  } 
Q [294] << INV_PO() >>
Why created:    <<P and B2>> S2 <<Q>> in alternative for [serial 1107]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 81:
Theorem (81) [serial 1114] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1111] 


Theorem (83)                               [serial 1107] 
P [273] << hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 >>
S [275]   if 
    (hrr >= mhr
    and sp >= psp)~> 
        {
          << hrr = HEART_RATE
            and hrr >= mhr
            and sp = SPO2
            and sp >= psp
            and INV_PO() >>
          poa := false
          &
          PO_Alarm!(false)
          << INV_PO() >> 
        }  
  []
    (hrr < mhr)~> 
        {
          << hrr = HEART_RATE
            and hrr < mhr
            and sp = SPO2
            and INV_PO() >>
          poa := true
          &
          PO_Alarm!(true)
          << INV_PO() >> 
        }  
  []
    (sp < psp)~> 
        {
          << hrr = HEART_RATE
            and sp < psp
            and sp = SPO2
            and INV_PO() >>
          poa := true
          &
          PO_Alarm!(true)
          << INV_PO() >> 
        }  
  fi
Q [294] << INV_PO() >>
Why created:  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1015]
Solved by: and theorems 44 57 69 82:
Theorem (44) [serial 1108] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1107] 
Theorem (57) [serial 1109] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1107] 
Theorem (69) [serial 1110] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1107] 
Theorem (82) [serial 1111] used for:
    <<P and B2>> S2 <<Q>> in alternative for [serial 1107] 


Theorem (84)                               [serial 1015] 
P [261] << INV_PO() >>
S [269]   << INV_PO() >>
  Heart_Rate?(hrr)
  ;
  << hrr = HEART_RATE
    and INV_PO() >>
  Spo2_Level?(sp)
  << hrr = HEART_RATE
    and INV_PO()
    and sp = SPO2 >>
  ;
    if 
      (hrr >= mhr
      and sp >= psp)~> 
          {
            << hrr = HEART_RATE
              and hrr >= mhr
              and sp = SPO2
              and sp >= psp
              and INV_PO() >>
            poa := false
            &
            PO_Alarm!(false)
            << INV_PO() >> 
          }  
    []
      (hrr < mhr)~> 
          {
            << hrr = HEART_RATE
              and hrr < mhr
              and sp = SPO2
              and INV_PO() >>
            poa := true
            &
            PO_Alarm!(true)
            << INV_PO() >> 
          }  
    []
      (sp < psp)~> 
          {
            << hrr = HEART_RATE
              and sp < psp
              and sp = SPO2
              and INV_PO() >>
            poa := true
            &
            PO_Alarm!(true)
            << INV_PO() >> 
          }  
    fi
  << INV_PO() >> 
Q [262] << INV_PO() >>
Why created:   <<M(run) and x>> A <<M(check_echo)>> for got_hrr_spo2: run-[x]->check_echo{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 30 31 35 39 83:
Theorem (30) [serial 1103] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1015] 
Theorem (31) [serial 1104] used for:
  <<Q3>> -> <<Q>> in sequential composition for [serial 1015] 
Theorem (35) [serial 1105] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1015] 
Theorem (39) [serial 1106] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1015] 
Theorem (83) [serial 1107] used for:
  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1015] 


Theorem (85)                               [serial 1368] 
P [298] << ( INV_PO() )
  and ( PO_Alarm_Echo@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [298] ->
Q [300] << INV_PO()
  and PO_Alarm_Echo@now >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1016]
Solved by: And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

Theorem (86)                               [serial 1369] 
P [310] << INV_PO() >>
S [261] ->
Q [261] << INV_PO() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1016]
Solved by: Identity (id):  P->P is tautology

Theorem (87)                               [serial 1371] 
P [300] << ( INV_PO()
  and PO_Alarm_Echo@now )
  and ( echo_val iff PO_Alarm_Echo@now ) >>
S [303] ->
Q [303] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
Why created:  <<P and v=e>> -> <<A>> in behavior action block for [serial 1370]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (88)                               [serial 1374] 
P [303] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
S [303] ->
Q [303] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1372]
Solved by: Identity (id):  P->P is tautology

Theorem (89)                               [serial 1375] 
P [308] << INV_PO() >>
S [308] ->
Q [308] << INV_PO() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1372]
Solved by: Identity (id):  P->P is tautology

Theorem (90)                               [serial 1385] 
P [303] << ( PO_Alarm_Echo iff echo_val )
  and INV_PO() >>
S [304] ->
Q [304] << ( echo_val iff poa ) or not ( echo_val iff poa ) >>
Why created:    normalization of [serial 1377]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (91)                               [serial 1377] 
P [303] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
S [304] ->
Q [304] << ( echo_val iff poa ) or ( not ( echo_val iff poa ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1376]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 90:
Theorem (90) [serial 1385] used for:
    normalization of [serial 1377] 


Theorem (92)                               [serial 1389] 
P [304] << ( ( PO_Alarm_Echo iff echo_val )
  and INV_PO() )
  and ( echo_val iff poa ) >>
S [304] ->
Q [308] << INV_PO() >>
Why created:    normalization of [serial 1387]
  Using: (bicom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (93)                               [serial 1387] 
P [304] << ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( echo_val iff poa ) >>
S [304] ->
Q [308] << INV_PO() >>
Why created:    <<P>> -> <<Q>>
  for [serial 1378]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 92:
Theorem (92) [serial 1389] used for:
    normalization of [serial 1387] 


Theorem (94)                               [serial 1378] 
P [304] << ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( echo_val iff poa ) >>
S [304] skip
Q [308] << INV_PO() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1376]
Solved by:  Skip Means Implication:  <<P>> skip <<Q>>  is  <<P>> -> <<Q>>
 and theorem 93:
Theorem (93) [serial 1387] used for:
    <<P>> -> <<Q>>
  for [serial 1378] 


Theorem (95)                               [serial 1397] 
P [304] << ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( not ( echo_val iff poa ) ) >>
S [306] ->
Q [306] << true >>
Why created:  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1379]
Solved by: Anything Implies True (a1tru): P->true

Theorem (96)                               [serial 1401] 
P [306] << ( ( ( PO_Alarm_Echo iff echo_val )
  and INV_PO() )
  and not ( echo_val iff poa ) )
  and true >>
S [306] ->
Q [308] << INV_PO() >>
Why created:    normalization of [serial 1399]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (97)                               [serial 1399] 
P [306] << ( ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( not ( echo_val iff poa ) ) )
  and true >>
S [306] ->
Q [308] << INV_PO() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1398]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 96:
Theorem (96) [serial 1401] used for:
    normalization of [serial 1399] 


Theorem (98)                               [serial 1398] 
P [306] << ( ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( not ( echo_val iff poa ) ) )
  and true@now >>
S [306] ->
Q [308] << INV_PO() >>
Why created:  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1379]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 97:
Theorem (97) [serial 1399] used for:
  Assume Present:  P = P@now = P^0   [serial 1398] 


Theorem (99)                               [serial 1379] 
P [304] << ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( not ( echo_val iff poa ) ) >>
S [306] Lost_Confirmation!
Q [308] << INV_PO() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1376]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 95 98:
Theorem (95) [serial 1397] used for:
  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1379] 
Theorem (98) [serial 1398] used for:
  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1379] 


Theorem (100)                               [serial 1376] 
P [303] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
S [304]   if 
    (echo_val iff poa)~> 
      skip 
  []
    (not ( echo_val iff poa ))~> 
      Lost_Confirmation! 
  fi
Q [308] << INV_PO() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1372]
Solved by: and theorems 91 94 99:
Theorem (91) [serial 1377] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1376] 
Theorem (94) [serial 1378] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1376] 
Theorem (99) [serial 1379] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1376] 


Theorem (101)                               [serial 1372] 
P [303] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
S [303] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
  if 
    (echo_val iff poa)~> 
      skip 
  []
    (not ( echo_val iff poa ))~> 
      Lost_Confirmation! 
  fi
<< INV_PO() >>
Q [308] << INV_PO() >>
Why created:  <<A>> S <<B>> in behavior action block for [serial 1370]
Solved by: null and theorems 88 89 100:
Theorem (88) [serial 1374] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1372] 
Theorem (89) [serial 1375] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1372] 
Theorem (100) [serial 1376] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1372] 


Theorem (102)                               [serial 1373] 
P [308] << INV_PO() >>
S [301] ->
Q [310] << INV_PO() >>
Why created:  <<B>> -> <<Q>> in behavior action block for [serial 1370]
Solved by: Identity (id):  P->P is tautology

Theorem (103)                               [serial 1370] 
P [300] << INV_PO()
  and PO_Alarm_Echo@now >>
S [301] declare 
   echo_val ~ boolean := PO_Alarm_Echo?   {
  << INV_PO()
    and ( echo_val iff PO_Alarm_Echo ) >>
    if 
      (echo_val iff poa)~> 
        skip 
    []
      (not ( echo_val iff poa ))~> 
        Lost_Confirmation! 
    fi
  << INV_PO() >>
  } 
Q [310] << INV_PO() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1016]
Solved by: Behavior Action Block (BAB): 
     <<P and x=e>> -> <<A>>
     <<A>> S <<B>> 
     <<B>> -> <<Q>>
----------------------------------------------------
<<P>> declare variable v~y:=e; { <<A>> S <<B>> } <<Q>> and theorems 87 101 102:
Theorem (87) [serial 1371] used for:
  <<P and v=e>> -> <<A>> in behavior action block for [serial 1370] 
Theorem (101) [serial 1372] used for:
  <<A>> S <<B>> in behavior action block for [serial 1370] 
Theorem (102) [serial 1373] used for:
  <<B>> -> <<Q>> in behavior action block for [serial 1370] 


Theorem (104)                               [serial 1016] 
P [298] << ( INV_PO() )
  and ( PO_Alarm_Echo@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [300] << INV_PO()
  and PO_Alarm_Echo@now >>
declare 
   echo_val ~ boolean := PO_Alarm_Echo?   {
  << INV_PO()
    and ( echo_val iff PO_Alarm_Echo ) >>
    if 
      (echo_val iff poa)~> 
        skip 
    []
      (not ( echo_val iff poa ))~> 
        Lost_Confirmation! 
    fi
  << INV_PO() >>
  } 
<< INV_PO() >>
Q [261] << INV_PO() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A};
Solved by: null and theorems 85 86 103:
Theorem (85) [serial 1368] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1016] 
Theorem (86) [serial 1369] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1016] 
Theorem (103) [serial 1370] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1016] 


Theorem (105)                               [serial 1411] 
P [313] << ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and INV_PO()
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [314] ->
Q [314] << true >>
Why created:    normalization of [serial 1407]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (106)                               [serial 1407] 
P [313] << ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [314] ->
Q [314] << true >>
Why created:  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1406]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 105:
Theorem (105) [serial 1411] used for:
    normalization of [serial 1407] 


Theorem (107)                               [serial 1413] 
P [314] << ( ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and INV_PO()
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) )
  and true >>
S [314] ->
Q [261] << INV_PO() >>
Why created:    normalization of [serial 1409]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (108)                               [serial 1409] 
P [314] << ( ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) )
  and true >>
S [314] ->
Q [261] << INV_PO() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1408]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 107:
Theorem (107) [serial 1413] used for:
    normalization of [serial 1409] 


Theorem (109)                               [serial 1408] 
P [314] << ( ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) )
  and true@now >>
S [314] ->
Q [261] << INV_PO() >>
Why created:  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1406]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 108:
Theorem (108) [serial 1409] used for:
  Assume Present:  P = P@now = P^0   [serial 1408] 


Theorem (110)                               [serial 1406] 
P [313] << ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [314] Lost_Confirmation!
Q [261] << INV_PO() >>
Why created:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1017]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 106 109:
Theorem (106) [serial 1407] used for:
  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1406] 
Theorem (109) [serial 1408] used for:
  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1406] 


Theorem (111)                               [serial 1017] 
P [313] << ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [314] Lost_Confirmation!
Q [261] << INV_PO() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A};
Solved by: null and theorem 110:
Theorem (110) [serial 1406] used for:
  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1017] 


Theorem (112)                               [serial 1010] 
P [241] <<   >>
S [247] ->
Q [241] << Pulse_Oximeter_Thread.impl proof obligations >>
Why created:  Initial proof obligations for Pulse_Oximeter_Thread.impl
Solved by:  Component verification conditions
 and theorems 24 27 28 29 84 104 111:
Theorem (24) [serial 1011] used for:
  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition. 
Theorem (27) [serial 1012] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (28) [serial 1013] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (29) [serial 1014] used for:
   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{}; 
Theorem (84) [serial 1015] used for:
   <<M(run) and x>> A <<M(check_echo)>> for got_hrr_spo2: run-[x]->check_echo{A}; 
Theorem (104) [serial 1016] used for:
   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A}; 
Theorem (111) [serial 1017] used for:
   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A}; 


Theorem (113)                               [serial 1019] 
P [431] << RA()
  and MRP_A() >>
S [419] ->
Q [419] << RA()
  and MRP_A() >>
Why created:  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition.
Solved by: Identity (id):  P->P is tautology

Theorem (114)                               [serial 1020] 
P [430] << RA()
  and MRP_A() >>
S [419] ->
Q [419] << RA()
  and MRP_A() >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by: Identity (id):  P->P is tautology

Theorem (115)                               [serial 1021] 
P [429] << RA()
  and MRP_A() >>
S [429] ->
Q [429] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by: Anything Implies True (a1tru): P->true

Theorem (116)                               [serial 1022] 
P [429] << RA()
  and MRP_A() >>
S [435] ->
Q [430] << RA()
  and MRP_A() >>
Why created:   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{};
Solved by: Identity (id):  P->P is tautology

Theorem (117)                               [serial 1458] 
P [439] << ( MRP_A()
  and RA() )
  and rpr = RESPIRATION_RATE >>
S [439] ->
Q [440] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
Why created:  applied port input of value <<pre and rpr=M(RP_Rate)>> -> <<post>> [serial 1435]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (118)                               [serial 1435] 
P [430] << MRP_A()
  and RA() >>
S [439] RP_Rate?(rpr)
Q [440] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1419]
  Using: (eqcom) (bl.ancom) 
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 117:
Theorem (117) [serial 1458] used for:
  applied port input of value <<pre and rpr=M(RP_Rate)>> -> <<post>> [serial 1435] 


Theorem (119)                               [serial 1419] 
P [430] << RA()
  and MRP_A() >>
S [439] RP_Rate?(rpr)
Q [440] << rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1023]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 118:
Theorem (118) [serial 1435] used for:
    normalization of [serial 1419] 


Theorem (120)                               [serial 1464] 
P [440] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [442] ->
Q [442] << rpr < mrp or not ( rpr < mrp ) >>
Why created:    normalization of [serial 1462]
  Using: ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (121)                               [serial 1462] 
P [440] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [442] ->
Q [442] << rpr < mrp or ( not ( rpr < mrp ) ) >>
Why created:  Replacing <= with not < of [serial 1437]
Solved by: [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 120:
Theorem (120) [serial 1464] used for:
    normalization of [serial 1462] 


Theorem (122)                               [serial 1437] 
P [440] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [442] ->
Q [442] << rpr < mrp or mrp <= rpr >>
Why created:    normalization of [serial 1421]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.orcom) 
Solved by: 'Less than' expressed in terms of 'less than or equal to'. (ltnle) and theorem 121:
Theorem (121) [serial 1462] used for:
  Replacing <= with not < of [serial 1437] 


Theorem (123)                               [serial 1421] 
P [440] << rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() >>
S [442] ->
Q [442] << ( rpr >= mrp ) or ( rpr < mrp ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1420]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Disjunction Commutes. (bl.orcom) and theorem 122:
Theorem (122) [serial 1437] used for:
    normalization of [serial 1421] 


Theorem (124)                               [serial 1439] 
P [442] << ( RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() )
  and mrp <= rpr >>
S [444] ->
Q [444] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1426]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (125)                               [serial 1426] 
P [442] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr >= mrp ) >>
S [444] ->
Q [444] << rpr = RESPIRATION_RATE
  and rpr >= mrp
  and MRP_A()
  and RA() >>
Why created:  P -> P1 in concurrent composition for [serial 1424]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 124:
Theorem (124) [serial 1439] used for:
    normalization of [serial 1426] 


Theorem (126)                               [serial 1441] 
P [446] << MRP_A()
  and RA() >>
S [446] ->
Q [431] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1427]
Solved by: Identity (id):  P->P is tautology

Theorem (127)                               [serial 1427] 
P [446] << RA()
  and MRP_A() >>
S [446] ->
Q [431] << RA()
  and MRP_A() >>
Why created:  Qk -> Q in concurrent composition for [serial 1424]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 126:
Theorem (126) [serial 1441] used for:
    normalization of [serial 1427] 


Theorem (128)                               [serial 1471] 
P [444] << ( LOW_RP() iff rma )
  and mrp <= rpr
  and MINIMUM_RESPIRATION_RATE = mrp
  and RESPIRATION_RATE = rpr >>
S [445] ->
Q [431] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE iff false )
  and MINIMUM_RESPIRATION_RATE = mrp >>
Why created:    normalization of [serial 1469]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: The negation of a proposition is equivalent to itself being equivalent to false. (nbfal)

Theorem (129)                               [serial 1469] 
P [444] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( rma iff LOW_RP() ) >>
S [445] ->
Q [431] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( false iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1468]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 128:
Theorem (128) [serial 1471] used for:
    normalization of [serial 1469] 


Theorem (130)                               [serial 1468] 
P [444] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [445] ->
Q [431] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( false iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) >>
Why created:  applied wp for assignment [serial 1467]
Solved by: Predicate Invocation. (PI) and theorem 129:
Theorem (129) [serial 1469] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1468] 


Theorem (131)                               [serial 1467] 
P [444] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [445] rma := false
Q [431] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( rma iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1466]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 130:
Theorem (130) [serial 1468] used for:
  applied wp for assignment [serial 1467] 


Theorem (132)                               [serial 1466] 
P [444] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [445] rma := false
Q [431] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( rma iff LOW_RP() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1443]
Solved by: Predicate Invocation. (PI) and theorem 131:
Theorem (131) [serial 1467] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1466] 


Theorem (133)                               [serial 1443] 
P [444] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [445] rma := false
Q [431] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1428]
  Using: (eqcom) changeAtLeastToAtMost (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 132:
Theorem (132) [serial 1466] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1443] 


Theorem (134)                               [serial 1428] 
P [444] << rpr = RESPIRATION_RATE
  and rpr >= mrp
  and MRP_A()
  and RA() >>
S [445] rma := false
Q [431] << RA()
  and MRP_A() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1424]
Solved by: Equality Commutes. (eqcom) [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 133:
Theorem (133) [serial 1443] used for:
    normalization of [serial 1428] 


Theorem (135)                               [serial 1445] 
P [442] << ( RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() )
  and mrp <= rpr >>
S [445] RM_Alarm!(false)
Q [446] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1429]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (136)                               [serial 1429] 
P [442] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr >= mrp ) >>
S [445] RM_Alarm!(false)
Q [446] << RA()
  and MRP_A() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1424]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 135:
Theorem (135) [serial 1445] used for:
    normalization of [serial 1429] 


Theorem (137)                               [serial 1424] 
P [442] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr >= mrp ) >>
S [444]   << rpr = RESPIRATION_RATE
    and rpr >= mrp
    and MRP_A()
    and RA() >>
  rma := false
  &
  RM_Alarm!(false)
  << RA()
    and MRP_A() >> 
Q [431] << RA()
  and MRP_A() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1422]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 125 127 134 136:
Theorem (125) [serial 1426] used for:
  P -> P1 in concurrent composition for [serial 1424] 
Theorem (127) [serial 1427] used for:
  Qk -> Q in concurrent composition for [serial 1424] 
Theorem (134) [serial 1428] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1424] 
Theorem (136) [serial 1429] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1424] 


Theorem (138)                               [serial 1422] 
P [442] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr >= mrp ) >>
S [443]   {
    << rpr = RESPIRATION_RATE
      and rpr >= mrp
      and MRP_A()
      and RA() >>
    rma := false
    &
    RM_Alarm!(false)
    << RA()
      and MRP_A() >> 
  } 
Q [431] << RA()
  and MRP_A() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1420]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 137:
Theorem (137) [serial 1424] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1422] 


Theorem (139)                               [serial 1447] 
P [442] << ( RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() )
  and rpr < mrp >>
S [451] ->
Q [451] << rpr < mrp
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1430]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (140)                               [serial 1430] 
P [442] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr < mrp ) >>
S [451] ->
Q [451] << rpr = RESPIRATION_RATE
  and rpr < mrp
  and MRP_A()
  and RA() >>
Why created:  P -> P1 in concurrent composition for [serial 1425]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 139:
Theorem (139) [serial 1447] used for:
    normalization of [serial 1430] 


Theorem (141)                               [serial 1449] 
P [453] << MRP_A()
  and RA() >>
S [453] ->
Q [431] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1431]
Solved by: Identity (id):  P->P is tautology

Theorem (142)                               [serial 1431] 
P [453] << RA()
  and MRP_A() >>
S [453] ->
Q [431] << RA()
  and MRP_A() >>
Why created:  Qk -> Q in concurrent composition for [serial 1425]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 141:
Theorem (141) [serial 1449] used for:
    normalization of [serial 1431] 


Theorem (143)                               [serial 1481] 
P [451] << rpr < mrp
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [452] ->
Q [431] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( true iff LOW_RP() ) >>
Why created:  applied wp for assignment [serial 1480]
Solved by: Superfluity of Equivalence. (bl.seq)

Theorem (144)                               [serial 1480] 
P [451] << rpr < mrp
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [452] rma := true
Q [431] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( rma iff LOW_RP() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1451]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 143:
Theorem (143) [serial 1481] used for:
  applied wp for assignment [serial 1480] 


Theorem (145)                               [serial 1451] 
P [451] << rpr < mrp
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [452] rma := true
Q [431] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1432]
  Using: (eqcom) (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 144:
Theorem (144) [serial 1480] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1451] 


Theorem (146)                               [serial 1432] 
P [451] << rpr = RESPIRATION_RATE
  and rpr < mrp
  and MRP_A()
  and RA() >>
S [452] rma := true
Q [431] << RA()
  and MRP_A() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1425]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 145:
Theorem (145) [serial 1451] used for:
    normalization of [serial 1432] 


Theorem (147)                               [serial 1453] 
P [442] << ( RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() )
  and rpr < mrp >>
S [452] RM_Alarm!(true)
Q [453] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1433]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (148)                               [serial 1433] 
P [442] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr < mrp ) >>
S [452] RM_Alarm!(true)
Q [453] << RA()
  and MRP_A() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1425]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 147:
Theorem (147) [serial 1453] used for:
    normalization of [serial 1433] 


Theorem (149)                               [serial 1425] 
P [442] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr < mrp ) >>
S [451]   << rpr = RESPIRATION_RATE
    and rpr < mrp
    and MRP_A()
    and RA() >>
  rma := true
  &
  RM_Alarm!(true)
  << RA()
    and MRP_A() >> 
Q [431] << RA()
  and MRP_A() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1423]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 140 142 146 148:
Theorem (140) [serial 1430] used for:
  P -> P1 in concurrent composition for [serial 1425] 
Theorem (142) [serial 1431] used for:
  Qk -> Q in concurrent composition for [serial 1425] 
Theorem (146) [serial 1432] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1425] 
Theorem (148) [serial 1433] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1425] 


Theorem (150)                               [serial 1423] 
P [442] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr < mrp ) >>
S [450]   {
    << rpr = RESPIRATION_RATE
      and rpr < mrp
      and MRP_A()
      and RA() >>
    rma := true
    &
    RM_Alarm!(true)
    << RA()
      and MRP_A() >> 
  } 
Q [431] << RA()
  and MRP_A() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1420]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 149:
Theorem (149) [serial 1425] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1423] 


Theorem (151)                               [serial 1420] 
P [440] << rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() >>
S [442]   if 
    (rpr >= mrp)~> 
        {
          << rpr = RESPIRATION_RATE
            and rpr >= mrp
            and MRP_A()
            and RA() >>
          rma := false
          &
          RM_Alarm!(false)
          << RA()
            and MRP_A() >> 
        }  
  []
    (rpr < mrp)~> 
        {
          << rpr = RESPIRATION_RATE
            and rpr < mrp
            and MRP_A()
            and RA() >>
          rma := true
          &
          RM_Alarm!(true)
          << RA()
            and MRP_A() >> 
        }  
  fi
Q [431] << RA()
  and MRP_A() >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1023]
Solved by: and theorems 123 138 150:
Theorem (123) [serial 1421] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1420] 
Theorem (138) [serial 1422] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1420] 
Theorem (150) [serial 1423] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1420] 


Theorem (152)                               [serial 1023] 
P [430] << RA()
  and MRP_A() >>
S [439]   RP_Rate?(rpr)
  << rpr = RESPIRATION_RATE
    and MRP_A()
    and RA() >>
  ;
    if 
      (rpr >= mrp)~> 
          {
            << rpr = RESPIRATION_RATE
              and rpr >= mrp
              and MRP_A()
              and RA() >>
            rma := false
            &
            RM_Alarm!(false)
            << RA()
              and MRP_A() >> 
          }  
    []
      (rpr < mrp)~> 
          {
            << rpr = RESPIRATION_RATE
              and rpr < mrp
              and MRP_A()
              and RA() >>
            rma := true
            &
            RM_Alarm!(true)
            << RA()
              and MRP_A() >> 
          }  
    fi 
Q [431] << RA()
  and MRP_A() >>
Why created:   <<M(run) and x>> A <<M(check_echo)>> for got_rp: run-[x]->check_echo{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 119 151:
Theorem (119) [serial 1419] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1023] 
Theorem (151) [serial 1420] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1023] 


Theorem (153)                               [serial 1525] 
P [458] << ( MRP_A()
  and RA() )
  and RM_Alarm_Echo@now
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [458] ->
Q [460] << RM_Alarm_Echo@now
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1512]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (154)                               [serial 1512] 
P [458] << ( RA()
  and MRP_A() )
  and ( RM_Alarm_Echo@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [458] ->
Q [460] << RA()
  and MRP_A()
  and RM_Alarm_Echo@now >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1024]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 153:
Theorem (153) [serial 1525] used for:
    normalization of [serial 1512] 


Theorem (155)                               [serial 1527] 
P [469] << MRP_A()
  and RA() >>
S [430] ->
Q [430] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1513]
Solved by: Identity (id):  P->P is tautology

Theorem (156)                               [serial 1513] 
P [469] << RA()
  and MRP_A() >>
S [430] ->
Q [430] << RA()
  and MRP_A() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1024]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 155:
Theorem (155) [serial 1527] used for:
    normalization of [serial 1513] 


Theorem (157)                               [serial 1529] 
P [460] << ( RM_Alarm_Echo@now
  and MRP_A()
  and RA() )
  and ( RM_Alarm_Echo@now iff echo_val ) >>
S [462] ->
Q [462] << ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1515]
  Using: (bl.ancom) (bicom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (158)                               [serial 1515] 
P [460] << ( RA()
  and MRP_A()
  and RM_Alarm_Echo@now )
  and ( echo_val iff RM_Alarm_Echo@now ) >>
S [462] ->
Q [462] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
Why created:  <<P and v=e>> -> <<A>> in behavior action block for [serial 1514]
Solved by: Conjunction Commutes. (bl.ancom) Biconditional (iff) Commutes. (bicom) and theorem 157:
Theorem (157) [serial 1529] used for:
    normalization of [serial 1515] 


Theorem (159)                               [serial 1531] 
P [462] << ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() >>
S [462] ->
Q [462] << ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1518]
  Using: (bicom) (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (160)                               [serial 1518] 
P [462] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
S [462] ->
Q [462] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1516]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 159:
Theorem (159) [serial 1531] used for:
    normalization of [serial 1518] 


Theorem (161)                               [serial 1533] 
P [467] << MRP_A()
  and RA() >>
S [467] ->
Q [467] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1519]
Solved by: Identity (id):  P->P is tautology

Theorem (162)                               [serial 1519] 
P [467] << RA()
  and MRP_A() >>
S [467] ->
Q [467] << RA()
  and MRP_A() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1516]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 161:
Theorem (161) [serial 1533] used for:
    normalization of [serial 1519] 


Theorem (163)                               [serial 1535] 
P [462] << ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() >>
S [463] ->
Q [463] << ( echo_val iff rma ) or not ( echo_val iff rma ) >>
Why created:    normalization of [serial 1521]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (164)                               [serial 1521] 
P [462] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
S [463] ->
Q [463] << ( echo_val iff rma ) or ( not ( echo_val iff rma ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1520]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 163:
Theorem (163) [serial 1535] used for:
    normalization of [serial 1521] 


Theorem (165)                               [serial 1537] 
P [463] << ( ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() )
  and ( echo_val iff rma ) >>
S [463] skip
Q [467] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1522]
  Using: (bicom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (166)                               [serial 1522] 
P [463] << ( RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) )
  and ( echo_val iff rma ) >>
S [463] skip
Q [467] << RA()
  and MRP_A() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1520]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 165:
Theorem (165) [serial 1537] used for:
    normalization of [serial 1522] 


Theorem (167)                               [serial 1539] 
P [463] << ( ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() )
  and not ( echo_val iff rma ) >>
S [465] Lost_Confirmation!
Q [467] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1523]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (168)                               [serial 1523] 
P [463] << ( RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) )
  and ( not ( echo_val iff rma ) ) >>
S [465] Lost_Confirmation!
Q [467] << RA()
  and MRP_A() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1520]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 167:
Theorem (167) [serial 1539] used for:
    normalization of [serial 1523] 


Theorem (169)                               [serial 1520] 
P [462] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
S [463]   if 
    (echo_val iff rma)~> 
      skip 
  []
    (not ( echo_val iff rma ))~> 
      Lost_Confirmation! 
  fi
Q [467] << RA()
  and MRP_A() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1516]
Solved by: and theorems 164 166 168:
Theorem (164) [serial 1521] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1520] 
Theorem (166) [serial 1522] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1520] 
Theorem (168) [serial 1523] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1520] 


Theorem (170)                               [serial 1516] 
P [462] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
S [462] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
  if 
    (echo_val iff rma)~> 
      skip 
  []
    (not ( echo_val iff rma ))~> 
      Lost_Confirmation! 
  fi
<< RA()
  and MRP_A() >>
Q [467] << RA()
  and MRP_A() >>
Why created:  <<A>> S <<B>> in behavior action block for [serial 1514]
Solved by: null and theorems 160 162 169:
Theorem (160) [serial 1518] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1516] 
Theorem (162) [serial 1519] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1516] 
Theorem (169) [serial 1520] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1516] 


Theorem (171)                               [serial 1541] 
P [467] << MRP_A()
  and RA() >>
S [461] ->
Q [469] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1517]
Solved by: Identity (id):  P->P is tautology

Theorem (172)                               [serial 1517] 
P [467] << RA()
  and MRP_A() >>
S [461] ->
Q [469] << RA()
  and MRP_A() >>
Why created:  <<B>> -> <<Q>> in behavior action block for [serial 1514]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 171:
Theorem (171) [serial 1541] used for:
    normalization of [serial 1517] 


Theorem (173)                               [serial 1514] 
P [460] << RA()
  and MRP_A()
  and RM_Alarm_Echo@now >>
S [461] declare 
   echo_val ~ boolean := RM_Alarm_Echo?   {
  << RA()
    and MRP_A()
    and ( echo_val iff RM_Alarm_Echo ) >>
    if 
      (echo_val iff rma)~> 
        skip 
    []
      (not ( echo_val iff rma ))~> 
        Lost_Confirmation! 
    fi
  << RA()
    and MRP_A() >>
  } 
Q [469] << RA()
  and MRP_A() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1024]
Solved by: Behavior Action Block (BAB): 
     <<P and x=e>> -> <<A>>
     <<A>> S <<B>> 
     <<B>> -> <<Q>>
----------------------------------------------------
<<P>> declare variable v~y:=e; { <<A>> S <<B>> } <<Q>> and theorems 158 170 172:
Theorem (158) [serial 1515] used for:
  <<P and v=e>> -> <<A>> in behavior action block for [serial 1514] 
Theorem (170) [serial 1516] used for:
  <<A>> S <<B>> in behavior action block for [serial 1514] 
Theorem (172) [serial 1517] used for:
  <<B>> -> <<Q>> in behavior action block for [serial 1514] 


Theorem (174)                               [serial 1024] 
P [458] << ( RA()
  and MRP_A() )
  and ( RM_Alarm_Echo@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [460] << RA()
  and MRP_A()
  and RM_Alarm_Echo@now >>
declare 
   echo_val ~ boolean := RM_Alarm_Echo?   {
  << RA()
    and MRP_A()
    and ( echo_val iff RM_Alarm_Echo ) >>
    if 
      (echo_val iff rma)~> 
        skip 
    []
      (not ( echo_val iff rma ))~> 
        Lost_Confirmation! 
    fi
  << RA()
    and MRP_A() >>
  } 
<< RA()
  and MRP_A() >>
Q [430] << RA()
  and MRP_A() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A};
Solved by: null and theorems 154 156 173:
Theorem (154) [serial 1512] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1024] 
Theorem (156) [serial 1513] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1024] 
Theorem (173) [serial 1514] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1024] 


Theorem (175)                               [serial 1572] 
P [472] << ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and ( MRP_A()
  and RA() )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [473] ->
Q [473] << true >>
Why created:    normalization of [serial 1568]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (176)                               [serial 1568] 
P [472] << ( RA()
  and MRP_A() )
  and ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [473] ->
Q [473] << true >>
Why created:  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1025]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 175:
Theorem (175) [serial 1572] used for:
    normalization of [serial 1568] 


Theorem (177)                               [serial 1574] 
P [473] << ( ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and ( MRP_A()
  and RA() )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) )
  and true >>
S [473] ->
Q [430] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1570]
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (178)                               [serial 1570] 
P [473] << ( ( RA()
  and MRP_A() )
  and ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) )
  and true >>
S [473] ->
Q [430] << RA()
  and MRP_A() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1569]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  Conjunction Commutes. (bl.ancom) and theorem 177:
Theorem (177) [serial 1574] used for:
    normalization of [serial 1570] 


Theorem (179)                               [serial 1569] 
P [473] << ( ( RA()
  and MRP_A() )
  and ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) )
  and true@now >>
S [473] ->
Q [430] << RA()
  and MRP_A() >>
Why created:  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1025]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 178:
Theorem (178) [serial 1570] used for:
  Assume Present:  P = P@now = P^0   [serial 1569] 


Theorem (180)                               [serial 1025] 
P [472] << ( RA()
  and MRP_A() )
  and ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [473] Lost_Confirmation!
Q [430] << RA()
  and MRP_A() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A};
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 176 179:
Theorem (176) [serial 1568] used for:
  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1025] 
Theorem (179) [serial 1569] used for:
  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1025] 


Theorem (181)                               [serial 1018] 
P [415] <<   >>
S [419] ->
Q [415] << Respiration_Monitor_Thread.impl proof obligations >>
Why created:  Initial proof obligations for Respiration_Monitor_Thread.impl
Solved by:  Component verification conditions
 and theorems 113 114 115 116 152 174 180:
Theorem (113) [serial 1019] used for:
  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition. 
Theorem (114) [serial 1020] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (115) [serial 1021] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (116) [serial 1022] used for:
   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{}; 
Theorem (152) [serial 1023] used for:
   <<M(run) and x>> A <<M(check_echo)>> for got_rp: run-[x]->check_echo{A}; 
Theorem (174) [serial 1024] used for:
   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A}; 
Theorem (180) [serial 1025] used for:
   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A}; 


Theorem (182)                               [serial 1582] 
P [623] << INV()
  and PI()
  and POA()
  and RMA() >>
S [606] ->
Q [606] << INV()
  and PI()
  and POA()
  and RMA() >>
Why created:    normalization of [serial 1580]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (183)                               [serial 1580] 
P [623] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
S [606] ->
Q [606] << INV()
  and POA()
  and RMA()
  and PI() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1027]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 182:
Theorem (182) [serial 1582] used for:
    normalization of [serial 1580] 


Theorem (184)                               [serial 1027] 
P [623] << INV_E() >>
S [606] ->
Q [606] << INV()
  and POA()
  and RMA()
  and PI() >>
Why created:  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 183:
Theorem (183) [serial 1580] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1027] 


Theorem (185)                               [serial 1585] 
P [621] << INV()
  and PI()
  and POA()
  and RMA() >>
S [606] ->
Q [606] << INV()
  and PI()
  and POA()
  and RMA() >>
Why created:    normalization of [serial 1583]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (186)                               [serial 1583] 
P [621] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
S [606] ->
Q [606] << INV()
  and POA()
  and RMA()
  and PI() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1028]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 185:
Theorem (185) [serial 1585] used for:
    normalization of [serial 1583] 


Theorem (187)                               [serial 1028] 
P [621] << INV_E() >>
S [606] ->
Q [606] << INV()
  and POA()
  and RMA()
  and PI() >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 186:
Theorem (186) [serial 1583] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1028] 


Theorem (188)                               [serial 1029] 
P [620] << INV_E() >>
S [620] ->
Q [620] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by: Anything Implies True (a1tru): P->true

Theorem (189)                               [serial 1030] 
P [620] << INV_E() >>
S [627] ->
Q [621] << INV_E() >>
Why created:   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{};
Solved by: Identity (id):  P->P is tautology

Theorem (190)                               [serial 1609] 
P [629] << ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 )@now
  and ( INV()
  and POA()
  and RMA()
  and PI() )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 )@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE )@u  ) >>
S [629] ->
Q [631] << INV()
  and RMA() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1592]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (191)                               [serial 1592] 
P [629] << PO_ALARM()@now
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [629] ->
Q [631] << INV()
  and RMA() >>
Why created:    normalization of [serial 1586]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 190:
Theorem (190) [serial 1609] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1592] 


Theorem (192)                               [serial 1586] 
P [629] << ( INV_E() )
  and ( PO_ALARM()@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [629] ->
Q [631] << INV()
  and RMA() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1031]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 191:
Theorem (191) [serial 1592] used for:
    normalization of [serial 1586] 


Theorem (193)                               [serial 1613] 
P [632] << ( INV()
  and RMA() )
  and ( PO_ALARM() iff po_alarm_active ) >>
S [632] ->
Q [633] << ( PO_ALARM() iff po_alarm_active )
  and INV()
  and RMA() >>
Why created:    normalization of [serial 1611]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (194)                               [serial 1611] 
P [632] << ( INV()
  and RMA() )
  and ( po_alarm_active iff PO_ALARM() ) >>
S [632] ->
Q [633] << ( PO_ALARM() iff po_alarm_active )
  and INV()
  and RMA() >>
Why created:  applied port input of value <<pre and po_alarm_active=M(PO_Alarm)>> -> <<post>> [serial 1594]
Solved by: Biconditional (iff) Commutes. (bicom) and theorem 193:
Theorem (193) [serial 1613] used for:
    normalization of [serial 1611] 


Theorem (195)                               [serial 1594] 
P [631] << INV()
  and RMA() >>
S [632] PO_Alarm?(po_alarm_active)
Q [633] << ( PO_ALARM() iff po_alarm_active )
  and INV()
  and RMA() >>
Why created:    normalization of [serial 1587]
  Using: (bicom) (bl.ancom) 
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 194:
Theorem (194) [serial 1611] used for:
  applied port input of value <<pre and po_alarm_active=M(PO_Alarm)>> -> <<post>> [serial 1594] 


Theorem (196)                               [serial 1587] 
P [631] << INV()
  and RMA() >>
S [632] PO_Alarm?(po_alarm_active)
Q [633] << INV()
  and RMA()
  and ( po_alarm_active iff PO_ALARM() ) >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1031]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 195:
Theorem (195) [serial 1594] used for:
    normalization of [serial 1587] 


Theorem (197)                               [serial 1615] 
P [633] << ( PO_ALARM() iff po_alarm_active )
  and INV()
  and RMA() >>
S [634] ->
Q [634] << PO_ALARM() iff po_alarm_active >>
Why created:  applied port output of value <<pre>> -> <<M(PO_Alarm_Echo)[PO_Alarm_Echo|po_alarm_active]>> [serial 1596]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (198)                               [serial 1616] 
P [634] << ( ( PO_ALARM() iff po_alarm_active )
  and INV()
  and RMA() )
  and ( PO_ALARM() iff po_alarm_active )@now >>
S [634] ->
Q [635] << INV()
  and POA()
  and RMA() >>
Why created:  applied port output <<pre and (PO_ALARM() iff po_alarm_active)@now>> -> <<post>> [serial 1596]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (199)                               [serial 1596] 
P [633] << ( PO_ALARM() iff po_alarm_active )
  and INV()
  and RMA() >>
S [634] PO_Alarm_Echo!(po_alarm_active)
Q [635] << INV()
  and POA()
  and RMA() >>
Why created:    normalization of [serial 1588]
  Using: (bicom) (bl.ancom) 
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 197 198:
Theorem (197) [serial 1615] used for:
  applied port output of value <<pre>> -> <<M(PO_Alarm_Echo)[PO_Alarm_Echo|po_alarm_active]>> [serial 1596] 
Theorem (198) [serial 1616] used for:
  applied port output <<pre and (PO_ALARM() iff po_alarm_active)@now>> -> <<post>> [serial 1596] 


Theorem (200)                               [serial 1588] 
P [633] << INV()
  and RMA()
  and ( po_alarm_active iff PO_ALARM() ) >>
S [634] PO_Alarm_Echo!(po_alarm_active)
Q [635] << INV()
  and RMA()
  and POA() >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1031]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 199:
Theorem (199) [serial 1596] used for:
    normalization of [serial 1588] 


Theorem (201)                               [serial 1635] 
P [635] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [636] ->
Q [614] << ( ( PO_ALARM() or RM_ALARM() ) iff ( PO_ALARM() or RM_ALARM() ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "rm_alarm_active" with its iff "RM_ALARM()" in its postcondition [serial 1634]
Solved by: Principle of identity for logical equivalence. (biid) 

Theorem (202)                               [serial 1634] 
P [635] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [636] ->
Q [614] << ( ( PO_ALARM() or RM_ALARM() ) iff ( PO_ALARM() or rm_alarm_active ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "po_alarm_active" with its iff "PO_ALARM()" in its postcondition [serial 1630]
Solved by:  Guided Substitution of Equals
 and theorem 201:
Theorem (201) [serial 1635] used for:
  Guided Substitution of Equals 
 replacing "rm_alarm_active" with its iff "RM_ALARM()" in its postcondition [serial 1634] 


Theorem (203)                               [serial 1630] 
P [635] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [636] ->
Q [614] << ( ( PO_ALARM() or RM_ALARM() ) iff ( po_alarm_active or rm_alarm_active ) ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1629]
Solved by:  Guided Substitution of Equals
 and theorem 202:
Theorem (202) [serial 1634] used for:
  Guided Substitution of Equals 
 replacing "po_alarm_active" with its iff "PO_ALARM()" in its postcondition [serial 1630] 


Theorem (204)                               [serial 1631] 
P [635] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [636] ->
Q [610] << ( PO_ALARM() iff po_alarm_active ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1629]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (205)                               [serial 1632] 
P [635] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [636] ->
Q [612] << ( RM_ALARM() iff rm_alarm_active ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1629]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (206)                               [serial 1633] 
P [635] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [636] ->
Q [194] << ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1629]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (207)                               [serial 1629] 
P [635] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [636] ->
Q [637] << ( ( PO_ALARM() or RM_ALARM() ) iff ( po_alarm_active or rm_alarm_active ) )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
Why created:    normalization of [serial 1627]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 203 204 205 206:
Theorem (203) [serial 1630] used for:
  Join consequents with conjunction. (3jca)
   [serial 1629] 
Theorem (204) [serial 1631] used for:
  Join consequents with conjunction. (3jca)
   [serial 1629] 
Theorem (205) [serial 1632] used for:
  Join consequents with conjunction. (3jca)
   [serial 1629] 
Theorem (206) [serial 1633] used for:
  Join consequents with conjunction. (3jca)
   [serial 1629] 


Theorem (208)                               [serial 1627] 
P [635] << ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() ) >>
S [636] ->
Q [637] << ( ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( ( po_alarm_active or rm_alarm_active ) iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1626]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 207:
Theorem (207) [serial 1629] used for:
    normalization of [serial 1627] 


Theorem (209)                               [serial 1626] 
P [635] << INV()
  and POA()
  and RMA() >>
S [636] ->
Q [637] << ( ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( ( po_alarm_active or rm_alarm_active ) iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  applied wp for assignment [serial 1625]
Solved by: Predicate Invocation. (PI) and theorem 208:
Theorem (208) [serial 1627] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1626] 


Theorem (210)                               [serial 1625] 
P [635] << INV()
  and POA()
  and RMA() >>
S [636] pause_inf := po_alarm_active or rm_alarm_active
Q [637] << ( ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1624]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 209:
Theorem (209) [serial 1626] used for:
  applied wp for assignment [serial 1625] 


Theorem (211)                               [serial 1624] 
P [635] << INV()
  and POA()
  and RMA() >>
S [636] pause_inf := po_alarm_active or rm_alarm_active
Q [637] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1598]
Solved by: Predicate Invocation. (PI) and theorem 210:
Theorem (210) [serial 1625] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1624] 


Theorem (212)                               [serial 1598] 
P [635] << INV()
  and POA()
  and RMA() >>
S [636] pause_inf := po_alarm_active or rm_alarm_active
Q [637] << INV_E() >>
Why created:    normalization of [serial 1589]
Solved by: Predicate Invocation. (PI) and theorem 211:
Theorem (211) [serial 1624] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1598] 


Theorem (213)                               [serial 1589] 
P [635] << INV()
  and RMA()
  and POA() >>
S [636] pause_inf := po_alarm_active or rm_alarm_active
Q [637] << INV_E() >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1031]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 212:
Theorem (212) [serial 1598] used for:
    normalization of [serial 1589] 


Theorem (214)                               [serial 1608] 
P [637] << ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [638] ->
Q [638] << ( PO_ALARM() or RM_ALARM() ) iff pause_inf >>
Why created:    normalization of [serial 1606]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (215)                               [serial 1606] 
P [637] << ( ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
S [638] ->
Q [638] << ( PO_ALARM() or RM_ALARM() ) iff pause_inf >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1605]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 214:
Theorem (214) [serial 1608] used for:
    normalization of [serial 1606] 


Theorem (216)                               [serial 1605] 
P [637] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
S [638] ->
Q [638] << ( PO_ALARM() or RM_ALARM() ) iff pause_inf >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1600]
Solved by: Predicate Invocation. (PI) and theorem 215:
Theorem (215) [serial 1606] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1605] 


Theorem (217)                               [serial 1600] 
P [637] << INV_E() >>
S [638] ->
Q [638] << ( PO_ALARM() or RM_ALARM() ) iff pause_inf >>
Why created:  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|pause_inf]>> [serial 1590]
Solved by: Predicate Invocation. (PI) and theorem 216:
Theorem (216) [serial 1605] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1600] 


Theorem (218)                               [serial 1604] 
P [638] << ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )@now
  and INV_E() >>
S [638] ->
Q [623] << INV_E() >>
Why created:    normalization of [serial 1601]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (219)                               [serial 1601] 
P [638] << ( INV_E() )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )@now >>
S [638] ->
Q [623] << INV_E() >>
Why created:  applied port output <<pre and (( PO_ALARM() or RM_ALARM() ) iff pause_inf)@now>> -> <<post>> [serial 1590]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 218:
Theorem (218) [serial 1604] used for:
    normalization of [serial 1601] 


Theorem (220)                               [serial 1590] 
P [637] << INV_E() >>
S [638] Pause_Infusion!(pause_inf)
Q [623] << INV_E() >>
Why created:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1031]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 217 219:
Theorem (217) [serial 1600] used for:
  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|pause_inf]>> [serial 1590] 
Theorem (219) [serial 1601] used for:
  applied port output <<pre and (( PO_ALARM() or RM_ALARM() ) iff pause_inf)@now>> -> <<post>> [serial 1590] 


Theorem (221)                               [serial 1031] 
P [629] << ( INV_E() )
  and ( PO_ALARM()@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [631]   << INV()
    and RMA() >>
  PO_Alarm?(po_alarm_active)
  ;
  << INV()
    and RMA()
    and ( po_alarm_active iff PO_ALARM() ) >>
  PO_Alarm_Echo!(po_alarm_active)
  ;
  << INV()
    and RMA()
    and POA() >>
  pause_inf := po_alarm_active or rm_alarm_active
  ;
  << INV_E() >>
  Pause_Infusion!(pause_inf) 
Q [623] << INV_E() >>
Why created:   <<M(run) and x>> A <<M(check_echo)>> for got_po: run-[x]->check_echo{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 192 196 200 213 220:
Theorem (192) [serial 1586] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1031] 
Theorem (196) [serial 1587] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1031] 
Theorem (200) [serial 1588] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1031] 
Theorem (213) [serial 1589] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1031] 
Theorem (220) [serial 1590] used for:
  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1031] 


Theorem (222)                               [serial 1646] 
P [641] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE )@now
  and ( INV()
  and POA()
  and RMA()
  and PI() )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 )@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE )@u  ) >>
S [641] ->
Q [642] << INV()
  and POA() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1641]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (223)                               [serial 1641] 
P [641] << RM_ALARM()@now
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [641] ->
Q [642] << INV()
  and POA() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1640]
Solved by: Predicate Invocation. (PI) and theorem 222:
Theorem (222) [serial 1646] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1641] 


Theorem (224)                               [serial 1650] 
P [643] << ( INV()
  and POA() )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [643] ->
Q [644] << ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() >>
Why created:    normalization of [serial 1648]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (225)                               [serial 1648] 
P [643] << ( INV()
  and POA() )
  and ( rm_alarm_active iff RM_ALARM() ) >>
S [643] ->
Q [644] << ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() >>
Why created:  applied port input of value <<pre and rm_alarm_active=M(RM_Alarm)>> -> <<post>> [serial 1642]
Solved by: Biconditional (iff) Commutes. (bicom) and theorem 224:
Theorem (224) [serial 1650] used for:
    normalization of [serial 1648] 


Theorem (226)                               [serial 1642] 
P [642] << INV()
  and POA() >>
S [643] RM_Alarm?(rm_alarm_active)
Q [644] << ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1640]
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 225:
Theorem (225) [serial 1648] used for:
  applied port input of value <<pre and rm_alarm_active=M(RM_Alarm)>> -> <<post>> [serial 1642] 


Theorem (227)                               [serial 1652] 
P [644] << ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() >>
S [645] ->
Q [645] << RM_ALARM() iff rm_alarm_active >>
Why created:  applied port output of value <<pre>> -> <<M(RM_Alarm_Echo)[RM_Alarm_Echo|rm_alarm_active]>> [serial 1643]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (228)                               [serial 1654] 
P [645] << ( ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() )
  and ( RM_ALARM() iff rm_alarm_active )@now >>
S [645] ->
Q [646] << INV() >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1653]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (229)                               [serial 1655] 
P [645] << ( ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() )
  and ( RM_ALARM() iff rm_alarm_active )@now >>
S [645] ->
Q [646] << POA() >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1653]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (230)                               [serial 1656] 
P [645] << ( ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() )
  and ( RM_ALARM() iff rm_alarm_active )@now >>
S [645] ->
Q [646] << RMA() >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1653]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (231)                               [serial 1653] 
P [645] << ( ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() )
  and ( RM_ALARM() iff rm_alarm_active )@now >>
S [645] ->
Q [646] << INV()
  and POA()
  and RMA() >>
Why created:  applied port output <<pre and (RM_ALARM() iff rm_alarm_active)@now>> -> <<post>> [serial 1643]
Solved by: Join consequents with conjunction. (3jca) and theorems 228 229 230:
Theorem (228) [serial 1654] used for:
  Join consequents with conjunction. (3jca)
   [serial 1653] 
Theorem (229) [serial 1655] used for:
  Join consequents with conjunction. (3jca)
   [serial 1653] 
Theorem (230) [serial 1656] used for:
  Join consequents with conjunction. (3jca)
   [serial 1653] 


Theorem (232)                               [serial 1643] 
P [644] << ( RM_ALARM() iff rm_alarm_active )
  and INV()
  and POA() >>
S [645] RM_Alarm_Echo!(rm_alarm_active)
Q [646] << INV()
  and POA()
  and RMA() >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1640]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 227 231:
Theorem (227) [serial 1652] used for:
  applied port output of value <<pre>> -> <<M(RM_Alarm_Echo)[RM_Alarm_Echo|rm_alarm_active]>> [serial 1643] 
Theorem (231) [serial 1653] used for:
  applied port output <<pre and (RM_ALARM() iff rm_alarm_active)@now>> -> <<post>> [serial 1643] 


Theorem (233)                               [serial 1674] 
P [646] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [647] ->
Q [614] << ( ( PO_ALARM() or RM_ALARM() ) iff ( PO_ALARM() or RM_ALARM() ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "po_alarm_active" with its iff "PO_ALARM()" in its postcondition [serial 1673]
Solved by: Principle of identity for logical equivalence. (biid) 

Theorem (234)                               [serial 1673] 
P [646] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [647] ->
Q [614] << ( ( PO_ALARM() or RM_ALARM() ) iff ( po_alarm_active or RM_ALARM() ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "rm_alarm_active" with its iff "RM_ALARM()" in its postcondition [serial 1669]
Solved by:  Guided Substitution of Equals
 and theorem 233:
Theorem (233) [serial 1674] used for:
  Guided Substitution of Equals 
 replacing "po_alarm_active" with its iff "PO_ALARM()" in its postcondition [serial 1673] 


Theorem (235)                               [serial 1669] 
P [646] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [647] ->
Q [614] << ( ( PO_ALARM() or RM_ALARM() ) iff ( po_alarm_active or rm_alarm_active ) ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1668]
Solved by:  Guided Substitution of Equals
 and theorem 234:
Theorem (234) [serial 1673] used for:
  Guided Substitution of Equals 
 replacing "rm_alarm_active" with its iff "RM_ALARM()" in its postcondition [serial 1669] 


Theorem (236)                               [serial 1670] 
P [646] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [647] ->
Q [610] << ( PO_ALARM() iff po_alarm_active ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1668]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (237)                               [serial 1671] 
P [646] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [647] ->
Q [612] << ( RM_ALARM() iff rm_alarm_active ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1668]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (238)                               [serial 1672] 
P [646] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [647] ->
Q [194] << ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1668]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (239)                               [serial 1668] 
P [646] << ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [647] ->
Q [648] << ( ( PO_ALARM() or RM_ALARM() ) iff ( po_alarm_active or rm_alarm_active ) )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
Why created:    normalization of [serial 1666]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 235 236 237 238:
Theorem (235) [serial 1669] used for:
  Join consequents with conjunction. (3jca)
   [serial 1668] 
Theorem (236) [serial 1670] used for:
  Join consequents with conjunction. (3jca)
   [serial 1668] 
Theorem (237) [serial 1671] used for:
  Join consequents with conjunction. (3jca)
   [serial 1668] 
Theorem (238) [serial 1672] used for:
  Join consequents with conjunction. (3jca)
   [serial 1668] 


Theorem (240)                               [serial 1666] 
P [646] << ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() ) >>
S [647] ->
Q [648] << ( ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( ( po_alarm_active or rm_alarm_active ) iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1665]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 239:
Theorem (239) [serial 1668] used for:
    normalization of [serial 1666] 


Theorem (241)                               [serial 1665] 
P [646] << INV()
  and POA()
  and RMA() >>
S [647] ->
Q [648] << ( ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( ( po_alarm_active or rm_alarm_active ) iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  applied wp for assignment [serial 1664]
Solved by: Predicate Invocation. (PI) and theorem 240:
Theorem (240) [serial 1666] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1665] 


Theorem (242)                               [serial 1664] 
P [646] << INV()
  and POA()
  and RMA() >>
S [647] pause_inf := po_alarm_active or rm_alarm_active
Q [648] << ( ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1663]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 241:
Theorem (241) [serial 1665] used for:
  applied wp for assignment [serial 1664] 


Theorem (243)                               [serial 1663] 
P [646] << INV()
  and POA()
  and RMA() >>
S [647] pause_inf := po_alarm_active or rm_alarm_active
Q [648] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1644]
Solved by: Predicate Invocation. (PI) and theorem 242:
Theorem (242) [serial 1664] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1663] 


Theorem (244)                               [serial 1644] 
P [646] << INV()
  and POA()
  and RMA() >>
S [647] pause_inf := po_alarm_active or rm_alarm_active
Q [648] << INV_E() >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1640]
Solved by: Predicate Invocation. (PI) and theorem 243:
Theorem (243) [serial 1663] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1644] 


Theorem (245)                               [serial 1686] 
P [648] << ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [649] ->
Q [649] << ( PO_ALARM() or RM_ALARM() ) iff pause_inf >>
Why created:    normalization of [serial 1684]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (246)                               [serial 1684] 
P [648] << ( ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
S [649] ->
Q [649] << ( PO_ALARM() or RM_ALARM() ) iff pause_inf >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1683]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 245:
Theorem (245) [serial 1686] used for:
    normalization of [serial 1684] 


Theorem (247)                               [serial 1683] 
P [648] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
S [649] ->
Q [649] << ( PO_ALARM() or RM_ALARM() ) iff pause_inf >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1678]
Solved by: Predicate Invocation. (PI) and theorem 246:
Theorem (246) [serial 1684] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1683] 


Theorem (248)                               [serial 1678] 
P [648] << INV_E() >>
S [649] ->
Q [649] << ( PO_ALARM() or RM_ALARM() ) iff pause_inf >>
Why created:  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|pause_inf]>> [serial 1645]
Solved by: Predicate Invocation. (PI) and theorem 247:
Theorem (247) [serial 1683] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1678] 


Theorem (249)                               [serial 1682] 
P [649] << ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )@now
  and INV_E() >>
S [649] ->
Q [623] << INV_E() >>
Why created:    normalization of [serial 1679]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (250)                               [serial 1679] 
P [649] << ( INV_E() )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )@now >>
S [649] ->
Q [623] << INV_E() >>
Why created:  applied port output <<pre and (( PO_ALARM() or RM_ALARM() ) iff pause_inf)@now>> -> <<post>> [serial 1645]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 249:
Theorem (249) [serial 1682] used for:
    normalization of [serial 1679] 


Theorem (251)                               [serial 1645] 
P [648] << INV_E() >>
S [649] Pause_Infusion!(pause_inf)
Q [623] << INV_E() >>
Why created:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1640]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 248 250:
Theorem (248) [serial 1678] used for:
  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|pause_inf]>> [serial 1645] 
Theorem (250) [serial 1679] used for:
  applied port output <<pre and (( PO_ALARM() or RM_ALARM() ) iff pause_inf)@now>> -> <<post>> [serial 1645] 


Theorem (252)                               [serial 1640] 
P [641] << RM_ALARM()@now
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [642]   << INV()
    and POA() >>
  RM_Alarm?(rm_alarm_active)
  ;
  << ( RM_ALARM() iff rm_alarm_active )
    and INV()
    and POA() >>
  RM_Alarm_Echo!(rm_alarm_active)
  ;
  << INV()
    and POA()
    and RMA() >>
  pause_inf := po_alarm_active or rm_alarm_active
  ;
  << INV_E() >>
  Pause_Infusion!(pause_inf) 
Q [623] << INV_E() >>
Why created:    normalization of [serial 1032]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) (bicom) 
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 223 226 232 244 251:
Theorem (223) [serial 1641] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1640] 
Theorem (226) [serial 1642] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1640] 
Theorem (232) [serial 1643] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1640] 
Theorem (244) [serial 1644] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1640] 
Theorem (251) [serial 1645] used for:
  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1640] 


Theorem (253)                               [serial 1032] 
P [641] << ( INV_E() )
  and ( RM_ALARM()@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [642]   << INV()
    and POA() >>
  RM_Alarm?(rm_alarm_active)
  ;
  << INV()
    and POA()
    and ( rm_alarm_active iff RM_ALARM() ) >>
  RM_Alarm_Echo!(rm_alarm_active)
  ;
  << INV()
    and RMA()
    and POA() >>
  pause_inf := po_alarm_active or rm_alarm_active
  ;
  << INV_E() >>
  Pause_Infusion!(pause_inf) 
Q [623] << INV_E() >>
Why created:   <<M(run) and x>> A <<M(check_echo)>> for got_rm: run-[x]->check_echo{A};
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) Biconditional (iff) Commutes. (bicom) and theorem 252:
Theorem (252) [serial 1640] used for:
    normalization of [serial 1032] 


Theorem (254)                               [serial 1698] 
P [652] << ( PAUSE_INFUSION_ECHO@now
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) )
  and ( PAUSE_INFUSION_ECHO@now iff echo_val ) >>
S [655] ->
Q [655] << ( PAUSE_INFUSION_ECHO iff echo_val )
  and INV_E() >>
Why created:    normalization of [serial 1688]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) (bicom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (255)                               [serial 1688] 
P [652] << ( ( INV_E() )
  and ( PAUSE_INFUSION_ECHO@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) )
  and ( echo_val iff PAUSE_INFUSION_ECHO@now ) >>
S [655] ->
Q [655] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
Why created:  <<P and v=e>> -> <<A>> in behavior action block for [serial 1687]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) Biconditional (iff) Commutes. (bicom) and theorem 254:
Theorem (254) [serial 1698] used for:
    normalization of [serial 1688] 


Theorem (256)                               [serial 1691] 
P [655] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
S [655] ->
Q [655] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1689]
Solved by: Identity (id):  P->P is tautology

Theorem (257)                               [serial 1692] 
P [660] << INV_E() >>
S [660] ->
Q [660] << INV_E() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1689]
Solved by: Identity (id):  P->P is tautology

Theorem (258)                               [serial 1700] 
P [655] << ( PAUSE_INFUSION_ECHO iff echo_val )
  and INV_E() >>
S [656] ->
Q [656] << ( echo_val iff pause_inf ) or not ( echo_val iff pause_inf ) >>
Why created:    normalization of [serial 1694]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (259)                               [serial 1694] 
P [655] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
S [656] ->
Q [656] << ( echo_val iff pause_inf ) or ( not ( echo_val iff pause_inf ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1693]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) and theorem 258:
Theorem (258) [serial 1700] used for:
    normalization of [serial 1694] 


Theorem (260)                               [serial 1702] 
P [656] << ( ( PAUSE_INFUSION_ECHO iff echo_val )
  and INV_E() )
  and ( echo_val iff pause_inf ) >>
S [656] skip
Q [660] << INV_E() >>
Why created:    normalization of [serial 1695]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (261)                               [serial 1695] 
P [656] << ( ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() )
  and ( echo_val iff pause_inf ) >>
S [656] skip
Q [660] << INV_E() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1693]
Solved by: Biconditional (iff) Commutes. (bicom) and theorem 260:
Theorem (260) [serial 1702] used for:
    normalization of [serial 1695] 


Theorem (262)                               [serial 1704] 
P [656] << ( ( PAUSE_INFUSION_ECHO iff echo_val )
  and INV_E() )
  and not ( echo_val iff pause_inf ) >>
S [658] Lost_Confirmation!
Q [660] << INV_E() >>
Why created:    normalization of [serial 1696]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (263)                               [serial 1696] 
P [656] << ( ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() )
  and ( not ( echo_val iff pause_inf ) ) >>
S [658] Lost_Confirmation!
Q [660] << INV_E() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1693]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) and theorem 262:
Theorem (262) [serial 1704] used for:
    normalization of [serial 1696] 


Theorem (264)                               [serial 1693] 
P [655] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
S [656]   if 
    (echo_val iff pause_inf)~> 
      skip 
  []
    (not ( echo_val iff pause_inf ))~> 
      Lost_Confirmation! 
  fi
Q [660] << INV_E() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1689]
Solved by: and theorems 259 261 263:
Theorem (259) [serial 1694] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1693] 
Theorem (261) [serial 1695] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1693] 
Theorem (263) [serial 1696] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1693] 


Theorem (265)                               [serial 1689] 
P [655] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
S [655] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
  if 
    (echo_val iff pause_inf)~> 
      skip 
  []
    (not ( echo_val iff pause_inf ))~> 
      Lost_Confirmation! 
  fi
<< INV_E() >>
Q [660] << INV_E() >>
Why created:  <<A>> S <<B>> in behavior action block for [serial 1687]
Solved by: null and theorems 256 257 264:
Theorem (256) [serial 1691] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1689] 
Theorem (257) [serial 1692] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1689] 
Theorem (264) [serial 1693] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1689] 


Theorem (266)                               [serial 1690] 
P [660] << INV_E() >>
S [654] ->
Q [621] << INV_E() >>
Why created:  <<B>> -> <<Q>> in behavior action block for [serial 1687]
Solved by: Identity (id):  P->P is tautology

Theorem (267)                               [serial 1687] 
P [652] << ( INV_E() )
  and ( PAUSE_INFUSION_ECHO@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [654] declare 
   echo_val ~ boolean := Pause_Infusion_Echo?   {
  << ( echo_val iff PAUSE_INFUSION_ECHO )
    and INV_E() >>
    if 
      (echo_val iff pause_inf)~> 
        skip 
    []
      (not ( echo_val iff pause_inf ))~> 
        Lost_Confirmation! 
    fi
  << INV_E() >>
  } 
Q [621] << INV_E() >>
Why created:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1033]
Solved by: Behavior Action Block (BAB): 
     <<P and x=e>> -> <<A>>
     <<A>> S <<B>> 
     <<B>> -> <<Q>>
----------------------------------------------------
<<P>> declare variable v~y:=e; { <<A>> S <<B>> } <<Q>> and theorems 255 265 266:
Theorem (255) [serial 1688] used for:
  <<P and v=e>> -> <<A>> in behavior action block for [serial 1687] 
Theorem (265) [serial 1689] used for:
  <<A>> S <<B>> in behavior action block for [serial 1687] 
Theorem (266) [serial 1690] used for:
  <<B>> -> <<Q>> in behavior action block for [serial 1687] 


Theorem (268)                               [serial 1033] 
P [652] << ( INV_E() )
  and ( PAUSE_INFUSION_ECHO@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [654] declare 
   echo_val ~ boolean := Pause_Infusion_Echo?   {
  << ( echo_val iff PAUSE_INFUSION_ECHO )
    and INV_E() >>
    if 
      (echo_val iff pause_inf)~> 
        skip 
    []
      (not ( echo_val iff pause_inf ))~> 
        Lost_Confirmation! 
    fi
  << INV_E() >>
  } 
Q [621] << INV_E() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A};
Solved by: null and theorem 267:
Theorem (267) [serial 1687] used for:
  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1033] 


Theorem (269)                               [serial 1727] 
P [665] << ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [666] ->
Q [666] << true >>
Why created:    normalization of [serial 1723]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (270)                               [serial 1723] 
P [665] << ( INV_E() )
  and ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [666] ->
Q [666] << true >>
Why created:  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1034]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 269:
Theorem (269) [serial 1727] used for:
    normalization of [serial 1723] 


Theorem (271)                               [serial 1729] 
P [666] << ( ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) )
  and true >>
S [666] ->
Q [621] << INV_E() >>
Why created:    normalization of [serial 1725]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (272)                               [serial 1725] 
P [666] << ( ( INV_E() )
  and ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) )
  and true >>
S [666] ->
Q [621] << INV_E() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1724]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 271:
Theorem (271) [serial 1729] used for:
    normalization of [serial 1725] 


Theorem (273)                               [serial 1724] 
P [666] << ( ( INV_E() )
  and ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) )
  and true@now >>
S [666] ->
Q [621] << INV_E() >>
Why created:  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1034]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 272:
Theorem (272) [serial 1725] used for:
  Assume Present:  P = P@now = P^0   [serial 1724] 


Theorem (274)                               [serial 1034] 
P [665] << ( INV_E() )
  and ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [666] Lost_Confirmation!
Q [621] << INV_E() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A};
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 270 273:
Theorem (270) [serial 1723] used for:
  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1034] 
Theorem (273) [serial 1724] used for:
  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1034] 


Theorem (275)                               [serial 1026] 
P [605] <<   >>
S [606] ->
Q [605] << Coordinator_Thread.echo proof obligations >>
Why created:  Initial proof obligations for Coordinator_Thread.echo
Solved by:  Component verification conditions
 and theorems 184 187 188 189 221 253 268 274:
Theorem (184) [serial 1027] used for:
  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition. 
Theorem (187) [serial 1028] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (188) [serial 1029] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (189) [serial 1030] used for:
   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{}; 
Theorem (221) [serial 1031] used for:
   <<M(run) and x>> A <<M(check_echo)>> for got_po: run-[x]->check_echo{A}; 
Theorem (253) [serial 1032] used for:
   <<M(run) and x>> A <<M(check_echo)>> for got_rm: run-[x]->check_echo{A}; 
Theorem (268) [serial 1033] used for:
   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A}; 
Theorem (274) [serial 1034] used for:
   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A}; 


Theorem (276)                               [serial 1771] 
P [1] << ( ( ( last_action'EndPriming = LAST_ACTION_A or last_action'SafetyStopPump = LAST_ACTION_A or 
last_action'StopButton = LAST_ACTION_A ) or KVO_RATE_property = PUMP_RATE$() ) iff Pause_Infusion )
  and ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) iff PO_Alarm )
  and ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE iff RM_Alarm )
  and ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) implies ( ( last_action'EndPriming = LAST_ACTION_A or 
last_action'SafetyStopPump = LAST_ACTION_A or last_action'StopButton = LAST_ACTION_A ) or 
KVO_RATE_property = PUMP_RATE$() ) ) >>
S    ->
Q [2] << ( HEART_RATE < MINIMUM_HEART_RATE or RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE or 
SPO2 < PROGRAMMED_SPO2 ) implies ( ( last_action'EndPriming = LAST_ACTION_A or 
last_action'SafetyStopPump = LAST_ACTION_A or last_action'StopButton = LAST_ACTION_A ) or 
KVO_RATE_property = PUMP_RATE$() ) >>
Why created:    normalization of [serial 1769]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by: Absorb parentheses, middle term in disjunction (bl.orabpm)

Theorem (277)                               [serial 1769] 
P [1] << ( Pause_Infusion iff ( PUMP_RATE$() = KVO_RATE_property or ( ( LAST_ACTION_A = last_action'SafetyStopPump ) or 
( LAST_ACTION_A = last_action'StopButton ) or ( LAST_ACTION_A = last_action'EndPriming ) ) ) )
  and ( PO_Alarm iff ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) )
  and ( RM_Alarm iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) )
  and ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) implies ( PUMP_RATE$() = KVO_RATE_property or 
( ( LAST_ACTION_A = last_action'SafetyStopPump ) or ( LAST_ACTION_A = last_action'StopButton ) or 
( LAST_ACTION_A = last_action'EndPriming ) ) ) ) >>
S    ->
Q [2] << ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 or RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) implies ( 
PUMP_RATE$() = KVO_RATE_property or ( ( LAST_ACTION_A = last_action'SafetyStopPump ) or 
( LAST_ACTION_A = last_action'StopButton ) or ( LAST_ACTION_A = last_action'EndPriming ) ) ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1768]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 276:
Theorem (276) [serial 1771] used for:
    normalization of [serial 1769] 


Theorem (278)                               [serial 1768] 
P [1] << ( Pause_Infusion iff ( PUMP_RATE$() = KVO_RATE_property or HALT() ) )
  and ( PO_Alarm iff PO_ALARM() )
  and ( RM_Alarm iff RM_ALARM() )
  and ( ( PO_ALARM() or RM_ALARM() ) implies ( PUMP_RATE$() = KVO_RATE_property or 
HALT() ) ) >>
S    ->
Q [2] << ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 or RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) implies ( 
PUMP_RATE$() = KVO_RATE_property or HALT() ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1767]
Solved by: Predicate Invocation. (PI) and theorem 277:
Theorem (277) [serial 1769] used for:
  Substituted assertions' predicates for labels  [serial 1768] 


Theorem (279)                               [serial 1767] 
P [1] << ( Pause_Infusion iff ( PUMP_RATE$() = KVO_RATE_property or HALT() ) )
  and ( PO_Alarm iff PO_ALARM() )
  and ( RM_Alarm iff RM_ALARM() )
  and ( ( PO_ALARM() or RM_ALARM() ) implies ( PUMP_RATE$() = KVO_RATE_property or 
HALT() ) ) >>
S    ->
Q [2] << IS_SAFE() >>
Why created:  Substituting Equals Within Conjunction [serial 1035]
Solved by: Predicate Invocation. (PI) and theorem 278:
Theorem (278) [serial 1768] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1767] 


Theorem (280)                               [serial 1035] 
P [1] << ( Pause_Infusion iff ( PUMP_RATE$() = KVO_RATE_property or HALT() ) )
  and ( PO_Alarm iff PO_ALARM() )
  and ( RM_Alarm iff RM_ALARM() )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S    ->
Q [2] << IS_SAFE() >>
Why created:  Conjunction of Subcomponents' Invariants imply SysIoMT.impl's Invariant
Solved by: A equality theorem for substitution. (subequ12a) and theorem 279:
Theorem (279) [serial 1767] used for:
  Substituting Equals Within Conjunction [serial 1035] 


Theorem (281)                               [serial 1776] 
P [1] << ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion >>
S    ->
Q [2] << ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion >>
Why created:    normalization of [serial 1036]
Solved by: Identity (id):  P->P is tautology

Theorem (282)                               [serial 1036] 
P [1] << ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S    ->
Q [2] << ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion >>
Why created:  Subcomponent's Invariant implies Coordinator.impl's Invariant
Solved by: [Add unnecessary parentheses] and theorem 281:
Theorem (281) [serial 1776] used for:
    normalization of [serial 1036] 


Theorem (283)                               [serial 1781] 
P [1] << ( ( ( last_action'EndPriming = LAST_ACTION_A or last_action'SafetyStopPump = LAST_ACTION_A or 
last_action'StopButton = LAST_ACTION_A ) or KVO_RATE_property = PUMP_RATE$() ) iff Pause_Infusion )
  and ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) iff PO_Alarm )
  and ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE iff RM_Alarm )
  and ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) implies ( ( last_action'EndPriming = LAST_ACTION_A or 
last_action'SafetyStopPump = LAST_ACTION_A or last_action'StopButton = LAST_ACTION_A ) or 
KVO_RATE_property = PUMP_RATE$() ) ) >>
S    ->
Q [2] << ( HEART_RATE < MINIMUM_HEART_RATE or RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE or 
SPO2 < PROGRAMMED_SPO2 ) implies ( ( last_action'EndPriming = LAST_ACTION_A or 
last_action'SafetyStopPump = LAST_ACTION_A or last_action'StopButton = LAST_ACTION_A ) or 
KVO_RATE_property = PUMP_RATE$() ) >>
Why created:    normalization of [serial 1779]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by: Absorb parentheses, middle term in disjunction (bl.orabpm)

Theorem (284)                               [serial 1779] 
P [1] << ( Pause_Infusion iff ( PUMP_RATE$() = KVO_RATE_property or ( ( LAST_ACTION_A = last_action'SafetyStopPump ) or 
( LAST_ACTION_A = last_action'StopButton ) or ( LAST_ACTION_A = last_action'EndPriming ) ) ) )
  and ( PO_Alarm iff ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) )
  and ( RM_Alarm iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) )
  and ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) implies ( PUMP_RATE$() = KVO_RATE_property or 
( ( LAST_ACTION_A = last_action'SafetyStopPump ) or ( LAST_ACTION_A = last_action'StopButton ) or 
( LAST_ACTION_A = last_action'EndPriming ) ) ) ) >>
S    ->
Q [2] << ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 or RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) implies ( 
PUMP_RATE$() = KVO_RATE_property or ( ( LAST_ACTION_A = last_action'SafetyStopPump ) or 
( LAST_ACTION_A = last_action'StopButton ) or ( LAST_ACTION_A = last_action'EndPriming ) ) ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1778]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 283:
Theorem (283) [serial 1781] used for:
    normalization of [serial 1779] 


Theorem (285)                               [serial 1778] 
P [1] << ( Pause_Infusion iff ( PUMP_RATE$() = KVO_RATE_property or HALT() ) )
  and ( PO_Alarm iff PO_ALARM() )
  and ( RM_Alarm iff RM_ALARM() )
  and ( ( PO_ALARM() or RM_ALARM() ) implies ( PUMP_RATE$() = KVO_RATE_property or 
HALT() ) ) >>
S    ->
Q [2] << ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 or RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) implies ( 
PUMP_RATE$() = KVO_RATE_property or HALT() ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1777]
Solved by: Predicate Invocation. (PI) and theorem 284:
Theorem (284) [serial 1779] used for:
  Substituted assertions' predicates for labels  [serial 1778] 


Theorem (286)                               [serial 1777] 
P [1] << ( Pause_Infusion iff ( PUMP_RATE$() = KVO_RATE_property or HALT() ) )
  and ( PO_Alarm iff PO_ALARM() )
  and ( RM_Alarm iff RM_ALARM() )
  and ( ( PO_ALARM() or RM_ALARM() ) implies ( PUMP_RATE$() = KVO_RATE_property or 
HALT() ) ) >>
S    ->
Q [2] << IS_SAFE() >>
Why created:  Substituting Equals Within Conjunction [serial 1037]
Solved by: Predicate Invocation. (PI) and theorem 285:
Theorem (285) [serial 1778] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1777] 


Theorem (287)                               [serial 1037] 
P [1] << ( Pause_Infusion iff ( PUMP_RATE$() = KVO_RATE_property or HALT() ) )
  and ( PO_Alarm iff PO_ALARM() )
  and ( RM_Alarm iff RM_ALARM() )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S    ->
Q [2] << IS_SAFE() >>
Why created:  Conjunction of Subcomponents' Invariants imply SysIoMT.impl's Invariant
Solved by: A equality theorem for substitution. (subequ12a) and theorem 286:
Theorem (286) [serial 1777] used for:
  Substituting Equals Within Conjunction [serial 1037] 


Theorem (288)                               [serial 1786] 
P [1] << ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion >>
S    ->
Q [2] << ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion >>
Why created:    normalization of [serial 1038]
Solved by: Identity (id):  P->P is tautology

Theorem (289)                               [serial 1038] 
P [1] << ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S    ->
Q [2] << ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion >>
Why created:  Subcomponent's Invariant implies Coordinator.impl's Invariant
Solved by: [Add unnecessary parentheses] and theorem 288:
Theorem (288) [serial 1786] used for:
    normalization of [serial 1038] 


Theorem (290)                               [serial 1039] 
P [1] << PO_ALARM() or RM_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() or RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection pcc.pause_infusion -> pct.pause_infusion:
 pause_infusion -> pause_infusion
Solved by: Identity (id):  P->P is tautology

Theorem (291)                               [serial 1040] 
P [1] << pump_rate = PUMP_RATE() >>
S [2] ->
Q [1] << pump_rate = PUMP_RATE() >>
Why created:  Composition of Subcomponents via Directional Connection pcp.pct.pump_rate -> pmp.pump_rate:
 pump_rate -> pump_rate
Solved by: Identity (id):  P->P is tautology

Theorem (292)                               [serial 1041] 
P [1] << PO_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection pot.PO_Alarm -> poc.poa:
 PO_Alarm -> poa
Solved by: Identity (id):  P->P is tautology

Theorem (293)                               [serial 1042] 
P [1] << RM_ALARM() >>
S [2] ->
Q [1] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection rmt.RM_Alarm -> rmc.rma:
 RM_Alarm -> rma
Solved by: Identity (id):  P->P is tautology

Theorem (294)                               [serial 1043] 
P [1] << RM_ALARM() >>
S [2] ->
Q [1] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection spt.RM_Alarm_Echo -> spc.rmae:
 RM_Alarm_Echo -> rmae
Solved by: Identity (id):  P->P is tautology

Theorem (295)                               [serial 1044] 
P [1] << PO_ALARM() or RM_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() or RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection spt.Pause_Infusion -> spc.pi:
 Pause_Infusion -> pi
Solved by: Identity (id):  P->P is tautology

Theorem (296)                               [serial 1045] 
P [1] << PO_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection spt.PO_Alarm_Echo -> spc.poae:
 PO_Alarm_Echo -> poae
Solved by: Identity (id):  P->P is tautology

Theorem (297)                               [serial 1046] 
P [1] << PO_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection spc.PO_Alarm -> spt.PO_Alarm:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (298)                               [serial 1047] 
P [1] << RM_ALARM() >>
S [2] ->
Q [1] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection spc.RM_Alarm -> spt.RM_Alarm:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (299)                               [serial 1048] 
P [1] << PAUSE_INFUSION_ECHO >>
S [2] ->
Q [1] << PAUSE_INFUSION_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection spc.Pause_Infusion_Echo -> spt.Pause_Infusion_Echo:
 Pause_Infusion_Echo -> Pause_Infusion_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (300)                               [serial 1049] 
P [1] << infused_drug = PUMP_RATE() >>
S [2] ->
Q [1] << infused_drug = PUMP_RATE() >>
Why created:  Composition of Subcomponents via Directional Connection pca_pump.pmp.infused_drug -> patient.Infused_Drug:
 infused_drug -> Infused_Drug
Solved by: Identity (id):  P->P is tautology

Theorem (301)                               [serial 1050] 
P [1] << PO_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection pulse_oximeter.poc.poc.PO_Alarm -> coordinator.spp.spc.poa:
 PO_Alarm -> poa
Solved by: Identity (id):  P->P is tautology

Theorem (302)                               [serial 1051] 
P [1] << RM_ALARM() >>
S [2] ->
Q [1] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection resp_monitor.rmp.rmc.RM_Alarm -> coordinator.spp.spc.rma:
 RM_Alarm -> rma
Solved by: Identity (id):  P->P is tautology

Theorem (303)                               [serial 1052] 
P [1] << PO_ALARM() or RM_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() or RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection coordinator.spp.spc.Pause_Infusion -> pca_pump.pcp.pcc.pi:
 Pause_Infusion -> pi
Solved by: Identity (id):  P->P is tautology

Theorem (304)                               [serial 1053] 
P [89] << Infused_Drug = PUMP_RATE() >>
S [75] ->
Q [122] << Infused_Drug = PUMP_RATE() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTsimple::SysIoMT.impl.infusion_set:
 Infused_Drug -> Infused_Drug
Solved by: Identity (id):  P->P is tautology

Theorem (305)                               [serial 1054] 
P [132] << PO_ALARM() or RM_ALARM() >>
S [72] ->
Q [87] << PO_ALARM() or RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTsimple::SysIoMT.impl.pause_infusion:
 Pause_Infusion -> Pause_infusion
Solved by: Identity (id):  P->P is tautology

Theorem (306)                               [serial 1055] 
P [102] << PO_ALARM() >>
S [73] ->
Q [128] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTsimple::SysIoMT.impl.spo2_alarm:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (307)                               [serial 1056] 
P [112] << RM_ALARM() >>
S [74] ->
Q [130] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTsimple::SysIoMT.impl.resp_alarm:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (308)                               [serial 1057] 
P [128] << PO_ALARM() >>
S [143] ->
Q [151] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTsimple::Coordinator.impl.poa:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (309)                               [serial 1058] 
P [130] << RM_ALARM() >>
S [144] ->
Q [153] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTsimple::Coordinator.impl.rma:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (310)                               [serial 1059] 
P [155] << PO_ALARM() or RM_ALARM() >>
S [145] ->
Q [132] << PO_ALARM() or RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTsimple::Coordinator.impl.pi:
 Pause_Infusion -> Pause_Infusion
Solved by: Identity (id):  P->P is tautology

Theorem (311)                               [serial 1060] 
P [151] << PO_ALARM() >>
S [165] ->
Q [176] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTsimple::Coordinator_Process.impl.poa:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (312)                               [serial 1061] 
P [153] << RM_ALARM() >>
S [166] ->
Q [179] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTsimple::Coordinator_Process.impl.rma:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (313)                               [serial 1062] 
P [173] << PO_ALARM() or RM_ALARM() >>
S [167] ->
Q [155] << PO_ALARM() or RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTsimple::Coordinator_Process.impl.pi:
 Pause_Infusion -> Pause_Infusion
Solved by: Identity (id):  P->P is tautology

Theorem (314)                               [serial 1063] 
P [78] << infused_drug = PUMP_RATE() >>
S [49] ->
Q [725] << infused_drug = PUMP_RATE() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.infusion_set:
 infused_drug -> Infused_Drug
Solved by: Identity (id):  P->P is tautology

Theorem (315)                               [serial 1064] 
P [515] << PO_ALARM() or RM_ALARM() >>
S [33] ->
Q [77] << PO_ALARM() or RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.pause_infusion:
 Pause_Infusion -> pause_infusion
Solved by: Identity (id):  P->P is tautology

Theorem (316)                               [serial 1065] 
P [174] << PO_ALARM() >>
S [35] ->
Q [513] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.po_alarm:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (317)                               [serial 1066] 
P [353] << RM_ALARM() >>
S [37] ->
Q [514] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.rm_alarm:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (318)                               [serial 1067] 
P [147] << infused_drug = PUMP_RATE() >>
S [96] ->
Q [78] << infused_drug = PUMP_RATE() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pd:
 infused_drug -> infused_drug
Solved by: Identity (id):  P->P is tautology

Theorem (319)                               [serial 1068] 
P [77] << PO_ALARM() or RM_ALARM() >>
S [92] ->
Q [103] << PO_ALARM() or RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pif:
 pause_infusion -> pause_infusion
Solved by: Identity (id):  P->P is tautology

Theorem (320)                               [serial 1069] 
P [104] << pump_rate = PUMP_RATE() >>
S [94] ->
Q [152] << pump_rate = PUMP_RATE() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pr:
 pump_rate -> pump_rate
Solved by: Identity (id):  P->P is tautology

Theorem (321)                               [serial 1070] 
P [103] << PO_ALARM() or RM_ALARM() >>
S [115] ->
Q [160] << PO_ALARM() or RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.pi1:
 pause_infusion -> pi
Solved by: Identity (id):  P->P is tautology

Theorem (322)                               [serial 1071] 
P [161] << PO_ALARM() or RM_ALARM() >>
S [116] ->
Q [129] << PO_ALARM() or RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.pi2:
 pause_infusion -> pause_infusion
Solved by: Identity (id):  P->P is tautology

Theorem (323)                               [serial 1072] 
P [130] << pump_rate = PUMP_RATE() >>
S [123] ->
Q [104] << pump_rate = PUMP_RATE() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.PCA_Pump_Process_impl_new_connection:
 pump_rate -> pump_rate
Solved by: Identity (id):  P->P is tautology

Theorem (324)                               [serial 1073] 
P [199] << PO_ALARM() >>
S [186] ->
Q [174] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter.impl.poa:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (325)                               [serial 1074] 
P [231] << PO_ALARM() >>
S [215] ->
Q [332] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter_Process.impl.pol1:
 PO_Alarm -> poa
Solved by: Identity (id):  P->P is tautology

Theorem (326)                               [serial 1075] 
P [333] << PO_ALARM() >>
S [216] ->
Q [199] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter_Process.impl.pol2:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (327)                               [serial 1076] 
P [376] << RM_ALARM() >>
S [366] ->
Q [353] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor.impl.rma:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (328)                               [serial 1077] 
P [404] << RM_ALARM() >>
S [394] ->
Q [487] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor_Process.impl.rma1:
 RM_Alarm -> rma
Solved by: Identity (id):  P->P is tautology

Theorem (329)                               [serial 1078] 
P [490] << RM_ALARM() >>
S [395] ->
Q [376] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor_Process.impl.rma2:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (330)                               [serial 1079] 
P [513] << PO_ALARM() >>
S [528] ->
Q [543] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.poa:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (331)                               [serial 1080] 
P [514] << RM_ALARM() >>
S [529] ->
Q [544] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.rma:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (332)                               [serial 1081] 
P [545] << PO_ALARM() or RM_ALARM() >>
S [530] ->
Q [515] << PO_ALARM() or RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.pi:
 Pause_Infusion -> Pause_Infusion
Solved by: Identity (id):  P->P is tautology

Theorem (333)                               [serial 1082] 
P [519] << PAUSE_INFUSION_ECHO >>
S [531] ->
Q [549] << PAUSE_INFUSION_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.pie:
 Pause_Infusion_Echo -> Pause_Infusion_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (334)                               [serial 1083] 
P [547] << PO_ALARM() >>
S [533] ->
Q [517] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.icp:
 PO_Alarm_Echo -> PO_Alarm_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (335)                               [serial 1084] 
P [540] << RM_ALARM() >>
S [534] ->
Q [509] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.icr:
 RM_Alarm_Echo -> RM_Alarm_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (336)                               [serial 1085] 
P [543] << PO_ALARM() >>
S [560] ->
Q [682] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poa1:
 PO_Alarm -> poa
Solved by: Identity (id):  P->P is tautology

Theorem (337)                               [serial 1086] 
P [683] << PO_ALARM() >>
S [561] ->
Q [592] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poa2:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (338)                               [serial 1087] 
P [544] << RM_ALARM() >>
S [564] ->
Q [685] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rma1:
 RM_Alarm -> rma
Solved by: Identity (id):  P->P is tautology

Theorem (339)                               [serial 1088] 
P [687] << RM_ALARM() >>
S [565] ->
Q [593] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rma2:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (340)                               [serial 1089] 
P [549] << PAUSE_INFUSION_ECHO >>
S [568] ->
Q [690] << PAUSE_INFUSION_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pie1:
 Pause_Infusion_Echo -> pie
Solved by: Identity (id):  P->P is tautology

Theorem (341)                               [serial 1090] 
P [692] << PAUSE_INFUSION_ECHO >>
S [569] ->
Q [598] << PAUSE_INFUSION_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pie2:
 Pause_Infusion_Echo -> Pause_Infusion_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (342)                               [serial 1091] 
P [594] << PO_ALARM() or RM_ALARM() >>
S [571] ->
Q [695] << PO_ALARM() or RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pi1:
 Pause_Infusion -> pi
Solved by: Identity (id):  P->P is tautology

Theorem (343)                               [serial 1092] 
P [697] << PO_ALARM() or RM_ALARM() >>
S [572] ->
Q [545] << PO_ALARM() or RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pi2:
 Pause_Infusion -> Pause_Infusion
Solved by: Identity (id):  P->P is tautology

Theorem (344)                               [serial 1093] 
P [589] << RM_ALARM() >>
S [574] ->
Q [700] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rme1:
 RM_Alarm_Echo -> rmae
Solved by: Identity (id):  P->P is tautology

Theorem (345)                               [serial 1094] 
P [702] << RM_ALARM() >>
S [575] ->
Q [540] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rme2:
 RM_Alarm_Echo -> RM_Alarm_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (346)                               [serial 1095] 
P [596] << PO_ALARM() >>
S [577] ->
Q [705] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poe1:
 PO_Alarm_Echo -> poae
Solved by: Identity (id):  P->P is tautology

Theorem (347)                               [serial 1096] 
P [707] << PO_ALARM() >>
S [578] ->
Q [547] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poe2:
 PO_Alarm_Echo -> PO_Alarm_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (348)                               [serial 1001] 
Why created:  All verification conditions have been proved correct. 
Solved by:  Component and Connection Proofs
 and theorems 21 112 181 275 280 282 287 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347:
Theorem (21) [serial 1002] used for:
  Initial proof obligations for Coordinator_Thread.simple 
Theorem (112) [serial 1010] used for:
  Initial proof obligations for Pulse_Oximeter_Thread.impl 
Theorem (181) [serial 1018] used for:
  Initial proof obligations for Respiration_Monitor_Thread.impl 
Theorem (275) [serial 1026] used for:
  Initial proof obligations for Coordinator_Thread.echo 
Theorem (280) [serial 1035] used for:
  Conjunction of Subcomponents' Invariants imply SysIoMT.impl's Invariant 
Theorem (282) [serial 1036] used for:
  Subcomponent's Invariant implies Coordinator.impl's Invariant 
Theorem (287) [serial 1037] used for:
  Conjunction of Subcomponents' Invariants imply SysIoMT.impl's Invariant 
Theorem (289) [serial 1038] used for:
  Subcomponent's Invariant implies Coordinator.impl's Invariant 
Theorem (290) [serial 1039] used for:
  Composition of Subcomponents via Directional Connection pcc.pause_infusion -> pct.pause_infusion:
 pause_infusion -> pause_infusion 
Theorem (291) [serial 1040] used for:
  Composition of Subcomponents via Directional Connection pcp.pct.pump_rate -> pmp.pump_rate:
 pump_rate -> pump_rate 
Theorem (292) [serial 1041] used for:
  Composition of Subcomponents via Directional Connection pot.PO_Alarm -> poc.poa:
 PO_Alarm -> poa 
Theorem (293) [serial 1042] used for:
  Composition of Subcomponents via Directional Connection rmt.RM_Alarm -> rmc.rma:
 RM_Alarm -> rma 
Theorem (294) [serial 1043] used for:
  Composition of Subcomponents via Directional Connection spt.RM_Alarm_Echo -> spc.rmae:
 RM_Alarm_Echo -> rmae 
Theorem (295) [serial 1044] used for:
  Composition of Subcomponents via Directional Connection spt.Pause_Infusion -> spc.pi:
 Pause_Infusion -> pi 
Theorem (296) [serial 1045] used for:
  Composition of Subcomponents via Directional Connection spt.PO_Alarm_Echo -> spc.poae:
 PO_Alarm_Echo -> poae 
Theorem (297) [serial 1046] used for:
  Composition of Subcomponents via Directional Connection spc.PO_Alarm -> spt.PO_Alarm:
 PO_Alarm -> PO_Alarm 
Theorem (298) [serial 1047] used for:
  Composition of Subcomponents via Directional Connection spc.RM_Alarm -> spt.RM_Alarm:
 RM_Alarm -> RM_Alarm 
Theorem (299) [serial 1048] used for:
  Composition of Subcomponents via Directional Connection spc.Pause_Infusion_Echo -> spt.Pause_Infusion_Echo:
 Pause_Infusion_Echo -> Pause_Infusion_Echo 
Theorem (300) [serial 1049] used for:
  Composition of Subcomponents via Directional Connection pca_pump.pmp.infused_drug -> patient.Infused_Drug:
 infused_drug -> Infused_Drug 
Theorem (301) [serial 1050] used for:
  Composition of Subcomponents via Directional Connection pulse_oximeter.poc.poc.PO_Alarm -> coordinator.spp.spc.poa:
 PO_Alarm -> poa 
Theorem (302) [serial 1051] used for:
  Composition of Subcomponents via Directional Connection resp_monitor.rmp.rmc.RM_Alarm -> coordinator.spp.spc.rma:
 RM_Alarm -> rma 
Theorem (303) [serial 1052] used for:
  Composition of Subcomponents via Directional Connection coordinator.spp.spc.Pause_Infusion -> pca_pump.pcp.pcc.pi:
 Pause_Infusion -> pi 
Theorem (304) [serial 1053] used for:
  Composition of Subcomponents via Directional Connection IoMTsimple::SysIoMT.impl.infusion_set:
 Infused_Drug -> Infused_Drug 
Theorem (305) [serial 1054] used for:
  Composition of Subcomponents via Directional Connection IoMTsimple::SysIoMT.impl.pause_infusion:
 Pause_Infusion -> Pause_infusion 
Theorem (306) [serial 1055] used for:
  Composition of Subcomponents via Directional Connection IoMTsimple::SysIoMT.impl.spo2_alarm:
 PO_Alarm -> PO_Alarm 
Theorem (307) [serial 1056] used for:
  Composition of Subcomponents via Directional Connection IoMTsimple::SysIoMT.impl.resp_alarm:
 RM_Alarm -> RM_Alarm 
Theorem (308) [serial 1057] used for:
  Composition of Subcomponents via Directional Connection IoMTsimple::Coordinator.impl.poa:
 PO_Alarm -> PO_Alarm 
Theorem (309) [serial 1058] used for:
  Composition of Subcomponents via Directional Connection IoMTsimple::Coordinator.impl.rma:
 RM_Alarm -> RM_Alarm 
Theorem (310) [serial 1059] used for:
  Composition of Subcomponents via Directional Connection IoMTsimple::Coordinator.impl.pi:
 Pause_Infusion -> Pause_Infusion 
Theorem (311) [serial 1060] used for:
  Composition of Subcomponents via Directional Connection IoMTsimple::Coordinator_Process.impl.poa:
 PO_Alarm -> PO_Alarm 
Theorem (312) [serial 1061] used for:
  Composition of Subcomponents via Directional Connection IoMTsimple::Coordinator_Process.impl.rma:
 RM_Alarm -> RM_Alarm 
Theorem (313) [serial 1062] used for:
  Composition of Subcomponents via Directional Connection IoMTsimple::Coordinator_Process.impl.pi:
 Pause_Infusion -> Pause_Infusion 
Theorem (314) [serial 1063] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.infusion_set:
 infused_drug -> Infused_Drug 
Theorem (315) [serial 1064] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.pause_infusion:
 Pause_Infusion -> pause_infusion 
Theorem (316) [serial 1065] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.po_alarm:
 PO_Alarm -> PO_Alarm 
Theorem (317) [serial 1066] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.rm_alarm:
 RM_Alarm -> RM_Alarm 
Theorem (318) [serial 1067] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pd:
 infused_drug -> infused_drug 
Theorem (319) [serial 1068] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pif:
 pause_infusion -> pause_infusion 
Theorem (320) [serial 1069] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pr:
 pump_rate -> pump_rate 
Theorem (321) [serial 1070] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.pi1:
 pause_infusion -> pi 
Theorem (322) [serial 1071] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.pi2:
 pause_infusion -> pause_infusion 
Theorem (323) [serial 1072] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.PCA_Pump_Process_impl_new_connection:
 pump_rate -> pump_rate 
Theorem (324) [serial 1073] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter.impl.poa:
 PO_Alarm -> PO_Alarm 
Theorem (325) [serial 1074] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter_Process.impl.pol1:
 PO_Alarm -> poa 
Theorem (326) [serial 1075] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter_Process.impl.pol2:
 PO_Alarm -> PO_Alarm 
Theorem (327) [serial 1076] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor.impl.rma:
 RM_Alarm -> RM_Alarm 
Theorem (328) [serial 1077] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor_Process.impl.rma1:
 RM_Alarm -> rma 
Theorem (329) [serial 1078] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor_Process.impl.rma2:
 RM_Alarm -> RM_Alarm 
Theorem (330) [serial 1079] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.poa:
 PO_Alarm -> PO_Alarm 
Theorem (331) [serial 1080] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.rma:
 RM_Alarm -> RM_Alarm 
Theorem (332) [serial 1081] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.pi:
 Pause_Infusion -> Pause_Infusion 
Theorem (333) [serial 1082] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.pie:
 Pause_Infusion_Echo -> Pause_Infusion_Echo 
Theorem (334) [serial 1083] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.icp:
 PO_Alarm_Echo -> PO_Alarm_Echo 
Theorem (335) [serial 1084] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.icr:
 RM_Alarm_Echo -> RM_Alarm_Echo 
Theorem (336) [serial 1085] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poa1:
 PO_Alarm -> poa 
Theorem (337) [serial 1086] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poa2:
 PO_Alarm -> PO_Alarm 
Theorem (338) [serial 1087] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rma1:
 RM_Alarm -> rma 
Theorem (339) [serial 1088] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rma2:
 RM_Alarm -> RM_Alarm 
Theorem (340) [serial 1089] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pie1:
 Pause_Infusion_Echo -> pie 
Theorem (341) [serial 1090] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pie2:
 Pause_Infusion_Echo -> Pause_Infusion_Echo 
Theorem (342) [serial 1091] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pi1:
 Pause_Infusion -> pi 
Theorem (343) [serial 1092] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pi2:
 Pause_Infusion -> Pause_Infusion 
Theorem (344) [serial 1093] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rme1:
 RM_Alarm_Echo -> rmae 
Theorem (345) [serial 1094] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rme2:
 RM_Alarm_Echo -> RM_Alarm_Echo 
Theorem (346) [serial 1095] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poe1:
 PO_Alarm_Echo -> poae 
Theorem (347) [serial 1096] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poe2:
 PO_Alarm_Echo -> PO_Alarm_Echo 


closing proof file "/Applications/osate2_2023-12-master/Eclipse.app/Contents/MacOS/proof.txt" 