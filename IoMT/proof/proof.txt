This file, proof.txt, was produced the BLESS Proof Assistant v3.2.4
  at Sun Apr 28 11:12:33 CDT 2024 by brianlarson

Theorem (1)                               [serial 1086] 
P [268] << MHR_A()
  and POA_A()
  and PSPO2_A() >>
S [253] ->
Q [253] << MHR_A()
  and POA_A()
  and PSPO2_A() >>
Why created:    normalization of [serial 1084]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (2)                               [serial 1084] 
P [268] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
S [253] ->
Q [253] << MHR_A()
  and PSPO2_A()
  and POA_A() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1003]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 1:
Theorem (1) [serial 1086] used for:
    normalization of [serial 1084] 


Theorem (3)                               [serial 1003] 
P [268] << INV_PO() >>
S [253] ->
Q [253] << MHR_A()
  and PSPO2_A()
  and POA_A() >>
Why created:  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 2:
Theorem (2) [serial 1084] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1003] 


Theorem (4)                               [serial 1089] 
P [267] << MHR_A()
  and POA_A()
  and PSPO2_A() >>
S [253] ->
Q [253] << MHR_A()
  and POA_A()
  and PSPO2_A() >>
Why created:    normalization of [serial 1087]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (5)                               [serial 1087] 
P [267] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
S [253] ->
Q [253] << MHR_A()
  and PSPO2_A()
  and POA_A() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1004]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 4:
Theorem (4) [serial 1089] used for:
    normalization of [serial 1087] 


Theorem (6)                               [serial 1004] 
P [267] << INV_PO() >>
S [253] ->
Q [253] << MHR_A()
  and PSPO2_A()
  and POA_A() >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 5:
Theorem (5) [serial 1087] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1004] 


Theorem (7)                               [serial 1005] 
P [266] << INV_PO() >>
S [266] ->
Q [266] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by: Anything Implies True (a1tru): P->true

Theorem (8)                               [serial 1006] 
P [266] << INV_PO() >>
S [271] ->
Q [267] << INV_PO() >>
Why created:   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{};
Solved by: Identity (id):  P->P is tautology

Theorem (9)                               [serial 1090] 
P [267] << INV_PO() >>
S [267] ->
Q [275] << INV_PO() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1007]
Solved by: Identity (id):  P->P is tautology

Theorem (10)                               [serial 1091] 
P [300] << INV_PO() >>
S [268] ->
Q [268] << INV_PO() >>
Why created:  <<Q3>> -> <<Q>> in sequential composition for [serial 1007]
Solved by: Identity (id):  P->P is tautology

Theorem (11)                               [serial 1162] 
P [276] << HEART_RATE = hrr
  and INV_PO() >>
S [276] ->
Q [277] << HEART_RATE = hrr
  and INV_PO() >>
Why created:    normalization of [serial 1160]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (12)                               [serial 1160] 
P [276] << ( INV_PO() )
  and hrr = HEART_RATE >>
S [276] ->
Q [277] << HEART_RATE = hrr
  and INV_PO() >>
Why created:  applied port input of value <<pre and hrr=M(Heart_Rate)>> -> <<post>> [serial 1115]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 11:
Theorem (11) [serial 1162] used for:
    normalization of [serial 1160] 


Theorem (13)                               [serial 1115] 
P [275] << INV_PO() >>
S [276] Heart_Rate?(hrr)
Q [277] << HEART_RATE = hrr
  and INV_PO() >>
Why created:    normalization of [serial 1092]
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 12:
Theorem (12) [serial 1160] used for:
  applied port input of value <<pre and hrr=M(Heart_Rate)>> -> <<post>> [serial 1115] 


Theorem (14)                               [serial 1092] 
P [275] << INV_PO() >>
S [276] Heart_Rate?(hrr)
Q [277] << hrr = HEART_RATE
  and INV_PO() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1007]
Solved by: Equality Commutes. (eqcom) and theorem 13:
Theorem (13) [serial 1115] used for:
    normalization of [serial 1092] 


Theorem (15)                               [serial 1165] 
P [278] << ( HEART_RATE = hrr
  and INV_PO() )
  and SPO2 = sp >>
S [278] ->
Q [279] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1163]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (16)                               [serial 1163] 
P [278] << ( HEART_RATE = hrr
  and INV_PO() )
  and sp = SPO2 >>
S [278] ->
Q [279] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:  applied port input of value <<pre and sp=M(Spo2_Level)>> -> <<post>> [serial 1117]
Solved by: Equality Commutes. (eqcom) and theorem 15:
Theorem (15) [serial 1165] used for:
    normalization of [serial 1163] 


Theorem (17)                               [serial 1117] 
P [277] << HEART_RATE = hrr
  and INV_PO() >>
S [278] Spo2_Level?(sp)
Q [279] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1093]
  Using: (eqcom) (bl.ancom) 
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 16:
Theorem (16) [serial 1163] used for:
  applied port input of value <<pre and sp=M(Spo2_Level)>> -> <<post>> [serial 1117] 


Theorem (18)                               [serial 1093] 
P [277] << hrr = HEART_RATE
  and INV_PO() >>
S [278] Spo2_Level?(sp)
Q [279] << hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1007]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 17:
Theorem (17) [serial 1117] used for:
    normalization of [serial 1093] 


Theorem (19)                               [serial 1170] 
P [279] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [281] ->
Q [281] << ( not ( hrr < mhr ) or hrr < mhr or sp < psp )
  and ( not ( sp < psp ) or hrr < mhr or sp < psp ) >>
Why created:  Distributing Postcondition Or-Over-And [serial 1169]
Solved by: Law of Excluded middle. (exmid)

Theorem (20)                               [serial 1169] 
P [279] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [281] ->
Q [281] << ( not ( hrr < mhr )
  and not ( sp < psp ) ) or hrr < mhr or sp < psp >>
Why created:    normalization of [serial 1167]
Solved by: Distribution and-over-or with wff lists. (bl.dba2owl) and theorem 19:
Theorem (19) [serial 1170] used for:
  Distributing Postcondition Or-Over-And [serial 1169] 


Theorem (21)                               [serial 1167] 
P [279] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [281] ->
Q [281] << ( ( not ( hrr < mhr ) )
  and ( not ( sp < psp ) ) ) or hrr < mhr or sp < psp >>
Why created:  Replacing <= with not < of [serial 1119]
Solved by: [Add unnecessary parentheses] and theorem 20:
Theorem (20) [serial 1169] used for:
    normalization of [serial 1167] 


Theorem (22)                               [serial 1119] 
P [279] << HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [281] ->
Q [281] << ( mhr <= hrr
  and psp <= sp ) or hrr < mhr or sp < psp >>
Why created:    normalization of [serial 1095]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) (bl.orcom) 
Solved by: 'Less than' expressed in terms of 'less than or equal to'. (ltnle) and theorem 21:
Theorem (21) [serial 1167] used for:
  Replacing <= with not < of [serial 1119] 


Theorem (23)                               [serial 1095] 
P [279] << hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 >>
S [281] ->
Q [281] << ( hrr >= mhr
  and sp >= psp ) or ( hrr < mhr ) or ( sp < psp ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1094]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 22:
Theorem (22) [serial 1119] used for:
    normalization of [serial 1095] 


Theorem (24)                               [serial 1121] 
P [281] << ( mhr <= hrr
  and psp <= sp )
  and ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() ) >>
S [283] ->
Q [283] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1102]
  Using: (eqcom) changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (25)                               [serial 1102] 
P [281] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr >= mhr
  and sp >= psp ) >>
S [283] ->
Q [283] << hrr = HEART_RATE
  and hrr >= mhr
  and sp = SPO2
  and sp >= psp
  and INV_PO() >>
Why created:  P -> P1 in concurrent composition for [serial 1099]
Solved by: Equality Commutes. (eqcom) [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 24:
Theorem (24) [serial 1121] used for:
    normalization of [serial 1102] 


Theorem (26)                               [serial 1103] 
P [285] << INV_PO() >>
S [285] ->
Q [300] << INV_PO() >>
Why created:  Qk -> Q in concurrent composition for [serial 1099]
Solved by: Identity (id):  P->P is tautology

Theorem (27)                               [serial 1179] 
P [283] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [284] ->
Q [300] << ( LOW_SPO2_HR() iff false )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:  applied wp for assignment [serial 1178]
Solved by: The negation of a proposition is equivalent to itself being equivalent to false. (nbfal)

Theorem (28)                               [serial 1178] 
P [283] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [284] poa := false
Q [300] << ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:    normalization of [serial 1176]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 27:
Theorem (27) [serial 1179] used for:
  applied wp for assignment [serial 1178] 


Theorem (29)                               [serial 1176] 
P [283] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [284] poa := false
Q [300] << ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1175]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 28:
Theorem (28) [serial 1178] used for:
    normalization of [serial 1176] 


Theorem (30)                               [serial 1175] 
P [283] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [284] poa := false
Q [300] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1123]
Solved by: Predicate Invocation. (PI) and theorem 29:
Theorem (29) [serial 1176] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1175] 


Theorem (31)                               [serial 1123] 
P [283] << mhr <= hrr
  and psp <= sp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [284] poa := false
Q [300] << INV_PO() >>
Why created:    normalization of [serial 1104]
  Using: (eqcom) changeAtLeastToAtMost (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 30:
Theorem (30) [serial 1175] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1123] 


Theorem (32)                               [serial 1104] 
P [283] << hrr = HEART_RATE
  and hrr >= mhr
  and sp = SPO2
  and sp >= psp
  and INV_PO() >>
S [284] poa := false
Q [300] << INV_PO() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1099]
Solved by: Equality Commutes. (eqcom) [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 31:
Theorem (31) [serial 1123] used for:
    normalization of [serial 1104] 


Theorem (33)                               [serial 1125] 
P [281] << ( mhr <= hrr
  and psp <= sp )
  and ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() ) >>
S [284] PO_Alarm!(false)
Q [285] << INV_PO() >>
Why created:    normalization of [serial 1105]
  Using: (eqcom) changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (34)                               [serial 1105] 
P [281] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr >= mhr
  and sp >= psp ) >>
S [284] PO_Alarm!(false)
Q [285] << INV_PO() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1099]
Solved by: Equality Commutes. (eqcom) [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 33:
Theorem (33) [serial 1125] used for:
    normalization of [serial 1105] 


Theorem (35)                               [serial 1099] 
P [281] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr >= mhr
  and sp >= psp ) >>
S [283]   << hrr = HEART_RATE
    and hrr >= mhr
    and sp = SPO2
    and sp >= psp
    and INV_PO() >>
  poa := false
  &
  PO_Alarm!(false)
  << INV_PO() >> 
Q [300] << INV_PO() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1096]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 25 26 32 34:
Theorem (25) [serial 1102] used for:
  P -> P1 in concurrent composition for [serial 1099] 
Theorem (26) [serial 1103] used for:
  Qk -> Q in concurrent composition for [serial 1099] 
Theorem (32) [serial 1104] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1099] 
Theorem (34) [serial 1105] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1099] 


Theorem (36)                               [serial 1096] 
P [281] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr >= mhr
  and sp >= psp ) >>
S [282]   {
    << hrr = HEART_RATE
      and hrr >= mhr
      and sp = SPO2
      and sp >= psp
      and INV_PO() >>
    poa := false
    &
    PO_Alarm!(false)
    << INV_PO() >> 
  } 
Q [300] << INV_PO() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1094]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 35:
Theorem (35) [serial 1099] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1096] 


Theorem (37)                               [serial 1127] 
P [281] << ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() )
  and hrr < mhr >>
S [289] ->
Q [289] << hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1106]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (38)                               [serial 1106] 
P [281] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr < mhr ) >>
S [289] ->
Q [289] << hrr = HEART_RATE
  and hrr < mhr
  and sp = SPO2
  and INV_PO() >>
Why created:  P -> P1 in concurrent composition for [serial 1100]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 37:
Theorem (37) [serial 1127] used for:
    normalization of [serial 1106] 


Theorem (39)                               [serial 1107] 
P [291] << INV_PO() >>
S [291] ->
Q [300] << INV_PO() >>
Why created:  Qk -> Q in concurrent composition for [serial 1100]
Solved by: Identity (id):  P->P is tautology

Theorem (40)                               [serial 1240] 
P [289] << ( ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp )
  and hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp >>
S [290] poa := true
Q [300] << ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:    normalization of [serial 1238]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (41)                               [serial 1238] 
P [289] << hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp
  and ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
S [290] poa := true
Q [300] << ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1237]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 40:
Theorem (40) [serial 1240] used for:
    normalization of [serial 1238] 


Theorem (42)                               [serial 1237] 
P [289] << hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp
  and ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
S [290] poa := true
Q [300] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1129]
Solved by: Predicate Invocation. (PI) and theorem 41:
Theorem (41) [serial 1238] used for:
  Substituted assertions' predicates for labels  [serial 1237] 


Theorem (43)                               [serial 1129] 
P [289] << hrr < mhr
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [290] poa := true
Q [300] << INV_PO() >>
Why created:    normalization of [serial 1108]
  Using: (eqcom) (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 42:
Theorem (42) [serial 1237] used for:
  Substituted assertions' predicates for labels  [serial 1129] 


Theorem (44)                               [serial 1108] 
P [289] << hrr = HEART_RATE
  and hrr < mhr
  and sp = SPO2
  and INV_PO() >>
S [290] poa := true
Q [300] << INV_PO() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1100]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 43:
Theorem (43) [serial 1129] used for:
    normalization of [serial 1108] 


Theorem (45)                               [serial 1131] 
P [281] << ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() )
  and hrr < mhr >>
S [290] PO_Alarm!(true)
Q [291] << INV_PO() >>
Why created:    normalization of [serial 1109]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (46)                               [serial 1109] 
P [281] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr < mhr ) >>
S [290] PO_Alarm!(true)
Q [291] << INV_PO() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1100]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 45:
Theorem (45) [serial 1131] used for:
    normalization of [serial 1109] 


Theorem (47)                               [serial 1100] 
P [281] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr < mhr ) >>
S [289]   << hrr = HEART_RATE
    and hrr < mhr
    and sp = SPO2
    and INV_PO() >>
  poa := true
  &
  PO_Alarm!(true)
  << INV_PO() >> 
Q [300] << INV_PO() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1097]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 38 39 44 46:
Theorem (38) [serial 1106] used for:
  P -> P1 in concurrent composition for [serial 1100] 
Theorem (39) [serial 1107] used for:
  Qk -> Q in concurrent composition for [serial 1100] 
Theorem (44) [serial 1108] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1100] 
Theorem (46) [serial 1109] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1100] 


Theorem (48)                               [serial 1097] 
P [281] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( hrr < mhr ) >>
S [288]   {
    << hrr = HEART_RATE
      and hrr < mhr
      and sp = SPO2
      and INV_PO() >>
    poa := true
    &
    PO_Alarm!(true)
    << INV_PO() >> 
  } 
Q [300] << INV_PO() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1094]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 47:
Theorem (47) [serial 1100] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1097] 


Theorem (49)                               [serial 1133] 
P [281] << ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() )
  and sp < psp >>
S [295] ->
Q [295] << sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
Why created:    normalization of [serial 1110]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (50)                               [serial 1110] 
P [281] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( sp < psp ) >>
S [295] ->
Q [295] << hrr = HEART_RATE
  and sp < psp
  and sp = SPO2
  and INV_PO() >>
Why created:  P -> P1 in concurrent composition for [serial 1101]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 49:
Theorem (49) [serial 1133] used for:
    normalization of [serial 1110] 


Theorem (51)                               [serial 1111] 
P [297] << INV_PO() >>
S [297] ->
Q [300] << INV_PO() >>
Why created:  Qk -> Q in concurrent composition for [serial 1101]
Solved by: Identity (id):  P->P is tautology

Theorem (52)                               [serial 1260] 
P [295] << ( ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp )
  and sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp >>
S [296] ->
Q [300] << ( LOW_SPO2_HR() iff true )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:  applied wp for assignment [serial 1259]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (53)                               [serial 1259] 
P [295] << ( ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp )
  and sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp >>
S [296] poa := true
Q [300] << ( LOW_SPO2_HR() iff poa )
  and MINIMUM_HEART_RATE = mhr
  and PROGRAMMED_SPO2 = psp >>
Why created:    normalization of [serial 1257]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 52:
Theorem (52) [serial 1260] used for:
  applied wp for assignment [serial 1259] 


Theorem (54)                               [serial 1257] 
P [295] << sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp
  and ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
S [296] poa := true
Q [300] << ( ( mhr = MINIMUM_HEART_RATE )
  and ( psp = PROGRAMMED_SPO2 )
  and ( poa iff LOW_SPO2_HR() ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1256]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 53:
Theorem (53) [serial 1259] used for:
    normalization of [serial 1257] 


Theorem (55)                               [serial 1256] 
P [295] << sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp
  and ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
S [296] poa := true
Q [300] << ( MHR_A()
  and PSPO2_A()
  and POA_A() ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1135]
Solved by: Predicate Invocation. (PI) and theorem 54:
Theorem (54) [serial 1257] used for:
  Substituted assertions' predicates for labels  [serial 1256] 


Theorem (56)                               [serial 1135] 
P [295] << sp < psp
  and HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() >>
S [296] poa := true
Q [300] << INV_PO() >>
Why created:    normalization of [serial 1112]
  Using: (eqcom) (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 55:
Theorem (55) [serial 1256] used for:
  Substituted assertions' predicates for labels  [serial 1135] 


Theorem (57)                               [serial 1112] 
P [295] << hrr = HEART_RATE
  and sp < psp
  and sp = SPO2
  and INV_PO() >>
S [296] poa := true
Q [300] << INV_PO() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1101]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 56:
Theorem (56) [serial 1135] used for:
    normalization of [serial 1112] 


Theorem (58)                               [serial 1137] 
P [281] << ( HEART_RATE = hrr
  and SPO2 = sp
  and INV_PO() )
  and sp < psp >>
S [296] PO_Alarm!(true)
Q [297] << INV_PO() >>
Why created:    normalization of [serial 1113]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (59)                               [serial 1113] 
P [281] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( sp < psp ) >>
S [296] PO_Alarm!(true)
Q [297] << INV_PO() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1101]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 58:
Theorem (58) [serial 1137] used for:
    normalization of [serial 1113] 


Theorem (60)                               [serial 1101] 
P [281] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( sp < psp ) >>
S [295]   << hrr = HEART_RATE
    and sp < psp
    and sp = SPO2
    and INV_PO() >>
  poa := true
  &
  PO_Alarm!(true)
  << INV_PO() >> 
Q [300] << INV_PO() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1098]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 50 51 57 59:
Theorem (50) [serial 1110] used for:
  P -> P1 in concurrent composition for [serial 1101] 
Theorem (51) [serial 1111] used for:
  Qk -> Q in concurrent composition for [serial 1101] 
Theorem (57) [serial 1112] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1101] 
Theorem (59) [serial 1113] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1101] 


Theorem (61)                               [serial 1098] 
P [281] << ( hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 )
  and ( sp < psp ) >>
S [294]   {
    << hrr = HEART_RATE
      and sp < psp
      and sp = SPO2
      and INV_PO() >>
    poa := true
    &
    PO_Alarm!(true)
    << INV_PO() >> 
  } 
Q [300] << INV_PO() >>
Why created:    <<P and B2>> S2 <<Q>> in alternative for [serial 1094]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 60:
Theorem (60) [serial 1101] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1098] 


Theorem (62)                               [serial 1094] 
P [279] << hrr = HEART_RATE
  and INV_PO()
  and sp = SPO2 >>
S [281]   if 
    (hrr >= mhr
    and sp >= psp)~> 
        {
          << hrr = HEART_RATE
            and hrr >= mhr
            and sp = SPO2
            and sp >= psp
            and INV_PO() >>
          poa := false
          &
          PO_Alarm!(false)
          << INV_PO() >> 
        }  
  []
    (hrr < mhr)~> 
        {
          << hrr = HEART_RATE
            and hrr < mhr
            and sp = SPO2
            and INV_PO() >>
          poa := true
          &
          PO_Alarm!(true)
          << INV_PO() >> 
        }  
  []
    (sp < psp)~> 
        {
          << hrr = HEART_RATE
            and sp < psp
            and sp = SPO2
            and INV_PO() >>
          poa := true
          &
          PO_Alarm!(true)
          << INV_PO() >> 
        }  
  fi
Q [300] << INV_PO() >>
Why created:  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1007]
Solved by: and theorems 23 36 48 61:
Theorem (23) [serial 1095] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1094] 
Theorem (36) [serial 1096] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1094] 
Theorem (48) [serial 1097] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1094] 
Theorem (61) [serial 1098] used for:
    <<P and B2>> S2 <<Q>> in alternative for [serial 1094] 


Theorem (63)                               [serial 1007] 
P [267] << INV_PO() >>
S [275]   << INV_PO() >>
  Heart_Rate?(hrr)
  ;
  << hrr = HEART_RATE
    and INV_PO() >>
  Spo2_Level?(sp)
  << hrr = HEART_RATE
    and INV_PO()
    and sp = SPO2 >>
  ;
    if 
      (hrr >= mhr
      and sp >= psp)~> 
          {
            << hrr = HEART_RATE
              and hrr >= mhr
              and sp = SPO2
              and sp >= psp
              and INV_PO() >>
            poa := false
            &
            PO_Alarm!(false)
            << INV_PO() >> 
          }  
    []
      (hrr < mhr)~> 
          {
            << hrr = HEART_RATE
              and hrr < mhr
              and sp = SPO2
              and INV_PO() >>
            poa := true
            &
            PO_Alarm!(true)
            << INV_PO() >> 
          }  
    []
      (sp < psp)~> 
          {
            << hrr = HEART_RATE
              and sp < psp
              and sp = SPO2
              and INV_PO() >>
            poa := true
            &
            PO_Alarm!(true)
            << INV_PO() >> 
          }  
    fi
  << INV_PO() >> 
Q [268] << INV_PO() >>
Why created:   <<M(run) and x>> A <<M(check_echo)>> for got_hrr_spo2: run-[x]->check_echo{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 9 10 14 18 62:
Theorem (9) [serial 1090] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1007] 
Theorem (10) [serial 1091] used for:
  <<Q3>> -> <<Q>> in sequential composition for [serial 1007] 
Theorem (14) [serial 1092] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1007] 
Theorem (18) [serial 1093] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1007] 
Theorem (62) [serial 1094] used for:
  <<Q2 and P3>> S3 <<Q3>> in sequential composition for [serial 1007] 


Theorem (64)                               [serial 1355] 
P [304] << ( INV_PO() )
  and ( PO_Alarm_Echo@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [304] ->
Q [306] << INV_PO()
  and PO_Alarm_Echo@now >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1008]
Solved by: And Introduction Schema (bl.aiswll)(bl.aiswlr):  (X and Y and Z)->(X and Y)

Theorem (65)                               [serial 1356] 
P [316] << INV_PO() >>
S [267] ->
Q [267] << INV_PO() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1008]
Solved by: Identity (id):  P->P is tautology

Theorem (66)                               [serial 1358] 
P [306] << ( INV_PO()
  and PO_Alarm_Echo@now )
  and ( echo_val iff PO_Alarm_Echo@now ) >>
S [309] ->
Q [309] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
Why created:  <<P and v=e>> -> <<A>> in behavior action block for [serial 1357]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (67)                               [serial 1361] 
P [309] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
S [309] ->
Q [309] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1359]
Solved by: Identity (id):  P->P is tautology

Theorem (68)                               [serial 1362] 
P [314] << INV_PO() >>
S [314] ->
Q [314] << INV_PO() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1359]
Solved by: Identity (id):  P->P is tautology

Theorem (69)                               [serial 1372] 
P [309] << ( PO_Alarm_Echo iff echo_val )
  and INV_PO() >>
S [310] ->
Q [310] << ( echo_val iff poa ) or not ( echo_val iff poa ) >>
Why created:    normalization of [serial 1364]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (70)                               [serial 1364] 
P [309] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
S [310] ->
Q [310] << ( echo_val iff poa ) or ( not ( echo_val iff poa ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1363]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 69:
Theorem (69) [serial 1372] used for:
    normalization of [serial 1364] 


Theorem (71)                               [serial 1376] 
P [310] << ( ( PO_Alarm_Echo iff echo_val )
  and INV_PO() )
  and ( echo_val iff poa ) >>
S [310] ->
Q [314] << INV_PO() >>
Why created:    normalization of [serial 1374]
  Using: (bicom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (72)                               [serial 1374] 
P [310] << ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( echo_val iff poa ) >>
S [310] ->
Q [314] << INV_PO() >>
Why created:    <<P>> -> <<Q>>
  for [serial 1365]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 71:
Theorem (71) [serial 1376] used for:
    normalization of [serial 1374] 


Theorem (73)                               [serial 1365] 
P [310] << ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( echo_val iff poa ) >>
S [310] skip
Q [314] << INV_PO() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1363]
Solved by:  Skip Means Implication:  <<P>> skip <<Q>>  is  <<P>> -> <<Q>>
 and theorem 72:
Theorem (72) [serial 1374] used for:
    <<P>> -> <<Q>>
  for [serial 1365] 


Theorem (74)                               [serial 1384] 
P [310] << ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( not ( echo_val iff poa ) ) >>
S [312] ->
Q [312] << true >>
Why created:  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1366]
Solved by: Anything Implies True (a1tru): P->true

Theorem (75)                               [serial 1388] 
P [312] << ( ( ( PO_Alarm_Echo iff echo_val )
  and INV_PO() )
  and not ( echo_val iff poa ) )
  and true >>
S [312] ->
Q [314] << INV_PO() >>
Why created:    normalization of [serial 1386]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (76)                               [serial 1386] 
P [312] << ( ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( not ( echo_val iff poa ) ) )
  and true >>
S [312] ->
Q [314] << INV_PO() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1385]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 75:
Theorem (75) [serial 1388] used for:
    normalization of [serial 1386] 


Theorem (77)                               [serial 1385] 
P [312] << ( ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( not ( echo_val iff poa ) ) )
  and true@now >>
S [312] ->
Q [314] << INV_PO() >>
Why created:  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1366]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 76:
Theorem (76) [serial 1386] used for:
  Assume Present:  P = P@now = P^0   [serial 1385] 


Theorem (78)                               [serial 1366] 
P [310] << ( INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) )
  and ( not ( echo_val iff poa ) ) >>
S [312] Lost_Confirmation!
Q [314] << INV_PO() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1363]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 74 77:
Theorem (74) [serial 1384] used for:
  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1366] 
Theorem (77) [serial 1385] used for:
  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1366] 


Theorem (79)                               [serial 1363] 
P [309] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
S [310]   if 
    (echo_val iff poa)~> 
      skip 
  []
    (not ( echo_val iff poa ))~> 
      Lost_Confirmation! 
  fi
Q [314] << INV_PO() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1359]
Solved by: and theorems 70 73 78:
Theorem (70) [serial 1364] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1363] 
Theorem (73) [serial 1365] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1363] 
Theorem (78) [serial 1366] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1363] 


Theorem (80)                               [serial 1359] 
P [309] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
S [309] << INV_PO()
  and ( echo_val iff PO_Alarm_Echo ) >>
  if 
    (echo_val iff poa)~> 
      skip 
  []
    (not ( echo_val iff poa ))~> 
      Lost_Confirmation! 
  fi
<< INV_PO() >>
Q [314] << INV_PO() >>
Why created:  <<A>> S <<B>> in behavior action block for [serial 1357]
Solved by: null and theorems 67 68 79:
Theorem (67) [serial 1361] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1359] 
Theorem (68) [serial 1362] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1359] 
Theorem (79) [serial 1363] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1359] 


Theorem (81)                               [serial 1360] 
P [314] << INV_PO() >>
S [307] ->
Q [316] << INV_PO() >>
Why created:  <<B>> -> <<Q>> in behavior action block for [serial 1357]
Solved by: Identity (id):  P->P is tautology

Theorem (82)                               [serial 1357] 
P [306] << INV_PO()
  and PO_Alarm_Echo@now >>
S [307] declare 
   echo_val ~ boolean := PO_Alarm_Echo?   {
  << INV_PO()
    and ( echo_val iff PO_Alarm_Echo ) >>
    if 
      (echo_val iff poa)~> 
        skip 
    []
      (not ( echo_val iff poa ))~> 
        Lost_Confirmation! 
    fi
  << INV_PO() >>
  } 
Q [316] << INV_PO() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1008]
Solved by: Behavior Action Block (BAB): 
     <<P and x=e>> -> <<A>>
     <<A>> S <<B>> 
     <<B>> -> <<Q>>
----------------------------------------------------
<<P>> declare variable v~y:=e; { <<A>> S <<B>> } <<Q>> and theorems 66 80 81:
Theorem (66) [serial 1358] used for:
  <<P and v=e>> -> <<A>> in behavior action block for [serial 1357] 
Theorem (80) [serial 1359] used for:
  <<A>> S <<B>> in behavior action block for [serial 1357] 
Theorem (81) [serial 1360] used for:
  <<B>> -> <<Q>> in behavior action block for [serial 1357] 


Theorem (83)                               [serial 1008] 
P [304] << ( INV_PO() )
  and ( PO_Alarm_Echo@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [306] << INV_PO()
  and PO_Alarm_Echo@now >>
declare 
   echo_val ~ boolean := PO_Alarm_Echo?   {
  << INV_PO()
    and ( echo_val iff PO_Alarm_Echo ) >>
    if 
      (echo_val iff poa)~> 
        skip 
    []
      (not ( echo_val iff poa ))~> 
        Lost_Confirmation! 
    fi
  << INV_PO() >>
  } 
<< INV_PO() >>
Q [267] << INV_PO() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A};
Solved by: null and theorems 64 65 82:
Theorem (64) [serial 1355] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1008] 
Theorem (65) [serial 1356] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1008] 
Theorem (82) [serial 1357] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1008] 


Theorem (84)                               [serial 1398] 
P [319] << ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and INV_PO()
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [320] ->
Q [320] << true >>
Why created:    normalization of [serial 1394]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (85)                               [serial 1394] 
P [319] << ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [320] ->
Q [320] << true >>
Why created:  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1393]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 84:
Theorem (84) [serial 1398] used for:
    normalization of [serial 1394] 


Theorem (86)                               [serial 1400] 
P [320] << ( ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and INV_PO()
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) )
  and true >>
S [320] ->
Q [267] << INV_PO() >>
Why created:    normalization of [serial 1396]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (87)                               [serial 1396] 
P [320] << ( ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) )
  and true >>
S [320] ->
Q [267] << INV_PO() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1395]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 86:
Theorem (86) [serial 1400] used for:
    normalization of [serial 1396] 


Theorem (88)                               [serial 1395] 
P [320] << ( ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) )
  and true@now >>
S [320] ->
Q [267] << INV_PO() >>
Why created:  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1393]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 87:
Theorem (87) [serial 1396] used for:
  Assume Present:  P = P@now = P^0   [serial 1395] 


Theorem (89)                               [serial 1393] 
P [319] << ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [320] Lost_Confirmation!
Q [267] << INV_PO() >>
Why created:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1009]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 85 88:
Theorem (85) [serial 1394] used for:
  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1393] 
Theorem (88) [serial 1395] used for:
  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1393] 


Theorem (90)                               [serial 1009] 
P [319] << ( INV_PO() )
  and ( ( PO_Alarm or PO_Alarm_Echo )@( now - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PO_Echo_Limit s ) ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( PO_Alarm or PO_Alarm_Echo )@( u - IoMT_Properties::PO_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PO_Echo_Limit s ) ,, u 
   that ( PO_Alarm or PO_Alarm_Echo )@t  )  ) >>
S [320] Lost_Confirmation!
Q [267] << INV_PO() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A};
Solved by: null and theorem 89:
Theorem (89) [serial 1393] used for:
  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1009] 


Theorem (91)                               [serial 1002] 
P [247] <<   >>
S [253] ->
Q [247] << Pulse_Oximeter_Thread.impl proof obligations >>
Why created:  Initial proof obligations for Pulse_Oximeter_Thread.impl
Solved by:  Component verification conditions
 and theorems 3 6 7 8 63 83 90:
Theorem (3) [serial 1003] used for:
  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition. 
Theorem (6) [serial 1004] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (7) [serial 1005] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (8) [serial 1006] used for:
   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{}; 
Theorem (63) [serial 1007] used for:
   <<M(run) and x>> A <<M(check_echo)>> for got_hrr_spo2: run-[x]->check_echo{A}; 
Theorem (83) [serial 1008] used for:
   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A}; 
Theorem (90) [serial 1009] used for:
   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A}; 


Theorem (92)                               [serial 1011] 
P [429] << RA()
  and MRP_A() >>
S [419] ->
Q [419] << RA()
  and MRP_A() >>
Why created:  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition.
Solved by: Identity (id):  P->P is tautology

Theorem (93)                               [serial 1012] 
P [428] << RA()
  and MRP_A() >>
S [419] ->
Q [419] << RA()
  and MRP_A() >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by: Identity (id):  P->P is tautology

Theorem (94)                               [serial 1013] 
P [427] << RA()
  and MRP_A() >>
S [427] ->
Q [427] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by: Anything Implies True (a1tru): P->true

Theorem (95)                               [serial 1014] 
P [427] << RA()
  and MRP_A() >>
S [431] ->
Q [428] << RA()
  and MRP_A() >>
Why created:   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{};
Solved by: Identity (id):  P->P is tautology

Theorem (96)                               [serial 1445] 
P [434] << ( MRP_A()
  and RA() )
  and rpr = RESPIRATION_RATE >>
S [434] ->
Q [435] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
Why created:  applied port input of value <<pre and rpr=M(RP_Rate)>> -> <<post>> [serial 1422]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (97)                               [serial 1422] 
P [428] << MRP_A()
  and RA() >>
S [434] RP_Rate?(rpr)
Q [435] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1406]
  Using: (eqcom) (bl.ancom) 
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 96:
Theorem (96) [serial 1445] used for:
  applied port input of value <<pre and rpr=M(RP_Rate)>> -> <<post>> [serial 1422] 


Theorem (98)                               [serial 1406] 
P [428] << RA()
  and MRP_A() >>
S [434] RP_Rate?(rpr)
Q [435] << rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1015]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 97:
Theorem (97) [serial 1422] used for:
    normalization of [serial 1406] 


Theorem (99)                               [serial 1451] 
P [435] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [437] ->
Q [437] << rpr < mrp or not ( rpr < mrp ) >>
Why created:    normalization of [serial 1449]
  Using: ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (100)                               [serial 1449] 
P [435] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [437] ->
Q [437] << rpr < mrp or ( not ( rpr < mrp ) ) >>
Why created:  Replacing <= with not < of [serial 1424]
Solved by: [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 99:
Theorem (99) [serial 1451] used for:
    normalization of [serial 1449] 


Theorem (101)                               [serial 1424] 
P [435] << RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [437] ->
Q [437] << rpr < mrp or mrp <= rpr >>
Why created:    normalization of [serial 1408]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.orcom) 
Solved by: 'Less than' expressed in terms of 'less than or equal to'. (ltnle) and theorem 100:
Theorem (100) [serial 1449] used for:
  Replacing <= with not < of [serial 1424] 


Theorem (102)                               [serial 1408] 
P [435] << rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() >>
S [437] ->
Q [437] << ( rpr >= mrp ) or ( rpr < mrp ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1407]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Disjunction Commutes. (bl.orcom) and theorem 101:
Theorem (101) [serial 1424] used for:
    normalization of [serial 1408] 


Theorem (103)                               [serial 1426] 
P [437] << ( RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() )
  and mrp <= rpr >>
S [438] ->
Q [438] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1413]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (104)                               [serial 1413] 
P [437] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr >= mrp ) >>
S [438] ->
Q [438] << rpr = RESPIRATION_RATE
  and rpr >= mrp
  and MRP_A()
  and RA() >>
Why created:  P -> P1 in concurrent composition for [serial 1411]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 103:
Theorem (103) [serial 1426] used for:
    normalization of [serial 1413] 


Theorem (105)                               [serial 1428] 
P [440] << MRP_A()
  and RA() >>
S [440] ->
Q [429] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1414]
Solved by: Identity (id):  P->P is tautology

Theorem (106)                               [serial 1414] 
P [440] << RA()
  and MRP_A() >>
S [440] ->
Q [429] << RA()
  and MRP_A() >>
Why created:  Qk -> Q in concurrent composition for [serial 1411]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 105:
Theorem (105) [serial 1428] used for:
    normalization of [serial 1414] 


Theorem (107)                               [serial 1458] 
P [438] << ( LOW_RP() iff rma )
  and mrp <= rpr
  and MINIMUM_RESPIRATION_RATE = mrp
  and RESPIRATION_RATE = rpr >>
S [439] ->
Q [429] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE iff false )
  and MINIMUM_RESPIRATION_RATE = mrp >>
Why created:    normalization of [serial 1456]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: The negation of a proposition is equivalent to itself being equivalent to false. (nbfal)

Theorem (108)                               [serial 1456] 
P [438] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( rma iff LOW_RP() ) >>
S [439] ->
Q [429] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( false iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1455]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 107:
Theorem (107) [serial 1458] used for:
    normalization of [serial 1456] 


Theorem (109)                               [serial 1455] 
P [438] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [439] ->
Q [429] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( false iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) >>
Why created:  applied wp for assignment [serial 1454]
Solved by: Predicate Invocation. (PI) and theorem 108:
Theorem (108) [serial 1456] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1455] 


Theorem (110)                               [serial 1454] 
P [438] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [439] rma := false
Q [429] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( rma iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1453]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 109:
Theorem (109) [serial 1455] used for:
  applied wp for assignment [serial 1454] 


Theorem (111)                               [serial 1453] 
P [438] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [439] rma := false
Q [429] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( rma iff LOW_RP() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1430]
Solved by: Predicate Invocation. (PI) and theorem 110:
Theorem (110) [serial 1454] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1453] 


Theorem (112)                               [serial 1430] 
P [438] << mrp <= rpr
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [439] rma := false
Q [429] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1415]
  Using: (eqcom) changeAtLeastToAtMost (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 111:
Theorem (111) [serial 1453] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1430] 


Theorem (113)                               [serial 1415] 
P [438] << rpr = RESPIRATION_RATE
  and rpr >= mrp
  and MRP_A()
  and RA() >>
S [439] rma := false
Q [429] << RA()
  and MRP_A() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1411]
Solved by: Equality Commutes. (eqcom) [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 112:
Theorem (112) [serial 1430] used for:
    normalization of [serial 1415] 


Theorem (114)                               [serial 1432] 
P [437] << ( RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() )
  and mrp <= rpr >>
S [439] RM_Alarm!(false)
Q [440] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1416]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES changeAtLeastToAtMost (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (115)                               [serial 1416] 
P [437] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr >= mrp ) >>
S [439] RM_Alarm!(false)
Q [440] << RA()
  and MRP_A() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1411]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] [change A>=B to B<=A] Conjunction Commutes. (bl.ancom) and theorem 114:
Theorem (114) [serial 1432] used for:
    normalization of [serial 1416] 


Theorem (116)                               [serial 1411] 
P [437] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr >= mrp ) >>
S [438]   << rpr = RESPIRATION_RATE
    and rpr >= mrp
    and MRP_A()
    and RA() >>
  rma := false
  &
  RM_Alarm!(false)
  << RA()
    and MRP_A() >> 
Q [429] << RA()
  and MRP_A() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1409]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 104 106 113 115:
Theorem (104) [serial 1413] used for:
  P -> P1 in concurrent composition for [serial 1411] 
Theorem (106) [serial 1414] used for:
  Qk -> Q in concurrent composition for [serial 1411] 
Theorem (113) [serial 1415] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1411] 
Theorem (115) [serial 1416] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1411] 


Theorem (117)                               [serial 1409] 
P [437] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr >= mrp ) >>
S [438]   {
    << rpr = RESPIRATION_RATE
      and rpr >= mrp
      and MRP_A()
      and RA() >>
    rma := false
    &
    RM_Alarm!(false)
    << RA()
      and MRP_A() >> 
  } 
Q [429] << RA()
  and MRP_A() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1407]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 116:
Theorem (116) [serial 1411] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1409] 


Theorem (118)                               [serial 1434] 
P [437] << ( RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() )
  and rpr < mrp >>
S [443] ->
Q [443] << rpr < mrp
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1417]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (119)                               [serial 1417] 
P [437] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr < mrp ) >>
S [443] ->
Q [443] << rpr = RESPIRATION_RATE
  and rpr < mrp
  and MRP_A()
  and RA() >>
Why created:  P -> P1 in concurrent composition for [serial 1412]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 118:
Theorem (118) [serial 1434] used for:
    normalization of [serial 1417] 


Theorem (120)                               [serial 1436] 
P [445] << MRP_A()
  and RA() >>
S [445] ->
Q [429] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1418]
Solved by: Identity (id):  P->P is tautology

Theorem (121)                               [serial 1418] 
P [445] << RA()
  and MRP_A() >>
S [445] ->
Q [429] << RA()
  and MRP_A() >>
Why created:  Qk -> Q in concurrent composition for [serial 1412]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 120:
Theorem (120) [serial 1436] used for:
    normalization of [serial 1418] 


Theorem (122)                               [serial 1468] 
P [443] << rpr < mrp
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [444] ->
Q [429] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( true iff LOW_RP() ) >>
Why created:  applied wp for assignment [serial 1467]
Solved by: Superfluity of Equivalence. (bl.seq)

Theorem (123)                               [serial 1467] 
P [443] << rpr < mrp
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [444] rma := true
Q [429] << ( mrp = MINIMUM_RESPIRATION_RATE )
  and ( rma iff LOW_RP() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1438]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 122:
Theorem (122) [serial 1468] used for:
  applied wp for assignment [serial 1467] 


Theorem (124)                               [serial 1438] 
P [443] << rpr < mrp
  and RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() >>
S [444] rma := true
Q [429] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1419]
  Using: (eqcom) (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 123:
Theorem (123) [serial 1467] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1438] 


Theorem (125)                               [serial 1419] 
P [443] << rpr = RESPIRATION_RATE
  and rpr < mrp
  and MRP_A()
  and RA() >>
S [444] rma := true
Q [429] << RA()
  and MRP_A() >>
Why created:  <<P1>> S1 <<Q>> in concurrent composition for [serial 1412]
Solved by: Equality Commutes. (eqcom) Conjunction Commutes. (bl.ancom) and theorem 124:
Theorem (124) [serial 1438] used for:
    normalization of [serial 1419] 


Theorem (126)                               [serial 1440] 
P [437] << ( RESPIRATION_RATE = rpr
  and MRP_A()
  and RA() )
  and rpr < mrp >>
S [444] RM_Alarm!(true)
Q [445] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1420]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (127)                               [serial 1420] 
P [437] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr < mrp ) >>
S [444] RM_Alarm!(true)
Q [445] << RA()
  and MRP_A() >>
Why created:  <<P>> S2 <<Q2>> in concurrent composition for [serial 1412]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 126:
Theorem (126) [serial 1440] used for:
    normalization of [serial 1420] 


Theorem (128)                               [serial 1412] 
P [437] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr < mrp ) >>
S [443]   << rpr = RESPIRATION_RATE
    and rpr < mrp
    and MRP_A()
    and RA() >>
  rma := true
  &
  RM_Alarm!(true)
  << RA()
    and MRP_A() >> 
Q [429] << RA()
  and MRP_A() >>
Why created:  <<P>> T <<Q>> in behavior action block for [serial 1410]
Solved by:  Concurrent Composition Rule (CCk):
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
 and theorems 119 121 125 127:
Theorem (119) [serial 1417] used for:
  P -> P1 in concurrent composition for [serial 1412] 
Theorem (121) [serial 1418] used for:
  Qk -> Q in concurrent composition for [serial 1412] 
Theorem (125) [serial 1419] used for:
  <<P1>> S1 <<Q>> in concurrent composition for [serial 1412] 
Theorem (127) [serial 1420] used for:
  <<P>> S2 <<Q2>> in concurrent composition for [serial 1412] 


Theorem (129)                               [serial 1410] 
P [437] << ( rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() )
  and ( rpr < mrp ) >>
S [443]   {
    << rpr = RESPIRATION_RATE
      and rpr < mrp
      and MRP_A()
      and RA() >>
    rma := true
    &
    RM_Alarm!(true)
    << RA()
      and MRP_A() >> 
  } 
Q [429] << RA()
  and MRP_A() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1407]
Solved by: Behavior Action Block, simple (BABs): 
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>
 and theorem 128:
Theorem (128) [serial 1412] used for:
  <<P>> T <<Q>> in behavior action block for [serial 1410] 


Theorem (130)                               [serial 1407] 
P [435] << rpr = RESPIRATION_RATE
  and MRP_A()
  and RA() >>
S [437]   if 
    (rpr >= mrp)~> 
        {
          << rpr = RESPIRATION_RATE
            and rpr >= mrp
            and MRP_A()
            and RA() >>
          rma := false
          &
          RM_Alarm!(false)
          << RA()
            and MRP_A() >> 
        }  
  []
    (rpr < mrp)~> 
        {
          << rpr = RESPIRATION_RATE
            and rpr < mrp
            and MRP_A()
            and RA() >>
          rma := true
          &
          RM_Alarm!(true)
          << RA()
            and MRP_A() >> 
        }  
  fi
Q [429] << RA()
  and MRP_A() >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1015]
Solved by: and theorems 102 117 129:
Theorem (102) [serial 1408] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1407] 
Theorem (117) [serial 1409] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1407] 
Theorem (129) [serial 1410] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1407] 


Theorem (131)                               [serial 1015] 
P [428] << RA()
  and MRP_A() >>
S [434]   RP_Rate?(rpr)
  << rpr = RESPIRATION_RATE
    and MRP_A()
    and RA() >>
  ;
    if 
      (rpr >= mrp)~> 
          {
            << rpr = RESPIRATION_RATE
              and rpr >= mrp
              and MRP_A()
              and RA() >>
            rma := false
            &
            RM_Alarm!(false)
            << RA()
              and MRP_A() >> 
          }  
    []
      (rpr < mrp)~> 
          {
            << rpr = RESPIRATION_RATE
              and rpr < mrp
              and MRP_A()
              and RA() >>
            rma := true
            &
            RM_Alarm!(true)
            << RA()
              and MRP_A() >> 
          }  
    fi 
Q [429] << RA()
  and MRP_A() >>
Why created:   <<M(run) and x>> A <<M(check_echo)>> for got_rp: run-[x]->check_echo{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 98 130:
Theorem (98) [serial 1406] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1015] 
Theorem (130) [serial 1407] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1015] 


Theorem (132)                               [serial 1512] 
P [449] << ( MRP_A()
  and RA() )
  and RM_Alarm_Echo@now
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [449] ->
Q [450] << RM_Alarm_Echo@now
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1499]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (133)                               [serial 1499] 
P [449] << ( RA()
  and MRP_A() )
  and ( RM_Alarm_Echo@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [449] ->
Q [450] << RA()
  and MRP_A()
  and RM_Alarm_Echo@now >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1016]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 132:
Theorem (132) [serial 1512] used for:
    normalization of [serial 1499] 


Theorem (134)                               [serial 1514] 
P [459] << MRP_A()
  and RA() >>
S [428] ->
Q [428] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1500]
Solved by: Identity (id):  P->P is tautology

Theorem (135)                               [serial 1500] 
P [459] << RA()
  and MRP_A() >>
S [428] ->
Q [428] << RA()
  and MRP_A() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1016]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 134:
Theorem (134) [serial 1514] used for:
    normalization of [serial 1500] 


Theorem (136)                               [serial 1516] 
P [450] << ( RM_Alarm_Echo@now
  and MRP_A()
  and RA() )
  and ( RM_Alarm_Echo@now iff echo_val ) >>
S [452] ->
Q [452] << ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1502]
  Using: (bl.ancom) (bicom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (137)                               [serial 1502] 
P [450] << ( RA()
  and MRP_A()
  and RM_Alarm_Echo@now )
  and ( echo_val iff RM_Alarm_Echo@now ) >>
S [452] ->
Q [452] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
Why created:  <<P and v=e>> -> <<A>> in behavior action block for [serial 1501]
Solved by: Conjunction Commutes. (bl.ancom) Biconditional (iff) Commutes. (bicom) and theorem 136:
Theorem (136) [serial 1516] used for:
    normalization of [serial 1502] 


Theorem (138)                               [serial 1518] 
P [452] << ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() >>
S [452] ->
Q [452] << ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() >>
Why created:    normalization of [serial 1505]
  Using: (bicom) (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (139)                               [serial 1505] 
P [452] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
S [452] ->
Q [452] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1503]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 138:
Theorem (138) [serial 1518] used for:
    normalization of [serial 1505] 


Theorem (140)                               [serial 1520] 
P [457] << MRP_A()
  and RA() >>
S [457] ->
Q [457] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1506]
Solved by: Identity (id):  P->P is tautology

Theorem (141)                               [serial 1506] 
P [457] << RA()
  and MRP_A() >>
S [457] ->
Q [457] << RA()
  and MRP_A() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1503]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 140:
Theorem (140) [serial 1520] used for:
    normalization of [serial 1506] 


Theorem (142)                               [serial 1522] 
P [452] << ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() >>
S [453] ->
Q [453] << ( echo_val iff rma ) or not ( echo_val iff rma ) >>
Why created:    normalization of [serial 1508]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (143)                               [serial 1508] 
P [452] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
S [453] ->
Q [453] << ( echo_val iff rma ) or ( not ( echo_val iff rma ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1507]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 142:
Theorem (142) [serial 1522] used for:
    normalization of [serial 1508] 


Theorem (144)                               [serial 1524] 
P [453] << ( ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() )
  and ( echo_val iff rma ) >>
S [453] skip
Q [457] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1509]
  Using: (bicom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (145)                               [serial 1509] 
P [453] << ( RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) )
  and ( echo_val iff rma ) >>
S [453] skip
Q [457] << RA()
  and MRP_A() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1507]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 144:
Theorem (144) [serial 1524] used for:
    normalization of [serial 1509] 


Theorem (146)                               [serial 1526] 
P [453] << ( ( RM_Alarm_Echo iff echo_val )
  and MRP_A()
  and RA() )
  and not ( echo_val iff rma ) >>
S [455] Lost_Confirmation!
Q [457] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1510]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (147)                               [serial 1510] 
P [453] << ( RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) )
  and ( not ( echo_val iff rma ) ) >>
S [455] Lost_Confirmation!
Q [457] << RA()
  and MRP_A() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1507]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 146:
Theorem (146) [serial 1526] used for:
    normalization of [serial 1510] 


Theorem (148)                               [serial 1507] 
P [452] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
S [453]   if 
    (echo_val iff rma)~> 
      skip 
  []
    (not ( echo_val iff rma ))~> 
      Lost_Confirmation! 
  fi
Q [457] << RA()
  and MRP_A() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1503]
Solved by: and theorems 143 145 147:
Theorem (143) [serial 1508] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1507] 
Theorem (145) [serial 1509] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1507] 
Theorem (147) [serial 1510] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1507] 


Theorem (149)                               [serial 1503] 
P [452] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
S [452] << RA()
  and MRP_A()
  and ( echo_val iff RM_Alarm_Echo ) >>
  if 
    (echo_val iff rma)~> 
      skip 
  []
    (not ( echo_val iff rma ))~> 
      Lost_Confirmation! 
  fi
<< RA()
  and MRP_A() >>
Q [457] << RA()
  and MRP_A() >>
Why created:  <<A>> S <<B>> in behavior action block for [serial 1501]
Solved by: null and theorems 139 141 148:
Theorem (139) [serial 1505] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1503] 
Theorem (141) [serial 1506] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1503] 
Theorem (148) [serial 1507] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1503] 


Theorem (150)                               [serial 1528] 
P [457] << MRP_A()
  and RA() >>
S [451] ->
Q [459] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1504]
Solved by: Identity (id):  P->P is tautology

Theorem (151)                               [serial 1504] 
P [457] << RA()
  and MRP_A() >>
S [451] ->
Q [459] << RA()
  and MRP_A() >>
Why created:  <<B>> -> <<Q>> in behavior action block for [serial 1501]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 150:
Theorem (150) [serial 1528] used for:
    normalization of [serial 1504] 


Theorem (152)                               [serial 1501] 
P [450] << RA()
  and MRP_A()
  and RM_Alarm_Echo@now >>
S [451] declare 
   echo_val ~ boolean := RM_Alarm_Echo?   {
  << RA()
    and MRP_A()
    and ( echo_val iff RM_Alarm_Echo ) >>
    if 
      (echo_val iff rma)~> 
        skip 
    []
      (not ( echo_val iff rma ))~> 
        Lost_Confirmation! 
    fi
  << RA()
    and MRP_A() >>
  } 
Q [459] << RA()
  and MRP_A() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1016]
Solved by: Behavior Action Block (BAB): 
     <<P and x=e>> -> <<A>>
     <<A>> S <<B>> 
     <<B>> -> <<Q>>
----------------------------------------------------
<<P>> declare variable v~y:=e; { <<A>> S <<B>> } <<Q>> and theorems 137 149 151:
Theorem (137) [serial 1502] used for:
  <<P and v=e>> -> <<A>> in behavior action block for [serial 1501] 
Theorem (149) [serial 1503] used for:
  <<A>> S <<B>> in behavior action block for [serial 1501] 
Theorem (151) [serial 1504] used for:
  <<B>> -> <<Q>> in behavior action block for [serial 1501] 


Theorem (153)                               [serial 1016] 
P [449] << ( RA()
  and MRP_A() )
  and ( RM_Alarm_Echo@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [450] << RA()
  and MRP_A()
  and RM_Alarm_Echo@now >>
declare 
   echo_val ~ boolean := RM_Alarm_Echo?   {
  << RA()
    and MRP_A()
    and ( echo_val iff RM_Alarm_Echo ) >>
    if 
      (echo_val iff rma)~> 
        skip 
    []
      (not ( echo_val iff rma ))~> 
        Lost_Confirmation! 
    fi
  << RA()
    and MRP_A() >>
  } 
<< RA()
  and MRP_A() >>
Q [428] << RA()
  and MRP_A() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A};
Solved by: null and theorems 133 135 152:
Theorem (133) [serial 1499] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1016] 
Theorem (135) [serial 1500] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1016] 
Theorem (152) [serial 1501] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1016] 


Theorem (154)                               [serial 1559] 
P [462] << ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and ( MRP_A()
  and RA() )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [463] ->
Q [463] << true >>
Why created:    normalization of [serial 1555]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (155)                               [serial 1555] 
P [462] << ( RA()
  and MRP_A() )
  and ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [463] ->
Q [463] << true >>
Why created:  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1017]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 154:
Theorem (154) [serial 1559] used for:
    normalization of [serial 1555] 


Theorem (156)                               [serial 1561] 
P [463] << ( ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and ( MRP_A()
  and RA() )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) )
  and true >>
S [463] ->
Q [428] << MRP_A()
  and RA() >>
Why created:    normalization of [serial 1557]
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (157)                               [serial 1557] 
P [463] << ( ( RA()
  and MRP_A() )
  and ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) )
  and true >>
S [463] ->
Q [428] << RA()
  and MRP_A() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1556]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  Conjunction Commutes. (bl.ancom) and theorem 156:
Theorem (156) [serial 1561] used for:
    normalization of [serial 1557] 


Theorem (158)                               [serial 1556] 
P [463] << ( ( RA()
  and MRP_A() )
  and ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) )
  and true@now >>
S [463] ->
Q [428] << RA()
  and MRP_A() >>
Why created:  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1017]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 157:
Theorem (157) [serial 1557] used for:
  Assume Present:  P = P@now = P^0   [serial 1556] 


Theorem (159)                               [serial 1017] 
P [462] << ( RA()
  and MRP_A() )
  and ( ( RM_Alarm or RM_Alarm_Echo )@( now - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::RM_Echo_Limit s ) ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_Alarm_Echo@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RM_Alarm or RM_Alarm_Echo )@( u - IoMT_Properties::RM_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::RM_Echo_Limit s ) ,, u 
   that ( RM_Alarm or RM_Alarm_Echo )@t  )  ) >>
S [463] Lost_Confirmation!
Q [428] << RA()
  and MRP_A() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A};
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 155 158:
Theorem (155) [serial 1555] used for:
  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1017] 
Theorem (158) [serial 1556] used for:
  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1017] 


Theorem (160)                               [serial 1010] 
P [416] <<   >>
S [419] ->
Q [416] << Respiration_Monitor_Thread.impl proof obligations >>
Why created:  Initial proof obligations for Respiration_Monitor_Thread.impl
Solved by:  Component verification conditions
 and theorems 92 93 94 95 131 153 159:
Theorem (92) [serial 1011] used for:
  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition. 
Theorem (93) [serial 1012] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (94) [serial 1013] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (95) [serial 1014] used for:
   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{}; 
Theorem (131) [serial 1015] used for:
   <<M(run) and x>> A <<M(check_echo)>> for got_rp: run-[x]->check_echo{A}; 
Theorem (153) [serial 1016] used for:
   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A}; 
Theorem (159) [serial 1017] used for:
   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A}; 


Theorem (161)                               [serial 1575] 
P [614] << ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff Pause_Infusion )
  and ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff pause_inf )
  and ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) iff po_alarm_active )
  and ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE iff rm_alarm_active ) >>
S [614] ->
Q [603] << ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff PAUSE_INFUSION >>
Why created:    normalization of [serial 1573]
  Using: ADD_UNNECESSARY_PARETHESES (bl.orcom) 
Solved by: Absorb parentheses, middle term in disjunction (bl.orabpm)

Theorem (162)                               [serial 1573] 
P [614] << ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff Pause_Infusion )
  and ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff pause_inf )
  and ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) iff po_alarm_active )
  and ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE iff rm_alarm_active ) >>
S [614] ->
Q [603] << ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) iff PAUSE_INFUSION >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1572]
Solved by: [Add unnecessary parentheses] Disjunction Commutes. (bl.orcom) and theorem 161:
Theorem (161) [serial 1575] used for:
    normalization of [serial 1573] 


Theorem (163)                               [serial 1572] 
P [614] << ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff Pause_Infusion )
  and ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff pause_inf )
  and ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) iff po_alarm_active )
  and ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE iff rm_alarm_active ) >>
S [614] ->
Q [603] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:    normalization of [serial 1570]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) (bl.orcom) 
Solved by: Predicate Invocation. (PI) and theorem 162:
Theorem (162) [serial 1573] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1572] 


Theorem (164)                               [serial 1570] 
P [614] << ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) iff Pause_Infusion )
  and ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) iff pause_inf )
  and ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) iff po_alarm_active )
  and ( ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff rm_alarm_active ) >>
S [614] ->
Q [603] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1569]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 163:
Theorem (163) [serial 1572] used for:
    normalization of [serial 1570] 


Theorem (165)                               [serial 1569] 
P [614] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [614] ->
Q [603] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:    normalization of [serial 1567]
  Using: (bicom) (bl.ancom) (bl.orcom) 
Solved by: Predicate Invocation. (PI) and theorem 164:
Theorem (164) [serial 1570] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1569] 


Theorem (166)                               [serial 1567] 
P [614] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) >>
S [614] ->
Q [603] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1019]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 165:
Theorem (165) [serial 1569] used for:
    normalization of [serial 1567] 


Theorem (167)                               [serial 1019] 
P [614] << INV()
  and POA()
  and RMA()
  and PI() >>
S [614] ->
Q [603] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:  <<I>> -> BLESS::Invariant of thread Coordinator_Thread.echo
Solved by: Predicate Invocation. (PI) and theorem 166:
Theorem (166) [serial 1567] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1019] 


Theorem (168)                               [serial 1580] 
P [628] << INV()
  and PI()
  and POA()
  and RMA() >>
S [614] ->
Q [614] << INV()
  and PI()
  and POA()
  and RMA() >>
Why created:    normalization of [serial 1578]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (169)                               [serial 1578] 
P [628] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
S [614] ->
Q [614] << INV()
  and POA()
  and RMA()
  and PI() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1020]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 168:
Theorem (168) [serial 1580] used for:
    normalization of [serial 1578] 


Theorem (170)                               [serial 1020] 
P [628] << INV_E() >>
S [614] ->
Q [614] << INV()
  and POA()
  and RMA()
  and PI() >>
Why created:  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 169:
Theorem (169) [serial 1578] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1020] 


Theorem (171)                               [serial 1583] 
P [627] << INV()
  and PI()
  and POA()
  and RMA() >>
S [614] ->
Q [614] << INV()
  and PI()
  and POA()
  and RMA() >>
Why created:    normalization of [serial 1581]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Identity (id):  P->P is tautology

Theorem (172)                               [serial 1581] 
P [627] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
S [614] ->
Q [614] << INV()
  and POA()
  and RMA()
  and PI() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1021]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 171:
Theorem (171) [serial 1583] used for:
    normalization of [serial 1581] 


Theorem (173)                               [serial 1021] 
P [627] << INV_E() >>
S [614] ->
Q [614] << INV()
  and POA()
  and RMA()
  and PI() >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 172:
Theorem (172) [serial 1581] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1021] 


Theorem (174)                               [serial 1022] 
P [626] << INV_E() >>
S [626] ->
Q [626] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by: Anything Implies True (a1tru): P->true

Theorem (175)                               [serial 1023] 
P [626] << INV_E() >>
S [630] ->
Q [627] << INV_E() >>
Why created:   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{};
Solved by: Identity (id):  P->P is tautology

Theorem (176)                               [serial 1611] 
P [631] << ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 )@now
  and ( INV()
  and POA()
  and RMA()
  and PI() )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 )@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE )@u  ) >>
S [631] ->
Q [632] << INV()
  and RMA() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1590]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (177)                               [serial 1590] 
P [631] << PO_ALARM()@now
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [631] ->
Q [632] << INV()
  and RMA() >>
Why created:    normalization of [serial 1584]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 176:
Theorem (176) [serial 1611] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1590] 


Theorem (178)                               [serial 1584] 
P [631] << ( INV_E() )
  and ( PO_ALARM()@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [631] ->
Q [632] << INV()
  and RMA() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1024]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 177:
Theorem (177) [serial 1590] used for:
    normalization of [serial 1584] 


Theorem (179)                               [serial 1616] 
P [633] << ( INV()
  and RMA() )
  and ( PO_ALARM() iff po_alarm_active ) >>
S [633] ->
Q [634] << ( PO_ALARM() iff po_alarm_active )
  and INV()
  and RMA()
  and true >>
Why created:    normalization of [serial 1614]
  Using: (bicom) (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (180)                               [serial 1614] 
P [633] << ( INV()
  and RMA() )
  and ( po_alarm_active iff PO_ALARM() ) >>
S [633] ->
Q [634] << ( PO_ALARM() iff po_alarm_active )
  and true
  and INV()
  and RMA() >>
Why created:   add user-defined "givens" to postcondition
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 179:
Theorem (179) [serial 1616] used for:
    normalization of [serial 1614] 


Theorem (181)                               [serial 1616] 
P [633] << ( INV()
  and RMA() )
  and ( PO_ALARM() iff po_alarm_active ) >>
S [633] ->
Q [634] << ( PO_ALARM() iff po_alarm_active )
  and INV()
  and RMA()
  and true >>
Why created:    normalization of [serial 1614]
  Using: (bicom) (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (182)                               [serial 1614] 
P [633] << ( INV()
  and RMA() )
  and ( po_alarm_active iff PO_ALARM() ) >>
S [633] ->
Q [634] << ( PO_ALARM() iff po_alarm_active )
  and true
  and INV()
  and RMA() >>
Why created:   add user-defined "givens" to postcondition
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 181:
Theorem (181) [serial 1616] used for:
    normalization of [serial 1614] 


Theorem (183)                               [serial 1613] 
P [633] << ( INV()
  and RMA() )
  and ( po_alarm_active iff PO_ALARM() ) >>
S [633] ->
Q [634] << ( PO_ALARM() iff po_alarm_active )
  and GIVEN_POA()
  and INV()
  and RMA() >>
Why created:  applied port input of value <<pre and po_alarm_active=M(PO_Alarm)>> -> <<post>> [serial 1592]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 182 182:
Theorem (182) [serial 1614] used for:
   add user-defined "givens" to postcondition 
Theorem (182) [serial 1614] used for:
   add user-defined "givens" to postcondition 


Theorem (184)                               [serial 1592] 
P [632] << INV()
  and RMA() >>
S [633] PO_Alarm?(po_alarm_active)
Q [634] << ( PO_ALARM() iff po_alarm_active )
  and GIVEN_POA()
  and INV()
  and RMA() >>
Why created:    normalization of [serial 1585]
  Using: (bicom) (bl.ancom) 
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
 and theorem 183:
Theorem (183) [serial 1613] used for:
  applied port input of value <<pre and po_alarm_active=M(PO_Alarm)>> -> <<post>> [serial 1592] 


Theorem (185)                               [serial 1585] 
P [632] << INV()
  and RMA() >>
S [633] PO_Alarm?(po_alarm_active)
Q [634] << INV()
  and RMA()
  and ( po_alarm_active iff PO_ALARM() )
  and GIVEN_POA() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1024]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 184:
Theorem (184) [serial 1592] used for:
    normalization of [serial 1585] 


Theorem (186)                               [serial 1632] 
P [634] << ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) iff po_alarm_active )
  and ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff PO_ALARM_ECHO )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [635] ->
Q [635] << PO_ALARM() iff PO_ALARM_ECHO >>
Why created:    normalization of [serial 1630]
  Using: (bicom) (bl.ancom) 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (187)                               [serial 1630] 
P [634] << ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) iff po_alarm_active )
  and ( PO_ALARM() iff PO_ALARM_ECHO )
  and ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( rm_alarm_active iff RM_ALARM() ) >>
S [635] ->
Q [635] << PO_ALARM_ECHO iff PO_ALARM() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1629]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 186:
Theorem (186) [serial 1632] used for:
    normalization of [serial 1630] 


Theorem (188)                               [serial 1629] 
P [634] << ( PO_ALARM() iff po_alarm_active )
  and GIVEN_POA()
  and INV()
  and RMA() >>
S [635] ->
Q [635] << PO_ALARM_ECHO iff PO_ALARM() >>
Why created:  Guided Substitution of Equals 
 replacing "po_alarm_active" with its iff "PO_ALARM()" in its postcondition [serial 1619]
Solved by: Predicate Invocation. (PI) and theorem 187:
Theorem (187) [serial 1630] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1629] 


Theorem (189)                               [serial 1619] 
P [634] << ( PO_ALARM() iff po_alarm_active )
  and GIVEN_POA()
  and INV()
  and RMA() >>
S [635] ->
Q [635] << PO_ALARM_ECHO iff po_alarm_active >>
Why created:  applied port output of value <<pre>> -> <<M(PO_Alarm_Echo)[PO_Alarm_Echo|po_alarm_active]>> [serial 1594]
Solved by:  Guided Substitution of Equals
 and theorem 188:
Theorem (188) [serial 1629] used for:
  Guided Substitution of Equals 
 replacing "po_alarm_active" with its iff "PO_ALARM()" in its postcondition [serial 1619] 


Theorem (190)                               [serial 1620] 
P [635] << ( ( PO_ALARM() iff po_alarm_active )
  and GIVEN_POA()
  and INV()
  and RMA() )
  and ( PO_ALARM_ECHO iff po_alarm_active )@now >>
S [635] ->
Q [636] << INV()
  and POA()
  and RMA() >>
Why created:  applied port output <<pre and (PO_ALARM_ECHO iff po_alarm_active)@now>> -> <<post>> [serial 1594]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (191)                               [serial 1594] 
P [634] << ( PO_ALARM() iff po_alarm_active )
  and GIVEN_POA()
  and INV()
  and RMA() >>
S [635] PO_Alarm_Echo!(po_alarm_active)
Q [636] << INV()
  and POA()
  and RMA() >>
Why created:    normalization of [serial 1586]
  Using: (bicom) (bl.ancom) 
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 189 190:
Theorem (189) [serial 1619] used for:
  applied port output of value <<pre>> -> <<M(PO_Alarm_Echo)[PO_Alarm_Echo|po_alarm_active]>> [serial 1594] 
Theorem (190) [serial 1620] used for:
  applied port output <<pre and (PO_ALARM_ECHO iff po_alarm_active)@now>> -> <<post>> [serial 1594] 


Theorem (192)                               [serial 1586] 
P [634] << INV()
  and RMA()
  and ( po_alarm_active iff PO_ALARM() )
  and GIVEN_POA() >>
S [635] PO_Alarm_Echo!(po_alarm_active)
Q [636] << INV()
  and RMA()
  and POA() >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1024]
Solved by: Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) and theorem 191:
Theorem (191) [serial 1594] used for:
    normalization of [serial 1586] 


Theorem (193)                               [serial 1644] 
P [636] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [637] ->
Q [621] << ( ( PO_ALARM() or RM_ALARM() ) iff ( PO_ALARM() or RM_ALARM() ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "rm_alarm_active" with its iff "RM_ALARM()" in its postcondition [serial 1643]
Solved by: Principle of identity for logical equivalence. (biid) 

Theorem (194)                               [serial 1643] 
P [636] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [637] ->
Q [621] << ( ( PO_ALARM() or RM_ALARM() ) iff ( PO_ALARM() or rm_alarm_active ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "po_alarm_active" with its iff "PO_ALARM()" in its postcondition [serial 1639]
Solved by:  Guided Substitution of Equals
 and theorem 193:
Theorem (193) [serial 1644] used for:
  Guided Substitution of Equals 
 replacing "rm_alarm_active" with its iff "RM_ALARM()" in its postcondition [serial 1643] 


Theorem (195)                               [serial 1639] 
P [636] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [637] ->
Q [621] << ( ( PO_ALARM() or RM_ALARM() ) iff ( po_alarm_active or rm_alarm_active ) ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1638]
Solved by:  Guided Substitution of Equals
 and theorem 194:
Theorem (194) [serial 1643] used for:
  Guided Substitution of Equals 
 replacing "po_alarm_active" with its iff "PO_ALARM()" in its postcondition [serial 1639] 


Theorem (196)                               [serial 1640] 
P [636] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [637] ->
Q [609] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1638]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (197)                               [serial 1641] 
P [636] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [637] ->
Q [617] << ( PO_ALARM() iff po_alarm_active ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1638]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (198)                               [serial 1642] 
P [636] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [637] ->
Q [619] << ( RM_ALARM() iff rm_alarm_active ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1638]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (199)                               [serial 1638] 
P [636] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [637] ->
Q [638] << ( ( PO_ALARM() or RM_ALARM() ) iff ( po_alarm_active or rm_alarm_active ) )
  and ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
Why created:    normalization of [serial 1636]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 195 196 197 198:
Theorem (195) [serial 1639] used for:
  Join consequents with conjunction. (3jca)
   [serial 1638] 
Theorem (196) [serial 1640] used for:
  Join consequents with conjunction. (3jca)
   [serial 1638] 
Theorem (197) [serial 1641] used for:
  Join consequents with conjunction. (3jca)
   [serial 1638] 
Theorem (198) [serial 1642] used for:
  Join consequents with conjunction. (3jca)
   [serial 1638] 


Theorem (200)                               [serial 1636] 
P [636] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() ) >>
S [637] ->
Q [638] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( ( po_alarm_active or rm_alarm_active ) iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1635]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 199:
Theorem (199) [serial 1638] used for:
    normalization of [serial 1636] 


Theorem (201)                               [serial 1635] 
P [636] << INV()
  and POA()
  and RMA() >>
S [637] ->
Q [638] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( ( po_alarm_active or rm_alarm_active ) iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  applied wp for assignment [serial 1634]
Solved by: Predicate Invocation. (PI) and theorem 200:
Theorem (200) [serial 1636] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1635] 


Theorem (202)                               [serial 1634] 
P [636] << INV()
  and POA()
  and RMA() >>
S [637] pause_inf := po_alarm_active or rm_alarm_active
Q [638] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1633]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 201:
Theorem (201) [serial 1635] used for:
  applied wp for assignment [serial 1634] 


Theorem (203)                               [serial 1633] 
P [636] << INV()
  and POA()
  and RMA() >>
S [637] pause_inf := po_alarm_active or rm_alarm_active
Q [638] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1596]
Solved by: Predicate Invocation. (PI) and theorem 202:
Theorem (202) [serial 1634] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1633] 


Theorem (204)                               [serial 1596] 
P [636] << INV()
  and POA()
  and RMA() >>
S [637] pause_inf := po_alarm_active or rm_alarm_active
Q [638] << INV_E() >>
Why created:    normalization of [serial 1587]
Solved by: Predicate Invocation. (PI) and theorem 203:
Theorem (203) [serial 1633] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1596] 


Theorem (205)                               [serial 1587] 
P [636] << INV()
  and RMA()
  and POA() >>
S [637] pause_inf := po_alarm_active or rm_alarm_active
Q [638] << INV_E() >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1024]
Solved by: Conjunction Commutes. (bl.ancom) and theorem 204:
Theorem (204) [serial 1596] used for:
    normalization of [serial 1587] 


Theorem (206)                               [serial 1610] 
P [638] << ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [639] ->
Q [639] << ( PO_ALARM() or RM_ALARM() ) iff pause_inf >>
Why created:    normalization of [serial 1608]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (207)                               [serial 1608] 
P [638] << ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [639] ->
Q [639] << ( ( PO_ALARM() or RM_ALARM() ) ) iff pause_inf >>
Why created:  Guided Substitution of Equals 
 replacing "PAUSE_INFUSION" with its iff "( ( PO_ALARM() or RM_ALARM() ) )" in its postcondition [serial 1607]
Solved by: [Add unnecessary parentheses] and theorem 206:
Theorem (206) [serial 1610] used for:
    normalization of [serial 1608] 


Theorem (208)                               [serial 1607] 
P [638] << ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [639] ->
Q [639] << PAUSE_INFUSION iff pause_inf >>
Why created:  Replacing port names with BLESS::Assertion properties  [serial 1606]
Solved by:  Guided Substitution of Equals
 and theorem 207:
Theorem (207) [serial 1608] used for:
  Guided Substitution of Equals 
 replacing "PAUSE_INFUSION" with its iff "( ( PO_ALARM() or RM_ALARM() ) )" in its postcondition [serial 1607] 


Theorem (209)                               [serial 1606] 
P [638] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [639] ->
Q [639] << PAUSE_INFUSION iff pause_inf >>
Why created:    normalization of [serial 1604]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by:  Replacing port names with BLESS::Assertion properties
 and theorem 208:
Theorem (208) [serial 1607] used for:
  Replacing port names with BLESS::Assertion properties  [serial 1606] 


Theorem (210)                               [serial 1604] 
P [638] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
S [639] ->
Q [639] << PAUSE_INFUSION iff pause_inf >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1603]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 209:
Theorem (209) [serial 1606] used for:
    normalization of [serial 1604] 


Theorem (211)                               [serial 1603] 
P [638] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
S [639] ->
Q [639] << PAUSE_INFUSION iff pause_inf >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1598]
Solved by: Predicate Invocation. (PI) and theorem 210:
Theorem (210) [serial 1604] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1603] 


Theorem (212)                               [serial 1598] 
P [638] << INV_E() >>
S [639] ->
Q [639] << PAUSE_INFUSION iff pause_inf >>
Why created:  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|pause_inf]>> [serial 1588]
Solved by: Predicate Invocation. (PI) and theorem 211:
Theorem (211) [serial 1603] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1598] 


Theorem (213)                               [serial 1602] 
P [639] << ( PAUSE_INFUSION iff pause_inf )@now
  and INV_E() >>
S [639] ->
Q [628] << INV_E() >>
Why created:    normalization of [serial 1599]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (214)                               [serial 1599] 
P [639] << ( INV_E() )
  and ( PAUSE_INFUSION iff pause_inf )@now >>
S [639] ->
Q [628] << INV_E() >>
Why created:  applied port output <<pre and (PAUSE_INFUSION iff pause_inf)@now>> -> <<post>> [serial 1588]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 213:
Theorem (213) [serial 1602] used for:
    normalization of [serial 1599] 


Theorem (215)                               [serial 1588] 
P [638] << INV_E() >>
S [639] Pause_Infusion!(pause_inf)
Q [628] << INV_E() >>
Why created:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1024]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 212 214:
Theorem (212) [serial 1598] used for:
  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|pause_inf]>> [serial 1588] 
Theorem (214) [serial 1599] used for:
  applied port output <<pre and (PAUSE_INFUSION iff pause_inf)@now>> -> <<post>> [serial 1588] 


Theorem (216)                               [serial 1024] 
P [631] << ( INV_E() )
  and ( PO_ALARM()@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [632]   << INV()
    and RMA() >>
  PO_Alarm?(po_alarm_active)
  ;
  << INV()
    and RMA()
    and ( po_alarm_active iff PO_ALARM() )
    and GIVEN_POA() >>
  PO_Alarm_Echo!(po_alarm_active)
  ;
  << INV()
    and RMA()
    and POA() >>
  pause_inf := po_alarm_active or rm_alarm_active
  ;
  << INV_E() >>
  Pause_Infusion!(pause_inf) 
Q [628] << INV_E() >>
Why created:   <<M(run) and x>> A <<M(check_echo)>> for got_po: run-[x]->check_echo{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 178 185 192 205 215:
Theorem (178) [serial 1584] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1024] 
Theorem (185) [serial 1585] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1024] 
Theorem (192) [serial 1586] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1024] 
Theorem (205) [serial 1587] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1024] 
Theorem (215) [serial 1588] used for:
  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1024] 


Theorem (217)                               [serial 1655] 
P [641] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE )@now
  and ( INV()
  and POA()
  and RMA()
  and PI() )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 )@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE )@u  ) >>
S [641] ->
Q [642] << INV()
  and POA() >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1654]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (218)                               [serial 1654] 
P [641] << RM_ALARM()@now
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [641] ->
Q [642] << INV()
  and POA() >>
Why created:    normalization of [serial 1648]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Predicate Invocation. (PI) and theorem 217:
Theorem (217) [serial 1655] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1654] 


Theorem (219)                               [serial 1648] 
P [641] << ( INV_E() )
  and ( RM_ALARM()@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [641] ->
Q [642] << INV()
  and POA() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1025]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 218:
Theorem (218) [serial 1654] used for:
    normalization of [serial 1648] 


Theorem (220)                               [serial 1657] 
P [642] << INV()
  and POA() >>
S [643] RM_Alarm?(rm_alarm_active)
Q [644] << INV()
  and POA()
  and ( rm_alarm_active iff RM_ALARM() )
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (221)                               [serial 1657] 
P [642] << INV()
  and POA() >>
S [643] RM_Alarm?(rm_alarm_active)
Q [644] << INV()
  and POA()
  and ( rm_alarm_active iff RM_ALARM() )
  and true >>
Why created:   add user-defined "givens" to postcondition
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (222)                               [serial 1649] 
P [642] << INV()
  and POA() >>
S [643] RM_Alarm?(rm_alarm_active)
Q [644] << INV()
  and POA()
  and ( rm_alarm_active iff RM_ALARM() )
  and GIVEN_RMA() >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1025]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
 and theorems 221 221:
Theorem (221) [serial 1657] used for:
   add user-defined "givens" to postcondition 
Theorem (221) [serial 1657] used for:
   add user-defined "givens" to postcondition 


Theorem (223)                               [serial 1671] 
P [644] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) )
  and ( RM_ALARM() iff RM_ALARM_ECHO ) >>
S [645] ->
Q [645] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff ( ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1670]
Solved by: Principle of identity for logical equivalence. (biid) 

Theorem (224)                               [serial 1670] 
P [644] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) )
  and ( RM_ALARM() iff RM_ALARM_ECHO ) >>
S [645] ->
Q [645] << RM_ALARM() iff ( ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "RM_ALARM_ECHO" with its iff "RM_ALARM()" in its postcondition [serial 1669]
Solved by: Predicate Invocation. (PI) and theorem 223:
Theorem (223) [serial 1671] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1670] 


Theorem (225)                               [serial 1669] 
P [644] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) )
  and ( RM_ALARM() iff RM_ALARM_ECHO ) >>
S [645] ->
Q [645] << RM_ALARM_ECHO iff ( ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "rm_alarm_active" with its iff "( ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) )" in its postcondition [serial 1668]
Solved by:  Guided Substitution of Equals
 and theorem 224:
Theorem (224) [serial 1670] used for:
  Guided Substitution of Equals 
 replacing "RM_ALARM_ECHO" with its iff "RM_ALARM()" in its postcondition [serial 1669] 


Theorem (226)                               [serial 1668] 
P [644] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) )
  and ( RM_ALARM() iff RM_ALARM_ECHO ) >>
S [645] ->
Q [645] << RM_ALARM_ECHO iff rm_alarm_active >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1661]
Solved by:  Guided Substitution of Equals
 and theorem 225:
Theorem (225) [serial 1669] used for:
  Guided Substitution of Equals 
 replacing "rm_alarm_active" with its iff "( ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) )" in its postcondition [serial 1668] 


Theorem (227)                               [serial 1661] 
P [644] << INV()
  and POA()
  and ( rm_alarm_active iff RM_ALARM() )
  and GIVEN_RMA() >>
S [645] ->
Q [645] << RM_ALARM_ECHO iff rm_alarm_active >>
Why created:  applied port output of value <<pre>> -> <<M(RM_Alarm_Echo)[RM_Alarm_Echo|rm_alarm_active]>> [serial 1650]
Solved by: Predicate Invocation. (PI) and theorem 226:
Theorem (226) [serial 1668] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1661] 


Theorem (228)                               [serial 1662] 
P [645] << ( INV()
  and POA()
  and ( rm_alarm_active iff RM_ALARM() )
  and GIVEN_RMA() )
  and ( RM_ALARM_ECHO iff rm_alarm_active )@now >>
S [645] ->
Q [646] << INV()
  and RMA()
  and POA() >>
Why created:  applied port output <<pre and (RM_ALARM_ECHO iff rm_alarm_active)@now>> -> <<post>> [serial 1650]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (229)                               [serial 1650] 
P [644] << INV()
  and POA()
  and ( rm_alarm_active iff RM_ALARM() )
  and GIVEN_RMA() >>
S [645] RM_Alarm_Echo!(rm_alarm_active)
Q [646] << INV()
  and RMA()
  and POA() >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1025]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 227 228:
Theorem (227) [serial 1661] used for:
  applied port output of value <<pre>> -> <<M(RM_Alarm_Echo)[RM_Alarm_Echo|rm_alarm_active]>> [serial 1650] 
Theorem (228) [serial 1662] used for:
  applied port output <<pre and (RM_ALARM_ECHO iff rm_alarm_active)@now>> -> <<post>> [serial 1650] 


Theorem (230)                               [serial 1684] 
P [646] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [647] ->
Q [621] << ( ( PO_ALARM() or RM_ALARM() ) iff ( PO_ALARM() or RM_ALARM() ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "rm_alarm_active" with its iff "RM_ALARM()" in its postcondition [serial 1683]
Solved by: Principle of identity for logical equivalence. (biid) 

Theorem (231)                               [serial 1683] 
P [646] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [647] ->
Q [621] << ( ( PO_ALARM() or RM_ALARM() ) iff ( PO_ALARM() or rm_alarm_active ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "po_alarm_active" with its iff "PO_ALARM()" in its postcondition [serial 1679]
Solved by:  Guided Substitution of Equals
 and theorem 230:
Theorem (230) [serial 1684] used for:
  Guided Substitution of Equals 
 replacing "rm_alarm_active" with its iff "RM_ALARM()" in its postcondition [serial 1683] 


Theorem (232)                               [serial 1679] 
P [646] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [647] ->
Q [621] << ( ( PO_ALARM() or RM_ALARM() ) iff ( po_alarm_active or rm_alarm_active ) ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1678]
Solved by:  Guided Substitution of Equals
 and theorem 231:
Theorem (231) [serial 1683] used for:
  Guided Substitution of Equals 
 replacing "po_alarm_active" with its iff "PO_ALARM()" in its postcondition [serial 1679] 


Theorem (233)                               [serial 1680] 
P [646] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [647] ->
Q [609] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1678]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (234)                               [serial 1681] 
P [646] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [647] ->
Q [617] << ( PO_ALARM() iff po_alarm_active ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1678]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (235)                               [serial 1682] 
P [646] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [647] ->
Q [619] << ( RM_ALARM() iff rm_alarm_active ) >>
Why created:  Join consequents with conjunction. (3jca)
   [serial 1678]
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (236)                               [serial 1678] 
P [646] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [647] ->
Q [648] << ( ( PO_ALARM() or RM_ALARM() ) iff ( po_alarm_active or rm_alarm_active ) )
  and ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
Why created:    normalization of [serial 1676]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by: Join consequents with conjunction. (3jca) and theorems 232 233 234 235:
Theorem (232) [serial 1679] used for:
  Join consequents with conjunction. (3jca)
   [serial 1678] 
Theorem (233) [serial 1680] used for:
  Join consequents with conjunction. (3jca)
   [serial 1678] 
Theorem (234) [serial 1681] used for:
  Join consequents with conjunction. (3jca)
   [serial 1678] 
Theorem (235) [serial 1682] used for:
  Join consequents with conjunction. (3jca)
   [serial 1678] 


Theorem (237)                               [serial 1676] 
P [646] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( po_alarm_active iff PO_ALARM() ) >>
S [647] ->
Q [648] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( ( po_alarm_active or rm_alarm_active ) iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1675]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 236:
Theorem (236) [serial 1678] used for:
    normalization of [serial 1676] 


Theorem (238)                               [serial 1675] 
P [646] << INV()
  and RMA()
  and POA() >>
S [647] ->
Q [648] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( ( po_alarm_active or rm_alarm_active ) iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  applied wp for assignment [serial 1674]
Solved by: Predicate Invocation. (PI) and theorem 237:
Theorem (237) [serial 1676] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1675] 


Theorem (239)                               [serial 1674] 
P [646] << INV()
  and RMA()
  and POA() >>
S [647] pause_inf := po_alarm_active or rm_alarm_active
Q [648] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1673]
Solved by:  Assignment (asgn)(AA):
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
 and theorem 238:
Theorem (238) [serial 1675] used for:
  applied wp for assignment [serial 1674] 


Theorem (240)                               [serial 1673] 
P [646] << INV()
  and RMA()
  and POA() >>
S [647] pause_inf := po_alarm_active or rm_alarm_active
Q [648] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1651]
Solved by: Predicate Invocation. (PI) and theorem 239:
Theorem (239) [serial 1674] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1673] 


Theorem (241)                               [serial 1651] 
P [646] << INV()
  and RMA()
  and POA() >>
S [647] pause_inf := po_alarm_active or rm_alarm_active
Q [648] << INV_E() >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1025]
Solved by: Predicate Invocation. (PI) and theorem 240:
Theorem (240) [serial 1673] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1651] 


Theorem (242)                               [serial 1698] 
P [648] << ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [649] ->
Q [649] << ( ( PO_ALARM() or RM_ALARM() ) ) iff ( ( PO_ALARM() or RM_ALARM() ) ) >>
Why created:  Guided Substitution of Equals 
 replacing "pause_inf" with its iff "( ( PO_ALARM() or RM_ALARM() ) )" in its postcondition [serial 1697]
Solved by: Principle of identity for logical equivalence. (biid) 

Theorem (243)                               [serial 1697] 
P [648] << ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [649] ->
Q [649] << ( ( PO_ALARM() or RM_ALARM() ) ) iff pause_inf >>
Why created:  Guided Substitution of Equals 
 replacing "PAUSE_INFUSION" with its iff "( ( PO_ALARM() or RM_ALARM() ) )" in its postcondition [serial 1696]
Solved by:  Guided Substitution of Equals
 and theorem 242:
Theorem (242) [serial 1698] used for:
  Guided Substitution of Equals 
 replacing "pause_inf" with its iff "( ( PO_ALARM() or RM_ALARM() ) )" in its postcondition [serial 1697] 


Theorem (244)                               [serial 1696] 
P [648] << ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [649] ->
Q [649] << PAUSE_INFUSION iff pause_inf >>
Why created:  Replacing port names with BLESS::Assertion properties  [serial 1693]
Solved by:  Guided Substitution of Equals
 and theorem 243:
Theorem (243) [serial 1697] used for:
  Guided Substitution of Equals 
 replacing "PAUSE_INFUSION" with its iff "( ( PO_ALARM() or RM_ALARM() ) )" in its postcondition [serial 1696] 


Theorem (245)                               [serial 1693] 
P [648] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
S [649] ->
Q [649] << PAUSE_INFUSION iff pause_inf >>
Why created:    normalization of [serial 1690]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by:  Replacing port names with BLESS::Assertion properties
 and theorem 244:
Theorem (244) [serial 1696] used for:
  Replacing port names with BLESS::Assertion properties  [serial 1693] 


Theorem (246)                               [serial 1690] 
P [648] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
S [649] ->
Q [649] << PAUSE_INFUSION iff pause_inf >>
Why created:  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|pause_inf]>> [serial 1689]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 245:
Theorem (245) [serial 1693] used for:
    normalization of [serial 1690] 


Theorem (247)                               [serial 1695] 
P [649] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) )
  and ( PAUSE_INFUSION iff pause_inf )@now >>
S [649] ->
Q [628] << ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( ( PO_ALARM() or RM_ALARM() ) iff pause_inf )
  and ( PO_ALARM() iff po_alarm_active )
  and ( RM_ALARM() iff rm_alarm_active ) >>
Why created:    normalization of [serial 1691]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (248)                               [serial 1691] 
P [649] << ( ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) )
  and ( PAUSE_INFUSION iff pause_inf )@now >>
S [649] ->
Q [628] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  applied port output <<pre and (PAUSE_INFUSION iff pause_inf)@now>> -> <<post>> [serial 1689]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 247:
Theorem (247) [serial 1695] used for:
    normalization of [serial 1691] 


Theorem (249)                               [serial 1689] 
P [648] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
S [649] Pause_Infusion!(pause_inf)
Q [628] << ( ( ( PO_ALARM() or RM_ALARM() ) iff Pause_Infusion )
  and ( po_alarm_active iff PO_ALARM() )
  and ( rm_alarm_active iff RM_ALARM() )
  and ( pause_inf iff ( RM_ALARM() or PO_ALARM() ) ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1688]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 246 248:
Theorem (246) [serial 1690] used for:
  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|pause_inf]>> [serial 1689] 
Theorem (248) [serial 1691] used for:
  applied port output <<pre and (PAUSE_INFUSION iff pause_inf)@now>> -> <<post>> [serial 1689] 


Theorem (250)                               [serial 1688] 
P [648] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
S [649] Pause_Infusion!(pause_inf)
Q [628] << ( INV()
  and POA()
  and RMA()
  and PI() ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1652]
Solved by: Predicate Invocation. (PI) and theorem 249:
Theorem (249) [serial 1689] used for:
  Substituted assertions' predicates for labels  [serial 1688] 


Theorem (251)                               [serial 1652] 
P [648] << INV_E() >>
S [649] Pause_Infusion!(pause_inf)
Q [628] << INV_E() >>
Why created:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1025]
Solved by: Predicate Invocation. (PI) and theorem 250:
Theorem (250) [serial 1688] used for:
  Substituted assertions' predicates for labels  [serial 1652] 


Theorem (252)                               [serial 1025] 
P [641] << ( INV_E() )
  and ( RM_ALARM()@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PO_ALARM()@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that RM_ALARM()@u  ) >>
S [642]   << INV()
    and POA() >>
  RM_Alarm?(rm_alarm_active)
  ;
  << INV()
    and POA()
    and ( rm_alarm_active iff RM_ALARM() )
    and GIVEN_RMA() >>
  RM_Alarm_Echo!(rm_alarm_active)
  ;
  << INV()
    and RMA()
    and POA() >>
  pause_inf := po_alarm_active or rm_alarm_active
  ;
  << INV_E() >>
  Pause_Infusion!(pause_inf) 
Q [628] << INV_E() >>
Why created:   <<M(run) and x>> A <<M(check_echo)>> for got_rm: run-[x]->check_echo{A};
Solved by:  Sequential Composition Rule (SCk):
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
 and theorems 219 222 229 241 251:
Theorem (219) [serial 1648] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1025] 
Theorem (222) [serial 1649] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1025] 
Theorem (229) [serial 1650] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1025] 
Theorem (241) [serial 1651] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1025] 
Theorem (251) [serial 1652] used for:
  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1025] 


Theorem (253)                               [serial 1711] 
P [651] << ( PAUSE_INFUSION_ECHO@now
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) )
  and ( PAUSE_INFUSION_ECHO@now iff echo_val ) >>
S [654] ->
Q [654] << ( PAUSE_INFUSION_ECHO iff echo_val )
  and INV_E() >>
Why created:    normalization of [serial 1701]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) (bicom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (254)                               [serial 1701] 
P [651] << ( ( INV_E() )
  and ( PAUSE_INFUSION_ECHO@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) )
  and ( echo_val iff PAUSE_INFUSION_ECHO@now ) >>
S [654] ->
Q [654] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
Why created:  <<P and v=e>> -> <<A>> in behavior action block for [serial 1700]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) Biconditional (iff) Commutes. (bicom) and theorem 253:
Theorem (253) [serial 1711] used for:
    normalization of [serial 1701] 


Theorem (255)                               [serial 1704] 
P [654] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
S [654] ->
Q [654] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1702]
Solved by: Identity (id):  P->P is tautology

Theorem (256)                               [serial 1705] 
P [659] << INV_E() >>
S [659] ->
Q [659] << INV_E() >>
Why created:  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1702]
Solved by: Identity (id):  P->P is tautology

Theorem (257)                               [serial 1713] 
P [654] << ( PAUSE_INFUSION_ECHO iff echo_val )
  and INV_E() >>
S [655] ->
Q [655] << ( echo_val iff pause_inf ) or not ( echo_val iff pause_inf ) >>
Why created:    normalization of [serial 1707]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) 
Solved by: Law of Excluded middle. (exmid)

Theorem (258)                               [serial 1707] 
P [654] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
S [655] ->
Q [655] << ( echo_val iff pause_inf ) or ( not ( echo_val iff pause_inf ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1706]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) and theorem 257:
Theorem (257) [serial 1713] used for:
    normalization of [serial 1707] 


Theorem (259)                               [serial 1715] 
P [655] << ( ( PAUSE_INFUSION_ECHO iff echo_val )
  and INV_E() )
  and ( echo_val iff pause_inf ) >>
S [655] skip
Q [659] << INV_E() >>
Why created:    normalization of [serial 1708]
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (260)                               [serial 1708] 
P [655] << ( ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() )
  and ( echo_val iff pause_inf ) >>
S [655] skip
Q [659] << INV_E() >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1706]
Solved by: Biconditional (iff) Commutes. (bicom) and theorem 259:
Theorem (259) [serial 1715] used for:
    normalization of [serial 1708] 


Theorem (261)                               [serial 1717] 
P [655] << ( ( PAUSE_INFUSION_ECHO iff echo_val )
  and INV_E() )
  and not ( echo_val iff pause_inf ) >>
S [657] Lost_Confirmation!
Q [659] << INV_E() >>
Why created:    normalization of [serial 1709]
  Using: ADD_UNNECESSARY_PARETHESES (bicom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (262)                               [serial 1709] 
P [655] << ( ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() )
  and ( not ( echo_val iff pause_inf ) ) >>
S [657] Lost_Confirmation!
Q [659] << INV_E() >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1706]
Solved by: [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) and theorem 261:
Theorem (261) [serial 1717] used for:
    normalization of [serial 1709] 


Theorem (263)                               [serial 1706] 
P [654] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
S [655]   if 
    (echo_val iff pause_inf)~> 
      skip 
  []
    (not ( echo_val iff pause_inf ))~> 
      Lost_Confirmation! 
  fi
Q [659] << INV_E() >>
Why created:  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1702]
Solved by: and theorems 258 260 262:
Theorem (258) [serial 1707] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1706] 
Theorem (260) [serial 1708] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1706] 
Theorem (262) [serial 1709] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1706] 


Theorem (264)                               [serial 1702] 
P [654] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
S [654] << ( echo_val iff PAUSE_INFUSION_ECHO )
  and INV_E() >>
  if 
    (echo_val iff pause_inf)~> 
      skip 
  []
    (not ( echo_val iff pause_inf ))~> 
      Lost_Confirmation! 
  fi
<< INV_E() >>
Q [659] << INV_E() >>
Why created:  <<A>> S <<B>> in behavior action block for [serial 1700]
Solved by: null and theorems 255 256 263:
Theorem (255) [serial 1704] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1702] 
Theorem (256) [serial 1705] used for:
  as <<post>> -> <<Q>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1702] 
Theorem (263) [serial 1706] used for:
  as <<pre>> S <<post>> in <<P>> { <<pre>> S <<post>> } <<Q>> [serial 1702] 


Theorem (265)                               [serial 1703] 
P [659] << INV_E() >>
S [653] ->
Q [627] << INV_E() >>
Why created:  <<B>> -> <<Q>> in behavior action block for [serial 1700]
Solved by: Identity (id):  P->P is tautology

Theorem (266)                               [serial 1700] 
P [651] << ( INV_E() )
  and ( PAUSE_INFUSION_ECHO@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [653] declare 
   echo_val ~ boolean := Pause_Infusion_Echo?   {
  << ( echo_val iff PAUSE_INFUSION_ECHO )
    and INV_E() >>
    if 
      (echo_val iff pause_inf)~> 
        skip 
    []
      (not ( echo_val iff pause_inf ))~> 
        Lost_Confirmation! 
    fi
  << INV_E() >>
  } 
Q [627] << INV_E() >>
Why created:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1026]
Solved by: Behavior Action Block (BAB): 
     <<P and x=e>> -> <<A>>
     <<A>> S <<B>> 
     <<B>> -> <<Q>>
----------------------------------------------------
<<P>> declare variable v~y:=e; { <<A>> S <<B>> } <<Q>> and theorems 254 264 265:
Theorem (254) [serial 1701] used for:
  <<P and v=e>> -> <<A>> in behavior action block for [serial 1700] 
Theorem (264) [serial 1702] used for:
  <<A>> S <<B>> in behavior action block for [serial 1700] 
Theorem (265) [serial 1703] used for:
  <<B>> -> <<Q>> in behavior action block for [serial 1700] 


Theorem (267)                               [serial 1026] 
P [651] << ( INV_E() )
  and ( PAUSE_INFUSION_ECHO@now )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [653] declare 
   echo_val ~ boolean := Pause_Infusion_Echo?   {
  << ( echo_val iff PAUSE_INFUSION_ECHO )
    and INV_E() >>
    if 
      (echo_val iff pause_inf)~> 
        skip 
    []
      (not ( echo_val iff pause_inf ))~> 
        Lost_Confirmation! 
    fi
  << INV_E() >>
  } 
Q [627] << INV_E() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A};
Solved by: null and theorem 266:
Theorem (266) [serial 1700] used for:
  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1026] 


Theorem (268)                               [serial 1736] 
P [663] << ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [664] ->
Q [664] << true >>
Why created:    normalization of [serial 1733]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Anything Implies True (a1tru): P->true

Theorem (269)                               [serial 1733] 
P [663] << ( INV_E() )
  and ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [664] ->
Q [664] << true >>
Why created:  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1027]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 268:
Theorem (268) [serial 1736] used for:
    normalization of [serial 1733] 


Theorem (270)                               [serial 1738] 
P [664] << ( ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and INV_E()
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) )
  and true >>
S [664] ->
Q [627] << INV_E() >>
Why created:    normalization of [serial 1734]
  Using: (bl.atintro) ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: True can be removed from conjunction. (truan)(truconj)

Theorem (271)                               [serial 1734] 
P [664] << ( ( INV_E() )
  and ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) )
  and true@now >>
S [664] ->
Q [627] << INV_E() >>
Why created:  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1027]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 270:
Theorem (270) [serial 1738] used for:
    normalization of [serial 1734] 


Theorem (272)                               [serial 1027] 
P [663] << ( INV_E() )
  and ( ( Pause_Infusion or Pause_Infusion_Echo )@( now - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( now - IoMT_Properties::PCA_Echo_Limit s ) ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  ) )
  and not ( exists u ~ time 
   in tops ,, now 
   that PAUSE_INFUSION_ECHO@u  )
  and not ( exists u ~ time 
   in tops ,, now 
   that ( Pause_Infusion or Pause_Infusion_Echo )@( u - IoMT_Properties::PCA_Echo_Limit s )
  and not ( exists t ~ time 
   in ( u - IoMT_Properties::PCA_Echo_Limit s ) ,, u 
   that ( Pause_Infusion or Pause_Infusion_Echo )@t  )  ) >>
S [664] Lost_Confirmation!
Q [627] << INV_E() >>
Why created:   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A};
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
 and theorems 269 271:
Theorem (269) [serial 1733] used for:
  applied port output <<pre>> -> <<M[Lost_Confirmation]>> [serial 1027] 
Theorem (271) [serial 1734] used for:
  applied port output <<pre and M[Lost_Confirmation]@now>> -> <<post>> [serial 1027] 


Theorem (273)                               [serial 1018] 
P [608] <<   >>
S [614] ->
Q [608] << Coordinator_Thread.echo proof obligations >>
Why created:  Initial proof obligations for Coordinator_Thread.echo
Solved by:  Component verification conditions
 and theorems 167 170 173 174 175 216 252 267 272:
Theorem (167) [serial 1019] used for:
  <<I>> -> BLESS::Invariant of thread Coordinator_Thread.echo 
Theorem (170) [serial 1020] used for:
  <<M(check_echo)>> -> <<I>> from invariant I when complete state check_echo has Assertion <<M(check_echo)>> in its definition. 
Theorem (173) [serial 1021] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (174) [serial 1022] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (175) [serial 1023] used for:
   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{}; 
Theorem (216) [serial 1024] used for:
   <<M(run) and x>> A <<M(check_echo)>> for got_po: run-[x]->check_echo{A}; 
Theorem (252) [serial 1025] used for:
   <<M(run) and x>> A <<M(check_echo)>> for got_rm: run-[x]->check_echo{A}; 
Theorem (267) [serial 1026] used for:
   <<M(check_echo) and x>> A <<M(run)>> for got_echo: check_echo-[x]->run{A}; 
Theorem (272) [serial 1027] used for:
   <<M(check_echo) and x>> A <<M(run)>> for late_echo: check_echo-[x]->run{A}; 


Theorem (274)                               [serial 1744] 
P [1] << ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) iff PAUSE_INFUSION )
  and ( PAUSE_INFUSION implies KVO_RATE_property = PUMP_RATE$() ) >>
S    ->
Q [2] << ( ( HEART_RATE < MINIMUM_HEART_RATE or RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE or 
SPO2 < PROGRAMMED_SPO2 ) implies KVO_RATE_property = PUMP_RATE$() ) or HALT() >>
Why created:    normalization of [serial 1742]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bl.ancom) (bl.orcom) 
Solved by: Absorb parentheses, middle term in disjunction (bl.orabpm)

Theorem (275)                               [serial 1742] 
P [1] << ( PAUSE_INFUSION implies PUMP_RATE$() = KVO_RATE_property )
  and ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 ) or 
( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) iff PAUSE_INFUSION ) >>
S    ->
Q [2] << ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SPO2 < PROGRAMMED_SPO2 or RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) implies PUMP_RATE$() = KVO_RATE_property ) or 
HALT() ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1028]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 274:
Theorem (274) [serial 1744] used for:
    normalization of [serial 1742] 


Theorem (276)                               [serial 1028] 
P [1] << ( PAUSE_INFUSION implies PUMP_RATE$() = KVO_RATE_property )
  and ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION ) >>
S    ->
Q [2] << IS_SAFE() >>
Why created:  Conjunction of Subcomponents' Invariants imply SysIoMT.impl's Invariant
Solved by: Predicate Invocation. (PI) and theorem 275:
Theorem (275) [serial 1742] used for:
  Substituted assertions' predicates for labels  [serial 1028] 


Theorem (277)                               [serial 1750] 
P [1] << PAUSE_INFUSION implies KVO_RATE_property = PUMP_RATE$() >>
S    ->
Q [2] << PAUSE_INFUSION implies KVO_RATE_property = PUMP_RATE$() >>
Why created:    normalization of [serial 1029]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Identity (id):  P->P is tautology

Theorem (278)                               [serial 1029] 
P [1] << ( PAUSE_INFUSION implies PUMP_RATE$() = KVO_RATE_property ) >>
S    ->
Q [2] << PAUSE_INFUSION implies PUMP_RATE$() = KVO_RATE_property >>
Why created:  Subcomponent's Invariant implies PCA_Pump.impl's Invariant
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 277:
Theorem (277) [serial 1750] used for:
    normalization of [serial 1029] 


Theorem (279)                               [serial 1752] 
P [1] << PAUSE_INFUSION implies KVO_RATE_property = PUMP_RATE$() >>
S    ->
Q [2] << PAUSE_INFUSION implies KVO_RATE_property = PUMP_RATE$() >>
Why created:    normalization of [serial 1030]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES 
Solved by: Identity (id):  P->P is tautology

Theorem (280)                               [serial 1030] 
P [1] << ( PAUSE_INFUSION implies PUMP_RATE$() = KVO_RATE_property ) >>
S    ->
Q [2] << PAUSE_INFUSION implies PUMP_RATE$() = KVO_RATE_property >>
Why created:  Subcomponent's Invariant implies PCA_Pump_Process.impl's Invariant
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] and theorem 279:
Theorem (279) [serial 1752] used for:
    normalization of [serial 1030] 


Theorem (281)                               [serial 1754] 
P [1] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
S    ->
Q [2] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:    normalization of [serial 1031]
Solved by: Identity (id):  P->P is tautology

Theorem (282)                               [serial 1031] 
P [1] << ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION ) >>
S    ->
Q [2] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:  Subcomponent's Invariant implies Coordinator.impl's Invariant
Solved by: [Add unnecessary parentheses] and theorem 281:
Theorem (281) [serial 1754] used for:
    normalization of [serial 1031] 


Theorem (283)                               [serial 1756] 
P [1] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
S    ->
Q [2] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:    normalization of [serial 1032]
Solved by: Identity (id):  P->P is tautology

Theorem (284)                               [serial 1032] 
P [1] << ( ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION ) >>
S    ->
Q [2] << ( PO_ALARM() or RM_ALARM() ) iff PAUSE_INFUSION >>
Why created:  Subcomponent's Invariant implies Coordinator_Process.impl's Invariant
Solved by: [Add unnecessary parentheses] and theorem 283:
Theorem (283) [serial 1756] used for:
    normalization of [serial 1032] 


Theorem (285)                               [serial 1033] 
P [1] << PAUSE_INFUSION >>
S [2] ->
Q [1] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection pcc.pause_infusion -> pct.pause_infusion:
 pause_infusion -> pause_infusion
Solved by: Identity (id):  P->P is tautology

Theorem (286)                               [serial 1034] 
P [1] << pump_rate = PUMP_RATE$() >>
S [2] ->
Q [1] << pump_rate = PUMP_RATE$() >>
Why created:  Composition of Subcomponents via Directional Connection pcp.pct.pump_rate -> pmp.pump_rate:
 pump_rate -> pump_rate
Solved by: Identity (id):  P->P is tautology

Theorem (287)                               [serial 1035] 
P [1] << PO_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection pot.PO_Alarm -> poc.poa:
 PO_Alarm -> poa
Solved by: Identity (id):  P->P is tautology

Theorem (288)                               [serial 1760] 
P [1] << RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE >>
S [2] ->
Q [1] << RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE >>
Why created:    normalization of [serial 1758]
Solved by: Identity (id):  P->P is tautology

Theorem (289)                               [serial 1758] 
P [1] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) >>
S [2] ->
Q [1] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1757]
Solved by: [Add unnecessary parentheses] and theorem 288:
Theorem (288) [serial 1760] used for:
    normalization of [serial 1758] 


Theorem (290)                               [serial 1757] 
P [1] << RM_ALARM() >>
S [2] ->
Q [1] << ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1036]
Solved by: Predicate Invocation. (PI) and theorem 289:
Theorem (289) [serial 1758] used for:
  Substituted assertions' predicates for labels  [serial 1757] 


Theorem (291)                               [serial 1036] 
P [1] << RM_ALARM() >>
S [2] ->
Q [1] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection rmt.RM_Alarm -> rmc.rma:
 RM_Alarm -> rma
Solved by: Predicate Invocation. (PI) and theorem 290:
Theorem (290) [serial 1757] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1036] 


Theorem (292)                               [serial 1762] 
P [1] << RESPIRATION_RATE = RP_Rate >>
S [2] ->
Q [1] << RESPIRATION_RATE = RP_Rate >>
Why created:    normalization of [serial 1037]
Solved by: Identity (id):  P->P is tautology

Theorem (293)                               [serial 1037] 
P [1] << RP_Rate = RESPIRATION_RATE >>
S [2] ->
Q [1] << RP_Rate = RESPIRATION_RATE >>
Why created:  Composition of Subcomponents via Directional Connection rss.RP_Rate -> rmp.rmt.RP_Rate:
 RP_Rate -> RP_Rate
Solved by: Equality Commutes. (eqcom) and theorem 292:
Theorem (292) [serial 1762] used for:
    normalization of [serial 1037] 


Theorem (294)                               [serial 1038] 
P [1] << RM_ALARM_ECHO >>
S [2] ->
Q [1] << RM_ALARM_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection spt.RM_Alarm_Echo -> spc.rmae:
 RM_Alarm_Echo -> rmae
Solved by: Identity (id):  P->P is tautology

Theorem (295)                               [serial 1039] 
P [1] << PO_ALARM_ECHO >>
S [2] ->
Q [1] << PO_ALARM_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection spt.PO_Alarm_Echo -> spc.poae:
 PO_Alarm_Echo -> poae
Solved by: Identity (id):  P->P is tautology

Theorem (296)                               [serial 1040] 
P [1] << PAUSE_INFUSION >>
S [2] ->
Q [1] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection spt.Pause_Infusion -> spc.pi:
 Pause_Infusion -> pi
Solved by: Identity (id):  P->P is tautology

Theorem (297)                               [serial 1041] 
P [1] << PO_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection spc.PO_Alarm -> spt.PO_Alarm:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (298)                               [serial 1042] 
P [1] << RM_ALARM() >>
S [2] ->
Q [1] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection spc.RM_Alarm -> spt.RM_Alarm:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (299)                               [serial 1043] 
P [1] << PAUSE_INFUSION_ECHO >>
S [2] ->
Q [1] << PAUSE_INFUSION_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection spc.Pause_Infusion_Echo -> spt.Pause_Infusion_Echo:
 Pause_Infusion_Echo -> Pause_Infusion_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (300)                               [serial 1044] 
P [1] << infused_drug = PUMP_RATE$() >>
S [2] ->
Q [1] << infused_drug = PUMP_RATE$() >>
Why created:  Composition of Subcomponents via Directional Connection pca_pump.pmp.infused_drug -> patient.Infused_Drug:
 infused_drug -> Infused_Drug
Solved by: Identity (id):  P->P is tautology

Theorem (301)                               [serial 1045] 
P [1] << PO_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection pulse_oximeter.pop.poc.PO_Alarm -> coordinator.spp.spc.poa:
 PO_Alarm -> poa
Solved by: Identity (id):  P->P is tautology

Theorem (302)                               [serial 1046] 
P [1] << RM_ALARM() >>
S [2] ->
Q [1] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection resp_monitor.rmp.rmc.RM_Alarm -> coordinator.spp.spc.rma:
 RM_Alarm -> rma
Solved by: Identity (id):  P->P is tautology

Theorem (303)                               [serial 1047] 
P [1] << PAUSE_INFUSION >>
S [2] ->
Q [1] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection coordinator.spp.spc.Pause_Infusion -> pca_pump.pcp.pcc.pi:
 Pause_Infusion -> pi
Solved by: Identity (id):  P->P is tautology

Theorem (304)                               [serial 1048] 
P [67] << infused_drug = PUMP_RATE$() >>
S [38] ->
Q [715] << infused_drug = PUMP_RATE$() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.infusion_set:
 infused_drug -> Infused_Drug
Solved by: Identity (id):  P->P is tautology

Theorem (305)                               [serial 1049] 
P [509] << PAUSE_INFUSION >>
S [24] ->
Q [65] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.pause_infusion:
 Pause_Infusion -> pause_infusion
Solved by: Identity (id):  P->P is tautology

Theorem (306)                               [serial 1050] 
P [177] << PO_ALARM() >>
S [26] ->
Q [505] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.po_alarm:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (307)                               [serial 1051] 
P [358] << RM_ALARM() >>
S [28] ->
Q [501] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.rm_alarm:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (308)                               [serial 1052] 
P [69] << PAUSE_INFUSION_ECHO >>
S [31] ->
Q [511] << PAUSE_INFUSION_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.pause_infusion_echo:
 pause_infusion_echo -> Pause_Infusion_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (309)                               [serial 1053] 
P [145] << infused_drug = PUMP_RATE$() >>
S [86] ->
Q [67] << infused_drug = PUMP_RATE$() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pd:
 infused_drug -> infused_drug
Solved by: Identity (id):  P->P is tautology

Theorem (310)                               [serial 1054] 
P [65] << PAUSE_INFUSION >>
S [82] ->
Q [93] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pif:
 pause_infusion -> pause_infusion
Solved by: Identity (id):  P->P is tautology

Theorem (311)                               [serial 1055] 
P [97] << PAUSE_INFUSION_ECHO >>
S [83] ->
Q [69] << PAUSE_INFUSION_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pie:
 pause_infusion_echo -> pause_infusion_echo
Solved by: Identity (id):  P->P is tautology

Theorem (312)                               [serial 1056] 
P [95] << pump_rate = PUMP_RATE$() >>
S [84] ->
Q [150] << pump_rate = PUMP_RATE$() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pr:
 pump_rate -> pump_rate
Solved by: Identity (id):  P->P is tautology

Theorem (313)                               [serial 1057] 
P [93] << PAUSE_INFUSION >>
S [108] ->
Q [158] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.pi1:
 pause_infusion -> pi
Solved by: Identity (id):  P->P is tautology

Theorem (314)                               [serial 1058] 
P [160] << PAUSE_INFUSION >>
S [109] ->
Q [124] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.pi2:
 pause_infusion -> pause_infusion
Solved by: Identity (id):  P->P is tautology

Theorem (315)                               [serial 1059] 
P [121] << pump_rate = PUMP_RATE$() >>
S [115] ->
Q [95] << pump_rate = PUMP_RATE$() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.PCA_Pump_Process_impl_new_connection:
 pump_rate -> pump_rate
Solved by: Identity (id):  P->P is tautology

Theorem (316)                               [serial 1060] 
P [203] << PO_ALARM() >>
S [189] ->
Q [177] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter.impl.poa:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (317)                               [serial 1061] 
P [234] << PO_ALARM() >>
S [218] ->
Q [336] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter_Process.impl.pol1:
 PO_Alarm -> poa
Solved by: Identity (id):  P->P is tautology

Theorem (318)                               [serial 1062] 
P [338] << PO_ALARM() >>
S [219] ->
Q [203] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter_Process.impl.pol2:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (319)                               [serial 1063] 
P [378] << RM_ALARM() >>
S [369] ->
Q [358] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor.impl.rma:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (320)                               [serial 1064] 
P [403] << RM_ALARM() >>
S [392] ->
Q [479] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor_Process.impl.rma1:
 RM_Alarm -> rma
Solved by: Identity (id):  P->P is tautology

Theorem (321)                               [serial 1065] 
P [481] << RM_ALARM() >>
S [393] ->
Q [378] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor_Process.impl.rma2:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (322)                               [serial 1066] 
P [505] << PO_ALARM() >>
S [524] ->
Q [542] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.poa:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (323)                               [serial 1067] 
P [501] << RM_ALARM() >>
S [525] ->
Q [538] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.rma:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (324)                               [serial 1068] 
P [546] << PAUSE_INFUSION >>
S [526] ->
Q [509] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.pi:
 Pause_Infusion -> Pause_Infusion
Solved by: Identity (id):  P->P is tautology

Theorem (325)                               [serial 1069] 
P [511] << PAUSE_INFUSION_ECHO >>
S [527] ->
Q [548] << PAUSE_INFUSION_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.pie:
 Pause_Infusion_Echo -> Pause_Infusion_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (326)                               [serial 1070] 
P [544] << PO_ALARM_ECHO >>
S [529] ->
Q [507] << PO_ALARM_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.icp:
 PO_Alarm_Echo -> PO_Alarm_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (327)                               [serial 1071] 
P [540] << RM_ALARM_ECHO >>
S [530] ->
Q [503] << RM_ALARM_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.icr:
 RM_Alarm_Echo -> RM_Alarm_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (328)                               [serial 1072] 
P [542] << PO_ALARM() >>
S [561] ->
Q [674] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poa1:
 PO_Alarm -> poa
Solved by: Identity (id):  P->P is tautology

Theorem (329)                               [serial 1073] 
P [676] << PO_ALARM() >>
S [562] ->
Q [586] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poa2:
 PO_Alarm -> PO_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (330)                               [serial 1074] 
P [538] << RM_ALARM() >>
S [563] ->
Q [682] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rma1:
 RM_Alarm -> rma
Solved by: Identity (id):  P->P is tautology

Theorem (331)                               [serial 1075] 
P [684] << RM_ALARM() >>
S [564] ->
Q [582] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rma2:
 RM_Alarm -> RM_Alarm
Solved by: Identity (id):  P->P is tautology

Theorem (332)                               [serial 1076] 
P [548] << PAUSE_INFUSION_ECHO >>
S [565] ->
Q [694] << PAUSE_INFUSION_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pie1:
 Pause_Infusion_Echo -> pie
Solved by: Identity (id):  P->P is tautology

Theorem (333)                               [serial 1077] 
P [696] << PAUSE_INFUSION_ECHO >>
S [566] ->
Q [592] << PAUSE_INFUSION_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pie2:
 Pause_Infusion_Echo -> Pause_Infusion_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (334)                               [serial 1078] 
P [590] << PAUSE_INFUSION >>
S [567] ->
Q [690] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pi1:
 Pause_Infusion -> pi
Solved by: Identity (id):  P->P is tautology

Theorem (335)                               [serial 1079] 
P [692] << PAUSE_INFUSION >>
S [568] ->
Q [546] << PAUSE_INFUSION >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pi2:
 Pause_Infusion -> Pause_Infusion
Solved by: Identity (id):  P->P is tautology

Theorem (336)                               [serial 1080] 
P [584] << RM_ALARM_ECHO >>
S [569] ->
Q [686] << RM_ALARM_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rme1:
 RM_Alarm_Echo -> rmae
Solved by: Identity (id):  P->P is tautology

Theorem (337)                               [serial 1081] 
P [688] << RM_ALARM_ECHO >>
S [570] ->
Q [540] << RM_ALARM_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rme2:
 RM_Alarm_Echo -> RM_Alarm_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (338)                               [serial 1082] 
P [588] << PO_ALARM_ECHO >>
S [571] ->
Q [678] << PO_ALARM_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poe1:
 PO_Alarm_Echo -> poae
Solved by: Identity (id):  P->P is tautology

Theorem (339)                               [serial 1083] 
P [680] << PO_ALARM_ECHO >>
S [572] ->
Q [544] << PO_ALARM_ECHO >>
Why created:  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poe2:
 PO_Alarm_Echo -> PO_Alarm_Echo
Solved by: Identity (id):  P->P is tautology

Theorem (340)                               [serial 1001] 
Why created:  All verification conditions have been proved correct. 
Solved by:  Component and Connection Proofs
 and theorems 91 160 273 276 278 280 282 284 285 286 287 291 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339:
Theorem (91) [serial 1002] used for:
  Initial proof obligations for Pulse_Oximeter_Thread.impl 
Theorem (160) [serial 1010] used for:
  Initial proof obligations for Respiration_Monitor_Thread.impl 
Theorem (273) [serial 1018] used for:
  Initial proof obligations for Coordinator_Thread.echo 
Theorem (276) [serial 1028] used for:
  Conjunction of Subcomponents' Invariants imply SysIoMT.impl's Invariant 
Theorem (278) [serial 1029] used for:
  Subcomponent's Invariant implies PCA_Pump.impl's Invariant 
Theorem (280) [serial 1030] used for:
  Subcomponent's Invariant implies PCA_Pump_Process.impl's Invariant 
Theorem (282) [serial 1031] used for:
  Subcomponent's Invariant implies Coordinator.impl's Invariant 
Theorem (284) [serial 1032] used for:
  Subcomponent's Invariant implies Coordinator_Process.impl's Invariant 
Theorem (285) [serial 1033] used for:
  Composition of Subcomponents via Directional Connection pcc.pause_infusion -> pct.pause_infusion:
 pause_infusion -> pause_infusion 
Theorem (286) [serial 1034] used for:
  Composition of Subcomponents via Directional Connection pcp.pct.pump_rate -> pmp.pump_rate:
 pump_rate -> pump_rate 
Theorem (287) [serial 1035] used for:
  Composition of Subcomponents via Directional Connection pot.PO_Alarm -> poc.poa:
 PO_Alarm -> poa 
Theorem (291) [serial 1036] used for:
  Composition of Subcomponents via Directional Connection rmt.RM_Alarm -> rmc.rma:
 RM_Alarm -> rma 
Theorem (293) [serial 1037] used for:
  Composition of Subcomponents via Directional Connection rss.RP_Rate -> rmp.rmt.RP_Rate:
 RP_Rate -> RP_Rate 
Theorem (294) [serial 1038] used for:
  Composition of Subcomponents via Directional Connection spt.RM_Alarm_Echo -> spc.rmae:
 RM_Alarm_Echo -> rmae 
Theorem (295) [serial 1039] used for:
  Composition of Subcomponents via Directional Connection spt.PO_Alarm_Echo -> spc.poae:
 PO_Alarm_Echo -> poae 
Theorem (296) [serial 1040] used for:
  Composition of Subcomponents via Directional Connection spt.Pause_Infusion -> spc.pi:
 Pause_Infusion -> pi 
Theorem (297) [serial 1041] used for:
  Composition of Subcomponents via Directional Connection spc.PO_Alarm -> spt.PO_Alarm:
 PO_Alarm -> PO_Alarm 
Theorem (298) [serial 1042] used for:
  Composition of Subcomponents via Directional Connection spc.RM_Alarm -> spt.RM_Alarm:
 RM_Alarm -> RM_Alarm 
Theorem (299) [serial 1043] used for:
  Composition of Subcomponents via Directional Connection spc.Pause_Infusion_Echo -> spt.Pause_Infusion_Echo:
 Pause_Infusion_Echo -> Pause_Infusion_Echo 
Theorem (300) [serial 1044] used for:
  Composition of Subcomponents via Directional Connection pca_pump.pmp.infused_drug -> patient.Infused_Drug:
 infused_drug -> Infused_Drug 
Theorem (301) [serial 1045] used for:
  Composition of Subcomponents via Directional Connection pulse_oximeter.pop.poc.PO_Alarm -> coordinator.spp.spc.poa:
 PO_Alarm -> poa 
Theorem (302) [serial 1046] used for:
  Composition of Subcomponents via Directional Connection resp_monitor.rmp.rmc.RM_Alarm -> coordinator.spp.spc.rma:
 RM_Alarm -> rma 
Theorem (303) [serial 1047] used for:
  Composition of Subcomponents via Directional Connection coordinator.spp.spc.Pause_Infusion -> pca_pump.pcp.pcc.pi:
 Pause_Infusion -> pi 
Theorem (304) [serial 1048] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.infusion_set:
 infused_drug -> Infused_Drug 
Theorem (305) [serial 1049] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.pause_infusion:
 Pause_Infusion -> pause_infusion 
Theorem (306) [serial 1050] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.po_alarm:
 PO_Alarm -> PO_Alarm 
Theorem (307) [serial 1051] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.rm_alarm:
 RM_Alarm -> RM_Alarm 
Theorem (308) [serial 1052] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::SysIoMT.impl.pause_infusion_echo:
 pause_infusion_echo -> Pause_Infusion_Echo 
Theorem (309) [serial 1053] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pd:
 infused_drug -> infused_drug 
Theorem (310) [serial 1054] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pif:
 pause_infusion -> pause_infusion 
Theorem (311) [serial 1055] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pie:
 pause_infusion_echo -> pause_infusion_echo 
Theorem (312) [serial 1056] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump.impl.pr:
 pump_rate -> pump_rate 
Theorem (313) [serial 1057] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.pi1:
 pause_infusion -> pi 
Theorem (314) [serial 1058] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.pi2:
 pause_infusion -> pause_infusion 
Theorem (315) [serial 1059] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::PCA_Pump_Process.impl.PCA_Pump_Process_impl_new_connection:
 pump_rate -> pump_rate 
Theorem (316) [serial 1060] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter.impl.poa:
 PO_Alarm -> PO_Alarm 
Theorem (317) [serial 1061] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter_Process.impl.pol1:
 PO_Alarm -> poa 
Theorem (318) [serial 1062] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Pulse_Oximeter_Process.impl.pol2:
 PO_Alarm -> PO_Alarm 
Theorem (319) [serial 1063] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor.impl.rma:
 RM_Alarm -> RM_Alarm 
Theorem (320) [serial 1064] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor_Process.impl.rma1:
 RM_Alarm -> rma 
Theorem (321) [serial 1065] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Respiration_Monitor_Process.impl.rma2:
 RM_Alarm -> RM_Alarm 
Theorem (322) [serial 1066] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.poa:
 PO_Alarm -> PO_Alarm 
Theorem (323) [serial 1067] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.rma:
 RM_Alarm -> RM_Alarm 
Theorem (324) [serial 1068] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.pi:
 Pause_Infusion -> Pause_Infusion 
Theorem (325) [serial 1069] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.pie:
 Pause_Infusion_Echo -> Pause_Infusion_Echo 
Theorem (326) [serial 1070] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.icp:
 PO_Alarm_Echo -> PO_Alarm_Echo 
Theorem (327) [serial 1071] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator.impl.icr:
 RM_Alarm_Echo -> RM_Alarm_Echo 
Theorem (328) [serial 1072] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poa1:
 PO_Alarm -> poa 
Theorem (329) [serial 1073] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poa2:
 PO_Alarm -> PO_Alarm 
Theorem (330) [serial 1074] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rma1:
 RM_Alarm -> rma 
Theorem (331) [serial 1075] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rma2:
 RM_Alarm -> RM_Alarm 
Theorem (332) [serial 1076] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pie1:
 Pause_Infusion_Echo -> pie 
Theorem (333) [serial 1077] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pie2:
 Pause_Infusion_Echo -> Pause_Infusion_Echo 
Theorem (334) [serial 1078] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pi1:
 Pause_Infusion -> pi 
Theorem (335) [serial 1079] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.pi2:
 Pause_Infusion -> Pause_Infusion 
Theorem (336) [serial 1080] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rme1:
 RM_Alarm_Echo -> rmae 
Theorem (337) [serial 1081] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.rme2:
 RM_Alarm_Echo -> RM_Alarm_Echo 
Theorem (338) [serial 1082] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poe1:
 PO_Alarm_Echo -> poae 
Theorem (339) [serial 1083] used for:
  Composition of Subcomponents via Directional Connection IoMTwin::Coordinator_Process.impl.poe2:
 PO_Alarm_Echo -> PO_Alarm_Echo 


closing proof file "/Applications/osate2.14.0.app/Contents/MacOS/proof.txt" 