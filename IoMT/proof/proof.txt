This file, proof.txt, was produced the BLESS Proof Assistant v3.2.2
  at Sat Jan 27 21:49:00 CST 2024 by brianlarson

Theorem (1)                               [serial 1018] 
P [196] << ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion >>
S [192] ->
Q [192] << ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion >>
Why created:    normalization of [serial 1016]
Solved by: Identity (id):  P->P is tautology

Theorem (2)                               [serial 1016] 
P [196] << ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S [192] ->
Q [192] << ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1003]
Solved by: [Add unnecessary parentheses] and theorem 1:
Theorem (1) [serial 1018] used for:
    normalization of [serial 1016] 


Theorem (3)                               [serial 1003] 
P [196] << INV() >>
S [192] ->
Q [192] << ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion >>
Why created:  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition.
Solved by: Predicate Invocation. (PI) and theorem 2:
Theorem (2) [serial 1016] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1003] 


Theorem (4)                               [serial 1004] 
P [195] << INV() >>
S [195] ->
Q [195] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>>
Solved by: Anything Implies True (a1tru): P->true

Theorem (5)                               [serial 1019] 
P [197] << INV() >>
S [197] ->
Q [197] << ( not PO_ALARM()@now or PO_ALARM()@now or RM_ALARM()@now or ( PO_ALARM()@now or 
RM_ALARM()@now ) )
  and ( not RM_ALARM()@now or PO_ALARM()@now or RM_ALARM()@now or ( PO_ALARM()@now or 
RM_ALARM()@now ) ) >>
Why created:  Distributing Postcondition Or-Over-And [serial 1005]
Solved by: Law of Excluded middle. (exmid)

Theorem (6)                               [serial 1005] 
P [197] << INV() >>
S [197] ->
Q [197] << ( PO_ALARM()@now or RM_ALARM()@now ) or ( not PO_ALARM()@now
  and not RM_ALARM()@now ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state check, <<M(check)>> -> <<e1 or e2 or . . . en>>
Solved by: Distribution and-over-or with wff lists. (bl.dba2owl) and theorem 5:
Theorem (5) [serial 1019] used for:
  Distributing Postcondition Or-Over-And [serial 1005] 


Theorem (7)                               [serial 1006] 
P [195] << INV() >>
S [201] ->
Q [196] << INV() >>
Why created:   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{};
Solved by: Identity (id):  P->P is tautology

Theorem (8)                               [serial 1007] 
P [196] << INV() >>
S [202] ->
Q [197] << INV() >>
Why created:   <<M(run) and x>> -> <<M(check)>> for op: run-[x]->check{};
Solved by: Identity (id):  P->P is tautology

Theorem (9)                               [serial 1031] 
P [197] << ( PO_ALARM() or RM_ALARM() )
  and INV() >>
S [204] ->
Q [173] << PO_ALARM() or RM_ALARM() >>
Why created:    normalization of [serial 1027]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: And Introduction Schema (bl.aisl)(bl.aisr):  (X and Y)->X

Theorem (10)                               [serial 1027] 
P [197] << ( INV() )
  and ( PO_ALARM() or RM_ALARM() ) >>
S [204] ->
Q [173] << PO_ALARM() or RM_ALARM() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1025]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 9:
Theorem (9) [serial 1031] used for:
    normalization of [serial 1027] 


Theorem (11)                               [serial 1025] 
P [197] << ( INV() )
  and ( PO_ALARM()@now or RM_ALARM()@now ) >>
S [204] ->
Q [173] << PO_ALARM() or RM_ALARM() >>
Why created:  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|true]>> [serial 1024]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 10:
Theorem (10) [serial 1027] used for:
  Assume Present:  P = P@now = P^0   [serial 1025] 


Theorem (12)                               [serial 1028] 
P [204] << ( ( INV() )
  and ( PO_ALARM() or RM_ALARM() ) )
  and ( PO_ALARM() or RM_ALARM() ) >>
S [204] ->
Q [196] << INV() >>
Why created:  Assume Present:  P = P@now = P^0   [serial 1026]
Solved by: At Introduction: if a predicate is always true it's true at time t (bl.atintro) 
   or if a value is constant its value at time t is the same (bl.atintroc)  Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (13)                               [serial 1026] 
P [204] << ( ( INV() )
  and ( PO_ALARM()@now or RM_ALARM()@now ) )
  and ( PO_ALARM() or RM_ALARM() )@now >>
S [204] ->
Q [196] << INV() >>
Why created:  applied port output <<pre and (PO_ALARM() or RM_ALARM())@now>> -> <<post>> [serial 1024]
Solved by:  Assume Present:  P = P@now = P^0 
 and theorem 12:
Theorem (12) [serial 1028] used for:
  Assume Present:  P = P@now = P^0   [serial 1026] 


Theorem (14)                               [serial 1024] 
P [197] << ( INV() )
  and ( PO_ALARM()@now or RM_ALARM()@now ) >>
S [204] Pause_Infusion!(true)
Q [196] << INV() >>
Why created:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1008]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 11 13:
Theorem (11) [serial 1025] used for:
  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|true]>> [serial 1024] 
Theorem (13) [serial 1026] used for:
  applied port output <<pre and (PO_ALARM() or RM_ALARM())@now>> -> <<post>> [serial 1024] 


Theorem (15)                               [serial 1008] 
P [197] << ( INV() )
  and ( PO_ALARM()@now or RM_ALARM()@now ) >>
S [204] Pause_Infusion!(true)
Q [196] << INV() >>
Why created:   <<M(check) and x>> A <<M(run)>> for alarm: check-[x]->run{A};
Solved by: null and theorem 14:
Theorem (14) [serial 1024] used for:
  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1008] 


Theorem (16)                               [serial 1039] 
P [197] << ( not PO_ALARM()@now
  and not RM_ALARM()@now )
  and INV() >>
S [206] ->
Q [206] << not ( PO_ALARM() or RM_ALARM() ) >>
Why created:    normalization of [serial 1036]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (17)                               [serial 1036] 
P [197] << ( INV() )
  and ( not PO_ALARM()@now
  and not RM_ALARM()@now ) >>
S [206] ->
Q [206] << not ( PO_ALARM() or RM_ALARM() ) >>
Why created:  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|false]>> [serial 1035]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 16:
Theorem (16) [serial 1039] used for:
    normalization of [serial 1036] 


Theorem (18)                               [serial 1041] 
P [206] << ( ( not PO_ALARM()@now
  and not RM_ALARM()@now )
  and INV() )
  and ( not ( PO_ALARM() or RM_ALARM() ) )@now >>
S [206] ->
Q [196] << INV() >>
Why created:    normalization of [serial 1037]
  Using: ADD_UNNECESSARY_PARETHESES (bl.ancom) 
Solved by: Absorb parentheses, middle term in conjunction (bl.anabpm)

Theorem (19)                               [serial 1037] 
P [206] << ( ( INV() )
  and ( not PO_ALARM()@now
  and not RM_ALARM()@now ) )
  and ( not ( PO_ALARM() or RM_ALARM() ) )@now >>
S [206] ->
Q [196] << INV() >>
Why created:  applied port output <<pre and (not ( PO_ALARM() or RM_ALARM() ))@now>> -> <<post>> [serial 1035]
Solved by: [Add unnecessary parentheses] Conjunction Commutes. (bl.ancom) and theorem 18:
Theorem (18) [serial 1041] used for:
    normalization of [serial 1037] 


Theorem (20)                               [serial 1035] 
P [197] << ( INV() )
  and ( not PO_ALARM()@now
  and not RM_ALARM()@now ) >>
S [206] Pause_Infusion!(false)
Q [196] << INV() >>
Why created:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1009]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
 and theorems 17 19:
Theorem (17) [serial 1036] used for:
  applied port output of value <<pre>> -> <<M(Pause_Infusion)[Pause_Infusion|false]>> [serial 1035] 
Theorem (19) [serial 1037] used for:
  applied port output <<pre and (not ( PO_ALARM() or RM_ALARM() ))@now>> -> <<post>> [serial 1035] 


Theorem (21)                               [serial 1009] 
P [197] << ( INV() )
  and ( not PO_ALARM()@now
  and not RM_ALARM()@now ) >>
S [206] Pause_Infusion!(false)
Q [196] << INV() >>
Why created:   <<M(check) and x>> A <<M(run)>> for ok: check-[x]->run{A};
Solved by: null and theorem 20:
Theorem (20) [serial 1035] used for:
  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1009] 


Theorem (22)                               [serial 1002] 
P [189] <<   >>
S [192] ->
Q [189] << cc_app.impl proof obligations >>
Why created:  Initial proof obligations for cc_app.impl
Solved by:  Component verification conditions
 [Convert asseertion to port value.] and theorems 3 4 6 7 8 15 21:
Theorem (3) [serial 1003] used for:
  <<M(run)>> -> <<I>> from invariant I when complete state run has Assertion <<M(run)>> in its definition. 
Theorem (4) [serial 1004] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state start, <<M(start)>> -> <<e1 or e2 or . . . en>> 
Theorem (6) [serial 1005] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state check, <<M(check)>> -> <<e1 or e2 or . . . en>> 
Theorem (7) [serial 1006] used for:
   <<M(start)>> -> <<M(run)>> for go: start-[ ]->run{}; 
Theorem (8) [serial 1007] used for:
   <<M(run) and x>> -> <<M(check)>> for op: run-[x]->check{}; 
Theorem (15) [serial 1008] used for:
   <<M(check) and x>> A <<M(run)>> for alarm: check-[x]->run{A}; 
Theorem (21) [serial 1009] used for:
   <<M(check) and x>> A <<M(run)>> for ok: check-[x]->run{A}; 


Theorem (23)                               [serial 1052] 
P [1] << ( ( ( last_action'EndPriming = LAST_ACTION_A or last_action'SafetyStopPump = LAST_ACTION_A or 
last_action'StopButton = LAST_ACTION_A ) or KVO_RATE_property = PUMP_RATE$() ) iff Pause_Infusion )
  and ( ( HEART_RATE < MINIMUM_HEART_RATE or SpO2 < PROGRAMMED_SpO2 ) iff PO_alaram )
  and ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE iff RM_alaram )
  and ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SpO2 < PROGRAMMED_SpO2 ) or 
RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) implies ( ( last_action'EndPriming = LAST_ACTION_A or 
last_action'SafetyStopPump = LAST_ACTION_A or last_action'StopButton = LAST_ACTION_A ) or 
KVO_RATE_property = PUMP_RATE$() ) ) >>
S    ->
Q [2] << ( HEART_RATE < MINIMUM_HEART_RATE or RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE or 
SpO2 < PROGRAMMED_SpO2 ) implies ( ( last_action'EndPriming = LAST_ACTION_A or 
last_action'SafetyStopPump = LAST_ACTION_A or last_action'StopButton = LAST_ACTION_A ) or 
KVO_RATE_property = PUMP_RATE$() ) >>
Why created:    normalization of [serial 1050]
  Using: (eqcom) ADD_UNNECESSARY_PARETHESES (bicom) (bl.ancom) (bl.orcom) 
Solved by: Absorb parentheses, middle term in disjunction (bl.orabpm)

Theorem (24)                               [serial 1050] 
P [1] << ( Pause_Infusion iff ( PUMP_RATE$() = KVO_RATE_property or ( ( LAST_ACTION_A = last_action'SafetyStopPump ) or 
( LAST_ACTION_A = last_action'StopButton ) or ( LAST_ACTION_A = last_action'EndPriming ) ) ) )
  and ( PO_alaram iff ( HEART_RATE < MINIMUM_HEART_RATE or SpO2 < PROGRAMMED_SpO2 ) )
  and ( RM_alaram iff ( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) )
  and ( ( ( HEART_RATE < MINIMUM_HEART_RATE or SpO2 < PROGRAMMED_SpO2 ) or 
( RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) ) implies ( PUMP_RATE$() = KVO_RATE_property or 
( ( LAST_ACTION_A = last_action'SafetyStopPump ) or ( LAST_ACTION_A = last_action'StopButton ) or 
( LAST_ACTION_A = last_action'EndPriming ) ) ) ) >>
S    ->
Q [2] << ( ( HEART_RATE < MINIMUM_HEART_RATE or SpO2 < PROGRAMMED_SpO2 or RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) implies ( 
PUMP_RATE$() = KVO_RATE_property or ( ( LAST_ACTION_A = last_action'SafetyStopPump ) or 
( LAST_ACTION_A = last_action'StopButton ) or ( LAST_ACTION_A = last_action'EndPriming ) ) ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1049]
Solved by: Equality Commutes. (eqcom) [Add unnecessary parentheses] Biconditional (iff) Commutes. (bicom) Conjunction Commutes. (bl.ancom) Disjunction Commutes. (bl.orcom) and theorem 23:
Theorem (23) [serial 1052] used for:
    normalization of [serial 1050] 


Theorem (25)                               [serial 1049] 
P [1] << ( Pause_Infusion iff ( PUMP_RATE$() = KVO_RATE_property or HALT() ) )
  and ( PO_alaram iff PO_ALARM() )
  and ( RM_alaram iff RM_ALARM() )
  and ( ( PO_ALARM() or RM_ALARM() ) implies ( PUMP_RATE$() = KVO_RATE_property or 
HALT() ) ) >>
S    ->
Q [2] << ( ( HEART_RATE < MINIMUM_HEART_RATE or SpO2 < PROGRAMMED_SpO2 or RESPIRATION_RATE < MINIMUM_RESPIRATION_RATE ) implies ( 
PUMP_RATE$() = KVO_RATE_property or HALT() ) ) >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1048]
Solved by: Predicate Invocation. (PI) and theorem 24:
Theorem (24) [serial 1050] used for:
  Substituted assertions' predicates for labels  [serial 1049] 


Theorem (26)                               [serial 1048] 
P [1] << ( Pause_Infusion iff ( PUMP_RATE$() = KVO_RATE_property or HALT() ) )
  and ( PO_alaram iff PO_ALARM() )
  and ( RM_alaram iff RM_ALARM() )
  and ( ( PO_ALARM() or RM_ALARM() ) implies ( PUMP_RATE$() = KVO_RATE_property or 
HALT() ) ) >>
S    ->
Q [2] << IS_SAFE() >>
Why created:  Substituting Equals Within Conjunction [serial 1010]
Solved by: Predicate Invocation. (PI) and theorem 25:
Theorem (25) [serial 1049] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1048] 


Theorem (27)                               [serial 1010] 
P [1] << ( Pause_Infusion iff ( PUMP_RATE$() = KVO_RATE_property or HALT() ) )
  and ( PO_alaram iff PO_ALARM() )
  and ( RM_alaram iff RM_ALARM() )
  and ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S    ->
Q [2] << IS_SAFE() >>
Why created:  Conjunction of Subcomponents' Invariants imply SysIoMT.impl's Invariant
Solved by: A equality theorem for substitution. (subequ12a) and theorem 26:
Theorem (26) [serial 1048] used for:
  Substituting Equals Within Conjunction [serial 1010] 


Theorem (28)                               [serial 1057] 
P [1] << ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion >>
S    ->
Q [2] << ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion >>
Why created:    normalization of [serial 1011]
Solved by: Identity (id):  P->P is tautology

Theorem (29)                               [serial 1011] 
P [1] << ( ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion ) >>
S    ->
Q [2] << ( PO_ALARM() or RM_ALARM() ) implies Pause_Infusion >>
Why created:  Subcomponent's Invariant implies Control_Application.impl's Invariant
Solved by: [Add unnecessary parentheses] and theorem 28:
Theorem (28) [serial 1057] used for:
    normalization of [serial 1011] 


Theorem (30)                               [serial 1012] 
P [1] << Infused_Drug = PUMP_RATE() >>
S [2] ->
Q [1] << Infused_Drug = PUMP_RATE() >>
Why created:  Composition of Subcomponents via Directional Connection pca_pump.Infused_Drug -> patient.Infused_Drug:
 Infused_Drug -> Infused_Drug
Solved by: Identity (id):  P->P is tautology

Theorem (31)                               [serial 1013] 
P [1] << PO_ALARM() >>
S [2] ->
Q [1] << PO_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection pulse_oximeter.PO_alarm -> control_app.cc_proc.cc_app.PO_alarm:
 PO_alarm -> PO_alarm
Solved by: Identity (id):  P->P is tautology

Theorem (32)                               [serial 1014] 
P [1] << RM_ALARM() >>
S [2] ->
Q [1] << RM_ALARM() >>
Why created:  Composition of Subcomponents via Directional Connection resp_monitor.RM_alarm -> control_app.cc_proc.cc_app.RM_alarm:
 RM_alarm -> RM_alarm
Solved by: Identity (id):  P->P is tautology

Theorem (33)                               [serial 1015] 
P [87] << Infused_Drug = PUMP_RATE() >>
S [74] ->
Q [121] << Infused_Drug = PUMP_RATE() >>
Why created:  Composition of Subcomponents via Directional Connection IoMT::SysIoMT.impl.set_infusion:
 Infused_Drug -> Infused_Drug
Solved by: Identity (id):  P->P is tautology

Theorem (34)                               [serial 1001] 
Why created:  All verification conditions have been proved correct. 
Solved by:  Component and Connection Proofs
 and theorems 22 27 29 30 31 32 33:
Theorem (22) [serial 1002] used for:
  Initial proof obligations for cc_app.impl 
Theorem (27) [serial 1010] used for:
  Conjunction of Subcomponents' Invariants imply SysIoMT.impl's Invariant 
Theorem (29) [serial 1011] used for:
  Subcomponent's Invariant implies Control_Application.impl's Invariant 
Theorem (30) [serial 1012] used for:
  Composition of Subcomponents via Directional Connection pca_pump.Infused_Drug -> patient.Infused_Drug:
 Infused_Drug -> Infused_Drug 
Theorem (31) [serial 1013] used for:
  Composition of Subcomponents via Directional Connection pulse_oximeter.PO_alarm -> control_app.cc_proc.cc_app.PO_alarm:
 PO_alarm -> PO_alarm 
Theorem (32) [serial 1014] used for:
  Composition of Subcomponents via Directional Connection resp_monitor.RM_alarm -> control_app.cc_proc.cc_app.RM_alarm:
 RM_alarm -> RM_alarm 
Theorem (33) [serial 1015] used for:
  Composition of Subcomponents via Directional Connection IoMT::SysIoMT.impl.set_infusion:
 Infused_Drug -> Infused_Drug 


closing proof file "/Applications/osate2_2023-03-master/Eclipse.app/Contents/MacOS/proof.txt" 