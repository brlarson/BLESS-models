#  You chose proof script: /Users/brianlarson/git/BLESS-models/DDDRwE/proof scripts/subscripts/ratecontrol.ps
push
sort-by-component[rc::RateController.normal]
#rc::RateController.normal
#[serial 1012] <<M(wait)>> -> <<I>> from invariant I when complete state wait has Assertion <<M(wait)>> in its definition
make-an
axioms
#[serial 1013] Serban's Theorem:  disjunction of execute conditions leaving execution state first_rate, <<M(first_rate)>> -> <<e1 or e2 or . . . en>>
axioms
#[serial 1014] Serban's Theorem:  disjunction of execute conditions leaving execution state check_zero_division, <<M(check_zero_division)>> -> <<e1 or e2 or . . . en>>
replace<>
cnf
laws
normalize
axioms
#[serial 1015]  <<M(first_rate)>> -> <<M(wait)>> for RC0_init:first_rate-[ ]->wait{};
axioms
#[serial 1016]  <<M(wait) and x>> -> <<M(check_zero_division)>> for RC1_cci:wait-[x]->check_zero_division{};
axioms
#[serial 1017]  <<M(check_zero_division) and x>> -> <<M(err)>> for RC2_zero:check_zero_division-[x]->err{};
axioms
#[serial 1018]  <<M(check_zero_division) and x>> A <<M(wait)>> for RC3_nonzero:check_zero_division-[x]->wait{A};
reduce
reduce
reduce
reduce
axioms
atomic
normalize
axioms
remove-axioms-post
laws
normalize
now
split-post
axioms
push
#rc::RateController.normal
#[serial 1169]   normalization of [serial 1135
make-an
and-over-or-post
laws
normalize
axioms
#[serial 1183]   normalization of [serial 1139]
and-over-or-post
laws
normalize
axioms
#[serial 1260] Assume Present:  P = P@now = P^0  [serial 1167]
replace-port-value
axioms
#[serial 1262] Assume Present:  P = P@now = P^0  [serial 1238]
replace-port-value
laws
axioms
#[serial 1263] Assume Present:  P = P@now = P^0  [serial 1240]
replace-port-value
laws
axioms
#[serial 1264] Assume Present:  P = P@now = P^0  [serial 1242]
replace-port-value
laws
axioms
#[serial 1265] Assume Present:  P = P@now = P^0  [serial 1244]
replace-port-value
laws
axioms
#[serial 1266] Assume Present:  P = P@now = P^0  [serial 1246]
replace-port-value
laws
axioms
#[serial 1267] Assume Present:  P = P@now = P^0  [serial 1248]
replace-port-value
laws
axioms
#[serial 1272] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1268]
substitute-post
substitute-post
guided-sub-equals[dn_siri]
guided-sub-equals[y]
guided-sub-equals[siri]
normalize
laws
axioms
#[serial 1273] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1268]
guided-sub-equals[down]
substitute-post
normalize
laws
axioms
#[serial 1274] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1268]
guided-sub-equals[hylrl]
substitute-post
substitute-post
normalize
laws
axioms
#[serial 1275] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1268]
substitute-post
guided-sub-equals[siri]
normalize
laws
axioms
#[serial 1276] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1268]
guided-sub-equals[up]
substitute-post
normalize
laws
axioms
#[serial 1277] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1268]
guided-sub-equals[up_siri]
substitute-post
substitute-post
normalize
guided-sub-equals[siri]
guided-sub-equals[z]
normalize
laws
axioms
#[serial 1278] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1268]
guided-sub-equals[y]
substitute-post
normalize
laws
axioms
#[serial 1279] Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1268]
guided-sub-equals[z]
substitute-post
normalize
laws
axioms