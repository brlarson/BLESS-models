opening dump file "/Applications/OSATE-for-HAMR-and-BLESS/Eclipse-OfHaB.app/Contents/MacOS/dump.txt" Wed Jun 14 16:21:33 CDT 2023
opening proof script file "/Applications/OSATE-for-HAMR-and-BLESS/Eclipse-OfHaB.app/Contents/MacOS/script.txt"

Declarative Model has been Loaded.

 extracting initial proof obligation(s) for a package:  "CTCS"
  creating proof obligations for "MovementAuthority"
  creating proof obligations for "RadioBlockCenter"
  creating proof obligations for "MovementAuthority.i"
 extracting initial proof obligation(s) for a package:  "CTCS_Types"
  no proof obligations created for "Position"
  no proof obligations created for "movementAuthorization"
  no proof obligations created for "Acceleration"
  no proof obligations created for "Velocity"
  no proof obligations created for "Segment"
 extracting initial proof obligation(s) for a package:  "Threads"
  creating proof obligations for "AutoBrake"
  creating proof obligations for "AutoBrake.i"
[source=WaitFirstMA destination=CheckFirstMA dispatch condition=p, source=MoveForward destination=CheckMoveForward dispatch condition=p, source=MoveForwardLastSegment destination=CheckMoveForwardLastSegment dispatch condition=p, source=GotNewMA destination=CheckMATransition dispatch condition=p]
extracting proof obligations for "AutoBrake.i"

[serial 1002]: Threads::AutoBrake.i
P [33] <<   >>
S [39]->
Q [33] << AutoBrake.i proof obligations >>
What for:  Initial proof obligations for AutoBrake.i
Reason solved:  Component verification conditions
making initial obligations for complete states

[serial 1003]: Threads::AutoBrake.i
P [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [39]->
Q [39] << true >>
What for:  <<M(MoveForwardLastSegment)>> -> <<I>> from invariant I when complete state MoveForwardLastSegment has Assertion <<M(MoveForwardLastSegment)>> in its definition.

[serial 1004]: Threads::AutoBrake.i
P [54] << true >>
S [39]->
Q [39] << true >>
What for:  <<M(WaitFirstMA)>> -> <<I>> from invariant I when complete state WaitFirstMA has Assertion <<M(WaitFirstMA)>> in its definition.

[serial 1005]: Threads::AutoBrake.i
P [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [39]->
Q [39] << true >>
What for:  <<M(MoveForward)>> -> <<I>> from invariant I when complete state MoveForward has Assertion <<M(MoveForward)>> in its definition.

[serial 1006]: Threads::AutoBrake.i
P [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [39]->
Q [39] << true >>
What for:  <<M(GotNewMA)>> -> <<I>> from invariant I when complete state GotNewMA has Assertion <<M(GotNewMA)>> in its definition.
making Serban's theorems

[serial 1007]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [59]->
Q [59] << ( p < iSeg.e )
   or ( p >= iSeg.e ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForward, <<M(CheckMoveForward)>> -> <<e1 or e2 or . . . en>>

[serial 1008]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [65]->
Q [65] << ( not m_a'fresh )
   or m_a'fresh >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForwardLastSegment, <<M(CheckMoveForwardLastSegment)>> -> <<e1 or e2 or . . . en>>

[serial 1009]: Threads::AutoBrake.i
P [53] << true >>
S [53]->
Q [53] << true >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state Start, <<M(Start)>> -> <<e1 or e2 or . . . en>>

[serial 1010]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
S [61]->
Q [61] << ( i < ma.num_segments )
   or ( i = ma.num_segments )
   or ( i > ma.num_segments ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckForLastSegment, <<M(CheckForLastSegment)>> -> <<e1 or e2 or . . . en>>

[serial 1011]: Threads::AutoBrake.i
P [55] << true >>
S [55]->
Q [55] << ( not m_a'fresh )
   or m_a'fresh >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckFirstMA, <<M(CheckFirstMA)>> -> <<e1 or e2 or . . . en>>

[serial 1012]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [70]->
Q [70] << ( p < ma.ea )
   or ( p >= ma.ea ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMATransition, <<M(CheckMATransition)>> -> <<e1 or e2 or . . . en>>
making initial proof obligations for transitions

[serial 1013]: Threads::AutoBrake.i
P [53] << true >>
S [76]r!
Q [54] << true >>
What for:   <<M(Start)>> A <<M(WaitFirstMA)>> for Go: Start-[ ]->WaitFirstMA{A};

[serial 1014]: Threads::AutoBrake.i
P [79] << ( true )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [78]->
Q [55] << true >>
What for:   <<M(WaitFirstMA) and x>> -> <<M(CheckFirstMA)>> for FirstMA: WaitFirstMA-[x]->CheckFirstMA{};

[serial 1015]: Threads::AutoBrake.i
P [82] << not m_a'fresh >>
S [81]->
Q [54] << true >>
What for:   <<M(CheckFirstMA) and x>> -> <<M(WaitFirstMA)>> for NotYet: CheckFirstMA-[x]->WaitFirstMA{};

[serial 1016]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [86]  << AXIOM_CMA_IS_RMA() >>
  m_a?(ma)
  ;
  << ma = CMA >>
  i := 1
  ;
  << i = 1
    and ma = CMA >>
  iSeg := ma.seg[1]
  ;
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and AXIOM_NUM_SEG(ma : ma) >>
  nSeg := ma.seg[2]
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1]
    and AXIOM_NUM_SEG(ma : CMA) >> 
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(CheckFirstMA) and x>> A <<M(MoveForward)>> for GotFirstMA: CheckFirstMA-[x]->MoveForward{A};

[serial 1017]: Threads::AutoBrake.i
P [100] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [101]<< i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(MoveForward) and x>> A <<M(CheckMoveForward)>> for CheckSpeed: MoveForward-[x]->CheckMoveForward{A};

[serial 1018]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p < iSeg.e ) >>
S [128]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(CheckMoveForward) and x>> -> <<M(MoveForward)>> for SameSegment: CheckMoveForward-[x]->MoveForward{};

[serial 1019]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]  iSeg := nSeg
  ;
  << iSeg = CMA.seg[i + 1]
    and ma = CMA >>
  i := i + 1 
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
What for:   <<M(CheckMoveForward) and x>> A <<M(CheckForLastSegment)>> for NextSegment: CheckMoveForward-[x]->CheckForLastSegment{A};

[serial 1020]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141]nSeg := ma.seg[i + 1]
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(CheckForLastSegment) and x>> A <<M(MoveForward)>> for NotLastSegment: CheckForLastSegment-[x]->MoveForward{A};

[serial 1021]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]  r!
  ;
  << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA >>
  nSeg := [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] 
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:   <<M(CheckForLastSegment) and x>> A <<M(MoveForwardLastSegment)>> for IsLastSegment: CheckForLastSegment-[x]->MoveForwardLastSegment{A};

[serial 1022]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i > ma.num_segments ) >>
S [155]->
Q [72] << true >>
What for:   <<M(CheckForLastSegment) and x>> -> <<M(FAIL)>> for PastLastSegment: CheckForLastSegment-[x]->FAIL{};

[serial 1023]: Threads::AutoBrake.i
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [160]<< i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:   <<M(MoveForwardLastSegment) and x>> A <<M(CheckMoveForwardLastSegment)>> for LastSegment: MoveForwardLastSegment-[x]->CheckMoveForwardLastSegment{A};

[serial 1024]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( not m_a'fresh ) >>
S [186]->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:   <<M(CheckMoveForwardLastSegment) and x>> -> <<M(MoveForwardLastSegment)>> for NoMAYet: CheckMoveForwardLastSegment-[x]->MoveForwardLastSegment{};

[serial 1025]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [191]  << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA
    and AXIOM_NEXT_MA_IS_RMA() >>
  m_a?(next_ma)
  ;
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA >>
  nSeg := next_ma.seg[1]
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA
    and nSeg = NEXT_MA.seg[1] >> 
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:   <<M(CheckMoveForwardLastSegment) and x>> A <<M(GotNewMA)>> for GetNewMA: CheckMoveForwardLastSegment-[x]->GotNewMA{A};

[serial 1026]: Threads::AutoBrake.i
P [203] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [202]->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:   <<M(GotNewMA) and x>> -> <<M(CheckMATransition)>> for LastBitOfMa: GotNewMA-[x]->CheckMATransition{};

[serial 1027]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p < ma.ea ) >>
S [205]->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:   <<M(CheckMATransition) and x>> -> <<M(GotNewMA)>> for NotEndOfMA: CheckMATransition-[x]->GotNewMA{};

[serial 1028]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [210]  << AXIOM_CMA_IS_NEXT_MA()
    and next_ma = NEXT_MA >>
  ma := next_ma
  ;
  << ma = CMA >>
  i := 1
  ;
  << i = 1
    and ma = CMA >>
  iSeg := ma.seg[1]
  ;
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i] >>
  nSeg := ma.seg[2]
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1]
    and AXIOM_NUM_SEG(ma : ma) >> 
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(CheckMATransition) and x>> A <<M(MoveForward)>> for StartNextMa: CheckMATransition-[x]->MoveForward{A};
 extracting initial proof obligation(s) for a package:  "Train"
  no proof obligations created for "Operator"
  creating proof obligations for "ServiceBrake"
  creating proof obligations for "Motor"
  creating proof obligations for "Train"
  creating proof obligations for "EmergencyBrake"
  no proof obligations created for "ControllerProcess"
  creating proof obligations for "Sensor"
  creating proof obligations for "Train.i"
 extracting initial proof obligation(s) for a package:  "CTCS_Assertion"
source Assertion of driver.xl -> motor.xl:  << xl = OPERATOR_XL >>
destination Assertion of driver.xl -> motor.xl:  << xl = OPERATOR_XL >>

[serial 1029]: driver.xl -> motor.xl
P [1] << xl = OPERATOR_XL >>
S [2]->
Q [1] << xl = OPERATOR_XL >>
What for:  Composition of Subcomponents via Directional Connection driver.xl -> motor.xl:
 xl -> xl
source Assertion of sensor.p -> controller.control.p:  << p = POSITION >>
destination Assertion of sensor.p -> controller.control.p:  << p = POSITION >>

[serial 1030]: sensor.p -> controller.control.p
P [1] << p = POSITION >>
S [2]->
Q [1] << p = POSITION >>
What for:  Composition of Subcomponents via Directional Connection sensor.p -> controller.control.p:
 p -> p
source Assertion of sensor.v -> controller.control.v:  << v = VELOCITY >>
destination Assertion of sensor.v -> controller.control.v:  << v = VELOCITY >>

[serial 1031]: sensor.v -> controller.control.v
P [1] << v = VELOCITY >>
S [2]->
Q [1] << v = VELOCITY >>
What for:  Composition of Subcomponents via Directional Connection sensor.v -> controller.control.v:
 v -> v
source Assertion of controller.control.sb -> sbrake.brake:  << SB()
  and not EB() >>
destination Assertion of controller.control.sb -> sbrake.brake:  << SB()
  and not EB() >>

[serial 1032]: controller.control.sb -> sbrake.brake
P [1] << SB()
  and not EB() >>
S [2]->
Q [1] << SB()
  and not EB() >>
What for:  Composition of Subcomponents via Directional Connection controller.control.sb -> sbrake.brake:
 sb -> brake
source Assertion of controller.control.eb -> ebrake.brake:  << EB() >>
destination Assertion of controller.control.eb -> ebrake.brake:  << EB() >>

[serial 1033]: controller.control.eb -> ebrake.brake
P [1] << EB() >>
S [2]->
Q [1] << EB() >>
What for:  Composition of Subcomponents via Directional Connection controller.control.eb -> ebrake.brake:
 eb -> brake
source Assertion of rbc.ma -> train.controller.control.m_a:  << ma_m_a = RMA >>
destination Assertion of rbc.ma -> train.controller.control.m_a:  << ma_m_a = RMA >>

[serial 1034]: rbc.ma -> train.controller.control.m_a
P [1] << ma_m_a = RMA >>
S [2]->
Q [1] << ma_m_a = RMA >>
What for:  Composition of Subcomponents via Directional Connection rbc.ma -> train.controller.control.m_a:
 ma -> m_a
6 instance model connection assume-guarantee verification conditions generated.
source Assertion of ma:  << ma = RMA >>
destination Assertion of ma:  << ma = RMA >>

[serial 1035]: CTCS::MovementAuthority.i.ma
P [27] << ma = RMA >>
S [19]->
Q [14] << ma = RMA >>
What for:  Composition of Subcomponents via Directional Connection CTCS::MovementAuthority.i.ma:
 ma -> ma
source Assertion of auth:  << ma_m_a = RMA >>
destination Assertion of auth:  << ma_m_a = RMA >>

[serial 1036]: Train::Train.i.auth
P [14] << ma_m_a = RMA >>
S [73]->
Q [94] << ma_m_a = RMA >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.auth:
 ma -> m_a
source Assertion of pos:  << p = POSITION >>
destination Assertion of pos:  << p = POSITION >>

[serial 1037]: Train::Train.i.pos
P [32] << p = POSITION >>
S [74]->
Q [89] << p = POSITION >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.pos:
 p -> p
source Assertion of vel:  << v = VELOCITY >>
destination Assertion of vel:  << v = VELOCITY >>

[serial 1038]: Train::Train.i.vel
P [34] << v = VELOCITY >>
S [75]->
Q [91] << v = VELOCITY >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.vel:
 v -> v
source Assertion of dxl:  << xl = OPERATOR_XL >>
destination Assertion of dxl:  << xl = OPERATOR_XL >>

[serial 1039]: Train::Train.i.dxl
P [59] << xl = OPERATOR_XL >>
S [76]->
Q [23] << xl = OPERATOR_XL >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.dxl:
 xl -> xl
source Assertion of cpsb:  << SB()
  and not EB() >>
destination Assertion of cpsb:  << SB()
  and not EB() >>

[serial 1040]: Train::Train.i.cpsb
P [85] << SB()
  and not EB() >>
S [77]->
Q [44] << SB()
  and not EB() >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.cpsb:
 sb -> brake
source Assertion of cpeb:  << EB() >>
destination Assertion of cpeb:  << EB() >>

[serial 1041]: Train::Train.i.cpeb
P [87] << EB() >>
S [78]->
Q [51] << EB() >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.cpeb:
 eb -> brake
source Assertion of conn_s:  << p = POSITION >>
destination Assertion of conn_s:  << p = POSITION >>

[serial 1042]: Train::ControllerProcess.i.conn_s
P [89] << p = POSITION >>
S [103]->
Q [19] << p = POSITION >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_s:
 p -> p
source Assertion of conn_v:  << v = VELOCITY >>
destination Assertion of conn_v:  << v = VELOCITY >>

[serial 1043]: Train::ControllerProcess.i.conn_v
P [91] << v = VELOCITY >>
S [104]->
Q [21] << v = VELOCITY >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_v:
 v -> v
source Assertion of conn_ma:  << m_a = RMA >>
destination Assertion of conn_ma:  << m_a = RMA >>

[serial 1044]: Train::ControllerProcess.i.conn_ma
P [94] << m_a = RMA >>
S [106]->
Q [17] << m_a = RMA >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_ma:
 m_a -> m_a
source Assertion of conn_sb:  << SB()
  and not EB() >>
destination Assertion of conn_sb:  << SB()
  and not EB() >>

[serial 1045]: Train::ControllerProcess.i.conn_sb
P [12] << SB()
  and not EB() >>
S [108]->
Q [85] << SB()
  and not EB() >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_sb:
 sb -> sb
source Assertion of conn_eb:  << EB() >>
destination Assertion of conn_eb:  << EB() >>

[serial 1046]: Train::ControllerProcess.i.conn_eb
P [14] << EB() >>
S [109]->
Q [87] << EB() >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_eb:
 eb -> eb
12 declarative model connection assume-guarantee verification conditions generated.
There was one instance model connection lacking a BLESS::Assertion property on both ends.
There was one Declarative model connection lacking a BLESS::Assertion property on one end.
There were 3 Declarative model connections lacking a BLESS::Assertion property on both ends.
No errors found.
Executing proof script . . .
You chose proof script: /Users/brianlarson/git/BLESS-models/CTCS-3/proof/CTCS3.ps
step:  1
#This file, script.txt, was produced the BLESS Proof Assistant v3.2.0
step:  2
#  at Wed Jun 14 16:14:36 CDT 2023 by brianlarson
step:  3
#  You chose proof script: /Users/brianlarson/git/BLESS-models/CTCS-3/proof/CTCS3.ps
step:  4
#Threads::AutoBrake.i
step:  5
#[serial 1003] <<M(MoveForwardLastSegment)>> -> <<I>> from invariant I when complete state MoveForwardLastSegment has Assertion <<M(MoveForwardLastSegment)>> in its definitio
step:  6
****make-an****
Making obligation 0
Obligations:

[serial 1003]: Threads::AutoBrake.i
P [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [39]->
Q [39] << true >>
What for:  <<M(MoveForwardLastSegment)>> -> <<I>> from invariant I when complete state MoveForwardLastSegment has Assertion <<M(MoveForwardLastSegment)>> in its definition.
Done making obligation 0
step:  7
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1003]: Threads::AutoBrake.i
P [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [39]->
Q [39] << true >>
What for:  <<M(MoveForwardLastSegment)>> -> <<I>> from invariant I when complete state MoveForwardLastSegment has Assertion <<M(MoveForwardLastSegment)>> in its definition.
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [12.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1004]: Threads::AutoBrake.i
P [54] << true >>
S [39]->
Q [39] << true >>
What for:  <<M(WaitFirstMA)>> -> <<I>> from invariant I when complete state WaitFirstMA has Assertion <<M(WaitFirstMA)>> in its definition.
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  8
#[serial 1004] <<M(WaitFirstMA)>> -> <<I>> from invariant I when complete state WaitFirstMA has Assertion <<M(WaitFirstMA)>> in its definition.
step:  9
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1004]: Threads::AutoBrake.i
P [54] << true >>
S [39]->
Q [39] << true >>
What for:  <<M(WaitFirstMA)>> -> <<I>> from invariant I when complete state WaitFirstMA has Assertion <<M(WaitFirstMA)>> in its definition.
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [12.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1005]: Threads::AutoBrake.i
P [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [39]->
Q [39] << true >>
What for:  <<M(MoveForward)>> -> <<I>> from invariant I when complete state MoveForward has Assertion <<M(MoveForward)>> in its definition.
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  10
#[serial 1005] <<M(MoveForward)>> -> <<I>> from invariant I when complete state MoveForward has Assertion <<M(MoveForward)>> in its definition.
step:  11
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1005]: Threads::AutoBrake.i
P [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [39]->
Q [39] << true >>
What for:  <<M(MoveForward)>> -> <<I>> from invariant I when complete state MoveForward has Assertion <<M(MoveForward)>> in its definition.
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [12.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1006]: Threads::AutoBrake.i
P [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [39]->
Q [39] << true >>
What for:  <<M(GotNewMA)>> -> <<I>> from invariant I when complete state GotNewMA has Assertion <<M(GotNewMA)>> in its definition.
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  12
#[serial 1006] <<M(GotNewMA)>> -> <<I>> from invariant I when complete state GotNewMA has Assertion <<M(GotNewMA)>> in its definition.
step:  13
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1006]: Threads::AutoBrake.i
P [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [39]->
Q [39] << true >>
What for:  <<M(GotNewMA)>> -> <<I>> from invariant I when complete state GotNewMA has Assertion <<M(GotNewMA)>> in its definition.
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1048]: Threads::AutoBrake.i
P [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [39]->
Q [39] << true >>
What for:    normalization of [serial 1006]
. . . done Normalizing Unsolved Proof Obligations [12.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1048]: Threads::AutoBrake.i
P [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [39]->
Q [39] << true >>
What for:    normalization of [serial 1006]
Done Normalizing
step:  14
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1048]: Threads::AutoBrake.i
P [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [39]->
Q [39] << true >>
What for:    normalization of [serial 1006]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [12.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1007]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [59]->
Q [59] << ( p < iSeg.e )
   or ( p >= iSeg.e ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForward, <<M(CheckMoveForward)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  15
#[serial 1007] Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForward, <<M(CheckMoveForward)>> -> <<e1 or e2 or . . . en>>
step:  16
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1007]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [59]->
Q [59] << ( p < iSeg.e )
   or ( p >= iSeg.e ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForward, <<M(CheckMoveForward)>> -> <<e1 or e2 or . . . en>>
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1051]: Threads::AutoBrake.i
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [59]->
Q [59] << iSeg.e <= p
   or p < iSeg.e >>
What for:    normalization of [serial 1007]
. . . done Normalizing Unsolved Proof Obligations [12.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1051]: Threads::AutoBrake.i
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [59]->
Q [59] << iSeg.e <= p
   or p < iSeg.e >>
What for:    normalization of [serial 1007]
Done Normalizing
step:  17
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1051]: Threads::AutoBrake.i
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [59]->
Q [59] << iSeg.e <= p
   or p < iSeg.e >>
What for:    normalization of [serial 1007]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1053]: Threads::AutoBrake.i
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [59]->
Q [59] << ( not ( p < iSeg.e ) )
   or p < iSeg.e >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1051]
. . . Substituting <= with not < [12.7 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1053]: Threads::AutoBrake.i
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [59]->
Q [59] << ( not ( p < iSeg.e ) )
   or p < iSeg.e >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1051]
Done replacing a<=b with (not b<a)
step:  18
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1053]: Threads::AutoBrake.i
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [59]->
Q [59] << ( not ( p < iSeg.e ) )
   or p < iSeg.e >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1051]
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 1054]: Threads::AutoBrake.i
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [59]->
Q [59] << true >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1053]
. . . done Applying Laws [12.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1054]: Threads::AutoBrake.i
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [59]->
Q [59] << true >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1053]
Done applying laws
step:  19
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1054]: Threads::AutoBrake.i
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [59]->
Q [59] << true >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1053]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [12.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1008]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [65]->
Q [65] << ( not m_a'fresh )
   or m_a'fresh >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForwardLastSegment, <<M(CheckMoveForwardLastSegment)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  20
#[serial 1008] Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForwardLastSegment, <<M(CheckMoveForwardLastSegment)>> -> <<e1 or e2 or . . . en>>
step:  21
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1008]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [65]->
Q [65] << ( not m_a'fresh )
   or m_a'fresh >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForwardLastSegment, <<M(CheckMoveForwardLastSegment)>> -> <<e1 or e2 or . . . en>>
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 1055]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [65]->
Q [65] << true >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1008]
. . . done Applying Laws [12.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1055]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [65]->
Q [65] << true >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1008]
Done applying laws
step:  22
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1055]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [65]->
Q [65] << true >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1008]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [12.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1009]: Threads::AutoBrake.i
P [53] << true >>
S [53]->
Q [53] << true >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state Start, <<M(Start)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  23
#[serial 1009] Serban's Theorem:  disjunction of execute conditions leaving execution state Start, <<M(Start)>> -> <<e1 or e2 or . . . en>>
step:  24
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1009]: Threads::AutoBrake.i
P [53] << true >>
S [53]->
Q [53] << true >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state Start, <<M(Start)>> -> <<e1 or e2 or . . . en>>
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [12.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1010]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
S [61]->
Q [61] << ( i < ma.num_segments )
   or ( i = ma.num_segments )
   or ( i > ma.num_segments ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckForLastSegment, <<M(CheckForLastSegment)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  25
#[serial 1010] Serban's Theorem:  disjunction of execute conditions leaving execution state CheckForLastSegment, <<M(CheckForLastSegment)>> -> <<e1 or e2 or . . . en>>
step:  26
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1010]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
S [61]->
Q [61] << ( i < ma.num_segments )
   or ( i = ma.num_segments )
   or ( i > ma.num_segments ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckForLastSegment, <<M(CheckForLastSegment)>> -> <<e1 or e2 or . . . en>>
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of Greater Than: (a>b) = (b<a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1057]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [61]->
Q [61] << i = ma.num_segments
   or i < ma.num_segments
   or ma.num_segments < i >>
What for:    normalization of [serial 1010]
. . . done Normalizing Unsolved Proof Obligations [12.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1057]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [61]->
Q [61] << i = ma.num_segments
   or i < ma.num_segments
   or ma.num_segments < i >>
What for:    normalization of [serial 1010]
Done Normalizing
step:  27
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1057]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [61]->
Q [61] << i = ma.num_segments
   or i < ma.num_segments
   or ma.num_segments < i >>
What for:    normalization of [serial 1010]
Reason solved:  Less than, greater than, or equal:  |-a<b or b<a or a=b
Has applied law "Less than, greater than, or equal:  |-a<b or b<a or a=b " to get:

[serial 1059]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [61]->
Q [61] << true >>
What for:  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1057]
. . . done Applying Laws [12.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1059]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [61]->
Q [61] << true >>
What for:  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1057]
Done applying laws
step:  28
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1059]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [61]->
Q [61] << true >>
What for:  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1057]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [12.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1011]: Threads::AutoBrake.i
P [55] << true >>
S [55]->
Q [55] << ( not m_a'fresh )
   or m_a'fresh >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckFirstMA, <<M(CheckFirstMA)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  29
#[serial 1011] Serban's Theorem:  disjunction of execute conditions leaving execution state CheckFirstMA, <<M(CheckFirstMA)>> -> <<e1 or e2 or . . . en>>
step:  30
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1011]: Threads::AutoBrake.i
P [55] << true >>
S [55]->
Q [55] << ( not m_a'fresh )
   or m_a'fresh >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckFirstMA, <<M(CheckFirstMA)>> -> <<e1 or e2 or . . . en>>
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 1060]: Threads::AutoBrake.i
P [55] << true >>
S [55]->
Q [55] << true >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1011]
. . . done Applying Laws [12.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1060]: Threads::AutoBrake.i
P [55] << true >>
S [55]->
Q [55] << true >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1011]
Done applying laws
step:  31
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1060]: Threads::AutoBrake.i
P [55] << true >>
S [55]->
Q [55] << true >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1011]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [12.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1012]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [70]->
Q [70] << ( p < ma.ea )
   or ( p >= ma.ea ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMATransition, <<M(CheckMATransition)>> -> <<e1 or e2 or . . . en>>
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  32
#[serial 1012] Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMATransition, <<M(CheckMATransition)>> -> <<e1 or e2 or . . . en>>
step:  33
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1012]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [70]->
Q [70] << ( p < ma.ea )
   or ( p >= ma.ea ) >>
What for:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMATransition, <<M(CheckMATransition)>> -> <<e1 or e2 or . . . en>>
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1062]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70]->
Q [70] << ma.ea <= p
   or p < ma.ea >>
What for:    normalization of [serial 1012]
. . . done Normalizing Unsolved Proof Obligations [12.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1062]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70]->
Q [70] << ma.ea <= p
   or p < ma.ea >>
What for:    normalization of [serial 1012]
Done Normalizing
step:  34
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1062]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70]->
Q [70] << ma.ea <= p
   or p < ma.ea >>
What for:    normalization of [serial 1012]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1064]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70]->
Q [70] << ( not ( p < ma.ea ) )
   or p < ma.ea >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1062]
. . . Substituting <= with not < [12.8 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1064]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70]->
Q [70] << ( not ( p < ma.ea ) )
   or p < ma.ea >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1062]
Done replacing a<=b with (not b<a)
step:  35
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1064]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70]->
Q [70] << ( not ( p < ma.ea ) )
   or p < ma.ea >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1062]
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 1065]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70]->
Q [70] << true >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1064]
. . . done Applying Laws [12.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1065]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70]->
Q [70] << true >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1064]
Done applying laws
step:  36
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1065]: Threads::AutoBrake.i
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70]->
Q [70] << true >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1064]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [12.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1013]: Threads::AutoBrake.i
P [53] << true >>
S [76]r!
Q [54] << true >>
What for:   <<M(Start)>> A <<M(WaitFirstMA)>> for Go: Start-[ ]->WaitFirstMA{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  37
#[serial 1013]  <<M(Start)>> A <<M(WaitFirstMA)>> for GoStart-[ ]->WaitFirstMA{A};
step:  38
****reduce****

[serial 1066]: Threads::AutoBrake.i
P [53] << true >>
S [76]r!
Q [54] << true >>
What for:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1013]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1066]: Threads::AutoBrake.i
P [53] << true >>
S [76]r!
Q [54] << true >>
What for:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1013]
done reducing composite actions
step:  39
****atomic****
applying atomic actions . . .
out event port r on line 76 does not have a BLESS::Assertion property AutoBrake.i; <<true>> used instead.

This Proof Obligation:

[serial 1066]: Threads::AutoBrake.i
P [53] << true >>
S [76]r!
Q [54] << true >>
What for:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1013]
Has applied <<pre>> -> <<M(r)>> for <<pre>> r! <<post>> to get:

[serial 1067]: Threads::AutoBrake.i
P [53] << true >>
S [76]->
Q [76] << true >>
What for:  applied port output <<pre>> -> <<M[r]>> [serial 1066]
Has applied <<pre and r@now>> -> <<post>> for <<pre>> r! <<post>> to get:

[serial 1068]: Threads::AutoBrake.i
P [76] << ( true )
  and true@now >>
S [76]->
Q [54] << true >>
What for:  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1066]
. . . done applying atomic actions [12.8 seconds ]
After "atomic" remaining 
Obligations:

[serial 1067]: Threads::AutoBrake.i
P [53] << true >>
S [76]->
Q [76] << true >>
What for:  applied port output <<pre>> -> <<M[r]>> [serial 1066]

[serial 1068]: Threads::AutoBrake.i
P [76] << ( true )
  and true@now >>
S [76]->
Q [54] << true >>
What for:  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1066]
Done reducing atomic actions
step:  40
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1067]: Threads::AutoBrake.i
P [53] << true >>
S [76]->
Q [76] << true >>
What for:  applied port output <<pre>> -> <<M[r]>> [serial 1066]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true

This Proof Obligation:

[serial 1068]: Threads::AutoBrake.i
P [76] << ( true )
  and true@now >>
S [76]->
Q [54] << true >>
What for:  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1066]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [12.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1014]: Threads::AutoBrake.i
P [79] << ( true )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [78]->
Q [55] << true >>
What for:   <<M(WaitFirstMA) and x>> -> <<M(CheckFirstMA)>> for FirstMA: WaitFirstMA-[x]->CheckFirstMA{};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  41
#[serial 1014]  <<M(WaitFirstMA) and x>> -> <<M(CheckFirstMA)>> for FirstMAWaitFirstMA-[x]->CheckFirstMA{};
step:  42
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1014]: Threads::AutoBrake.i
P [79] << ( true )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [78]->
Q [55] << true >>
What for:   <<M(WaitFirstMA) and x>> -> <<M(CheckFirstMA)>> for FirstMA: WaitFirstMA-[x]->CheckFirstMA{};
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [12.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1015]: Threads::AutoBrake.i
P [82] << not m_a'fresh >>
S [81]->
Q [54] << true >>
What for:   <<M(CheckFirstMA) and x>> -> <<M(WaitFirstMA)>> for NotYet: CheckFirstMA-[x]->WaitFirstMA{};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  43
#[serial 1015]  <<M(CheckFirstMA) and x>> -> <<M(WaitFirstMA)>> for NotYetCheckFirstMA-[x]->WaitFirstMA{};
step:  44
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1015]: Threads::AutoBrake.i
P [82] << not m_a'fresh >>
S [81]->
Q [54] << true >>
What for:   <<M(CheckFirstMA) and x>> -> <<M(WaitFirstMA)>> for NotYet: CheckFirstMA-[x]->WaitFirstMA{};
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [12.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1016]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [86]  << AXIOM_CMA_IS_RMA() >>
  m_a?(ma)
  ;
  << ma = CMA >>
  i := 1
  ;
  << i = 1
    and ma = CMA >>
  iSeg := ma.seg[1]
  ;
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and AXIOM_NUM_SEG(ma : ma) >>
  nSeg := ma.seg[2]
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1]
    and AXIOM_NUM_SEG(ma : CMA) >> 
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(CheckFirstMA) and x>> A <<M(MoveForward)>> for GotFirstMA: CheckFirstMA-[x]->MoveForward{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  45
#[serial 1016]  <<M(CheckFirstMA) and x>> A <<M(MoveForward)>> for GotFirstMACheckFirstMA-[x]->MoveForward{A};
step:  46
****reduce****
This proof obligation:

[serial 1016]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [86]  << AXIOM_CMA_IS_RMA() >>
  m_a?(ma)
  ;
  << ma = CMA >>
  i := 1
  ;
  << i = 1
    and ma = CMA >>
  iSeg := ma.seg[1]
  ;
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and AXIOM_NUM_SEG(ma : ma) >>
  nSeg := ma.seg[2]
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1]
    and AXIOM_NUM_SEG(ma : CMA) >> 
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(CheckFirstMA) and x>> A <<M(MoveForward)>> for GotFirstMA: CheckFirstMA-[x]->MoveForward{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P3>> S3 <<Q3>>
 
was reduced to:

[serial 1069]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << AXIOM_CMA_IS_RMA() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1016]

[serial 1070]: Threads::AutoBrake.i
P [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<Q4>> -> <<Q>> in sequential composition for [serial 1016]

[serial 1071]: Threads::AutoBrake.i
P [86] << AXIOM_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << ma = CMA >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]

[serial 1072]: Threads::AutoBrake.i
P [88] << ma = CMA >>
S [89]i := 1
Q [90] << i = 1
  and ma = CMA >>
What for:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1016]

[serial 1073]: Threads::AutoBrake.i
P [90] << i = 1
  and ma = CMA >>
S [91]iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
What for:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1016]

[serial 1074]: Threads::AutoBrake.i
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : CMA) >>
What for:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1016]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1069]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << AXIOM_CMA_IS_RMA() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1016]

[serial 1070]: Threads::AutoBrake.i
P [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<Q4>> -> <<Q>> in sequential composition for [serial 1016]

[serial 1071]: Threads::AutoBrake.i
P [86] << AXIOM_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << ma = CMA >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]

[serial 1072]: Threads::AutoBrake.i
P [88] << ma = CMA >>
S [89]i := 1
Q [90] << i = 1
  and ma = CMA >>
What for:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1016]

[serial 1073]: Threads::AutoBrake.i
P [90] << i = 1
  and ma = CMA >>
S [91]iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
What for:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1016]

[serial 1074]: Threads::AutoBrake.i
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : CMA) >>
What for:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1016]
done reducing composite actions
step:  47
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1069]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << AXIOM_CMA_IS_RMA() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1016]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1075]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

This proof obligation:

[serial 1073]: Threads::AutoBrake.i
P [90] << i = 1
  and ma = CMA >>
S [91]iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
What for:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1016]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1076]: Threads::AutoBrake.i
P [90] << i = 1
  and ma = CMA >>
S [91]iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

This proof obligation:

[serial 1074]: Threads::AutoBrake.i
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : CMA) >>
What for:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1016]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1077]: Threads::AutoBrake.i
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [12.8 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1070]: Threads::AutoBrake.i
P [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<Q4>> -> <<Q>> in sequential composition for [serial 1016]

[serial 1071]: Threads::AutoBrake.i
P [86] << AXIOM_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << ma = CMA >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]

[serial 1072]: Threads::AutoBrake.i
P [88] << ma = CMA >>
S [89]i := 1
Q [90] << i = 1
  and ma = CMA >>
What for:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1016]

[serial 1075]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << true >>
What for:   add user-defined axioms to postcondition

[serial 1076]: Threads::AutoBrake.i
P [90] << i = 1
  and ma = CMA >>
S [91]iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and true >>
What for:   add user-defined axioms to postcondition

[serial 1077]: Threads::AutoBrake.i
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and true >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  48
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1076]: Threads::AutoBrake.i
P [90] << i = 1
  and ma = CMA >>
S [91]iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and true >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1078]: Threads::AutoBrake.i
P [90] << i = 1
  and ma = CMA >>
S [91]iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
What for:  Law of And-Simplification:  P and true is P [serial 1076]

This Proof Obligation:

[serial 1077]: Threads::AutoBrake.i
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and true >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1079]: Threads::AutoBrake.i
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1] >>
What for:  Law of And-Simplification:  P and true is P [serial 1077]
. . . done Applying Laws [12.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1070]: Threads::AutoBrake.i
P [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<Q4>> -> <<Q>> in sequential composition for [serial 1016]

[serial 1071]: Threads::AutoBrake.i
P [86] << AXIOM_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << ma = CMA >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]

[serial 1072]: Threads::AutoBrake.i
P [88] << ma = CMA >>
S [89]i := 1
Q [90] << i = 1
  and ma = CMA >>
What for:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1016]

[serial 1075]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << true >>
What for:   add user-defined axioms to postcondition

[serial 1078]: Threads::AutoBrake.i
P [90] << i = 1
  and ma = CMA >>
S [91]iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
What for:  Law of And-Simplification:  P and true is P [serial 1076]

[serial 1079]: Threads::AutoBrake.i
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1] >>
What for:  Law of And-Simplification:  P and true is P [serial 1077]
Done applying laws
step:  49
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1070]: Threads::AutoBrake.i
P [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<Q4>> -> <<Q>> in sequential composition for [serial 1016]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Equality: (a=b) = (b=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1081]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1070]

This Proof Obligation:

[serial 1071]: Threads::AutoBrake.i
P [86] << AXIOM_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << ma = CMA >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]
Reason solved:  Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 1083]: Threads::AutoBrake.i
P [86] << AXIOM_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << CMA = ma >>
What for:    normalization of [serial 1071]

This Proof Obligation:

[serial 1072]: Threads::AutoBrake.i
P [88] << ma = CMA >>
S [89]i := 1
Q [90] << i = 1
  and ma = CMA >>
What for:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1016]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1085]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]i := 1
Q [90] << CMA = ma
  and i = 1 >>
What for:    normalization of [serial 1072]

This Proof Obligation:

[serial 1078]: Threads::AutoBrake.i
P [90] << i = 1
  and ma = CMA >>
S [91]iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
What for:  Law of And-Simplification:  P and true is P [serial 1076]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1088]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]iSeg := ma.seg[1]
Q [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
What for:    normalization of [serial 1078]

This Proof Obligation:

[serial 1079]: Threads::AutoBrake.i
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1] >>
What for:  Law of And-Simplification:  P and true is P [serial 1077]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Equality: (a=b) = (b=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1090]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1 >>
What for:    normalization of [serial 1079]
. . . done Normalizing Unsolved Proof Obligations [12.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1075]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << true >>
What for:   add user-defined axioms to postcondition

[serial 1081]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1070]

[serial 1083]: Threads::AutoBrake.i
P [86] << AXIOM_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << CMA = ma >>
What for:    normalization of [serial 1071]

[serial 1085]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]i := 1
Q [90] << CMA = ma
  and i = 1 >>
What for:    normalization of [serial 1072]

[serial 1088]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]iSeg := ma.seg[1]
Q [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
What for:    normalization of [serial 1078]

[serial 1090]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1 >>
What for:    normalization of [serial 1079]
Done Normalizing
step:  50
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  51
#Threads::AutoBrake.i
step:  52
#[serial 1075]  add user-defined axioms to postconditi
step:  53
****make-an****
Making obligation 14
Obligations:

[serial 1075]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << true >>
What for:   add user-defined axioms to postcondition
Done making obligation 14
step:  54
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1075]: Threads::AutoBrake.i
P [85] << m_a'fresh >>
S [85]->
Q [86] << true >>
What for:   add user-defined axioms to postcondition
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [12.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1081]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1070]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  55
#[serial 1081]   normalization of [serial 1070]
step:  56
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1081]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1070]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1096]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]

[serial 1097]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]

[serial 1098]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA.seg[1 + i] = nSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]

[serial 1099]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
. . . done splitting postcondition  [12.8 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1096]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]

[serial 1097]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]

[serial 1098]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA.seg[1 + i] = nSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]

[serial 1099]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
Done splitting postcondition
step:  57
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1096]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1097]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1098]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << CMA.seg[1 + i] = nSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [12.8 seconds ]
After "axioms" remaining 
Obligations:

[serial 1099]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
Done trying to apply axioms
step:  58
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1099]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57]->
Q [57] << i < CMA.num_segments >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1100]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and ( 1 < CMA.num_segments ) >>
S [57]->
Q [57] << i < CMA.num_segments >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1099]
. . . done substituting assertions' for Labels [12.8 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1100]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and ( 1 < CMA.num_segments ) >>
S [57]->
Q [57] << i < CMA.num_segments >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1099]
Done substituting Assertion labels in preconditions
step:  59
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1100]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and ( 1 < CMA.num_segments ) >>
S [57]->
Q [57] << i < CMA.num_segments >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1099]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1101]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and ( 1 < CMA.num_segments ) >>
S [57]->
Q [57] << i < ma.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1100]
. . . done guided substitution of equals  [12.8 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1101]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and ( 1 < CMA.num_segments ) >>
S [57]->
Q [57] << i < ma.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1100]
Done guided substituting an equals
step:  60
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1101]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and ( 1 < CMA.num_segments ) >>
S [57]->
Q [57] << i < ma.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1100]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1103]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57]->
Q [57] << i < ma.num_segments >>
What for:    normalization of [serial 1101]
. . . done Normalizing Unsolved Proof Obligations [12.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1103]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57]->
Q [57] << i < ma.num_segments >>
What for:    normalization of [serial 1101]
Done Normalizing
step:  61
****guided-sub-equals****
guided substitution of equals "i" . . .
equality selected for substitution:  i = 1

This Proof Obligation:

[serial 1103]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57]->
Q [57] << i < ma.num_segments >>
What for:    normalization of [serial 1101]
Reason solved:  Guided Substitution of Equals
Has substituted 
"i" with its = "( 1 )"
 to get:

[serial 1105]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57]->
Q [57] << ( 1 ) < ma.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1103]
. . . done guided substitution of equals  [12.8 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1105]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57]->
Q [57] << ( 1 ) < ma.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1103]
Done guided substituting an equals
step:  62
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1105]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57]->
Q [57] << ( 1 ) < ma.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1103]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1107]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57]->
Q [57] << 1 < ma.num_segments >>
What for:    normalization of [serial 1105]
. . . done Normalizing Unsolved Proof Obligations [12.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1107]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57]->
Q [57] << 1 < ma.num_segments >>
What for:    normalization of [serial 1105]
Done Normalizing
step:  63
****guided-sub-equals****
guided substitution of equals "ma" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1107]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57]->
Q [57] << 1 < ma.num_segments >>
What for:    normalization of [serial 1105]
Reason solved:  Guided Substitution of Equals
Has substituted 
"ma" with its = "CMA"
 to get:

[serial 1109]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57]->
Q [57] << 1 < CMA.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1107]
. . . done guided substitution of equals  [12.8 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1109]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57]->
Q [57] << 1 < CMA.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1107]
Done guided substituting an equals
step:  64
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1109]: Threads::AutoBrake.i
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57]->
Q [57] << 1 < CMA.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1107]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [12.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1083]: Threads::AutoBrake.i
P [86] << AXIOM_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << CMA = ma >>
What for:    normalization of [serial 1071]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  65
#[serial 1083]   normalization of [serial 1071]
step:  66
****atomic****
applying atomic actions . . .

This Proof Obligation:

[serial 1083]: Threads::AutoBrake.i
P [86] << AXIOM_CMA_IS_RMA() >>
S [87]m_a?(ma)
Q [88] << CMA = ma >>
What for:    normalization of [serial 1071]
Reason solved:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
Has applied when <<pre and v=M(m_a)>> -> <<post>> for <<pre>> m_a?(ma) <<post>> to get:

[serial 1110]: Threads::AutoBrake.i
P [87] << ( AXIOM_CMA_IS_RMA() )
  and ma = RMA >>
S [87]->
Q [88] << CMA = ma >>
What for:  applied port input of value <<pre and ma=M(m_a)>> -> <<post>> [serial 1083]
. . . done applying atomic actions [12.8 seconds ]
After "atomic" remaining 
Obligations:

[serial 1110]: Threads::AutoBrake.i
P [87] << ( AXIOM_CMA_IS_RMA() )
  and ma = RMA >>
S [87]->
Q [88] << CMA = ma >>
What for:  applied port input of value <<pre and ma=M(m_a)>> -> <<post>> [serial 1083]
Done reducing atomic actions
step:  67
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1110]: Threads::AutoBrake.i
P [87] << ( AXIOM_CMA_IS_RMA() )
  and ma = RMA >>
S [87]->
Q [88] << CMA = ma >>
What for:  applied port input of value <<pre and ma=M(m_a)>> -> <<post>> [serial 1083]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1111]: Threads::AutoBrake.i
P [87] << ( ( CMA = RMA ) )
  and ma = RMA >>
S [87]->
Q [88] << CMA = ma >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1110]
. . . done substituting assertions' for Labels [12.8 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1111]: Threads::AutoBrake.i
P [87] << ( ( CMA = RMA ) )
  and ma = RMA >>
S [87]->
Q [88] << CMA = ma >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1110]
Done substituting Assertion labels in preconditions
step:  68
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1111]: Threads::AutoBrake.i
P [87] << ( ( CMA = RMA ) )
  and ma = RMA >>
S [87]->
Q [88] << CMA = ma >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1110]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1113]: Threads::AutoBrake.i
P [87] << CMA = RMA
  and RMA = ma >>
S [87]->
Q [88] << CMA = ma >>
What for:    normalization of [serial 1111]
. . . done Normalizing Unsolved Proof Obligations [12.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1113]: Threads::AutoBrake.i
P [87] << CMA = RMA
  and RMA = ma >>
S [87]->
Q [88] << CMA = ma >>
What for:    normalization of [serial 1111]
Done Normalizing
step:  69
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = RMA

This Proof Obligation:

[serial 1113]: Threads::AutoBrake.i
P [87] << CMA = RMA
  and RMA = ma >>
S [87]->
Q [88] << CMA = ma >>
What for:    normalization of [serial 1111]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "RMA"
 to get:

[serial 1115]: Threads::AutoBrake.i
P [87] << CMA = RMA
  and RMA = ma >>
S [87]->
Q [88] << RMA = ma >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "RMA" in its postcondition [serial 1113]
. . . done guided substitution of equals  [12.8 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1115]: Threads::AutoBrake.i
P [87] << CMA = RMA
  and RMA = ma >>
S [87]->
Q [88] << RMA = ma >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "RMA" in its postcondition [serial 1113]
Done guided substituting an equals
step:  70
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1115]: Threads::AutoBrake.i
P [87] << CMA = RMA
  and RMA = ma >>
S [87]->
Q [88] << RMA = ma >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "RMA" in its postcondition [serial 1113]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [12.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1085]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]i := 1
Q [90] << CMA = ma
  and i = 1 >>
What for:    normalization of [serial 1072]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  71
#[serial 1085]   normalization of [serial 1072]
step:  72
****atomic****
applying atomic actions . . .
solving assignment on line 89
replacing "i" with "1"
makes:  << CMA = ma
  and ( 1 ) = 1 >>

This Proof Obligation:

[serial 1085]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]i := 1
Q [90] << CMA = ma
  and i = 1 >>
What for:    normalization of [serial 1072]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1116]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma
  and ( 1 ) = 1 >>
What for:  applied wp for assignment [serial 1085]
. . . done applying atomic actions [12.8 seconds ]
After "atomic" remaining 
Obligations:

[serial 1116]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma
  and ( 1 ) = 1 >>
What for:  applied wp for assignment [serial 1085]
Done reducing atomic actions
step:  73
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1116]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma
  and ( 1 ) = 1 >>
What for:  applied wp for assignment [serial 1085]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1118]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma
  and 1 = 1 >>
What for:    normalization of [serial 1116]
. . . done Normalizing Unsolved Proof Obligations [12.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1118]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma
  and 1 = 1 >>
What for:    normalization of [serial 1116]
Done Normalizing
step:  74
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1118]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma
  and 1 = 1 >>
What for:    normalization of [serial 1116]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 1120]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma
  and true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1118]

This Proof Obligation:

[serial 1120]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma
  and true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1118]
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1121]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << ( CMA = ma ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1120]
. . . done Applying Laws [12.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1121]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << ( CMA = ma ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1120]
Done applying laws
step:  75
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1121]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << ( CMA = ma ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1120]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1123]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma >>
What for:    normalization of [serial 1121]
. . . done Normalizing Unsolved Proof Obligations [12.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1123]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma >>
What for:    normalization of [serial 1121]
Done Normalizing
step:  76
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1123]: Threads::AutoBrake.i
P [88] << CMA = ma >>
S [89]->
Q [90] << CMA = ma >>
What for:    normalization of [serial 1121]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [12.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1088]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]iSeg := ma.seg[1]
Q [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
What for:    normalization of [serial 1078]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  77
#[serial 1088]   normalization of [serial 1078]
step:  78
****atomic****
applying atomic actions . . .
solving assignment on line 91
replacing "iSeg" with "
^{ma 
 ^{. 
  ^{seg 
   ^{[ 
    ^{QUANTITY 1}}}}}"
makes:  << CMA = ma
  and CMA.seg[i] = ma.seg[1]
  and i = 1 >>

This Proof Obligation:

[serial 1088]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]iSeg := ma.seg[1]
Q [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
What for:    normalization of [serial 1078]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1125]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << CMA = ma
  and CMA.seg[i] = ma.seg[1]
  and i = 1 >>
What for:  applied wp for assignment [serial 1088]
. . . done applying atomic actions [12.8 seconds ]
After "atomic" remaining 
Obligations:

[serial 1125]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << CMA = ma
  and CMA.seg[i] = ma.seg[1]
  and i = 1 >>
What for:  applied wp for assignment [serial 1088]
Done reducing atomic actions
step:  79
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1125]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << CMA = ma
  and CMA.seg[i] = ma.seg[1]
  and i = 1 >>
What for:  applied wp for assignment [serial 1088]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1126]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]

[serial 1127]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << CMA.seg[i] = ma.seg[1] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]

[serial 1128]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << i = 1 >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
. . . done splitting postcondition  [12.8 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1126]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]

[serial 1127]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << CMA.seg[i] = ma.seg[1] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]

[serial 1128]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << i = 1 >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Done splitting postcondition
step:  80
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1126]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1128]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << i = 1 >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [12.8 seconds ]
After "axioms" remaining 
Obligations:

[serial 1127]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << CMA.seg[i] = ma.seg[1] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Done trying to apply axioms
step:  81
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1127]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << CMA.seg[i] = ma.seg[1] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1129]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << ma.seg[i] = ma.seg[1] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1127]
. . . done guided substitution of equals  [12.8 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1129]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << ma.seg[i] = ma.seg[1] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1127]
Done guided substituting an equals
step:  82
****guided-sub-equals****
guided substitution of equals "i" . . .
equality selected for substitution:  i = 1

This Proof Obligation:

[serial 1129]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << ma.seg[i] = ma.seg[1] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1127]
Reason solved:  Guided Substitution of Equals
Has substituted 
"i" with its = "( 1 )"
 to get:

[serial 1130]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << ma.seg[( 1 )] = ma.seg[1] >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1129]
. . . done guided substitution of equals  [12.8 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1130]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << ma.seg[( 1 )] = ma.seg[1] >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1129]
Done guided substituting an equals
step:  83
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1130]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << ma.seg[( 1 )] = ma.seg[1] >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1129]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1132]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << ma.seg[1] = ma.seg[1] >>
What for:    normalization of [serial 1130]
. . . done Normalizing Unsolved Proof Obligations [12.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1132]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << ma.seg[1] = ma.seg[1] >>
What for:    normalization of [serial 1130]
Done Normalizing
step:  84
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1132]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << ma.seg[1] = ma.seg[1] >>
What for:    normalization of [serial 1130]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 1134]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1132]
. . . done Applying Laws [12.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1134]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1132]
Done applying laws
step:  85
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1134]: Threads::AutoBrake.i
P [90] << CMA = ma
  and i = 1 >>
S [91]->
Q [92] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1132]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [12.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1090]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1 >>
What for:    normalization of [serial 1079]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  86
#[serial 1090]   normalization of [serial 1079]
step:  87
****guided-sub-equals****
guided substitution of equals "i" . . .
equality selected for substitution:  i = 1

This Proof Obligation:

[serial 1090]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1 >>
What for:    normalization of [serial 1079]
Reason solved:  Guided Substitution of Equals
Has substituted 
"i" with its = "( 1 )"
 to get:

[serial 1135]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[( 1 )] = iSeg
  and CMA.seg[1 + ( 1 )] = nSeg
  and ( 1 ) = 1 >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1090]
. . . done guided substitution of equals  [12.8 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1135]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[( 1 )] = iSeg
  and CMA.seg[1 + ( 1 )] = nSeg
  and ( 1 ) = 1 >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1090]
Done guided substituting an equals
step:  88
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1135]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[( 1 )] = iSeg
  and CMA.seg[1 + ( 1 )] = nSeg
  and ( 1 ) = 1 >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1090]
Reasons solved:  
   Literal Arithmetic
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1137]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[1] = iSeg
  and CMA.seg[2] = nSeg
  and 1 = 1 >>
What for:    normalization of [serial 1135]
. . . done Normalizing Unsolved Proof Obligations [12.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1137]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[1] = iSeg
  and CMA.seg[2] = nSeg
  and 1 = 1 >>
What for:    normalization of [serial 1135]
Done Normalizing
step:  89
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1137]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[1] = iSeg
  and CMA.seg[2] = nSeg
  and 1 = 1 >>
What for:    normalization of [serial 1135]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1139]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = nSeg
  and 1 = 1 >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1137]
. . . done guided substitution of equals  [12.8 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1139]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = nSeg
  and 1 = 1 >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1137]
Done guided substituting an equals
step:  90
****atomic****
applying atomic actions . . .
solving assignment on line 94
replacing "nSeg" with "
^{ma 
 ^{. 
  ^{seg 
   ^{[ 
    ^{QUANTITY 2}}}}}"
makes:  << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = ma.seg[2]
  and 1 = 1 >>

This Proof Obligation:

[serial 1139]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]nSeg := ma.seg[2]
Q [95] << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = nSeg
  and 1 = 1 >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1137]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1140]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = ma.seg[2]
  and 1 = 1 >>
What for:  applied wp for assignment [serial 1139]
. . . done applying atomic actions [12.8 seconds ]
After "atomic" remaining 
Obligations:

[serial 1140]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = ma.seg[2]
  and 1 = 1 >>
What for:  applied wp for assignment [serial 1139]
Done reducing atomic actions
step:  91
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1140]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = ma.seg[2]
  and 1 = 1 >>
What for:  applied wp for assignment [serial 1139]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 1141]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << true
  and ma.seg[1] = iSeg
  and true
  and true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1140]

This Proof Obligation:

[serial 1141]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << true
  and ma.seg[1] = iSeg
  and true
  and true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1140]
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1142]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << ( ma.seg[1] = iSeg ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1141]
. . . done Applying Laws [12.9 seconds ]
After "laws" remaining 
Obligations:

[serial 1142]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << ( ma.seg[1] = iSeg ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1141]
Done applying laws
step:  92
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1142]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << ( ma.seg[1] = iSeg ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1141]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1144]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << iSeg = ma.seg[1] >>
What for:    normalization of [serial 1142]
. . . done Normalizing Unsolved Proof Obligations [12.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1144]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << iSeg = ma.seg[1] >>
What for:    normalization of [serial 1142]
Done Normalizing
step:  93
****guided-sub-equals****
guided substitution of equals "ma" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1144]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << iSeg = ma.seg[1] >>
What for:    normalization of [serial 1142]
Reason solved:  Guided Substitution of Equals
Has substituted 
"ma" with its = "CMA"
 to get:

[serial 1146]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << iSeg = CMA.seg[1] >>
What for:  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1144]
. . . done guided substitution of equals  [12.9 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1146]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << iSeg = CMA.seg[1] >>
What for:  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1144]
Done guided substituting an equals
step:  94
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1146]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << iSeg = CMA.seg[1] >>
What for:  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1144]
Reason solved:  Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 1148]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << CMA.seg[1] = iSeg >>
What for:    normalization of [serial 1146]
. . . done Normalizing Unsolved Proof Obligations [12.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1148]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << CMA.seg[1] = iSeg >>
What for:    normalization of [serial 1146]
Done Normalizing
step:  95
****guided-sub-equals****
guided substitution of equals "1" . . .
equality selected for substitution:  i = 1

This Proof Obligation:

[serial 1148]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << CMA.seg[1] = iSeg >>
What for:    normalization of [serial 1146]
Reason solved:  Guided Substitution of Equals
Has substituted 
"1" with its = "i"
 to get:

[serial 1150]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << CMA.seg[i] = iSeg >>
What for:  Guided Substitution of Equals 
 replacing "1" with its = "i" in its postcondition [serial 1148]
. . . done guided substitution of equals  [12.9 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1150]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << CMA.seg[i] = iSeg >>
What for:  Guided Substitution of Equals 
 replacing "1" with its = "i" in its postcondition [serial 1148]
Done guided substituting an equals
step:  96
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1150]: Threads::AutoBrake.i
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94]->
Q [95] << CMA.seg[i] = iSeg >>
What for:  Guided Substitution of Equals 
 replacing "1" with its = "i" in its postcondition [serial 1148]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [12.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1017]: Threads::AutoBrake.i
P [100] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [101]<< i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(MoveForward) and x>> A <<M(CheckMoveForward)>> for CheckSpeed: MoveForward-[x]->CheckMoveForward{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  97
#[serial 1017]  <<M(MoveForward) and x>> A <<M(CheckMoveForward)>> for CheckSpeedMoveForward-[x]->CheckMoveForward{A};
step:  98
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1017]: Threads::AutoBrake.i
P [100] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [101]<< i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(MoveForward) and x>> A <<M(CheckMoveForward)>> for CheckSpeed: MoveForward-[x]->CheckMoveForward{A};
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1151]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [101]<< i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1017]
. . . done Applying Laws [12.9 seconds ]
After "laws" remaining 
Obligations:

[serial 1151]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [101]<< i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1017]
Done applying laws
step:  99
****reduce****

[serial 1152]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1151]

[serial 1153]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [105]  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1151]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1152]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1151]

[serial 1153]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [105]  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1151]
done reducing composite actions
step:  100
****reduce****
This proof obligation:

[serial 1153]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [105]  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1151]
Reason solved:  Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>>
as <<P>> if (B1)-><<P1>>S1<<Q1>> [] (B2)-><<P2>>S2<<Q2>> [] . . . [] (Bn)-><<Pn>>Sn<<Qn>> fi <<Q>> 

was reduced to:

[serial 1154]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [105]->
Q [105] << ( v >= iSeg.v_e )
   or ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1153]

[serial 1155]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B0>> S0 <<Q>> in alternative for [serial 1153]

[serial 1156]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B1>> S1 <<Q>> in alternative for [serial 1153]

[serial 1157]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B2>> S2 <<Q>> in alternative for [serial 1153]

[serial 1158]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B3>> S3 <<Q>> in alternative for [serial 1153]

[serial 1159]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [124]  {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B4>> S4 <<Q>> in alternative for [serial 1153]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1152]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1151]

[serial 1154]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [105]->
Q [105] << ( v >= iSeg.v_e )
   or ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1153]

[serial 1155]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B0>> S0 <<Q>> in alternative for [serial 1153]

[serial 1156]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B1>> S1 <<Q>> in alternative for [serial 1153]

[serial 1157]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B2>> S2 <<Q>> in alternative for [serial 1153]

[serial 1158]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B3>> S3 <<Q>> in alternative for [serial 1153]

[serial 1159]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [124]  {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B4>> S4 <<Q>> in alternative for [serial 1153]
done reducing composite actions
step:  101
****reduce****
Reducing Existential Quantification of:

[serial 1155]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B0>> S0 <<Q>> in alternative for [serial 1153]
Reason solved:  Introduction of Existential Quantification
as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1160]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1155]
Reducing Existential Quantification of:

[serial 1156]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B1>> S1 <<Q>> in alternative for [serial 1153]
Reason solved:  Introduction of Existential Quantification
as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1161]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1156]
Reducing Existential Quantification of:

[serial 1157]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B2>> S2 <<Q>> in alternative for [serial 1153]
Reason solved:  Introduction of Existential Quantification
as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1162]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1157]
Reducing Existential Quantification of:

[serial 1158]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B3>> S3 <<Q>> in alternative for [serial 1153]
Reason solved:  Introduction of Existential Quantification
as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1163]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1158]
Reducing Existential Quantification of:

[serial 1159]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [124]  {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:    <<P and B4>> S4 <<Q>> in alternative for [serial 1153]
Reason solved:  Introduction of Existential Quantification
as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1164]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [124]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1159]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1152]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1151]

[serial 1154]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [105]->
Q [105] << ( v >= iSeg.v_e )
   or ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1153]

[serial 1160]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1155]

[serial 1161]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1156]

[serial 1162]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1157]

[serial 1163]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1158]

[serial 1164]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [124]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1159]
done reducing composite actions
step:  102
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  103
#Threads::AutoBrake.i
step:  104
#[serial 1152] as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 115
step:  105
****make-an****
Making obligation 21
Obligations:

[serial 1152]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1151]
Done making obligation 21
step:  106
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1152]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1151]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1165]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and true
  and true
  and true
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [12.9 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1165]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and true
  and true
  and true
  and true >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  107
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1165]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and true
  and true
  and true
  and true >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1166]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Law of And-Simplification:  P and true is P [serial 1165]
. . . done Applying Laws [12.9 seconds ]
After "laws" remaining 
Obligations:

[serial 1166]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Law of And-Simplification:  P and true is P [serial 1165]
Done applying laws
step:  108
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1166]: Threads::AutoBrake.i
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100]->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Law of And-Simplification:  P and true is P [serial 1165]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [12.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1154]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [105]->
Q [105] << ( v >= iSeg.v_e )
   or ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1153]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  109
#[serial 1154]   <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1153]
step:  110
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1154]: Threads::AutoBrake.i
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [105]->
Q [105] << ( v >= iSeg.v_e )
   or ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1153]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1168]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1154]
. . . done Normalizing Unsolved Proof Obligations [12.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1168]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1154]
Done Normalizing
step:  111
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1168]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1154]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1170]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( ( not ( v < iSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1168]
. . . Substituting <= with not < [12.9 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1170]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( ( not ( v < iSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1168]
Done replacing a<=b with (not b<a)
step:  112
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1170]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( ( not ( v < iSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1168]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1172]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v < iSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1170]
. . . done Normalizing Unsolved Proof Obligations [12.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1172]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v < iSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1170]
Done Normalizing
step:  113
****conjunctive-normal-form****
Transforming into Conjunctive Normal Form . . .

This Proof Obligation:

[serial 1172]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v < iSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1170]
Reason solved:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
Has applied Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into conjunctive normal form to get:

[serial 1174]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1172]
. . . done putting into conjunctive normal form [13.0 seconds ]
After "conjunctive normal form" remaining 
Obligations:

[serial 1174]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1172]
Done making conjunctive normal forms.
step:  114
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1174]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1172]
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 1175]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1174]

This Proof Obligation:

[serial 1175]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1174]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1176]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1175]

This Proof Obligation:

[serial 1176]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1175]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1177]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1176]

This Proof Obligation:

[serial 1177]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1176]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1178]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1177]

This Proof Obligation:

[serial 1178]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1177]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1179]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1178]

This Proof Obligation:

[serial 1179]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1178]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1180]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1179]
. . . done Applying Laws [13.0 seconds ]
After "laws" remaining 
Obligations:

[serial 1180]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1179]
Done applying laws
step:  115
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1180]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1179]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1182]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << true >>
What for:    normalization of [serial 1180]
. . . done Normalizing Unsolved Proof Obligations [13.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1182]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << true >>
What for:    normalization of [serial 1180]
Done Normalizing
step:  116
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1182]: Threads::AutoBrake.i
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105]->
Q [105] << true >>
What for:    normalization of [serial 1180]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [13.0 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1160]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1155]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  117
#[serial 1160] <<P>> T <<Q>> in existential lattice quantification for [serial 1155]
step:  118
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1160]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1155]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1184]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( v >= iSeg.v_e ) >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1160]
. . . done Applying Laws [13.0 seconds ]
After "laws" remaining 
Obligations:

[serial 1184]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( v >= iSeg.v_e ) >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1160]
Done applying laws
step:  119
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1184]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( v >= iSeg.v_e ) >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1160]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1186]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1184]
. . . done Normalizing Unsolved Proof Obligations [13.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1186]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1184]
Done Normalizing
step:  120
****reduce****

Reducing Concurrent Computation of:

[serial 1186]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1184]
Reason solved:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1188]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]eb!(true)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1186]

[serial 1189]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1186]

[serial 1190]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]ca!(0 mpss)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1186]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1188]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]eb!(true)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1186]

[serial 1189]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1186]

[serial 1190]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]ca!(0 mpss)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1186]
done reducing composite actions
step:  121
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
newPortAssertion=EB()

This Proof Obligation:

[serial 1188]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]eb!(true)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1186]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(eb)[eb|true]>>  for <<pre>> eb!(true) <<post>> to get:

[serial 1191]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188]

The Same Proof Obligation:
Has applied <<pre and (EB())@now>> -> <<post>> for  <<pre>> eb!(true) <<post>> to get:

[serial 1192]: Threads::AutoBrake.i
P [107] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( EB() )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1188]
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=not ( SB()
  and not EB() )

This Proof Obligation:

[serial 1189]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1186]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(sb)[sb|false]>>  for <<pre>> sb!(false) <<post>> to get:

[serial 1193]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [107] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1189]

The Same Proof Obligation:
Has applied <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> for  <<pre>> sb!(false) <<post>> to get:

[serial 1194]: Threads::AutoBrake.i
P [107] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( not ( SB()
  and not EB() ) )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1189]
Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB()
                                             or EB() ))-> 0 mpss, (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB()
      or EB() ))-> 0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1190]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]ca!(0 mpss)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1186]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied <<pre and (ca=0 mpss)@now>> -> <<post>> for  <<pre>> ca!(QUANTITY) <<post>> to get:

[serial 1195]: Threads::AutoBrake.i
P [107] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( ca = ( 0 mpss ) )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1190]
Has applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>>where (( SB()
   or EB() ))-> 0 mpss for ca!(0 mpss) to get:

[serial 1196]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1190]
. . . done applying atomic actions [13.0 seconds ]
After "atomic" remaining 
Obligations:

[serial 1191]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188]

[serial 1192]: Threads::AutoBrake.i
P [107] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( EB() )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1188]

[serial 1193]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [107] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1189]

[serial 1194]: Threads::AutoBrake.i
P [107] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( not ( SB()
  and not EB() ) )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1189]

[serial 1195]: Threads::AutoBrake.i
P [107] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( ca = ( 0 mpss ) )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1190]

[serial 1196]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1190]
Done reducing atomic actions
step:  122
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1192]: Threads::AutoBrake.i
P [107] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( EB() )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1188]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1197]: Threads::AutoBrake.i
P [107] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( EB() )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1192]

This Proof Obligation:

[serial 1194]: Threads::AutoBrake.i
P [107] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( not ( SB()
  and not EB() ) )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1189]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1198]: Threads::AutoBrake.i
P [107] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( not ( SB()
  and not EB() ) )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1194]

This Proof Obligation:

[serial 1195]: Threads::AutoBrake.i
P [107] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( ca = ( 0 mpss ) )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1190]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1199]: Threads::AutoBrake.i
P [107] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( ca = ( 0 mpss ) )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1195]
. . . done Applying Laws [13.0 seconds ]
After "laws" remaining 
Obligations:

[serial 1191]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188]

[serial 1193]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [107] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1189]

[serial 1196]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1190]

[serial 1197]: Threads::AutoBrake.i
P [107] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( EB() )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1192]

[serial 1198]: Threads::AutoBrake.i
P [107] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( not ( SB()
  and not EB() ) )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1194]

[serial 1199]: Threads::AutoBrake.i
P [107] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( ca = ( 0 mpss ) )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1195]
Done applying laws
step:  123
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1197]: Threads::AutoBrake.i
P [107] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( EB() )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1192]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1198]: Threads::AutoBrake.i
P [107] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( not ( SB()
  and not EB() ) )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1194]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1199]: Threads::AutoBrake.i
P [107] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( ca = ( 0 mpss ) )@now >>
S [107]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1195]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [13.0 seconds ]
After "axioms" remaining 
Obligations:

[serial 1191]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188]

[serial 1193]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [107] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1189]

[serial 1196]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1190]
Done trying to apply axioms
step:  124
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1193]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [107] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1189]
Reason solved:  DeMorgan's Law: not (A and B) = (not A) or (not B)
Has applied DeMorgan's Law: not (A and B) = (not A) or (not B)  to get:

[serial 1200]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [107] << ( not ( SB() )
   or not ( not EB() ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1193]
. . . done applying DeMorgan's Law  [13.0 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1191]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188]

[serial 1196]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1190]

[serial 1200]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [107] << ( not ( SB() )
   or not ( not EB() ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1193]
step:  125
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1196]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1190]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1203]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1196]

This Proof Obligation:

[serial 1200]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [107] << ( not ( SB() )
   or not ( not EB() ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1193]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1205]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [107] << EB()
   or not SB() >>
What for:    normalization of [serial 1200]
. . . done Normalizing Unsolved Proof Obligations [13.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1191]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188]

[serial 1203]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1196]

[serial 1205]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [107] << EB()
   or not SB() >>
What for:    normalization of [serial 1200]
Done Normalizing
step:  126
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1191]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1208]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [107]->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1191]

This Proof Obligation:

[serial 1203]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1196]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1209]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [107]->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1203]

This Proof Obligation:

[serial 1205]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]->
Q [107] << EB()
   or not SB() >>
What for:    normalization of [serial 1200]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1210]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [107]->
Q [107] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1205]
. . . done substituting assertions' for Labels [13.0 seconds ]
After "substitute" remaining 
Obligations:

[serial 1208]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [107]->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1191]

[serial 1209]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [107]->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1203]

[serial 1210]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [107]->
Q [107] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1205]
Done substituting Assertion labels.
step:  127
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1208]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [107]->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1191]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1212]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1208]

This Proof Obligation:

[serial 1209]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [107]->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1203]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1214]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1209]

This Proof Obligation:

[serial 1210]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [107]->
Q [107] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1205]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1216]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [107] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1210]
. . . done Normalizing Unsolved Proof Obligations [13.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1212]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1208]

[serial 1214]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1209]

[serial 1216]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [107] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1210]
Done Normalizing
step:  128
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1214]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1209]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1220]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
What for:  Associativity: (b.c).a = a.b.c [serial 1214]

This Proof Obligation:

[serial 1216]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [107] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1210]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1221]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [107] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1216]
. . . done Applying Laws [13.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1212]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1208]

[serial 1220]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
What for:  Associativity: (b.c).a = a.b.c [serial 1214]

[serial 1221]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [107] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1216]
Done applying laws
step:  129
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 iSeg.v_e <= v


This Proof Obligation:

[serial 1212]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1208]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 iSeg.v_e <= v


This Proof Obligation:

[serial 1220]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
What for:  Associativity: (b.c).a = a.b.c [serial 1214]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 iSeg.v_e <= v


This Proof Obligation:

[serial 1221]: Threads::AutoBrake.i
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107]->
Q [107] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1216]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [13.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1161]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1156]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  130
#[serial 1161] <<P>> T <<Q>> in existential lattice quantification for [serial 1156]
step:  131
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1161]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1156]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1222]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1161]
. . . done Applying Laws [13.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1222]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1161]
Done applying laws
step:  132
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1222]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1161]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1224]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1222]
. . . done Normalizing Unsolved Proof Obligations [13.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1224]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1222]
Done Normalizing
step:  133
****reduce****

Reducing Concurrent Computation of:

[serial 1224]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1222]
Reason solved:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1226]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]eb!(true)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1224]

[serial 1227]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1224]

[serial 1228]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]ca!(0 mpss)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1224]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1226]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]eb!(true)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1224]

[serial 1227]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1224]

[serial 1228]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]ca!(0 mpss)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1224]
done reducing composite actions
step:  134
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
newPortAssertion=EB()

This Proof Obligation:

[serial 1226]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]eb!(true)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1224]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(eb)[eb|true]>>  for <<pre>> eb!(true) <<post>> to get:

[serial 1229]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1226]

The Same Proof Obligation:
Has applied <<pre and (EB())@now>> -> <<post>> for  <<pre>> eb!(true) <<post>> to get:

[serial 1230]: Threads::AutoBrake.i
P [110] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( EB() )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1226]
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=not ( SB()
  and not EB() )

This Proof Obligation:

[serial 1227]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1224]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(sb)[sb|false]>>  for <<pre>> sb!(false) <<post>> to get:

[serial 1231]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [110] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1227]

The Same Proof Obligation:
Has applied <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> for  <<pre>> sb!(false) <<post>> to get:

[serial 1232]: Threads::AutoBrake.i
P [110] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( not ( SB()
  and not EB() ) )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1227]
Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB()
                                             or EB() ))-> 0 mpss, (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB()
      or EB() ))-> 0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1228]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]ca!(0 mpss)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1224]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied <<pre and (ca=0 mpss)@now>> -> <<post>> for  <<pre>> ca!(QUANTITY) <<post>> to get:

[serial 1233]: Threads::AutoBrake.i
P [110] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( ca = ( 0 mpss ) )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1228]
Has applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>>where (( SB()
   or EB() ))-> 0 mpss for ca!(0 mpss) to get:

[serial 1234]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1228]
. . . done applying atomic actions [13.1 seconds ]
After "atomic" remaining 
Obligations:

[serial 1229]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1226]

[serial 1230]: Threads::AutoBrake.i
P [110] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( EB() )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1226]

[serial 1231]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [110] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1227]

[serial 1232]: Threads::AutoBrake.i
P [110] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( not ( SB()
  and not EB() ) )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1227]

[serial 1233]: Threads::AutoBrake.i
P [110] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( ca = ( 0 mpss ) )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1228]

[serial 1234]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1228]
Done reducing atomic actions
step:  135
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1230]: Threads::AutoBrake.i
P [110] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( EB() )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1226]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1235]: Threads::AutoBrake.i
P [110] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( EB() )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1230]

This Proof Obligation:

[serial 1232]: Threads::AutoBrake.i
P [110] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( not ( SB()
  and not EB() ) )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1227]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1236]: Threads::AutoBrake.i
P [110] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( not ( SB()
  and not EB() ) )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1232]

This Proof Obligation:

[serial 1233]: Threads::AutoBrake.i
P [110] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( ca = ( 0 mpss ) )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1228]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1237]: Threads::AutoBrake.i
P [110] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( ca = ( 0 mpss ) )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1233]
. . . done Applying Laws [13.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1229]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1226]

[serial 1231]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [110] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1227]

[serial 1234]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1228]

[serial 1235]: Threads::AutoBrake.i
P [110] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( EB() )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1230]

[serial 1236]: Threads::AutoBrake.i
P [110] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( not ( SB()
  and not EB() ) )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1232]

[serial 1237]: Threads::AutoBrake.i
P [110] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( ca = ( 0 mpss ) )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1233]
Done applying laws
step:  136
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1235]: Threads::AutoBrake.i
P [110] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( EB() )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1230]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1236]: Threads::AutoBrake.i
P [110] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( not ( SB()
  and not EB() ) )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1232]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1237]: Threads::AutoBrake.i
P [110] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( ca = ( 0 mpss ) )@now >>
S [110]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1233]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [13.1 seconds ]
After "axioms" remaining 
Obligations:

[serial 1229]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1226]

[serial 1231]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [110] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1227]

[serial 1234]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1228]
Done trying to apply axioms
step:  137
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1229]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1226]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1238]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [110]->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1229]

This Proof Obligation:

[serial 1231]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [110] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1227]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1239]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [110]->
Q [110] << not ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1231]

This Proof Obligation:

[serial 1234]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1228]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1240]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [110]->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1234]
. . . done substituting assertions' for Labels [13.1 seconds ]
After "substitute" remaining 
Obligations:

[serial 1238]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [110]->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1229]

[serial 1239]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [110]->
Q [110] << not ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1231]

[serial 1240]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [110]->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1234]
Done substituting Assertion labels.
step:  138
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1238]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [110]->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1229]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1242]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1238]

This Proof Obligation:

[serial 1239]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [110]->
Q [110] << not ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1231]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1244]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << not ( not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:    normalization of [serial 1239]

This Proof Obligation:

[serial 1240]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [110]->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1234]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1246]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1240]
. . . done Normalizing Unsolved Proof Obligations [13.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1242]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1238]

[serial 1244]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << not ( not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:    normalization of [serial 1239]

[serial 1246]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1240]
Done Normalizing
step:  139
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v


This Proof Obligation:

[serial 1242]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1238]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [13.1 seconds ]
After "axioms" remaining 
Obligations:

[serial 1244]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << not ( not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:    normalization of [serial 1239]

[serial 1246]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1240]
Done trying to apply axioms
step:  140
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1244]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << not ( not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:    normalization of [serial 1239]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1250]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << ( not ( ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or not ( ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1244]
. . . done applying DeMorgan's Law  [13.1 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1246]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1240]

[serial 1250]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << ( not ( ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or not ( ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1244]
step:  141
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1250]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << ( not ( ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or not ( ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1244]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1253]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << not ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) )
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1250]
. . . done Normalizing Unsolved Proof Obligations [13.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1246]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1240]

[serial 1253]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << not ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) )
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1250]
Done Normalizing
step:  142
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1253]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << not ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) )
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1250]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1255]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << ( not ( not ( iSeg.v_e <= v ) )
   or not ( not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1253]
. . . done applying DeMorgan's Law  [13.1 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1246]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1240]

[serial 1255]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << ( not ( not ( iSeg.v_e <= v ) )
   or not ( not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1253]
step:  143
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1255]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << ( not ( not ( iSeg.v_e <= v ) )
   or not ( not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1253]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1258]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1255]
. . . done Normalizing Unsolved Proof Obligations [13.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1246]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1240]

[serial 1258]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1255]
Done Normalizing
step:  144
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1246]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1240]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1260]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
What for:  Associativity: (b.c).a = a.b.c [serial 1246]

This Proof Obligation:

[serial 1258]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1255]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1261]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1258]
. . . done Applying Laws [13.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1260]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
What for:  Associativity: (b.c).a = a.b.c [serial 1246]

[serial 1261]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1258]
Done applying laws
step:  145
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v


This Proof Obligation:

[serial 1260]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
What for:  Associativity: (b.c).a = a.b.c [serial 1246]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v


This Proof Obligation:

[serial 1261]: Threads::AutoBrake.i
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110]->
Q [110] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1258]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [13.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1162]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1157]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  146
#[serial 1162] <<P>> T <<Q>> in existential lattice quantification for [serial 1157]
step:  147
****reduce****

Reducing Concurrent Computation of:

[serial 1162]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1157]
Reason solved:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1262]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]sb!(true)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1162]

[serial 1263]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]eb!(false)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1162]

[serial 1264]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]ca!(0 mpss)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1162]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1262]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]sb!(true)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1162]

[serial 1263]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]eb!(false)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1162]

[serial 1264]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]ca!(0 mpss)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1162]
done reducing composite actions
step:  148
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=SB()
  and not EB()

This Proof Obligation:

[serial 1262]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]sb!(true)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1162]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(sb)[sb|true]>>  for <<pre>> sb!(true) <<post>> to get:

[serial 1265]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1262]

The Same Proof Obligation:
Has applied <<pre and (SB()
  and not EB())@now>> -> <<post>> for  <<pre>> sb!(true) <<post>> to get:

[serial 1266]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1262]
Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
newPortAssertion=not EB()

This Proof Obligation:

[serial 1263]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]eb!(false)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1162]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(eb)[eb|false]>>  for <<pre>> eb!(false) <<post>> to get:

[serial 1267]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]->
Q [114] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1263]

The Same Proof Obligation:
Has applied <<pre and (not EB())@now>> -> <<post>> for  <<pre>> eb!(false) <<post>> to get:

[serial 1268]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1263]
Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB()
                                             or EB() ))-> 0 mpss, (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB()
      or EB() ))-> 0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1264]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]ca!(0 mpss)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1162]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied <<pre and (ca=0 mpss)@now>> -> <<post>> for  <<pre>> ca!(QUANTITY) <<post>> to get:

[serial 1269]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( ca = ( 0 mpss ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1264]
Has applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>>where (( SB()
   or EB() ))-> 0 mpss for ca!(0 mpss) to get:

[serial 1270]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1264]
. . . done applying atomic actions [13.2 seconds ]
After "atomic" remaining 
Obligations:

[serial 1265]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1262]

[serial 1266]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1262]

[serial 1267]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]->
Q [114] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1263]

[serial 1268]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1263]

[serial 1269]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( ca = ( 0 mpss ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1264]

[serial 1270]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1264]
Done reducing atomic actions
step:  149
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1265]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1262]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1271]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [114]->
Q [12] << SB()
  and not EB() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1265]

This Proof Obligation:

[serial 1266]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1262]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1272]: Threads::AutoBrake.i
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1266]

This Proof Obligation:

[serial 1267]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]->
Q [114] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1263]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1273]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [114]->
Q [114] << not EB() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1267]

This Proof Obligation:

[serial 1268]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1263]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1274]: Threads::AutoBrake.i
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1268]

This Proof Obligation:

[serial 1269]: Threads::AutoBrake.i
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( ca = ( 0 mpss ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1264]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1275]: Threads::AutoBrake.i
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
  and ( ca = ( 0 mpss ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1269]

This Proof Obligation:

[serial 1270]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1264]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1276]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [114]->
Q [33] << ( SB()
   or EB() ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1270]

This Proof Obligation:

[serial 1272]: Threads::AutoBrake.i
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1266]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1277]: Threads::AutoBrake.i
P [114] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1272]

This Proof Obligation:

[serial 1274]: Threads::AutoBrake.i
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1268]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1278]: Threads::AutoBrake.i
P [114] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1274]

This Proof Obligation:

[serial 1275]: Threads::AutoBrake.i
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
  and ( ca = ( 0 mpss ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1269]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1279]: Threads::AutoBrake.i
P [114] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( ca = ( 0 mpss ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1275]
. . . done Applying Laws [13.2 seconds ]
After "laws" remaining 
Obligations:

[serial 1271]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [114]->
Q [12] << SB()
  and not EB() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1265]

[serial 1273]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [114]->
Q [114] << not EB() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1267]

[serial 1276]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [114]->
Q [33] << ( SB()
   or EB() ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1270]

[serial 1277]: Threads::AutoBrake.i
P [114] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1272]

[serial 1278]: Threads::AutoBrake.i
P [114] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1274]

[serial 1279]: Threads::AutoBrake.i
P [114] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( ca = ( 0 mpss ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1275]
Done applying laws
step:  150
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1271]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [114]->
Q [12] << SB()
  and not EB() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1265]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1281]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << SB()
  and not EB() >>
What for:    normalization of [serial 1271]

This Proof Obligation:

[serial 1273]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [114]->
Q [114] << not EB() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1267]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1283]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not EB() >>
What for:    normalization of [serial 1273]

This Proof Obligation:

[serial 1276]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [114]->
Q [33] << ( SB()
   or EB() ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1270]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1285]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1276]

This Proof Obligation:

[serial 1277]: Threads::AutoBrake.i
P [114] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( SB()
  and not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1272]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1287]: Threads::AutoBrake.i
P [114] << iSeg.v_n <= v
  and ( SB()
  and not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1277]

This Proof Obligation:

[serial 1278]: Threads::AutoBrake.i
P [114] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( not EB() )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1274]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1289]: Threads::AutoBrake.i
P [114] << iSeg.v_n <= v
  and ( not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1278]

This Proof Obligation:

[serial 1279]: Threads::AutoBrake.i
P [114] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( ca = ( 0 mpss ) )@now >>
S [114]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1275]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1291]: Threads::AutoBrake.i
P [114] << iSeg.v_n <= v
  and ( ca = 0 mpss )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1279]
. . . done Normalizing Unsolved Proof Obligations [13.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1281]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << SB()
  and not EB() >>
What for:    normalization of [serial 1271]

[serial 1283]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not EB() >>
What for:    normalization of [serial 1273]

[serial 1285]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1276]

[serial 1287]: Threads::AutoBrake.i
P [114] << iSeg.v_n <= v
  and ( SB()
  and not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1277]

[serial 1289]: Threads::AutoBrake.i
P [114] << iSeg.v_n <= v
  and ( not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1278]

[serial 1291]: Threads::AutoBrake.i
P [114] << iSeg.v_n <= v
  and ( ca = 0 mpss )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1279]
Done Normalizing
step:  151
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1287]: Threads::AutoBrake.i
P [114] << iSeg.v_n <= v
  and ( SB()
  and not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1277]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1289]: Threads::AutoBrake.i
P [114] << iSeg.v_n <= v
  and ( not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1278]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1291]: Threads::AutoBrake.i
P [114] << iSeg.v_n <= v
  and ( ca = 0 mpss )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1279]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [13.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1281]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << SB()
  and not EB() >>
What for:    normalization of [serial 1271]

[serial 1283]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not EB() >>
What for:    normalization of [serial 1273]

[serial 1285]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1276]
Done trying to apply axioms
step:  152
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1281]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << SB()
  and not EB() >>
What for:    normalization of [serial 1271]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1298]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1281]

This Proof Obligation:

[serial 1283]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not EB() >>
What for:    normalization of [serial 1273]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1299]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1283]

This Proof Obligation:

[serial 1285]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1276]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1300]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1285]
. . . done substituting assertions' for Labels [13.2 seconds ]
After "substitute" remaining 
Obligations:

[serial 1298]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1281]

[serial 1299]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1283]

[serial 1300]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1285]
Done substituting Assertion labels.
step:  153
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1298]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1281]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1302]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1298]

This Proof Obligation:

[serial 1299]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1283]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1304]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1299]

This Proof Obligation:

[serial 1300]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1285]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1306]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1300]
. . . done Normalizing Unsolved Proof Obligations [13.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1302]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1298]

[serial 1304]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1299]

[serial 1306]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1300]
Done Normalizing
step:  154
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1302]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1298]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1310]: Threads::AutoBrake.i
P [105] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1302]

This Proof Obligation:

[serial 1304]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1299]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1311]: Threads::AutoBrake.i
P [105] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1304]

This Proof Obligation:

[serial 1306]: Threads::AutoBrake.i
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1300]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1312]: Threads::AutoBrake.i
P [105] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1306]
. . . Substituting <= with not < [13.2 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1310]: Threads::AutoBrake.i
P [105] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1302]

[serial 1311]: Threads::AutoBrake.i
P [105] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1304]

[serial 1312]: Threads::AutoBrake.i
P [105] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1306]
Done replacing a<=b with (not b<a)
step:  155
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1310]: Threads::AutoBrake.i
P [105] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1302]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1314]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1310]

This Proof Obligation:

[serial 1311]: Threads::AutoBrake.i
P [105] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1304]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1316]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1311]

This Proof Obligation:

[serial 1312]: Threads::AutoBrake.i
P [105] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1306]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1318]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1312]
. . . done Normalizing Unsolved Proof Obligations [13.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1314]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1310]

[serial 1316]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1311]

[serial 1318]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1312]
Done Normalizing
step:  156
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1314]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1310]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1322]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1314]

This Proof Obligation:

[serial 1316]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1311]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1323]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1316]
. . . done applying DeMorgan's Law  [13.2 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1318]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1312]

[serial 1322]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1314]

[serial 1323]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1316]
step:  157
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1322]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1314]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1326]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1322]

This Proof Obligation:

[serial 1323]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1316]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1328]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1323]
. . . done Normalizing Unsolved Proof Obligations [13.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1318]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1312]

[serial 1326]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1322]

[serial 1328]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1323]
Done Normalizing
step:  158
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1328]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [114] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1323]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [13.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 1318]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1312]

[serial 1326]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1322]
Done trying to apply axioms
step:  159
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1318]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1312]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1331]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1318]

This Proof Obligation:

[serial 1326]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1322]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1332]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1326]
. . . done Applying Laws [13.3 seconds ]
After "laws" remaining 
Obligations:

[serial 1331]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1318]

[serial 1332]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1326]
Done applying laws
step:  160
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1332]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1326]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1333]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1332]

[serial 1334]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1332]

[serial 1335]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1332]
. . . done splitting postcondition  [13.3 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1331]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1318]

[serial 1333]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1332]

[serial 1334]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1332]

[serial 1335]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1332]
Done splitting postcondition
step:  161
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 not ( v < iSeg.v_n )


This Proof Obligation:

[serial 1331]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1318]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

This Proof Obligation:

[serial 1333]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1332]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1334]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1332]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [13.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 1335]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1332]
Done trying to apply axioms
step:  162
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1335]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1332]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1337]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1335]
. . . done Normalizing Unsolved Proof Obligations [13.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1337]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1335]
Done Normalizing
step:  163
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 not ( v < iSeg.v_n )


This Proof Obligation:

[serial 1337]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114]->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1335]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [13.3 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1163]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1158]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  164
#[serial 1163] <<P>> T <<Q>> in existential lattice quantification for [serial 1158]
step:  165
****reduce****

Reducing Concurrent Computation of:

[serial 1163]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1158]
Reason solved:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1339]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]sb!(true)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1163]

[serial 1340]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]eb!(false)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1163]

[serial 1341]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]ca!(0 mpss)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1163]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1339]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]sb!(true)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1163]

[serial 1340]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]eb!(false)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1163]

[serial 1341]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]ca!(0 mpss)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1163]
done reducing composite actions
step:  166
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=SB()
  and not EB()

This Proof Obligation:

[serial 1339]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]sb!(true)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1163]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(sb)[sb|true]>>  for <<pre>> sb!(true) <<post>> to get:

[serial 1342]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1339]

The Same Proof Obligation:
Has applied <<pre and (SB()
  and not EB())@now>> -> <<post>> for  <<pre>> sb!(true) <<post>> to get:

[serial 1343]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1339]
Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
newPortAssertion=not EB()

This Proof Obligation:

[serial 1340]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]eb!(false)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1163]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(eb)[eb|false]>>  for <<pre>> eb!(false) <<post>> to get:

[serial 1344]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]->
Q [119] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1340]

The Same Proof Obligation:
Has applied <<pre and (not EB())@now>> -> <<post>> for  <<pre>> eb!(false) <<post>> to get:

[serial 1345]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1340]
Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB()
                                             or EB() ))-> 0 mpss, (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB()
      or EB() ))-> 0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1341]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]ca!(0 mpss)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1163]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied <<pre and (ca=0 mpss)@now>> -> <<post>> for  <<pre>> ca!(QUANTITY) <<post>> to get:

[serial 1346]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( ca = ( 0 mpss ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1341]
Has applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>>where (( SB()
   or EB() ))-> 0 mpss for ca!(0 mpss) to get:

[serial 1347]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1341]
. . . done applying atomic actions [13.3 seconds ]
After "atomic" remaining 
Obligations:

[serial 1342]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1339]

[serial 1343]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1339]

[serial 1344]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]->
Q [119] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1340]

[serial 1345]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1340]

[serial 1346]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( ca = ( 0 mpss ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1341]

[serial 1347]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1341]
Done reducing atomic actions
step:  167
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1342]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1339]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1348]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [119]->
Q [12] << SB()
  and not EB() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1342]

This Proof Obligation:

[serial 1343]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1339]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1349]: Threads::AutoBrake.i
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1343]

This Proof Obligation:

[serial 1344]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]->
Q [119] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1340]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1350]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [119]->
Q [119] << not EB() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1344]

This Proof Obligation:

[serial 1345]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1340]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1351]: Threads::AutoBrake.i
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1345]

This Proof Obligation:

[serial 1346]: Threads::AutoBrake.i
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( ca = ( 0 mpss ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1341]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1352]: Threads::AutoBrake.i
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and ( ca = ( 0 mpss ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1346]

This Proof Obligation:

[serial 1347]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1341]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1353]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [119]->
Q [33] << ( SB()
   or EB() ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1347]

This Proof Obligation:

[serial 1349]: Threads::AutoBrake.i
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1343]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1354]: Threads::AutoBrake.i
P [119] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1349]

This Proof Obligation:

[serial 1351]: Threads::AutoBrake.i
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1345]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1355]: Threads::AutoBrake.i
P [119] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1351]

This Proof Obligation:

[serial 1352]: Threads::AutoBrake.i
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and ( ca = ( 0 mpss ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1346]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1356]: Threads::AutoBrake.i
P [119] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( ca = ( 0 mpss ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1352]
. . . done Applying Laws [13.3 seconds ]
After "laws" remaining 
Obligations:

[serial 1348]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [119]->
Q [12] << SB()
  and not EB() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1342]

[serial 1350]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [119]->
Q [119] << not EB() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1344]

[serial 1353]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [119]->
Q [33] << ( SB()
   or EB() ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1347]

[serial 1354]: Threads::AutoBrake.i
P [119] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1349]

[serial 1355]: Threads::AutoBrake.i
P [119] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1351]

[serial 1356]: Threads::AutoBrake.i
P [119] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( ca = ( 0 mpss ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1352]
Done applying laws
step:  168
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1348]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [119]->
Q [12] << SB()
  and not EB() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1342]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1358]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << SB()
  and not EB() >>
What for:    normalization of [serial 1348]

This Proof Obligation:

[serial 1350]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [119]->
Q [119] << not EB() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1344]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1360]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not EB() >>
What for:    normalization of [serial 1350]

This Proof Obligation:

[serial 1353]: Threads::AutoBrake.i
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [119]->
Q [33] << ( SB()
   or EB() ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1347]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1362]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1353]

This Proof Obligation:

[serial 1354]: Threads::AutoBrake.i
P [119] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( SB()
  and not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1349]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1364]: Threads::AutoBrake.i
P [119] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( SB()
  and not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1354]

This Proof Obligation:

[serial 1355]: Threads::AutoBrake.i
P [119] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( not EB() )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1351]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1366]: Threads::AutoBrake.i
P [119] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1355]

This Proof Obligation:

[serial 1356]: Threads::AutoBrake.i
P [119] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( ca = ( 0 mpss ) )@now >>
S [119]->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1352]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1368]: Threads::AutoBrake.i
P [119] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( ca = 0 mpss )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1356]
. . . done Normalizing Unsolved Proof Obligations [13.3 seconds ]
After "normalize" remaining 
Obligations:

[serial 1358]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << SB()
  and not EB() >>
What for:    normalization of [serial 1348]

[serial 1360]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not EB() >>
What for:    normalization of [serial 1350]

[serial 1362]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1353]

[serial 1364]: Threads::AutoBrake.i
P [119] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( SB()
  and not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1354]

[serial 1366]: Threads::AutoBrake.i
P [119] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1355]

[serial 1368]: Threads::AutoBrake.i
P [119] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( ca = 0 mpss )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1356]
Done Normalizing
step:  169
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1364]: Threads::AutoBrake.i
P [119] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( SB()
  and not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1354]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1366]: Threads::AutoBrake.i
P [119] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1355]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1368]: Threads::AutoBrake.i
P [119] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( ca = 0 mpss )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1356]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [13.3 seconds ]
After "axioms" remaining 
Obligations:

[serial 1358]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << SB()
  and not EB() >>
What for:    normalization of [serial 1348]

[serial 1360]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not EB() >>
What for:    normalization of [serial 1350]

[serial 1362]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1353]
Done trying to apply axioms
step:  170
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1358]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << SB()
  and not EB() >>
What for:    normalization of [serial 1348]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1375]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1358]

This Proof Obligation:

[serial 1360]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not EB() >>
What for:    normalization of [serial 1350]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1376]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1360]

This Proof Obligation:

[serial 1362]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1353]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1377]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1362]
. . . done substituting assertions' for Labels [13.3 seconds ]
After "substitute" remaining 
Obligations:

[serial 1375]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1358]

[serial 1376]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1360]

[serial 1377]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1362]
Done substituting Assertion labels.
step:  171
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1375]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1358]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1379]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1375]

This Proof Obligation:

[serial 1376]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1360]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1381]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1376]

This Proof Obligation:

[serial 1377]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1362]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1383]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1377]
. . . done Normalizing Unsolved Proof Obligations [13.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1379]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1375]

[serial 1381]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1376]

[serial 1383]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1377]
Done Normalizing
step:  172
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1379]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1375]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1387]: Threads::AutoBrake.i
P [105] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1379]

This Proof Obligation:

[serial 1381]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1376]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1388]: Threads::AutoBrake.i
P [105] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1381]

This Proof Obligation:

[serial 1383]: Threads::AutoBrake.i
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1377]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1389]: Threads::AutoBrake.i
P [105] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1383]
. . . Substituting <= with not < [13.4 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1387]: Threads::AutoBrake.i
P [105] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1379]

[serial 1388]: Threads::AutoBrake.i
P [105] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1381]

[serial 1389]: Threads::AutoBrake.i
P [105] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1383]
Done replacing a<=b with (not b<a)
step:  173
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1387]: Threads::AutoBrake.i
P [105] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1379]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1391]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1387]

This Proof Obligation:

[serial 1388]: Threads::AutoBrake.i
P [105] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1381]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1393]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1388]

This Proof Obligation:

[serial 1389]: Threads::AutoBrake.i
P [105] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1383]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1395]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1389]
. . . done Normalizing Unsolved Proof Obligations [13.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1391]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1387]

[serial 1393]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1388]

[serial 1395]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1389]
Done Normalizing
step:  174
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1391]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1387]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1399]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1391]

This Proof Obligation:

[serial 1393]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1388]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1400]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1393]
. . . done applying DeMorgan's Law  [13.4 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1395]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1389]

[serial 1399]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1391]

[serial 1400]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1393]
step:  175
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1399]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1391]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1403]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1399]

This Proof Obligation:

[serial 1400]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1393]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1405]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1400]
. . . done Normalizing Unsolved Proof Obligations [13.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1395]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1389]

[serial 1403]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1399]

[serial 1405]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1400]
Done Normalizing
step:  176
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1405]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [119] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1400]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [13.4 seconds ]
After "axioms" remaining 
Obligations:

[serial 1395]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1389]

[serial 1403]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1399]
Done trying to apply axioms
step:  177
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1395]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1389]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1408]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1395]

This Proof Obligation:

[serial 1403]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1399]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1409]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1403]
. . . done Applying Laws [13.4 seconds ]
After "laws" remaining 
Obligations:

[serial 1408]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1395]

[serial 1409]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1403]
Done applying laws
step:  178
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1409]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1403]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1410]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1409]

[serial 1411]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1409]

[serial 1412]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1409]
. . . done splitting postcondition  [13.4 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1408]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1395]

[serial 1410]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1409]

[serial 1411]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1409]

[serial 1412]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1409]
Done splitting postcondition
step:  179
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1408]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1395]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1414]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1408]

This Proof Obligation:

[serial 1412]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1409]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1418]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1412]
. . . done Normalizing Unsolved Proof Obligations [13.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1410]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1409]

[serial 1411]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1409]

[serial 1414]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1408]

[serial 1418]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1412]
Done Normalizing
step:  180
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1410]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1409]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1411]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1409]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )


This Proof Obligation:

[serial 1414]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1408]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )


This Proof Obligation:

[serial 1418]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119]->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1412]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [13.4 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1164]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [124]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1159]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  181
#[serial 1164] <<P>> T <<Q>> in existential lattice quantification for [serial 1159]
step:  182
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1164]: Threads::AutoBrake.i
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [124]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1159]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1422]: Threads::AutoBrake.i
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1164]
. . . done Normalizing Unsolved Proof Obligations [13.4 seconds ]
After "normalize" remaining 
Obligations:

[serial 1422]: Threads::AutoBrake.i
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1164]
Done Normalizing
step:  183
****reduce****

Reducing Concurrent Computation of:

[serial 1422]: Threads::AutoBrake.i
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1164]
Reason solved:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1424]: Threads::AutoBrake.i
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1422]

[serial 1425]: Threads::AutoBrake.i
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]eb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1422]

[serial 1426]: Threads::AutoBrake.i
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]ca!(xl)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1422]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1424]: Threads::AutoBrake.i
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1422]

[serial 1425]: Threads::AutoBrake.i
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]eb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1422]

[serial 1426]: Threads::AutoBrake.i
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]ca!(xl)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1422]
done reducing composite actions
step:  184
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1424]: Threads::AutoBrake.i
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1422]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1427]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1424]

This Proof Obligation:

[serial 1425]: Threads::AutoBrake.i
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]eb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1422]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1428]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]eb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1425]

This Proof Obligation:

[serial 1426]: Threads::AutoBrake.i
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]ca!(xl)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1422]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1429]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]ca!(xl)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1426]
. . . done Applying Laws [13.4 seconds ]
After "laws" remaining 
Obligations:

[serial 1427]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1424]

[serial 1428]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]eb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1425]

[serial 1429]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]ca!(xl)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1426]
Done applying laws
step:  185
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=not ( SB()
  and not EB() )

This Proof Obligation:

[serial 1427]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1424]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(sb)[sb|false]>>  for <<pre>> sb!(false) <<post>> to get:

[serial 1430]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1427]

The Same Proof Obligation:
Has applied <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> for  <<pre>> sb!(false) <<post>> to get:

[serial 1431]: Threads::AutoBrake.i
P [124] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( SB()
  and not EB() ) )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1427]
Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
newPortAssertion=not EB()

This Proof Obligation:

[serial 1428]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]eb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1425]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(eb)[eb|false]>>  for <<pre>> eb!(false) <<post>> to get:

[serial 1432]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1428]

The Same Proof Obligation:
Has applied <<pre and (not EB())@now>> -> <<post>> for  <<pre>> eb!(false) <<post>> to get:

[serial 1433]: Threads::AutoBrake.i
P [124] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not EB() )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1428]
Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB()
                                             or EB() ))-> 0 mpss, (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB()
      or EB() ))-> 0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1429]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]ca!(xl)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1426]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied <<pre and (ca=xl)@now>> -> <<post>> for  <<pre>> ca!(xl) <<post>> to get:

[serial 1434]: Threads::AutoBrake.i
P [124] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( ca = xl )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1429]
looking through terms of
  [(( SB()
      or EB() ))-> 0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]
no term was found that had expression e:
 xl
. . . done applying atomic actions [13.4 seconds ]
After "atomic" remaining 
Obligations:

[serial 1430]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1427]

[serial 1431]: Threads::AutoBrake.i
P [124] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( SB()
  and not EB() ) )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1427]

[serial 1432]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1428]

[serial 1433]: Threads::AutoBrake.i
P [124] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not EB() )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1428]

[serial 1434]: Threads::AutoBrake.i
P [124] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( ca = xl )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1429]
Done reducing atomic actions
step:  186
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1431]: Threads::AutoBrake.i
P [124] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( SB()
  and not EB() ) )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1427]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1435]: Threads::AutoBrake.i
P [124] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( SB()
  and not EB() ) )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1431]

This Proof Obligation:

[serial 1433]: Threads::AutoBrake.i
P [124] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not EB() )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1428]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1436]: Threads::AutoBrake.i
P [124] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not EB() )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1433]

This Proof Obligation:

[serial 1434]: Threads::AutoBrake.i
P [124] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( ca = xl )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1429]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1437]: Threads::AutoBrake.i
P [124] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( ca = xl )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1434]
. . . done Applying Laws [13.4 seconds ]
After "laws" remaining 
Obligations:

[serial 1430]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1427]

[serial 1432]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1428]

[serial 1435]: Threads::AutoBrake.i
P [124] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( SB()
  and not EB() ) )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1431]

[serial 1436]: Threads::AutoBrake.i
P [124] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not EB() )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1433]

[serial 1437]: Threads::AutoBrake.i
P [124] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( ca = xl )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1434]
Done applying laws
step:  187
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1435]: Threads::AutoBrake.i
P [124] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( SB()
  and not EB() ) )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1431]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1436]: Threads::AutoBrake.i
P [124] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not EB() )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1433]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1437]: Threads::AutoBrake.i
P [124] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( ca = xl )@now >>
S [124]->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:  Associativity: (b.c).a = a.b.c [serial 1434]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [13.5 seconds ]
After "axioms" remaining 
Obligations:

[serial 1430]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1427]

[serial 1432]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1428]
Done trying to apply axioms
step:  188
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1430]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1427]
Reason solved:  DeMorgan's Law: not (A and B) = (not A) or (not B)
Has applied DeMorgan's Law: not (A and B) = (not A) or (not B)  to get:

[serial 1438]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( not ( SB() )
   or not ( not EB() ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1430]
. . . done applying DeMorgan's Law  [13.5 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1432]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1428]

[serial 1438]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( not ( SB() )
   or not ( not EB() ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1430]
step:  189
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1438]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( not ( SB() )
   or not ( not EB() ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1430]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1441]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << EB()
   or not SB() >>
What for:    normalization of [serial 1438]
. . . done Normalizing Unsolved Proof Obligations [13.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 1432]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1428]

[serial 1441]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << EB()
   or not SB() >>
What for:    normalization of [serial 1438]
Done Normalizing
step:  190
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1432]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1428]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1443]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1432]

This Proof Obligation:

[serial 1441]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << EB()
   or not SB() >>
What for:    normalization of [serial 1438]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1444]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1441]
. . . done substituting assertions' for Labels [13.5 seconds ]
After "substitute" remaining 
Obligations:

[serial 1443]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1432]

[serial 1444]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1441]
Done substituting Assertion labels.
step:  191
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1443]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1432]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1446]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1443]

This Proof Obligation:

[serial 1444]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1441]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1448]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1444]
. . . done Normalizing Unsolved Proof Obligations [13.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 1446]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1443]

[serial 1448]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1444]
Done Normalizing
step:  192
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1448]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1444]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1451]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1448]
. . . done Applying Laws [13.5 seconds ]
After "laws" remaining 
Obligations:

[serial 1446]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1443]

[serial 1451]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1448]
Done applying laws
step:  193
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1446]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1443]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1452]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1446]

This Proof Obligation:

[serial 1451]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1448]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1453]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or not ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1451]
. . . Substituting <= with not < [13.5 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1452]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1446]

[serial 1453]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or not ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1451]
Done replacing a<=b with (not b<a)
step:  194
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1452]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1446]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1455]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1452]

This Proof Obligation:

[serial 1453]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or not ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1451]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1457]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1453]
. . . done Normalizing Unsolved Proof Obligations [13.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 1455]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1452]

[serial 1457]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1453]
Done Normalizing
step:  195
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1455]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1452]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1460]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1455]

This Proof Obligation:

[serial 1457]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1453]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1461]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) )
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1457]
. . . done applying DeMorgan's Law  [13.5 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1460]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1455]

[serial 1461]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) )
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1457]
step:  196
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1460]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1455]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1463]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1460]

This Proof Obligation:

[serial 1461]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) )
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1457]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1465]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1461]
. . . done Normalizing Unsolved Proof Obligations [13.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 1463]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1460]

[serial 1465]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1461]
Done Normalizing
step:  197
****axioms****
Applying Axioms . . .
AXIOM.premise_has_all_terms_of_conjunction_within_conclusion_disjunction found, in premise conjunction, all terms of this conjunction within disjunction conclusion:
 v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n


This Proof Obligation:

[serial 1465]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1461]
Reason solved:  Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}
Has been solved by Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}
. . . done Applying Axioms [13.5 seconds ]
After "axioms" remaining 
Obligations:

[serial 1463]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1460]
Done trying to apply axioms
step:  198
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  v < iSeg.v_n and iSeg.v_n < iSeg.v_e -> v < iSeg.v_e

This Proof Obligation:

[serial 1463]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124]->
Q [124] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1460]
Reason solved:  Transitivity: x<y and y<z -> x<z
Has applied Transitivity: x<y and y<z -> x<z  to get:

[serial 1468]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [124]->
Q [124] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Transitivity: x<y and y<z -> x<z  [serial 1463]
. . . done adding transitive terms [13.5 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 1468]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [124]->
Q [124] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Transitivity: x<y and y<z -> x<z  [serial 1463]
Done adding transitive relations
step:  199
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1468]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [124]->
Q [124] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Transitivity: x<y and y<z -> x<z  [serial 1463]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1469]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [124]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1468]

[serial 1470]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [124]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1468]
. . . done splitting postcondition  [13.5 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1469]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [124]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1468]

[serial 1470]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [124]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1468]
Done splitting postcondition
step:  200
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1469]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [124]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1468]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1470]: Threads::AutoBrake.i
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [124]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1468]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [13.5 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1018]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p < iSeg.e ) >>
S [128]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(CheckMoveForward) and x>> -> <<M(MoveForward)>> for SameSegment: CheckMoveForward-[x]->MoveForward{};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  201
#[serial 1018]  <<M(CheckMoveForward) and x>> -> <<M(MoveForward)>> for SameSegmentCheckMoveForward-[x]->MoveForward{};
step:  202
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1018]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p < iSeg.e ) >>
S [128]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(CheckMoveForward) and x>> -> <<M(MoveForward)>> for SameSegment: CheckMoveForward-[x]->MoveForward{};
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1472]: Threads::AutoBrake.i
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments
  and p < iSeg.e >>
S [128]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1018]
. . . done Normalizing Unsolved Proof Obligations [13.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 1472]: Threads::AutoBrake.i
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments
  and p < iSeg.e >>
S [128]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1018]
Done Normalizing
step:  203
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1472]: Threads::AutoBrake.i
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments
  and p < iSeg.e >>
S [128]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1018]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [13.5 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1019]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]  iSeg := nSeg
  ;
  << iSeg = CMA.seg[i + 1]
    and ma = CMA >>
  i := i + 1 
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
What for:   <<M(CheckMoveForward) and x>> A <<M(CheckForLastSegment)>> for NextSegment: CheckMoveForward-[x]->CheckForLastSegment{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  204
#[serial 1019]  <<M(CheckMoveForward) and x>> A <<M(CheckForLastSegment)>> for NextSegmentCheckMoveForward-[x]->CheckForLastSegment{A};
step:  205
****reduce****
This proof obligation:

[serial 1019]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]  iSeg := nSeg
  ;
  << iSeg = CMA.seg[i + 1]
    and ma = CMA >>
  i := i + 1 
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
What for:   <<M(CheckMoveForward) and x>> A <<M(CheckForLastSegment)>> for NextSegment: CheckMoveForward-[x]->CheckForLastSegment{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1474]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]iSeg := nSeg
Q [135] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1019]

[serial 1475]: Threads::AutoBrake.i
P [135] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [136]i := i + 1
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1019]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1474]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]iSeg := nSeg
Q [135] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1019]

[serial 1475]: Threads::AutoBrake.i
P [135] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [136]i := i + 1
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1019]
done reducing composite actions
step:  206
****atomic****
applying atomic actions . . .
solving assignment on line 134
replacing "iSeg" with "nSeg"
makes:  << nSeg = CMA.seg[i + 1]
  and ma = CMA >>

This Proof Obligation:

[serial 1474]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]iSeg := nSeg
Q [135] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1019]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1476]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]->
Q [135] << nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied wp for assignment [serial 1474]
solving assignment on line 136
replacing "i" with "i + 1"
makes:  << iSeg = CMA.seg[( i + 1 )]
  and ma = CMA >>

This Proof Obligation:

[serial 1475]: Threads::AutoBrake.i
P [135] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [136]i := i + 1
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1019]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1477]: Threads::AutoBrake.i
P [135] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [136]->
Q [61] << iSeg = CMA.seg[( i + 1 )]
  and ma = CMA >>
What for:  applied wp for assignment [serial 1475]
. . . done applying atomic actions [13.5 seconds ]
After "atomic" remaining 
Obligations:

[serial 1476]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]->
Q [135] << nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied wp for assignment [serial 1474]

[serial 1477]: Threads::AutoBrake.i
P [135] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [136]->
Q [61] << iSeg = CMA.seg[( i + 1 )]
  and ma = CMA >>
What for:  applied wp for assignment [serial 1475]
Done reducing atomic actions
step:  207
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1476]: Threads::AutoBrake.i
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]->
Q [135] << nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied wp for assignment [serial 1474]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1479]: Threads::AutoBrake.i
P [59] << iSeg.e <= p
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [134]->
Q [135] << CMA = ma
  and CMA.seg[1 + i] = nSeg >>
What for:    normalization of [serial 1476]

This Proof Obligation:

[serial 1477]: Threads::AutoBrake.i
P [135] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [136]->
Q [61] << iSeg = CMA.seg[( i + 1 )]
  and ma = CMA >>
What for:  applied wp for assignment [serial 1475]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1481]: Threads::AutoBrake.i
P [135] << CMA = ma
  and CMA.seg[1 + i] = iSeg >>
S [136]->
Q [61] << CMA = ma
  and CMA.seg[1 + i] = iSeg >>
What for:    normalization of [serial 1477]
. . . done Normalizing Unsolved Proof Obligations [13.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 1479]: Threads::AutoBrake.i
P [59] << iSeg.e <= p
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [134]->
Q [135] << CMA = ma
  and CMA.seg[1 + i] = nSeg >>
What for:    normalization of [serial 1476]

[serial 1481]: Threads::AutoBrake.i
P [135] << CMA = ma
  and CMA.seg[1 + i] = iSeg >>
S [136]->
Q [61] << CMA = ma
  and CMA.seg[1 + i] = iSeg >>
What for:    normalization of [serial 1477]
Done Normalizing
step:  208
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1479]: Threads::AutoBrake.i
P [59] << iSeg.e <= p
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [134]->
Q [135] << CMA = ma
  and CMA.seg[1 + i] = nSeg >>
What for:    normalization of [serial 1476]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1481]: Threads::AutoBrake.i
P [135] << CMA = ma
  and CMA.seg[1 + i] = iSeg >>
S [136]->
Q [61] << CMA = ma
  and CMA.seg[1 + i] = iSeg >>
What for:    normalization of [serial 1477]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [13.5 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1020]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141]nSeg := ma.seg[i + 1]
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(CheckForLastSegment) and x>> A <<M(MoveForward)>> for NotLastSegment: CheckForLastSegment-[x]->MoveForward{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  209
#[serial 1020]  <<M(CheckForLastSegment) and x>> A <<M(MoveForward)>> for NotLastSegmentCheckForLastSegment-[x]->MoveForward{A};
step:  210
****atomic****
applying atomic actions . . .
reduce asserted action
solving assignment on line 141
replacing "nSeg" with "
^{ma 
 ^{. 
  ^{seg 
   ^{[ 
    ^{+ i 
     ^{QUANTITY 1}}}}}}"
makes:  << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma.seg[i + 1] = CMA.seg[i + 1]
  and ma = CMA >>

This Proof Obligation:

[serial 1020]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141]nSeg := ma.seg[i + 1]
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(CheckForLastSegment) and x>> A <<M(MoveForward)>> for NotLastSegment: CheckForLastSegment-[x]->MoveForward{A};
Reasons solved:  
   Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
   Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1484]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma.seg[i + 1] = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied wp for assignment [serial 1020]
. . . done applying atomic actions [13.5 seconds ]
After "atomic" remaining 
Obligations:

[serial 1484]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma.seg[i + 1] = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied wp for assignment [serial 1020]
Done reducing atomic actions
step:  211
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1484]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma.seg[i + 1] = CMA.seg[i + 1]
  and ma = CMA >>
What for:  applied wp for assignment [serial 1020]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1486]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = ma.seg[1 + i]
  and i < CMA.num_segments >>
What for:    normalization of [serial 1484]
. . . done Normalizing Unsolved Proof Obligations [13.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 1486]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = ma.seg[1 + i]
  and i < CMA.num_segments >>
What for:    normalization of [serial 1484]
Done Normalizing
step:  212
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1486]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = ma.seg[1 + i]
  and i < CMA.num_segments >>
What for:    normalization of [serial 1484]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1488]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1486]

[serial 1489]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1486]

[serial 1490]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA.seg[1 + i] = ma.seg[1 + i] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1486]

[serial 1491]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << i < CMA.num_segments >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1486]
. . . done splitting postcondition  [13.5 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1488]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1486]

[serial 1489]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1486]

[serial 1490]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA.seg[1 + i] = ma.seg[1 + i] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1486]

[serial 1491]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << i < CMA.num_segments >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1486]
Done splitting postcondition
step:  213
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1488]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1486]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1489]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1486]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [13.5 seconds ]
After "axioms" remaining 
Obligations:

[serial 1490]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA.seg[1 + i] = ma.seg[1 + i] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1486]

[serial 1491]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << i < CMA.num_segments >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1486]
Done trying to apply axioms
step:  214
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1490]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << CMA.seg[1 + i] = ma.seg[1 + i] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1486]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1492]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << ma.seg[1 + i] = ma.seg[1 + i] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1490]
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1491]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << i < CMA.num_segments >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1486]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1493]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << i < ma.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1491]
. . . done guided substitution of equals  [13.5 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1492]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << ma.seg[1 + i] = ma.seg[1 + i] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1490]

[serial 1493]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << i < ma.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1491]
Done guided substituting an equals
step:  215
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1493]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << i < ma.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1491]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [13.5 seconds ]
After "axioms" remaining 
Obligations:

[serial 1492]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << ma.seg[1 + i] = ma.seg[1 + i] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1490]
Done trying to apply axioms
step:  216
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1492]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << ma.seg[1 + i] = ma.seg[1 + i] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1490]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 1494]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1492]
. . . done Applying Laws [13.5 seconds ]
After "laws" remaining 
Obligations:

[serial 1494]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1492]
Done applying laws
step:  217
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1494]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141]->
Q [57] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1492]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [13.5 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1021]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]  r!
  ;
  << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA >>
  nSeg := [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] 
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:   <<M(CheckForLastSegment) and x>> A <<M(MoveForwardLastSegment)>> for IsLastSegment: CheckForLastSegment-[x]->MoveForwardLastSegment{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  218
#[serial 1021]  <<M(CheckForLastSegment) and x>> A <<M(MoveForwardLastSegment)>> for IsLastSegmentCheckForLastSegment-[x]->MoveForwardLastSegment{A};
step:  219
****reduce****
This proof obligation:

[serial 1021]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]  r!
  ;
  << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA >>
  nSeg := [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] 
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:   <<M(CheckForLastSegment) and x>> A <<M(MoveForwardLastSegment)>> for IsLastSegment: CheckForLastSegment-[x]->MoveForwardLastSegment{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1495]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]r!
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1021]

[serial 1496]: Threads::AutoBrake.i
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149]nSeg := [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;]
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1021]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1495]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]r!
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1021]

[serial 1496]: Threads::AutoBrake.i
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149]nSeg := [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;]
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1021]
done reducing composite actions
step:  220
****atomic****
applying atomic actions . . .
out event port r on line 146 does not have a BLESS::Assertion property AutoBrake.i; <<true>> used instead.

This Proof Obligation:

[serial 1495]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]r!
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1021]
Has applied <<pre>> -> <<M(r)>> for <<pre>> r! <<post>> to get:

[serial 1497]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]->
Q [146] << true >>
What for:  applied port output <<pre>> -> <<M[r]>> [serial 1495]
Has applied <<pre and r@now>> -> <<post>> for <<pre>> r! <<post>> to get:

[serial 1498]: Threads::AutoBrake.i
P [146] << ( iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) )
  and true@now >>
S [146]->
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
What for:  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1495]
solving assignment on line 149
replacing "nSeg" with "
^{RECORD_TERM[segment] segment 
 ^{=> v_n 
  ^{QUANTITY 0 mps}} 
 ^{=> v_e 
  ^{QUANTITY 0 mps}} 
 ^{=> e 
  ^{ma 
   ^{. ea}}}}"
makes:  << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ( [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] ) = NULL_SEGMENT()
  and ma = CMA >>

This Proof Obligation:

[serial 1496]: Threads::AutoBrake.i
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149]nSeg := [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;]
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1021]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1499]: Threads::AutoBrake.i
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149]->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ( [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] ) = NULL_SEGMENT()
  and ma = CMA >>
What for:  applied wp for assignment [serial 1496]
. . . done applying atomic actions [13.5 seconds ]
After "atomic" remaining 
Obligations:

[serial 1497]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]->
Q [146] << true >>
What for:  applied port output <<pre>> -> <<M[r]>> [serial 1495]

[serial 1498]: Threads::AutoBrake.i
P [146] << ( iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) )
  and true@now >>
S [146]->
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
What for:  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1495]

[serial 1499]: Threads::AutoBrake.i
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149]->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ( [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] ) = NULL_SEGMENT()
  and ma = CMA >>
What for:  applied wp for assignment [serial 1496]
Done reducing atomic actions
step:  221
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1497]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]->
Q [146] << true >>
What for:  applied port output <<pre>> -> <<M[r]>> [serial 1495]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1501]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [146] << true >>
What for:    normalization of [serial 1497]

This Proof Obligation:

[serial 1498]: Threads::AutoBrake.i
P [146] << ( iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) )
  and true@now >>
S [146]->
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
What for:  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1495]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Constants are always the same
Has been normalized to get:

[serial 1503]: Threads::AutoBrake.i
P [146] << true
  and ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) >>
S [146]->
Q [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
What for:    normalization of [serial 1498]

This Proof Obligation:

[serial 1499]: Threads::AutoBrake.i
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149]->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ( [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] ) = NULL_SEGMENT()
  and ma = CMA >>
What for:  applied wp for assignment [serial 1496]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1505]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:    normalization of [serial 1499]
. . . done Normalizing Unsolved Proof Obligations [13.5 seconds ]
After "normalize" remaining 
Obligations:

[serial 1501]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [146] << true >>
What for:    normalization of [serial 1497]

[serial 1503]: Threads::AutoBrake.i
P [146] << true
  and ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) >>
S [146]->
Q [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
What for:    normalization of [serial 1498]

[serial 1505]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:    normalization of [serial 1499]
Done Normalizing
step:  222
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1503]: Threads::AutoBrake.i
P [146] << true
  and ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) >>
S [146]->
Q [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
What for:    normalization of [serial 1498]
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1509]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
What for:  Law of And-Simplification:  P and true is P [serial 1503]
. . . done Applying Laws [13.5 seconds ]
After "laws" remaining 
Obligations:

[serial 1501]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [146] << true >>
What for:    normalization of [serial 1497]

[serial 1505]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:    normalization of [serial 1499]

[serial 1509]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
What for:  Law of And-Simplification:  P and true is P [serial 1503]
Done applying laws
step:  223
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1505]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:    normalization of [serial 1499]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1510]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505]

[serial 1511]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505]

[serial 1512]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505]

[serial 1513]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505]

This Proof Obligation:

[serial 1509]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
What for:  Law of And-Simplification:  P and true is P [serial 1503]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1514]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1509]

[serial 1515]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1509]

[serial 1516]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1509]
. . . done splitting postcondition  [13.5 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1501]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [146] << true >>
What for:    normalization of [serial 1497]

[serial 1510]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505]

[serial 1511]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505]

[serial 1512]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505]

[serial 1513]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505]

[serial 1514]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1509]

[serial 1515]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1509]

[serial 1516]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1509]
Done splitting postcondition
step:  224
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1501]: Threads::AutoBrake.i
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [146] << true >>
What for:    normalization of [serial 1497]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true

This Proof Obligation:

[serial 1510]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1511]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1512]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [13.6 seconds ]
After "axioms" remaining 
Obligations:

[serial 1513]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505]

[serial 1514]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1509]

[serial 1515]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1509]

[serial 1516]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1509]
Done trying to apply axioms
step:  225
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1514]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1509]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1519]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA = ma >>
What for:    normalization of [serial 1514]

This Proof Obligation:

[serial 1515]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1509]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1521]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA.num_segments = i >>
What for:    normalization of [serial 1515]

This Proof Obligation:

[serial 1516]: Threads::AutoBrake.i
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146]->
Q [147] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1509]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1523]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA.seg[i] = iSeg >>
What for:    normalization of [serial 1516]
. . . done Normalizing Unsolved Proof Obligations [13.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 1513]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505]

[serial 1519]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA = ma >>
What for:    normalization of [serial 1514]

[serial 1521]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA.num_segments = i >>
What for:    normalization of [serial 1515]

[serial 1523]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA.seg[i] = iSeg >>
What for:    normalization of [serial 1516]
Done Normalizing
step:  226
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1519]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA = ma >>
What for:    normalization of [serial 1514]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1523]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA.seg[i] = iSeg >>
What for:    normalization of [serial 1516]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [13.6 seconds ]
After "axioms" remaining 
Obligations:

[serial 1513]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505]

[serial 1521]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA.num_segments = i >>
What for:    normalization of [serial 1515]
Done trying to apply axioms
step:  227
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = ma
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1521]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << CMA.num_segments = i >>
What for:    normalization of [serial 1515]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1527]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << ma.num_segments = i >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1521]
. . . done guided substitution of equals  [13.6 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1513]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505]
Reason solved:  Guided Substitution of Equals

[serial 1527]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << ma.num_segments = i >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1521]
Done guided substituting an equals
step:  228
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1527]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << ma.num_segments = i >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1521]
Reason solved:  Reflexivity of Equality: (a=b) = (b=a)
Has been normalized to get:

[serial 1530]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << i = ma.num_segments >>
What for:    normalization of [serial 1527]
. . . done Normalizing Unsolved Proof Obligations [13.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 1513]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505]
Reason solved:  Guided Substitution of Equals

[serial 1530]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << i = ma.num_segments >>
What for:    normalization of [serial 1527]
Done Normalizing
step:  229
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1530]: Threads::AutoBrake.i
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146]->
Q [147] << i = ma.num_segments >>
What for:    normalization of [serial 1527]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [13.6 seconds ]
After "axioms" remaining 
Obligations:

[serial 1513]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505]
Reason solved:  Guided Substitution of Equals
Done trying to apply axioms
step:  230
****substitute postcondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1513]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505]
Reasons solved:  
   Guided Substitution of Equals
   Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1532]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] ) = [segment: v_n->0 mps; 
v_e->0 mps; e->ma.ea;] >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1513]
. . . done substituting assertions' for Labels [13.6 seconds ]
After "substitute postcondition" remaining 
Obligations:

[serial 1532]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] ) = [segment: v_n->0 mps; 
v_e->0 mps; e->ma.ea;] >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1513]
Done substituting Assertion labels in postconditions.
step:  231
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1532]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] ) = [segment: v_n->0 mps; 
v_e->0 mps; e->ma.ea;] >>
What for:  Substituted assertions' predicates for labels in postconditions [serial 1513]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1533]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << ( [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] ) = [segment: v_n->0 mps; 
v_e->0 mps; e->ma.ea;] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1532]
. . . done guided substitution of equals  [13.6 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1533]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << ( [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] ) = [segment: v_n->0 mps; 
v_e->0 mps; e->ma.ea;] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1532]
Done guided substituting an equals
step:  232
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1533]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << ( [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] ) = [segment: v_n->0 mps; 
v_e->0 mps; e->ma.ea;] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1532]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 1534]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1533]
. . . done Applying Laws [13.6 seconds ]
After "laws" remaining 
Obligations:

[serial 1534]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1533]
Done applying laws
step:  233
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1534]: Threads::AutoBrake.i
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149]->
Q [63] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1533]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [13.6 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1022]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i > ma.num_segments ) >>
S [155]->
Q [72] << true >>
What for:   <<M(CheckForLastSegment) and x>> -> <<M(FAIL)>> for PastLastSegment: CheckForLastSegment-[x]->FAIL{};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  234
#[serial 1022]  <<M(CheckForLastSegment) and x>> -> <<M(FAIL)>> for PastLastSegmentCheckForLastSegment-[x]->FAIL{};
step:  235
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1022]: Threads::AutoBrake.i
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i > ma.num_segments ) >>
S [155]->
Q [72] << true >>
What for:   <<M(CheckForLastSegment) and x>> -> <<M(FAIL)>> for PastLastSegment: CheckForLastSegment-[x]->FAIL{};
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [13.6 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1023]: Threads::AutoBrake.i
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [160]<< i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:   <<M(MoveForwardLastSegment) and x>> A <<M(CheckMoveForwardLastSegment)>> for LastSegment: MoveForwardLastSegment-[x]->CheckMoveForwardLastSegment{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  236
#[serial 1023]  <<M(MoveForwardLastSegment) and x>> A <<M(CheckMoveForwardLastSegment)>> for LastSegmentMoveForwardLastSegment-[x]->CheckMoveForwardLastSegment{A};
step:  237
****reduce****

[serial 1535]: Threads::AutoBrake.i
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023]

[serial 1536]: Threads::AutoBrake.i
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1023]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1535]: Threads::AutoBrake.i
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023]

[serial 1536]: Threads::AutoBrake.i
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1023]
done reducing composite actions
step:  238
****reduce****
This proof obligation:

[serial 1536]: Threads::AutoBrake.i
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1023]
Reason solved:  Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>>
as <<P>> if (B1)-><<P1>>S1<<Q1>> [] (B2)-><<P2>>S2<<Q2>> [] . . . [] (Bn)-><<Pn>>Sn<<Qn>> fi <<Q>> 

was reduced to:

[serial 1537]: Threads::AutoBrake.i
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( v >= iSeg.v_e )
   or ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1536]

[serial 1538]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B0>> S0 <<Q>> in alternative for [serial 1536]

[serial 1539]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [168]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B1>> S1 <<Q>> in alternative for [serial 1536]

[serial 1540]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [172]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B2>> S2 <<Q>> in alternative for [serial 1536]

[serial 1541]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [177]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B3>> S3 <<Q>> in alternative for [serial 1536]

[serial 1542]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [182]  {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B4>> S4 <<Q>> in alternative for [serial 1536]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1535]: Threads::AutoBrake.i
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023]

[serial 1537]: Threads::AutoBrake.i
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( v >= iSeg.v_e )
   or ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1536]

[serial 1538]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B0>> S0 <<Q>> in alternative for [serial 1536]

[serial 1539]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [168]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B1>> S1 <<Q>> in alternative for [serial 1536]

[serial 1540]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [172]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B2>> S2 <<Q>> in alternative for [serial 1536]

[serial 1541]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [177]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B3>> S3 <<Q>> in alternative for [serial 1536]

[serial 1542]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [182]  {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B4>> S4 <<Q>> in alternative for [serial 1536]
done reducing composite actions
step:  239
****reduce****
Reducing Existential Quantification of:

[serial 1538]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B0>> S0 <<Q>> in alternative for [serial 1536]
Reason solved:  Introduction of Existential Quantification
as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1543]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1538]
Reducing Existential Quantification of:

[serial 1539]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [168]  {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B1>> S1 <<Q>> in alternative for [serial 1536]
Reason solved:  Introduction of Existential Quantification
as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1544]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1539]
Reducing Existential Quantification of:

[serial 1540]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [172]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B2>> S2 <<Q>> in alternative for [serial 1536]
Reason solved:  Introduction of Existential Quantification
as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1545]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1540]
Reducing Existential Quantification of:

[serial 1541]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [177]  {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B3>> S3 <<Q>> in alternative for [serial 1536]
Reason solved:  Introduction of Existential Quantification
as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1546]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1541]
Reducing Existential Quantification of:

[serial 1542]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [182]  {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:    <<P and B4>> S4 <<Q>> in alternative for [serial 1536]
Reason solved:  Introduction of Existential Quantification
as this
    <<P>> T <<Q>> 
  ----------------- 
<<P>> {  T  } <<Q>>


[serial 1547]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1542]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1535]: Threads::AutoBrake.i
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023]

[serial 1537]: Threads::AutoBrake.i
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( v >= iSeg.v_e )
   or ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1536]

[serial 1543]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1538]

[serial 1544]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1539]

[serial 1545]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1540]

[serial 1546]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1541]

[serial 1547]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1542]
done reducing composite actions
step:  240
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1535]: Threads::AutoBrake.i
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1549]: Threads::AutoBrake.i
P [159] << p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:    normalization of [serial 1535]

This Proof Obligation:

[serial 1537]: Threads::AutoBrake.i
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( v >= iSeg.v_e )
   or ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1536]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1551]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1537]

This Proof Obligation:

[serial 1543]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1538]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1553]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1543]

This Proof Obligation:

[serial 1544]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1539]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1555]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1544]

This Proof Obligation:

[serial 1545]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1540]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1557]: Threads::AutoBrake.i
P [163] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1545]

This Proof Obligation:

[serial 1546]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1541]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1559]: Threads::AutoBrake.i
P [163] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1546]

This Proof Obligation:

[serial 1547]: Threads::AutoBrake.i
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:  <<P>> T <<Q>> in existential lattice quantification for [serial 1542]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Reflexivity of Equality: (a=b) = (b=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1561]: Threads::AutoBrake.i
P [163] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1547]
. . . done Normalizing Unsolved Proof Obligations [13.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 1549]: Threads::AutoBrake.i
P [159] << p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:    normalization of [serial 1535]

[serial 1551]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1537]

[serial 1553]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1543]

[serial 1555]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1544]

[serial 1557]: Threads::AutoBrake.i
P [163] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1545]

[serial 1559]: Threads::AutoBrake.i
P [163] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1546]

[serial 1561]: Threads::AutoBrake.i
P [163] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1547]
Done Normalizing
step:  241
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1549]: Threads::AutoBrake.i
P [159] << p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:    normalization of [serial 1535]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1569]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1549]

This Proof Obligation:

[serial 1553]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1543]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1570]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1553]

This Proof Obligation:

[serial 1555]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1544]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1571]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1555]

This Proof Obligation:

[serial 1557]: Threads::AutoBrake.i
P [163] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1545]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1572]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1557]

This Proof Obligation:

[serial 1559]: Threads::AutoBrake.i
P [163] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1546]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1573]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1559]

This Proof Obligation:

[serial 1561]: Threads::AutoBrake.i
P [163] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1547]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1574]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1561]
. . . done Applying Laws [13.6 seconds ]
After "laws" remaining 
Obligations:

[serial 1551]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1537]

[serial 1569]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1549]

[serial 1570]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1553]

[serial 1571]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1555]

[serial 1572]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1557]

[serial 1573]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1559]

[serial 1574]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1561]
Done applying laws
step:  242
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1569]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1549]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1575]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and true
  and true
  and true
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [13.6 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1551]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1537]

[serial 1570]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1553]

[serial 1571]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1555]

[serial 1572]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1557]

[serial 1573]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1559]

[serial 1574]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1561]

[serial 1575]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and true
  and true
  and true
  and true >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  243
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1575]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and true
  and true
  and true
  and true >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1576]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Law of And-Simplification:  P and true is P [serial 1575]
. . . done Applying Laws [13.6 seconds ]
After "laws" remaining 
Obligations:

[serial 1551]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1537]

[serial 1570]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1553]

[serial 1571]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1555]

[serial 1572]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1557]

[serial 1573]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1559]

[serial 1574]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1561]

[serial 1576]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Law of And-Simplification:  P and true is P [serial 1575]
Done applying laws
step:  244
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1576]: Threads::AutoBrake.i
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159]->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Law of And-Simplification:  P and true is P [serial 1575]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [13.6 seconds ]
After "axioms" remaining 
Obligations:

[serial 1551]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1537]

[serial 1570]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1553]

[serial 1571]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1555]

[serial 1572]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1557]

[serial 1573]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1559]

[serial 1574]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1561]
Done trying to apply axioms
step:  245
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  246
#Threads::AutoBrake.i
step:  247
#[serial 1559]   normalization of [serial 154
step:  248
****make-an****
Making obligation 34
Obligations:

[serial 1551]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1537]
Done making obligation 34
step:  249
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1551]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1537]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1577]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( ( not ( v < iSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1551]
. . . Substituting <= with not < [13.6 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1577]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( ( not ( v < iSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1551]
Done replacing a<=b with (not b<a)
step:  250
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1577]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( ( not ( v < iSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1551]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1579]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v < iSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1577]
. . . done Normalizing Unsolved Proof Obligations [13.6 seconds ]
After "normalize" remaining 
Obligations:

[serial 1579]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v < iSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1577]
Done Normalizing
step:  251
****conjunctive-normal-form****
Transforming into Conjunctive Normal Form . . .

This Proof Obligation:

[serial 1579]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v < iSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
What for:    normalization of [serial 1577]
Reason solved:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
Has applied Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into conjunctive normal form to get:

[serial 1581]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1579]
. . . done putting into conjunctive normal form [13.7 seconds ]
After "conjunctive normal form" remaining 
Obligations:

[serial 1581]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1579]
Done making conjunctive normal forms.
step:  252
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1581]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1579]
Reason solved:  Law of Excluded Middle: P or not P is tautology
Has applied law "Law of Excluded Middle: P or not P is tautology " to get:

[serial 1582]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1581]

This Proof Obligation:

[serial 1582]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of Excluded Middle: P or not P is tautology [serial 1581]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1583]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1582]

This Proof Obligation:

[serial 1583]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1582]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1584]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1583]

This Proof Obligation:

[serial 1584]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1583]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1585]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1584]

This Proof Obligation:

[serial 1585]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1584]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1586]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1585]

This Proof Obligation:

[serial 1586]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true )
  and ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1585]
Reason solved:  Law of And-Simplification:  P and P is P
Has applied law "Law of And-Simplification:  P and P is P " to get:

[serial 1587]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1586]
. . . done Applying Laws [13.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1587]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1586]
Done applying laws
step:  253
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1587]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << ( true ) >>
What for:  Law of And-Simplification:  P and P is P [serial 1586]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1589]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << true >>
What for:    normalization of [serial 1587]
. . . done Normalizing Unsolved Proof Obligations [13.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1589]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << true >>
What for:    normalization of [serial 1587]
Done Normalizing
step:  254
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1589]: Threads::AutoBrake.i
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]->
Q [163] << true >>
What for:    normalization of [serial 1587]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [13.7 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1570]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1553]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  255
#[serial 1578] Associativity: (b.c).a = a.b.c [serial 1561]
step:  256
****reduce****

Reducing Concurrent Computation of:

[serial 1570]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1553]
Reason solved:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1591]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]eb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1570]

[serial 1592]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1570]

[serial 1593]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1570]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1591]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]eb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1570]

[serial 1592]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1570]

[serial 1593]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1570]
done reducing composite actions
step:  257
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
newPortAssertion=EB()

This Proof Obligation:

[serial 1591]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]eb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1570]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(eb)[eb|true]>>  for <<pre>> eb!(true) <<post>> to get:

[serial 1594]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1591]

The Same Proof Obligation:
Has applied <<pre and (EB())@now>> -> <<post>> for  <<pre>> eb!(true) <<post>> to get:

[serial 1595]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( EB() )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1591]
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=not ( SB()
  and not EB() )

This Proof Obligation:

[serial 1592]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1570]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(sb)[sb|false]>>  for <<pre>> sb!(false) <<post>> to get:

[serial 1596]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [165] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1592]

The Same Proof Obligation:
Has applied <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> for  <<pre>> sb!(false) <<post>> to get:

[serial 1597]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( not ( SB()
  and not EB() ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1592]
Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB()
                                             or EB() ))-> 0 mpss, (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB()
      or EB() ))-> 0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1593]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1570]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied <<pre and (ca=0 mpss)@now>> -> <<post>> for  <<pre>> ca!(QUANTITY) <<post>> to get:

[serial 1598]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( ca = ( 0 mpss ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1593]
Has applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>>where (( SB()
   or EB() ))-> 0 mpss for ca!(0 mpss) to get:

[serial 1599]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1593]
. . . done applying atomic actions [13.7 seconds ]
After "atomic" remaining 
Obligations:

[serial 1594]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1591]

[serial 1595]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( EB() )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1591]

[serial 1596]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [165] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1592]

[serial 1597]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( not ( SB()
  and not EB() ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1592]

[serial 1598]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( ca = ( 0 mpss ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1593]

[serial 1599]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1593]
Done reducing atomic actions
step:  258
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1595]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( EB() )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1591]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1600]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( EB() )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1595]

This Proof Obligation:

[serial 1597]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( not ( SB()
  and not EB() ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1592]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1601]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( not ( SB()
  and not EB() ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1597]

This Proof Obligation:

[serial 1598]: Threads::AutoBrake.i
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( ca = ( 0 mpss ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1593]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1602]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( ca = ( 0 mpss ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1598]
. . . done Applying Laws [13.7 seconds ]
After "laws" remaining 
Obligations:

[serial 1594]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1591]

[serial 1596]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [165] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1592]

[serial 1599]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1593]

[serial 1600]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( EB() )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1595]

[serial 1601]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( not ( SB()
  and not EB() ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1597]

[serial 1602]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( ca = ( 0 mpss ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1598]
Done applying laws
step:  259
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1600]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( EB() )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1595]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1601]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( not ( SB()
  and not EB() ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1597]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1602]: Threads::AutoBrake.i
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( ca = ( 0 mpss ) )@now >>
S [165]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1598]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [13.7 seconds ]
After "axioms" remaining 
Obligations:

[serial 1594]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1591]

[serial 1596]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [165] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1592]

[serial 1599]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1593]
Done trying to apply axioms
step:  260
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1594]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1591]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1603]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1594]

This Proof Obligation:

[serial 1596]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [165] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1592]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1604]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [165] << not ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1596]

This Proof Obligation:

[serial 1599]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1593]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1605]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1599]
. . . done substituting assertions' for Labels [13.7 seconds ]
After "substitute" remaining 
Obligations:

[serial 1603]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1594]

[serial 1604]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [165] << not ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1596]

[serial 1605]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1599]
Done substituting Assertion labels.
step:  261
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1603]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1594]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1607]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1603]

This Proof Obligation:

[serial 1604]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [165] << not ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1596]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1609]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << not ( not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:    normalization of [serial 1604]

This Proof Obligation:

[serial 1605]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165]->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1599]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1611]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1605]
. . . done Normalizing Unsolved Proof Obligations [13.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1607]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1603]

[serial 1609]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << not ( not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:    normalization of [serial 1604]

[serial 1611]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1605]
Done Normalizing
step:  262
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 iSeg.v_e <= v


This Proof Obligation:

[serial 1607]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1603]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [13.7 seconds ]
After "axioms" remaining 
Obligations:

[serial 1609]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << not ( not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:    normalization of [serial 1604]

[serial 1611]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1605]
Done trying to apply axioms
step:  263
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1609]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << not ( not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:    normalization of [serial 1604]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1615]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << ( not ( ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or not ( ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1609]
. . . done applying DeMorgan's Law  [13.7 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1611]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1605]

[serial 1615]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << ( not ( ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or not ( ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1609]
step:  264
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1615]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << ( not ( ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or not ( ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1609]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1618]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << not ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) )
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1615]
. . . done Normalizing Unsolved Proof Obligations [13.7 seconds ]
After "normalize" remaining 
Obligations:

[serial 1611]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1605]

[serial 1618]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << not ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) )
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1615]
Done Normalizing
step:  265
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1618]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << not ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) )
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1615]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1620]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << ( not ( not ( iSeg.v_e <= v ) )
   or not ( not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1618]
. . . done applying DeMorgan's Law  [13.8 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1611]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1605]

[serial 1620]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << ( not ( not ( iSeg.v_e <= v ) )
   or not ( not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1618]
step:  266
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1620]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << ( not ( not ( iSeg.v_e <= v ) )
   or not ( not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1618]
Reasons solved:  
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1623]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1620]
. . . done Normalizing Unsolved Proof Obligations [13.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1611]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1605]

[serial 1623]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1620]
Done Normalizing
step:  267
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1611]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1605]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1625]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
What for:  Associativity: (b.c).a = a.b.c [serial 1611]

This Proof Obligation:

[serial 1623]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1620]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1626]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1623]
. . . done Applying Laws [13.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1625]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
What for:  Associativity: (b.c).a = a.b.c [serial 1611]

[serial 1626]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1623]
Done applying laws
step:  268
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 iSeg.v_e <= v


This Proof Obligation:

[serial 1625]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
What for:  Associativity: (b.c).a = a.b.c [serial 1611]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 iSeg.v_e <= v


This Proof Obligation:

[serial 1626]: Threads::AutoBrake.i
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165]->
Q [165] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1623]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [13.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1571]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1555]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  269
#[serial 1579] Associativity: (b.c).a = a.b.c [serial 1563]
step:  270
****reduce****

Reducing Concurrent Computation of:

[serial 1571]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]  eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1555]
Reason solved:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1627]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]eb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1571]

[serial 1628]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1571]

[serial 1629]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1571]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1627]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]eb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1571]

[serial 1628]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1571]

[serial 1629]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1571]
done reducing composite actions
step:  271
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
newPortAssertion=EB()

This Proof Obligation:

[serial 1627]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]eb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1571]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(eb)[eb|true]>>  for <<pre>> eb!(true) <<post>> to get:

[serial 1630]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1627]

The Same Proof Obligation:
Has applied <<pre and (EB())@now>> -> <<post>> for  <<pre>> eb!(true) <<post>> to get:

[serial 1631]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( EB() )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1627]
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=not ( SB()
  and not EB() )

This Proof Obligation:

[serial 1628]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1571]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(sb)[sb|false]>>  for <<pre>> sb!(false) <<post>> to get:

[serial 1632]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [168] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1628]

The Same Proof Obligation:
Has applied <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> for  <<pre>> sb!(false) <<post>> to get:

[serial 1633]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( not ( SB()
  and not EB() ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1628]
Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB()
                                             or EB() ))-> 0 mpss, (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB()
      or EB() ))-> 0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1629]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1571]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied <<pre and (ca=0 mpss)@now>> -> <<post>> for  <<pre>> ca!(QUANTITY) <<post>> to get:

[serial 1634]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( ca = ( 0 mpss ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1629]
Has applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>>where (( SB()
   or EB() ))-> 0 mpss for ca!(0 mpss) to get:

[serial 1635]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1629]
. . . done applying atomic actions [13.8 seconds ]
After "atomic" remaining 
Obligations:

[serial 1630]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1627]

[serial 1631]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( EB() )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1627]

[serial 1632]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [168] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1628]

[serial 1633]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( not ( SB()
  and not EB() ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1628]

[serial 1634]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( ca = ( 0 mpss ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1629]

[serial 1635]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1629]
Done reducing atomic actions
step:  272
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1630]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [14] << EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1627]
Reason solved:  Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1637]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [14] << EB() >>
What for:    normalization of [serial 1630]

This Proof Obligation:

[serial 1631]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( EB() )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1627]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1639]: Threads::AutoBrake.i
P [168] << EB()@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1631]

This Proof Obligation:

[serial 1632]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [168] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1628]
Reason solved:  Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1641]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [168] << not ( SB()
  and not EB() ) >>
What for:    normalization of [serial 1632]

This Proof Obligation:

[serial 1633]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( not ( SB()
  and not EB() ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1628]
Reason solved:  Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1643]: Threads::AutoBrake.i
P [168] << ( not ( SB()
  and not EB() ) )@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1633]

This Proof Obligation:

[serial 1634]: Threads::AutoBrake.i
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( ca = ( 0 mpss ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1629]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1645]: Threads::AutoBrake.i
P [168] << ( ca = 0 mpss )@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1634]

This Proof Obligation:

[serial 1635]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1629]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1647]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1635]
. . . done Normalizing Unsolved Proof Obligations [13.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1637]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [14] << EB() >>
What for:    normalization of [serial 1630]

[serial 1639]: Threads::AutoBrake.i
P [168] << EB()@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1631]

[serial 1641]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [168] << not ( SB()
  and not EB() ) >>
What for:    normalization of [serial 1632]

[serial 1643]: Threads::AutoBrake.i
P [168] << ( not ( SB()
  and not EB() ) )@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1633]

[serial 1645]: Threads::AutoBrake.i
P [168] << ( ca = 0 mpss )@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1634]

[serial 1647]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1635]
Done Normalizing
step:  273
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1639]: Threads::AutoBrake.i
P [168] << EB()@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1631]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1654]: Threads::AutoBrake.i
P [168] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and EB()@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1639]

This Proof Obligation:

[serial 1643]: Threads::AutoBrake.i
P [168] << ( not ( SB()
  and not EB() ) )@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1633]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1655]: Threads::AutoBrake.i
P [168] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not ( SB()
  and not EB() ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1643]

This Proof Obligation:

[serial 1645]: Threads::AutoBrake.i
P [168] << ( ca = 0 mpss )@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:    normalization of [serial 1634]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1656]: Threads::AutoBrake.i
P [168] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = 0 mpss )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1645]
. . . done Applying Laws [13.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1637]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [14] << EB() >>
What for:    normalization of [serial 1630]

[serial 1641]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [168] << not ( SB()
  and not EB() ) >>
What for:    normalization of [serial 1632]

[serial 1647]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1635]

[serial 1654]: Threads::AutoBrake.i
P [168] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and EB()@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1639]

[serial 1655]: Threads::AutoBrake.i
P [168] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not ( SB()
  and not EB() ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1643]

[serial 1656]: Threads::AutoBrake.i
P [168] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = 0 mpss )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1645]
Done applying laws
step:  274
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1654]: Threads::AutoBrake.i
P [168] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and EB()@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1639]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1655]: Threads::AutoBrake.i
P [168] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not ( SB()
  and not EB() ) )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1643]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1656]: Threads::AutoBrake.i
P [168] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = 0 mpss )@now >>
S [168]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1645]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [13.8 seconds ]
After "axioms" remaining 
Obligations:

[serial 1637]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [14] << EB() >>
What for:    normalization of [serial 1630]

[serial 1641]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [168] << not ( SB()
  and not EB() ) >>
What for:    normalization of [serial 1632]

[serial 1647]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1635]
Done trying to apply axioms
step:  275
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1641]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [168] << not ( SB()
  and not EB() ) >>
What for:    normalization of [serial 1632]
Reason solved:  DeMorgan's Law: not (A and B) = (not A) or (not B)
Has applied DeMorgan's Law: not (A and B) = (not A) or (not B)  to get:

[serial 1657]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [168] << ( not ( SB() )
   or not ( not EB() ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1641]
. . . done applying DeMorgan's Law  [13.8 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1637]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [14] << EB() >>
What for:    normalization of [serial 1630]

[serial 1647]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1635]

[serial 1657]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [168] << ( not ( SB() )
   or not ( not EB() ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1641]
step:  276
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1657]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [168] << ( not ( SB() )
   or not ( not EB() ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1641]
Reasons solved:  
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1661]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [168] << EB()
   or not SB() >>
What for:    normalization of [serial 1657]
. . . done Normalizing Unsolved Proof Obligations [13.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1637]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [14] << EB() >>
What for:    normalization of [serial 1630]

[serial 1647]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1635]

[serial 1661]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [168] << EB()
   or not SB() >>
What for:    normalization of [serial 1657]
Done Normalizing
step:  277
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1637]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [14] << EB() >>
What for:    normalization of [serial 1630]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1663]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1637]

This Proof Obligation:

[serial 1647]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [33] << EB()
   or SB() >>
What for:    normalization of [serial 1635]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1664]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1647]

This Proof Obligation:

[serial 1661]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168]->
Q [168] << EB()
   or not SB() >>
What for:    normalization of [serial 1657]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1665]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [168] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1661]
. . . done substituting assertions' for Labels [13.8 seconds ]
After "substitute" remaining 
Obligations:

[serial 1663]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1637]

[serial 1664]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1647]

[serial 1665]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [168] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1661]
Done substituting Assertion labels.
step:  278
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1663]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1637]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1667]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1663]

This Proof Obligation:

[serial 1664]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1647]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1669]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1664]

This Proof Obligation:

[serial 1665]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168]->
Q [168] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1661]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1671]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [168] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1665]
. . . done Normalizing Unsolved Proof Obligations [13.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1667]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1663]

[serial 1669]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1664]

[serial 1671]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [168] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1665]
Done Normalizing
step:  279
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1669]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1664]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1675]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
What for:  Associativity: (b.c).a = a.b.c [serial 1669]

This Proof Obligation:

[serial 1671]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [168] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1665]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1676]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [168] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1671]
. . . done Applying Laws [13.8 seconds ]
After "laws" remaining 
Obligations:

[serial 1667]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1663]

[serial 1675]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
What for:  Associativity: (b.c).a = a.b.c [serial 1669]

[serial 1676]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [168] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1671]
Done applying laws
step:  280
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1675]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
What for:  Associativity: (b.c).a = a.b.c [serial 1669]
Reason solved:  Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1679]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [33] << iSeg.v_e <= v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1675]
. . . done Normalizing Unsolved Proof Obligations [13.8 seconds ]
After "normalize" remaining 
Obligations:

[serial 1667]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1663]

[serial 1676]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [168] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1671]

[serial 1679]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [33] << iSeg.v_e <= v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1675]
Done Normalizing
step:  281
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v


This Proof Obligation:

[serial 1667]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1663]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v


This Proof Obligation:

[serial 1676]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [168] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1671]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v


This Proof Obligation:

[serial 1679]: Threads::AutoBrake.i
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168]->
Q [33] << iSeg.v_e <= v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
What for:    normalization of [serial 1675]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [13.8 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1572]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1557]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  282
#[serial 1580] Associativity: (b.c).a = a.b.c [serial 1565]
step:  283
****reduce****

Reducing Concurrent Computation of:

[serial 1572]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1557]
Reason solved:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1682]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]sb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1572]

[serial 1683]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1572]

[serial 1684]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1572]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1682]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]sb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1572]

[serial 1683]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1572]

[serial 1684]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1572]
done reducing composite actions
step:  284
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=SB()
  and not EB()

This Proof Obligation:

[serial 1682]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]sb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1572]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(sb)[sb|true]>>  for <<pre>> sb!(true) <<post>> to get:

[serial 1685]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1682]

The Same Proof Obligation:
Has applied <<pre and (SB()
  and not EB())@now>> -> <<post>> for  <<pre>> sb!(true) <<post>> to get:

[serial 1686]: Threads::AutoBrake.i
P [172] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1682]
Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
newPortAssertion=not EB()

This Proof Obligation:

[serial 1683]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1572]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(eb)[eb|false]>>  for <<pre>> eb!(false) <<post>> to get:

[serial 1687]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [172] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1683]

The Same Proof Obligation:
Has applied <<pre and (not EB())@now>> -> <<post>> for  <<pre>> eb!(false) <<post>> to get:

[serial 1688]: Threads::AutoBrake.i
P [172] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1683]
Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB()
                                             or EB() ))-> 0 mpss, (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB()
      or EB() ))-> 0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1684]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1572]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied <<pre and (ca=0 mpss)@now>> -> <<post>> for  <<pre>> ca!(QUANTITY) <<post>> to get:

[serial 1689]: Threads::AutoBrake.i
P [172] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( ca = ( 0 mpss ) )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1684]
Has applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>>where (( SB()
   or EB() ))-> 0 mpss for ca!(0 mpss) to get:

[serial 1690]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1684]
. . . done applying atomic actions [13.9 seconds ]
After "atomic" remaining 
Obligations:

[serial 1685]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1682]

[serial 1686]: Threads::AutoBrake.i
P [172] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1682]

[serial 1687]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [172] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1683]

[serial 1688]: Threads::AutoBrake.i
P [172] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1683]

[serial 1689]: Threads::AutoBrake.i
P [172] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( ca = ( 0 mpss ) )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1684]

[serial 1690]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1684]
Done reducing atomic actions
step:  285
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1686]: Threads::AutoBrake.i
P [172] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1682]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1691]: Threads::AutoBrake.i
P [172] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( SB()
  and not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1686]

This Proof Obligation:

[serial 1688]: Threads::AutoBrake.i
P [172] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1683]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1692]: Threads::AutoBrake.i
P [172] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1688]

This Proof Obligation:

[serial 1689]: Threads::AutoBrake.i
P [172] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( ca = ( 0 mpss ) )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1684]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1693]: Threads::AutoBrake.i
P [172] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = ( 0 mpss ) )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1689]
. . . done Applying Laws [13.9 seconds ]
After "laws" remaining 
Obligations:

[serial 1685]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1682]

[serial 1687]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [172] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1683]

[serial 1690]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1684]

[serial 1691]: Threads::AutoBrake.i
P [172] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( SB()
  and not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1686]

[serial 1692]: Threads::AutoBrake.i
P [172] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1688]

[serial 1693]: Threads::AutoBrake.i
P [172] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = ( 0 mpss ) )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1689]
Done applying laws
step:  286
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1691]: Threads::AutoBrake.i
P [172] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( SB()
  and not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1686]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1692]: Threads::AutoBrake.i
P [172] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not EB() )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1688]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1693]: Threads::AutoBrake.i
P [172] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = ( 0 mpss ) )@now >>
S [172]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1689]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [13.9 seconds ]
After "axioms" remaining 
Obligations:

[serial 1685]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1682]

[serial 1687]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [172] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1683]

[serial 1690]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1684]
Done trying to apply axioms
step:  287
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1685]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1682]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1694]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1685]

This Proof Obligation:

[serial 1687]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [172] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1683]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1695]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [172] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1687]

This Proof Obligation:

[serial 1690]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1684]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1696]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1690]
. . . done substituting assertions' for Labels [13.9 seconds ]
After "substitute" remaining 
Obligations:

[serial 1694]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1685]

[serial 1695]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [172] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1687]

[serial 1696]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1690]
Done substituting Assertion labels.
step:  288
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1694]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1685]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1698]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1694]

This Proof Obligation:

[serial 1695]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [172] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1687]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1700]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1695]

This Proof Obligation:

[serial 1696]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172]->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1690]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1702]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1696]
. . . done Normalizing Unsolved Proof Obligations [13.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1698]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1694]

[serial 1700]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1695]

[serial 1702]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1696]
Done Normalizing
step:  289
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1698]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1694]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1706]: Threads::AutoBrake.i
P [163] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1698]

This Proof Obligation:

[serial 1700]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1695]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1707]: Threads::AutoBrake.i
P [163] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1700]

This Proof Obligation:

[serial 1702]: Threads::AutoBrake.i
P [163] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1696]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1708]: Threads::AutoBrake.i
P [163] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1702]
. . . Substituting <= with not < [13.9 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1706]: Threads::AutoBrake.i
P [163] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1698]

[serial 1707]: Threads::AutoBrake.i
P [163] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1700]

[serial 1708]: Threads::AutoBrake.i
P [163] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1702]
Done replacing a<=b with (not b<a)
step:  290
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1706]: Threads::AutoBrake.i
P [163] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1698]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1710]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1706]

This Proof Obligation:

[serial 1707]: Threads::AutoBrake.i
P [163] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1700]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1712]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1707]

This Proof Obligation:

[serial 1708]: Threads::AutoBrake.i
P [163] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1702]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1714]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1708]
. . . done Normalizing Unsolved Proof Obligations [13.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1710]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1706]

[serial 1712]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1707]

[serial 1714]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1708]
Done Normalizing
step:  291
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1710]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1706]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1718]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1710]

This Proof Obligation:

[serial 1712]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1707]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1719]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1712]
. . . done applying DeMorgan's Law  [13.9 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1714]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1708]

[serial 1718]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1710]

[serial 1719]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1712]
step:  292
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1718]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1710]
Reasons solved:  
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1722]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1718]

This Proof Obligation:

[serial 1719]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1712]
Reasons solved:  
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1724]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1719]
. . . done Normalizing Unsolved Proof Obligations [13.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1714]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1708]

[serial 1722]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1718]

[serial 1724]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1719]
Done Normalizing
step:  293
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1724]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [172] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1719]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [13.9 seconds ]
After "axioms" remaining 
Obligations:

[serial 1714]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1708]

[serial 1722]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1718]
Done trying to apply axioms
step:  294
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1714]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1708]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1727]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1714]

This Proof Obligation:

[serial 1722]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1718]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1728]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1722]
. . . done Applying Laws [13.9 seconds ]
After "laws" remaining 
Obligations:

[serial 1727]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1714]

[serial 1728]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1722]
Done applying laws
step:  295
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1728]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1722]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1729]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1728]

[serial 1730]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1728]

[serial 1731]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1728]
. . . done splitting postcondition  [13.9 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1727]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1714]

[serial 1729]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1728]

[serial 1730]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1728]

[serial 1731]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1728]
Done splitting postcondition
step:  296
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 not ( v < iSeg.v_n )


This Proof Obligation:

[serial 1727]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1714]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

This Proof Obligation:

[serial 1729]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1728]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1730]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1728]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [13.9 seconds ]
After "axioms" remaining 
Obligations:

[serial 1731]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1728]
Done trying to apply axioms
step:  297
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1731]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1728]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1733]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1731]
. . . done Normalizing Unsolved Proof Obligations [13.9 seconds ]
After "normalize" remaining 
Obligations:

[serial 1733]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1731]
Done Normalizing
step:  298
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 not ( v < iSeg.v_n )


This Proof Obligation:

[serial 1733]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172]->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1731]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [13.9 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1573]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1559]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  299
#[serial 1581] Associativity: (b.c).a = a.b.c [serial 1567]
step:  300
****reduce****

Reducing Concurrent Computation of:

[serial 1573]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]  sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1559]
Reason solved:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1735]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]sb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1573]

[serial 1736]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1573]

[serial 1737]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1573]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1735]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]sb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1573]

[serial 1736]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1573]

[serial 1737]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1573]
done reducing composite actions
step:  301
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=SB()
  and not EB()

This Proof Obligation:

[serial 1735]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]sb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1573]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(sb)[sb|true]>>  for <<pre>> sb!(true) <<post>> to get:

[serial 1738]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1735]

The Same Proof Obligation:
Has applied <<pre and (SB()
  and not EB())@now>> -> <<post>> for  <<pre>> sb!(true) <<post>> to get:

[serial 1739]: Threads::AutoBrake.i
P [177] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1735]
Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
newPortAssertion=not EB()

This Proof Obligation:

[serial 1736]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1573]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(eb)[eb|false]>>  for <<pre>> eb!(false) <<post>> to get:

[serial 1740]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [177] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1736]

The Same Proof Obligation:
Has applied <<pre and (not EB())@now>> -> <<post>> for  <<pre>> eb!(false) <<post>> to get:

[serial 1741]: Threads::AutoBrake.i
P [177] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1736]
Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB()
                                             or EB() ))-> 0 mpss, (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB()
      or EB() ))-> 0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1737]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1573]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied <<pre and (ca=0 mpss)@now>> -> <<post>> for  <<pre>> ca!(QUANTITY) <<post>> to get:

[serial 1742]: Threads::AutoBrake.i
P [177] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( ca = ( 0 mpss ) )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1737]
Has applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>>where (( SB()
   or EB() ))-> 0 mpss for ca!(0 mpss) to get:

[serial 1743]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1737]
. . . done applying atomic actions [13.9 seconds ]
After "atomic" remaining 
Obligations:

[serial 1738]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1735]

[serial 1739]: Threads::AutoBrake.i
P [177] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1735]

[serial 1740]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [177] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1736]

[serial 1741]: Threads::AutoBrake.i
P [177] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1736]

[serial 1742]: Threads::AutoBrake.i
P [177] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( ca = ( 0 mpss ) )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1737]

[serial 1743]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1737]
Done reducing atomic actions
step:  302
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1739]: Threads::AutoBrake.i
P [177] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1735]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1744]: Threads::AutoBrake.i
P [177] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( SB()
  and not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1739]

This Proof Obligation:

[serial 1741]: Threads::AutoBrake.i
P [177] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1736]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1745]: Threads::AutoBrake.i
P [177] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1741]

This Proof Obligation:

[serial 1742]: Threads::AutoBrake.i
P [177] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( ca = ( 0 mpss ) )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1737]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1746]: Threads::AutoBrake.i
P [177] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = ( 0 mpss ) )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1742]
. . . done Applying Laws [14.0 seconds ]
After "laws" remaining 
Obligations:

[serial 1738]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1735]

[serial 1740]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [177] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1736]

[serial 1743]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1737]

[serial 1744]: Threads::AutoBrake.i
P [177] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( SB()
  and not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1739]

[serial 1745]: Threads::AutoBrake.i
P [177] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1741]

[serial 1746]: Threads::AutoBrake.i
P [177] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = ( 0 mpss ) )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1742]
Done applying laws
step:  303
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1744]: Threads::AutoBrake.i
P [177] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( SB()
  and not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1739]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1745]: Threads::AutoBrake.i
P [177] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not EB() )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1741]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1746]: Threads::AutoBrake.i
P [177] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = ( 0 mpss ) )@now >>
S [177]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1742]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [14.0 seconds ]
After "axioms" remaining 
Obligations:

[serial 1738]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1735]

[serial 1740]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [177] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1736]

[serial 1743]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1737]
Done trying to apply axioms
step:  304
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1738]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [12] << SB()
  and not EB() >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1735]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1747]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1738]

This Proof Obligation:

[serial 1740]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [177] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1736]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1748]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [177] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1740]

This Proof Obligation:

[serial 1743]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]->
Q [33] << ( SB()
   or EB() ) >>
What for:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1737]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1749]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1743]
. . . done substituting assertions' for Labels [14.0 seconds ]
After "substitute" remaining 
Obligations:

[serial 1747]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1738]

[serial 1748]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [177] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1740]

[serial 1749]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1743]
Done substituting Assertion labels.
step:  305
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1747]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1738]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1751]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1747]

This Proof Obligation:

[serial 1748]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [177] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1740]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1753]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1748]

This Proof Obligation:

[serial 1749]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177]->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1743]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1755]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1749]
. . . done Normalizing Unsolved Proof Obligations [14.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1751]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1747]

[serial 1753]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1748]

[serial 1755]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1749]
Done Normalizing
step:  306
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1751]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1747]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1759]: Threads::AutoBrake.i
P [163] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1751]

This Proof Obligation:

[serial 1753]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1748]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1760]: Threads::AutoBrake.i
P [163] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1753]

This Proof Obligation:

[serial 1755]: Threads::AutoBrake.i
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
What for:    normalization of [serial 1749]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1761]: Threads::AutoBrake.i
P [163] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1755]
. . . Substituting <= with not < [14.0 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1759]: Threads::AutoBrake.i
P [163] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1751]

[serial 1760]: Threads::AutoBrake.i
P [163] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1753]

[serial 1761]: Threads::AutoBrake.i
P [163] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1755]
Done replacing a<=b with (not b<a)
step:  307
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1759]: Threads::AutoBrake.i
P [163] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1751]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1763]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1759]

This Proof Obligation:

[serial 1760]: Threads::AutoBrake.i
P [163] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1753]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1765]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1760]

This Proof Obligation:

[serial 1761]: Threads::AutoBrake.i
P [163] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1755]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1767]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1761]
. . . done Normalizing Unsolved Proof Obligations [14.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1763]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1759]

[serial 1765]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1760]

[serial 1767]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1761]
Done Normalizing
step:  308
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1763]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1759]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1771]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1763]

This Proof Obligation:

[serial 1765]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1760]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1772]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1765]
. . . done applying DeMorgan's Law  [14.0 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1767]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1761]

[serial 1771]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1763]

[serial 1772]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1765]
step:  309
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1771]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1763]
Reasons solved:  
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1775]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1771]

This Proof Obligation:

[serial 1772]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1765]
Reasons solved:  
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1777]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1772]
. . . done Normalizing Unsolved Proof Obligations [14.0 seconds ]
After "normalize" remaining 
Obligations:

[serial 1767]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1761]

[serial 1775]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1771]

[serial 1777]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1772]
Done Normalizing
step:  310
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1777]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [177] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1772]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [14.0 seconds ]
After "axioms" remaining 
Obligations:

[serial 1767]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1761]

[serial 1775]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1771]
Done trying to apply axioms
step:  311
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1767]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1761]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1780]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1767]

This Proof Obligation:

[serial 1775]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:    normalization of [serial 1771]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1781]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1775]
. . . done Applying Laws [14.0 seconds ]
After "laws" remaining 
Obligations:

[serial 1780]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1767]

[serial 1781]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1775]
Done applying laws
step:  312
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1781]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1775]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1782]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1781]

[serial 1783]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1781]

[serial 1784]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1781]
. . . done splitting postcondition  [14.0 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1780]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1767]

[serial 1782]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1781]

[serial 1783]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1781]

[serial 1784]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1781]
Done splitting postcondition
step:  313
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )


This Proof Obligation:

[serial 1780]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1767]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)

This Proof Obligation:

[serial 1782]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1781]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1783]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1781]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [14.0 seconds ]
After "axioms" remaining 
Obligations:

[serial 1784]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1781]
Done trying to apply axioms
step:  314
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1784]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1781]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1786]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1784]
. . . done Normalizing Unsolved Proof Obligations [14.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1786]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1784]
Done Normalizing
step:  315
****axioms****
Applying Axioms . . .
AXIOM.and_elimination_or_intoduction_schema found this common term between the premise conjunction and conclusion disjunction:
 not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )


This Proof Obligation:

[serial 1786]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177]->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1784]
Reason solved:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
Has been solved by And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)
. . . done Applying Axioms [14.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1574]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1561]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  316
#[serial 1582] Associativity: (b.c).a = a.b.c [serial 1569]
step:  317
****reduce****

Reducing Concurrent Computation of:

[serial 1574]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]  sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1561]
Reason solved:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
To:

[serial 1788]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1574]

[serial 1789]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1574]

[serial 1790]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]ca!(xl)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1574]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1788]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1574]

[serial 1789]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1574]

[serial 1790]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]ca!(xl)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1574]
done reducing composite actions
step:  318
****atomic****
applying atomic actions . . .
Proof.reducePortOutput portValue=<< SB()
  and not EB() >>
newPortAssertion=not ( SB()
  and not EB() )

This Proof Obligation:

[serial 1788]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S1 <<Q>> in concurrent composition for [serial 1574]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(sb)[sb|false]>>  for <<pre>> sb!(false) <<post>> to get:

[serial 1791]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1788]

The Same Proof Obligation:
Has applied <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> for  <<pre>> sb!(false) <<post>> to get:

[serial 1792]: Threads::AutoBrake.i
P [182] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( SB()
  and not EB() ) )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1788]
Proof.reducePortOutput portValue=<< EB() >>
Proof.reducePortOutput ASSERTION referencedPred=<<EB: :v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
newPortAssertion=not EB()

This Proof Obligation:

[serial 1789]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S2 <<Q>> in concurrent composition for [serial 1574]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied when <<pre>> -> <<M(eb)[eb|false]>>  for <<pre>> eb!(false) <<post>> to get:

[serial 1793]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1789]

The Same Proof Obligation:
Has applied <<pre and (not EB())@now>> -> <<post>> for  <<pre>> eb!(false) <<post>> to get:

[serial 1794]: Threads::AutoBrake.i
P [182] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not EB() )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1789]
Proof.reducePortOutput portValue=<< returns quantity mpss  := TRAIN_XL() >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE referencedPred=<<TRAIN_XL:  returns quantity mpss  :=   [(( SB()
                                             or EB() ))-> 0 mpss, (( not SB()
                                            and not EB() ))-> OPERATOR_XL] >>
Proof.reducePortOutput ASSERTION_FUNCTION INVOKE portValue=<< returns quantity mpss  := TRAIN_XL() >>
Making Proof Obligation for Conditional Expression for Port Output:  ca
referenced predicate=
  [(( SB()
      or EB() ))-> 0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]

This Proof Obligation:

[serial 1790]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]ca!(xl)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  <<P>> S3 <<Q>> in concurrent composition for [serial 1574]
Reason solved:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
Has applied <<pre and (ca=xl)@now>> -> <<post>> for  <<pre>> ca!(xl) <<post>> to get:

[serial 1795]: Threads::AutoBrake.i
P [182] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( ca = xl )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1790]
looking through terms of
  [(( SB()
      or EB() ))-> 0 mpss, (( not SB()
     and not EB() ))-> OPERATOR_XL]
no term was found that had expression e:
 xl
. . . done applying atomic actions [14.1 seconds ]
After "atomic" remaining 
Obligations:

[serial 1791]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1788]

[serial 1792]: Threads::AutoBrake.i
P [182] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( SB()
  and not EB() ) )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1788]

[serial 1793]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1789]

[serial 1794]: Threads::AutoBrake.i
P [182] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not EB() )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1789]

[serial 1795]: Threads::AutoBrake.i
P [182] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( ca = xl )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1790]
Done reducing atomic actions
step:  319
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1792]: Threads::AutoBrake.i
P [182] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( SB()
  and not EB() ) )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1788]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1796]: Threads::AutoBrake.i
P [182] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( SB()
  and not EB() ) )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1792]

This Proof Obligation:

[serial 1794]: Threads::AutoBrake.i
P [182] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not EB() )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1789]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1797]: Threads::AutoBrake.i
P [182] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not EB() )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1794]

This Proof Obligation:

[serial 1795]: Threads::AutoBrake.i
P [182] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( ca = xl )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1790]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1798]: Threads::AutoBrake.i
P [182] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( ca = xl )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1795]
. . . done Applying Laws [14.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1791]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1788]

[serial 1793]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1789]

[serial 1796]: Threads::AutoBrake.i
P [182] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( SB()
  and not EB() ) )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1792]

[serial 1797]: Threads::AutoBrake.i
P [182] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not EB() )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1794]

[serial 1798]: Threads::AutoBrake.i
P [182] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( ca = xl )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1795]
Done applying laws
step:  320
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1796]: Threads::AutoBrake.i
P [182] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( SB()
  and not EB() ) )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1792]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1797]: Threads::AutoBrake.i
P [182] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not EB() )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1794]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)

This Proof Obligation:

[serial 1798]: Threads::AutoBrake.i
P [182] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( ca = xl )@now >>
S [182]->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
What for:  Associativity: (b.c).a = a.b.c [serial 1795]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [14.1 seconds ]
After "axioms" remaining 
Obligations:

[serial 1791]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1788]

[serial 1793]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1789]
Done trying to apply axioms
step:  321
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1791]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( SB()
  and not EB() ) >>
What for:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1788]
Reason solved:  DeMorgan's Law: not (A and B) = (not A) or (not B)
Has applied DeMorgan's Law: not (A and B) = (not A) or (not B)  to get:

[serial 1799]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( not ( SB() )
   or not ( not EB() ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1791]
. . . done applying DeMorgan's Law  [14.1 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1793]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1789]

[serial 1799]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( not ( SB() )
   or not ( not EB() ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1791]
step:  322
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1799]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( not ( SB() )
   or not ( not EB() ) ) >>
What for:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1791]
Reasons solved:  
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1802]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << EB()
   or not SB() >>
What for:    normalization of [serial 1799]
. . . done Normalizing Unsolved Proof Obligations [14.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1793]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1789]

[serial 1802]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << EB()
   or not SB() >>
What for:    normalization of [serial 1799]
Done Normalizing
step:  323
****substitute both****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1793]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not EB() >>
What for:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1789]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1804]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1793]

This Proof Obligation:

[serial 1802]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << EB()
   or not SB() >>
What for:    normalization of [serial 1799]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1805]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1802]
. . . done substituting assertions' for Labels [14.1 seconds ]
After "substitute" remaining 
Obligations:

[serial 1804]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1793]

[serial 1805]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1802]
Done substituting Assertion labels.
step:  324
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1804]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1793]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1807]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1804]

This Proof Obligation:

[serial 1805]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
What for:  Substituted assertions' predicates for labels  [serial 1802]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Multiplication: a*b=b*a
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
   Reflexivity of Disjunction: (m or k) = (k or m)
Has been normalized to get:

[serial 1809]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1805]
. . . done Normalizing Unsolved Proof Obligations [14.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1807]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1804]

[serial 1809]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1805]
Done Normalizing
step:  325
****replace<=****
Substituting <= with not < . . .

This Proof Obligation:

[serial 1807]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1804]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1812]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1807]

This Proof Obligation:

[serial 1809]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
What for:    normalization of [serial 1805]
Reason solved:  At Most Is Not Less Than: (a<=b) = not(b<a)
Has applied At Most Is Not Less Than: (a<=b) = not(b<a)  to get:

[serial 1813]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) )
   or ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1809]
. . . Substituting <= with not < [14.1 seconds ]
After "a<=b with (not b<a)" remaining 
Obligations:

[serial 1812]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1807]

[serial 1813]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) )
   or ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1809]
Done replacing a<=b with (not b<a)
step:  326
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1812]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1807]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1815]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1812]

This Proof Obligation:

[serial 1813]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) )
   or ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1809]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1817]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
   or ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1813]
. . . done Normalizing Unsolved Proof Obligations [14.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1815]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1812]

[serial 1817]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
   or ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1813]
Done Normalizing
step:  327
****DeMorgan****
Applying DeMorgan's Law . . .

This Proof Obligation:

[serial 1815]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1812]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1820]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1815]

This Proof Obligation:

[serial 1817]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
   or ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:    normalization of [serial 1813]
Reason solved:  DeMorgan's Law: not (A or B) = (not A) and (not B)
Has applied DeMorgan's Law: not (A or B) = (not A) and (not B)  to get:

[serial 1821]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) )
   or ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1817]
. . . done applying DeMorgan's Law  [14.1 seconds ]
After DeMorgan's Law remaining 
Obligations:

[serial 1820]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1815]

[serial 1821]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) )
   or ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1817]
step:  328
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1821]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) )
   or ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1817]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1822]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1821]
. . . done Applying Laws [14.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1820]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1815]

[serial 1822]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1821]
Done applying laws
step:  329
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1820]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
What for:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1815]
Reasons solved:  
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1824]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1820]

This Proof Obligation:

[serial 1822]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
What for:  Associativity: (b.c).a = a.b.c [serial 1821]
Reasons solved:  
   Complement
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1826]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1822]
. . . done Normalizing Unsolved Proof Obligations [14.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1824]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1820]

[serial 1826]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1822]
Done Normalizing
step:  330
****axioms****
Applying Axioms . . .
AXIOM.premise_has_all_terms_of_conjunction_within_conclusion_disjunction found, in premise conjunction, all terms of this conjunction within disjunction conclusion:
 v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n


This Proof Obligation:

[serial 1826]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
What for:    normalization of [serial 1822]
Reason solved:  Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}
Has been solved by Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}
. . . done Applying Axioms [14.1 seconds ]
After "axioms" remaining 
Obligations:

[serial 1824]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1820]
Done trying to apply axioms
step:  331
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1824]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [182] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:    normalization of [serial 1820]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1829]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1824]

[serial 1830]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1824]
. . . done splitting postcondition  [14.1 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1829]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1824]

[serial 1830]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1824]
Done splitting postcondition
step:  332
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1830]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1824]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [14.1 seconds ]
After "axioms" remaining 
Obligations:

[serial 1829]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1824]
Done trying to apply axioms
step:  333
****transitive****
Adding transitive relations to conjunctions having inequalities . . .
Adding transitive terms to conjunctions . . .
Transitivity:  v < iSeg.v_n and iSeg.v_n < iSeg.v_e -> v < iSeg.v_e

This Proof Obligation:

[serial 1829]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]->
Q [86] << v < iSeg.v_e >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1824]
Reason solved:  Transitivity: x<y and y<z -> x<z
Has applied Transitivity: x<y and y<z -> x<z  to get:

[serial 1831]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [182]->
Q [86] << v < iSeg.v_e >>
What for:  Transitivity: x<y and y<z -> x<z  [serial 1829]
. . . done adding transitive terms [14.1 seconds ]
After adding equivalent terms remaining 
Obligations:

[serial 1831]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [182]->
Q [86] << v < iSeg.v_e >>
What for:  Transitivity: x<y and y<z -> x<z  [serial 1829]
Done adding transitive relations
step:  334
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1831]: Threads::AutoBrake.i
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [182]->
Q [86] << v < iSeg.v_e >>
What for:  Transitivity: x<y and y<z -> x<z  [serial 1829]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [14.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1024]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( not m_a'fresh ) >>
S [186]->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:   <<M(CheckMoveForwardLastSegment) and x>> -> <<M(MoveForwardLastSegment)>> for NoMAYet: CheckMoveForwardLastSegment-[x]->MoveForwardLastSegment{};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  335
#[serial 1024]  <<M(CheckMoveForwardLastSegment) and x>> -> <<M(MoveForwardLastSegment)>> for NoMAYetCheckMoveForwardLastSegment-[x]->MoveForwardLastSegment{};
step:  336
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1024]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( not m_a'fresh ) >>
S [186]->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
What for:   <<M(CheckMoveForwardLastSegment) and x>> -> <<M(MoveForwardLastSegment)>> for NoMAYet: CheckMoveForwardLastSegment-[x]->MoveForwardLastSegment{};
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [14.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1025]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [191]  << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA
    and AXIOM_NEXT_MA_IS_RMA() >>
  m_a?(next_ma)
  ;
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA >>
  nSeg := next_ma.seg[1]
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA
    and nSeg = NEXT_MA.seg[1] >> 
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:   <<M(CheckMoveForwardLastSegment) and x>> A <<M(GotNewMA)>> for GetNewMA: CheckMoveForwardLastSegment-[x]->GotNewMA{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  337
#[serial 1025]  <<M(CheckMoveForwardLastSegment) and x>> A <<M(GotNewMA)>> for GetNewMACheckMoveForwardLastSegment-[x]->GotNewMA{A};
step:  338
****reduce****
This proof obligation:

[serial 1025]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [191]  << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA
    and AXIOM_NEXT_MA_IS_RMA() >>
  m_a?(next_ma)
  ;
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA >>
  nSeg := next_ma.seg[1]
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA
    and nSeg = NEXT_MA.seg[1] >> 
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:   <<M(CheckMoveForwardLastSegment) and x>> A <<M(GotNewMA)>> for GetNewMA: CheckMoveForwardLastSegment-[x]->GotNewMA{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P1>> S1 <<Q1>>
 
was reduced to:

[serial 1832]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [65]->
Q [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and AXIOM_NEXT_MA_IS_RMA() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1025]

[serial 1833]: Threads::AutoBrake.i
P [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1] >>
S [67]->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1025]

[serial 1834]: Threads::AutoBrake.i
P [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and AXIOM_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1025]

[serial 1835]: Threads::AutoBrake.i
P [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
S [196]nSeg := next_ma.seg[1]
Q [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1] >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1025]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1832]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [65]->
Q [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and AXIOM_NEXT_MA_IS_RMA() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1025]

[serial 1833]: Threads::AutoBrake.i
P [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1] >>
S [67]->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1025]

[serial 1834]: Threads::AutoBrake.i
P [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and AXIOM_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1025]

[serial 1835]: Threads::AutoBrake.i
P [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
S [196]nSeg := next_ma.seg[1]
Q [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1] >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1025]
done reducing composite actions
step:  339
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1832]: Threads::AutoBrake.i
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [65]->
Q [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and AXIOM_NEXT_MA_IS_RMA() >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1025]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1837]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
What for:    normalization of [serial 1832]

This Proof Obligation:

[serial 1833]: Threads::AutoBrake.i
P [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1] >>
S [67]->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:  <<Q2>> -> <<Q>> in sequential composition for [serial 1025]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1839]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1833]

This Proof Obligation:

[serial 1834]: Threads::AutoBrake.i
P [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and AXIOM_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1025]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1841]: Threads::AutoBrake.i
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:    normalization of [serial 1834]

This Proof Obligation:

[serial 1835]: Threads::AutoBrake.i
P [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
S [196]nSeg := next_ma.seg[1]
Q [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1] >>
What for:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1025]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1843]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]nSeg := next_ma.seg[1]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1835]
. . . done Normalizing Unsolved Proof Obligations [14.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1837]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
What for:    normalization of [serial 1832]

[serial 1839]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1833]

[serial 1841]: Threads::AutoBrake.i
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:    normalization of [serial 1834]

[serial 1843]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]nSeg := next_ma.seg[1]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1835]
Done Normalizing
step:  340
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1837]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
What for:    normalization of [serial 1832]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1848]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [14.1 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1839]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1833]

[serial 1841]: Threads::AutoBrake.i
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:    normalization of [serial 1834]

[serial 1843]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]nSeg := next_ma.seg[1]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1835]

[serial 1848]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and true >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  341
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1848]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and true >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1849]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
What for:  Law of And-Simplification:  P and true is P [serial 1848]
. . . done Applying Laws [14.1 seconds ]
After "laws" remaining 
Obligations:

[serial 1839]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1833]

[serial 1841]: Threads::AutoBrake.i
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:    normalization of [serial 1834]

[serial 1843]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]nSeg := next_ma.seg[1]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1835]

[serial 1849]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
What for:  Law of And-Simplification:  P and true is P [serial 1848]
Done applying laws
step:  342
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1849]: Threads::AutoBrake.i
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65]->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
What for:  Law of And-Simplification:  P and true is P [serial 1848]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [14.1 seconds ]
After "axioms" remaining 
Obligations:

[serial 1839]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1833]

[serial 1841]: Threads::AutoBrake.i
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:    normalization of [serial 1834]

[serial 1843]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]nSeg := next_ma.seg[1]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1835]
Done trying to apply axioms
step:  343
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  344
#Threads::AutoBrake.i
step:  345
#[serial 1857]   normalization of [serial 185
step:  346
****make-an****
Making obligation 42
Obligations:

[serial 1839]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1833]
Done making obligation 42
step:  347
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1839]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1833]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1850]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]

[serial 1851]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]

[serial 1852]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]

[serial 1853]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [68] << NEXT_MA = next_ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]

[serial 1854]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << NEXT_MA.seg[1] = nSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]
. . . done splitting postcondition  [14.1 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1850]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]

[serial 1851]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]

[serial 1852]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]

[serial 1853]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [68] << NEXT_MA = next_ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]

[serial 1854]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << NEXT_MA.seg[1] = nSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]
Done splitting postcondition
step:  348
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1850]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1851]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1853]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [68] << NEXT_MA = next_ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1854]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << NEXT_MA.seg[1] = nSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [14.1 seconds ]
After "axioms" remaining 
Obligations:

[serial 1852]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]
Done trying to apply axioms
step:  349
****guided-sub-equals****
guided substitution of equals "i" . . .
equality selected for substitution:  CMA.num_segments = i

This Proof Obligation:

[serial 1852]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]
Reason solved:  Guided Substitution of Equals
Has substituted 
"i" with its = "
^{CMA 
 ^{. num_segments}}"
 to get:

[serial 1855]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "
^{CMA 
 ^{. num_segments}}" in its postcondition [serial 1852]
. . . done guided substitution of equals  [14.1 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1855]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "
^{CMA 
 ^{. num_segments}}" in its postcondition [serial 1852]
Done guided substituting an equals
step:  350
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1855]: Threads::AutoBrake.i
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67]->
Q [67] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "
^{CMA 
 ^{. num_segments}}" in its postcondition [serial 1852]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [14.1 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1841]: Threads::AutoBrake.i
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:    normalization of [serial 1834]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  351
#[serial 1859]   normalization of [serial 1852]
step:  352
****atomic****
applying atomic actions . . .

This Proof Obligation:

[serial 1841]: Threads::AutoBrake.i
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
S [193]m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:    normalization of [serial 1834]
Reason solved:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
Has applied when <<pre and v=M(m_a)>> -> <<post>> for <<pre>> m_a?(next_ma) <<post>> to get:

[serial 1856]: Threads::AutoBrake.i
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() )
  and next_ma = RMA >>
S [193]->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:  applied port input of value <<pre and next_ma=M(m_a)>> -> <<post>> [serial 1841]
. . . done applying atomic actions [14.1 seconds ]
After "atomic" remaining 
Obligations:

[serial 1856]: Threads::AutoBrake.i
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() )
  and next_ma = RMA >>
S [193]->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:  applied port input of value <<pre and next_ma=M(m_a)>> -> <<post>> [serial 1841]
Done reducing atomic actions
step:  353
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1856]: Threads::AutoBrake.i
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() )
  and next_ma = RMA >>
S [193]->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:  applied port input of value <<pre and next_ma=M(m_a)>> -> <<post>> [serial 1841]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1858]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:    normalization of [serial 1856]
. . . done Normalizing Unsolved Proof Obligations [14.1 seconds ]
After "normalize" remaining 
Obligations:

[serial 1858]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:    normalization of [serial 1856]
Done Normalizing
step:  354
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1858]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
What for:    normalization of [serial 1856]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1860]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [195] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1858]

[serial 1861]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [194] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1858]

[serial 1862]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1858]

[serial 1863]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1858]
. . . done splitting postcondition  [14.2 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1860]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [195] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1858]

[serial 1861]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [194] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1858]

[serial 1862]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1858]

[serial 1863]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1858]
Done splitting postcondition
step:  355
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1860]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [195] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1858]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1864]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [195] << CMA = ma >>
What for:  Associativity: (b.c).a = a.b.c [serial 1860]

This Proof Obligation:

[serial 1861]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [194] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1858]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1865]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [194] << CMA.num_segments = i >>
What for:  Associativity: (b.c).a = a.b.c [serial 1861]

This Proof Obligation:

[serial 1862]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1858]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1866]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Associativity: (b.c).a = a.b.c [serial 1862]

This Proof Obligation:

[serial 1863]: Threads::AutoBrake.i
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1858]
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1867]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:  Associativity: (b.c).a = a.b.c [serial 1863]
. . . done Applying Laws [14.2 seconds ]
After "laws" remaining 
Obligations:

[serial 1864]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [195] << CMA = ma >>
What for:  Associativity: (b.c).a = a.b.c [serial 1860]

[serial 1865]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [194] << CMA.num_segments = i >>
What for:  Associativity: (b.c).a = a.b.c [serial 1861]

[serial 1866]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Associativity: (b.c).a = a.b.c [serial 1862]

[serial 1867]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:  Associativity: (b.c).a = a.b.c [serial 1863]
Done applying laws
step:  356
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1864]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [195] << CMA = ma >>
What for:  Associativity: (b.c).a = a.b.c [serial 1860]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1865]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [194] << CMA.num_segments = i >>
What for:  Associativity: (b.c).a = a.b.c [serial 1861]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1866]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Associativity: (b.c).a = a.b.c [serial 1862]

[serial 1867]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:  Associativity: (b.c).a = a.b.c [serial 1863]
Done trying to apply axioms
step:  357
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1866]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Associativity: (b.c).a = a.b.c [serial 1862]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1868]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( NEXT_MA = RMA )
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1866]

This Proof Obligation:

[serial 1867]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:  Associativity: (b.c).a = a.b.c [serial 1863]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1869]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( NEXT_MA = RMA )
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1867]
. . . done substituting assertions' for Labels [14.2 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1868]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( NEXT_MA = RMA )
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1866]

[serial 1869]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( NEXT_MA = RMA )
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1867]
Done substituting Assertion labels in preconditions
step:  358
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1868]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( NEXT_MA = RMA )
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1866]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1871]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:    normalization of [serial 1868]

This Proof Obligation:

[serial 1869]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( NEXT_MA = RMA )
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1867]
Reasons solved:  
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1873]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:    normalization of [serial 1869]
. . . done Normalizing Unsolved Proof Obligations [14.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1871]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:    normalization of [serial 1868]

[serial 1873]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:    normalization of [serial 1869]
Done Normalizing
step:  359
****guided-sub-equals****
guided substitution of equals "NEXT_MA" . . .
equality selected for substitution:  NEXT_MA = RMA
equality selected for substitution:  NEXT_MA = RMA

This Proof Obligation:

[serial 1873]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [194] << NEXT_MA = next_ma >>
What for:    normalization of [serial 1869]
Reason solved:  Guided Substitution of Equals
Has substituted 
"NEXT_MA" with its = "RMA"
 to get:

[serial 1876]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [194] << RMA = next_ma >>
What for:  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "RMA" in its postcondition [serial 1873]
. . . done guided substitution of equals  [14.2 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1871]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:    normalization of [serial 1868]
Reason solved:  Guided Substitution of Equals

[serial 1876]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [194] << RMA = next_ma >>
What for:  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "RMA" in its postcondition [serial 1873]
Done guided substituting an equals
step:  360
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1876]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [194] << RMA = next_ma >>
What for:  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "RMA" in its postcondition [serial 1873]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1871]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:    normalization of [serial 1868]
Reason solved:  Guided Substitution of Equals
Done trying to apply axioms
step:  361
****guided-sub-equals****
guided substitution of equals "
^{CMA 
 ^{. num_segments}}" . . .
equality selected for substitution:  CMA.num_segments = i

This Proof Obligation:

[serial 1871]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
What for:    normalization of [serial 1868]
Reasons solved:  
   Guided Substitution of Equals
   Guided Substitution of Equals
Has substituted 
"
^{CMA 
 ^{. num_segments}}" with its = "i"
 to get:

[serial 1877]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[i] = iSeg >>
What for:  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "
^{CMA 
 ^{. num_segments}}" with its = "i" in its postcondition [serial 1871]
. . . done guided substitution of equals  [14.2 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1877]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[i] = iSeg >>
What for:  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "
^{CMA 
 ^{. num_segments}}" with its = "i" in its postcondition [serial 1871]
Done guided substituting an equals
step:  362
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1877]: Threads::AutoBrake.i
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193]->
Q [195] << CMA.seg[i] = iSeg >>
What for:  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "
^{CMA 
 ^{. num_segments}}" with its = "i" in its postcondition [serial 1871]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1843]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]nSeg := next_ma.seg[1]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1835]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  363
#[serial 1861]   normalization of [serial 1853]
step:  364
****atomic****
applying atomic actions . . .
solving assignment on line 196
replacing "nSeg" with "
^{next_ma 
 ^{. 
  ^{seg 
   ^{[ 
    ^{QUANTITY 1}}}}}"
makes:  << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = next_ma.seg[1] >>

This Proof Obligation:

[serial 1843]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]nSeg := next_ma.seg[1]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
What for:    normalization of [serial 1835]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1878]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = next_ma.seg[1] >>
What for:  applied wp for assignment [serial 1843]
. . . done applying atomic actions [14.2 seconds ]
After "atomic" remaining 
Obligations:

[serial 1878]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = next_ma.seg[1] >>
What for:  applied wp for assignment [serial 1843]
Done reducing atomic actions
step:  365
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1878]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = next_ma.seg[1] >>
What for:  applied wp for assignment [serial 1843]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1879]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [198] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878]

[serial 1880]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878]

[serial 1881]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [198] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878]

[serial 1882]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << NEXT_MA = next_ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878]

[serial 1883]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << NEXT_MA.seg[1] = next_ma.seg[1] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878]
. . . done splitting postcondition  [14.2 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1879]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [198] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878]

[serial 1880]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878]

[serial 1881]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [198] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878]

[serial 1882]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << NEXT_MA = next_ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878]

[serial 1883]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << NEXT_MA.seg[1] = next_ma.seg[1] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878]
Done splitting postcondition
step:  366
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1879]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [198] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1880]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << CMA.num_segments = i >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1881]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [198] << CMA.seg[CMA.num_segments] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1882]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [197] << NEXT_MA = next_ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1883]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << NEXT_MA.seg[1] = next_ma.seg[1] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878]
Done trying to apply axioms
step:  367
****guided-sub-equals****
guided substitution of equals "NEXT_MA" . . .
equality selected for substitution:  NEXT_MA = next_ma

This Proof Obligation:

[serial 1883]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << NEXT_MA.seg[1] = next_ma.seg[1] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878]
Reason solved:  Guided Substitution of Equals
Has substituted 
"NEXT_MA" with its = "next_ma"
 to get:

[serial 1884]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << next_ma.seg[1] = next_ma.seg[1] >>
What for:  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "next_ma" in its postcondition [serial 1883]
. . . done guided substitution of equals  [14.2 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1884]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << next_ma.seg[1] = next_ma.seg[1] >>
What for:  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "next_ma" in its postcondition [serial 1883]
Done guided substituting an equals
step:  368
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1884]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << next_ma.seg[1] = next_ma.seg[1] >>
What for:  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "next_ma" in its postcondition [serial 1883]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 1885]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1884]
. . . done Applying Laws [14.2 seconds ]
After "laws" remaining 
Obligations:

[serial 1885]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1884]
Done applying laws
step:  369
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1885]: Threads::AutoBrake.i
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196]->
Q [199] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1884]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1026]: Threads::AutoBrake.i
P [203] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [202]->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:   <<M(GotNewMA) and x>> -> <<M(CheckMATransition)>> for LastBitOfMa: GotNewMA-[x]->CheckMATransition{};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  370
#[serial 1026]  <<M(GotNewMA) and x>> -> <<M(CheckMATransition)>> for LastBitOfMaGotNewMA-[x]->CheckMATransition{};
step:  371
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1026]: Threads::AutoBrake.i
P [203] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [202]->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:   <<M(GotNewMA) and x>> -> <<M(CheckMATransition)>> for LastBitOfMa: GotNewMA-[x]->CheckMATransition{};
Reason solved:  Associativity: (b.c).a = a.b.c
Has applied law "Associativity: (b.c).a = a.b.c " to get:

[serial 1886]: Threads::AutoBrake.i
P [203] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [202]->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1026]
. . . done Applying Laws [14.2 seconds ]
After "laws" remaining 
Obligations:

[serial 1886]: Threads::AutoBrake.i
P [203] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [202]->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1026]
Done applying laws
step:  372
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1886]: Threads::AutoBrake.i
P [203] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [202]->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:  Associativity: (b.c).a = a.b.c [serial 1026]
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1027]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p < ma.ea ) >>
S [205]->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:   <<M(CheckMATransition) and x>> -> <<M(GotNewMA)>> for NotEndOfMA: CheckMATransition-[x]->GotNewMA{};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  373
#[serial 1027]  <<M(CheckMATransition) and x>> -> <<M(GotNewMA)>> for NotEndOfMACheckMATransition-[x]->GotNewMA{};
step:  374
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1027]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p < ma.ea ) >>
S [205]->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
What for:   <<M(CheckMATransition) and x>> -> <<M(GotNewMA)>> for NotEndOfMA: CheckMATransition-[x]->GotNewMA{};
Reason solved:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
Has been solved by And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1028]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [210]  << AXIOM_CMA_IS_NEXT_MA()
    and next_ma = NEXT_MA >>
  ma := next_ma
  ;
  << ma = CMA >>
  i := 1
  ;
  << i = 1
    and ma = CMA >>
  iSeg := ma.seg[1]
  ;
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i] >>
  nSeg := ma.seg[2]
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1]
    and AXIOM_NUM_SEG(ma : ma) >> 
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(CheckMATransition) and x>> A <<M(MoveForward)>> for StartNextMa: CheckMATransition-[x]->MoveForward{A};
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  375
#[serial 1028]  <<M(CheckMATransition) and x>> A <<M(MoveForward)>> for StartNextMaCheckMATransition-[x]->MoveForward{A};
step:  376
****reduce****
This proof obligation:

[serial 1028]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [210]  << AXIOM_CMA_IS_NEXT_MA()
    and next_ma = NEXT_MA >>
  ma := next_ma
  ;
  << ma = CMA >>
  i := 1
  ;
  << i = 1
    and ma = CMA >>
  iSeg := ma.seg[1]
  ;
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i] >>
  nSeg := ma.seg[2]
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1]
    and AXIOM_NUM_SEG(ma : ma) >> 
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:   <<M(CheckMATransition) and x>> A <<M(MoveForward)>> for StartNextMa: CheckMATransition-[x]->MoveForward{A};
 as <<P>> S <<Q>> where S is <<P0>> S0 <<Q0>> ; . . . ; <<P3>> S3 <<Q3>>
 
was reduced to:

[serial 1887]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1028]

[serial 1888]: Threads::AutoBrake.i
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : ma) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<Q4>> -> <<Q>> in sequential composition for [serial 1028]

[serial 1889]: Threads::AutoBrake.i
P [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211]ma := next_ma
Q [212] << ma = CMA >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]

[serial 1890]: Threads::AutoBrake.i
P [212] << ma = CMA >>
S [213]i := 1
Q [214] << i = 1
  and ma = CMA >>
What for:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028]

[serial 1891]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]iSeg := ma.seg[1]
Q [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
What for:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1028]

[serial 1892]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : ma) >>
What for:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1028]
After "reduce composite" remaining proof obligations: 

Obligations:

[serial 1887]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1028]

[serial 1888]: Threads::AutoBrake.i
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : ma) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<Q4>> -> <<Q>> in sequential composition for [serial 1028]

[serial 1889]: Threads::AutoBrake.i
P [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211]ma := next_ma
Q [212] << ma = CMA >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]

[serial 1890]: Threads::AutoBrake.i
P [212] << ma = CMA >>
S [213]i := 1
Q [214] << i = 1
  and ma = CMA >>
What for:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028]

[serial 1891]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]iSeg := ma.seg[1]
Q [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
What for:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1028]

[serial 1892]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : ma) >>
What for:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1028]
done reducing composite actions
step:  377
****push****
Pushing Unsolved Proof Obligations back to Intial Proof Obligations
step:  378
#Threads::AutoBrake.i
step:  379
#[serial 1905] <<P>> -> <<P1>> in sequential composition for [serial 102
step:  380
****make-an****
Making obligation 48
Obligations:

[serial 1887]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1028]
Done making obligation 48
step:  381
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1887]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
What for:  <<P>> -> <<P1>> in sequential composition for [serial 1028]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1893]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << true
  and next_ma = NEXT_MA >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [14.2 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1893]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << true
  and next_ma = NEXT_MA >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  382
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1893]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << true
  and next_ma = NEXT_MA >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1894]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << ( next_ma = NEXT_MA ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1893]
. . . done Applying Laws [14.2 seconds ]
After "laws" remaining 
Obligations:

[serial 1894]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << ( next_ma = NEXT_MA ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1893]
Done applying laws
step:  383
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1894]: Threads::AutoBrake.i
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70]->
Q [210] << ( next_ma = NEXT_MA ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1893]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Irreflexivity of At Least: (a>=b) = (b<=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1896]: Threads::AutoBrake.i
P [70] << ma.ea <= p
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70]->
Q [210] << NEXT_MA = next_ma >>
What for:    normalization of [serial 1894]
. . . done Normalizing Unsolved Proof Obligations [14.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1896]: Threads::AutoBrake.i
P [70] << ma.ea <= p
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70]->
Q [210] << NEXT_MA = next_ma >>
What for:    normalization of [serial 1894]
Done Normalizing
step:  384
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1896]: Threads::AutoBrake.i
P [70] << ma.ea <= p
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70]->
Q [210] << NEXT_MA = next_ma >>
What for:    normalization of [serial 1894]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1888]: Threads::AutoBrake.i
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : ma) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<Q4>> -> <<Q>> in sequential composition for [serial 1028]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  385
#[serial 1906] <<Q4>> -> <<Q>> in sequential composition for [serial 1028]
step:  386
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1888]: Threads::AutoBrake.i
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : ma) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  <<Q4>> -> <<Q>> in sequential composition for [serial 1028]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1898]: Threads::AutoBrake.i
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ( 1 < ma.num_segments ) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1888]
. . . done substituting assertions' for Labels [14.2 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1898]: Threads::AutoBrake.i
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ( 1 < ma.num_segments ) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1888]
Done substituting Assertion labels in preconditions
step:  387
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1898]: Threads::AutoBrake.i
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ( 1 < ma.num_segments ) >>
S [57]->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1888]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1900]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1898]
. . . done Normalizing Unsolved Proof Obligations [14.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1900]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1898]
Done Normalizing
step:  388
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1900]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
What for:    normalization of [serial 1898]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1902]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1900]

[serial 1903]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1900]

[serial 1904]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << CMA.seg[1 + i] = nSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1900]

[serial 1905]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << i < CMA.num_segments >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1900]
. . . done splitting postcondition  [14.2 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1902]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1900]

[serial 1903]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1900]

[serial 1904]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << CMA.seg[1 + i] = nSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1900]

[serial 1905]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << i < CMA.num_segments >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1900]
Done splitting postcondition
step:  389
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1902]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << CMA = ma >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1900]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1903]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << CMA.seg[i] = iSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1900]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1904]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << CMA.seg[1 + i] = nSeg >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1900]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1905]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << i < CMA.num_segments >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1900]
Done trying to apply axioms
step:  390
****guided-sub-equals****
guided substitution of equals "i" . . .
equality selected for substitution:  i = 1

This Proof Obligation:

[serial 1905]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << i < CMA.num_segments >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1900]
Reason solved:  Guided Substitution of Equals
Has substituted 
"i" with its = "( 1 )"
 to get:

[serial 1906]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << ( 1 ) < CMA.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1905]
. . . done guided substitution of equals  [14.2 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1906]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << ( 1 ) < CMA.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1905]
Done guided substituting an equals
step:  391
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1906]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << ( 1 ) < CMA.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1905]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1907]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << ( 1 ) < ma.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1906]
. . . done guided substitution of equals  [14.2 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1907]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << ( 1 ) < ma.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1906]
Done guided substituting an equals
step:  392
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1907]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << ( 1 ) < ma.num_segments >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1906]
Reasons solved:  
   Reflexivity of Addition: a+b=b+a
   Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1909]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << 1 < ma.num_segments >>
What for:    normalization of [serial 1907]
. . . done Normalizing Unsolved Proof Obligations [14.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1909]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << 1 < ma.num_segments >>
What for:    normalization of [serial 1907]
Done Normalizing
step:  393
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1909]: Threads::AutoBrake.i
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57]->
Q [57] << 1 < ma.num_segments >>
What for:    normalization of [serial 1907]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1889]: Threads::AutoBrake.i
P [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211]ma := next_ma
Q [212] << ma = CMA >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  394
#[serial 1907] <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]
step:  395
****atomic****
applying atomic actions . . .
solving assignment on line 211
replacing "ma" with "next_ma"
makes:  << next_ma = CMA >>

This Proof Obligation:

[serial 1889]: Threads::AutoBrake.i
P [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211]ma := next_ma
Q [212] << ma = CMA >>
What for:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1911]: Threads::AutoBrake.i
P [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211]->
Q [212] << next_ma = CMA >>
What for:  applied wp for assignment [serial 1889]
. . . done applying atomic actions [14.2 seconds ]
After "atomic" remaining 
Obligations:

[serial 1911]: Threads::AutoBrake.i
P [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211]->
Q [212] << next_ma = CMA >>
What for:  applied wp for assignment [serial 1889]
Done reducing atomic actions
step:  396
****substitute precondition****
Substituting Assertions for Labels . . .

This Proof Obligation:

[serial 1911]: Threads::AutoBrake.i
P [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211]->
Q [212] << next_ma = CMA >>
What for:  applied wp for assignment [serial 1889]
Reason solved:  Substitution of Assertion Labels
Has substituted assertions' predicates for labels to get:

[serial 1912]: Threads::AutoBrake.i
P [210] << ( CMA = NEXT_MA )
  and next_ma = NEXT_MA >>
S [211]->
Q [212] << next_ma = CMA >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1911]
. . . done substituting assertions' for Labels [14.2 seconds ]
After "substitute precondition" remaining 
Obligations:

[serial 1912]: Threads::AutoBrake.i
P [210] << ( CMA = NEXT_MA )
  and next_ma = NEXT_MA >>
S [211]->
Q [212] << next_ma = CMA >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1911]
Done substituting Assertion labels in preconditions
step:  397
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1912]: Threads::AutoBrake.i
P [210] << ( CMA = NEXT_MA )
  and next_ma = NEXT_MA >>
S [211]->
Q [212] << next_ma = CMA >>
What for:  Substituted assertions' predicates for labels in preconditions [serial 1911]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1914]: Threads::AutoBrake.i
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211]->
Q [212] << CMA = next_ma >>
What for:    normalization of [serial 1912]
. . . done Normalizing Unsolved Proof Obligations [14.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1914]: Threads::AutoBrake.i
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211]->
Q [212] << CMA = next_ma >>
What for:    normalization of [serial 1912]
Done Normalizing
step:  398
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = NEXT_MA

This Proof Obligation:

[serial 1914]: Threads::AutoBrake.i
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211]->
Q [212] << CMA = next_ma >>
What for:    normalization of [serial 1912]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "NEXT_MA"
 to get:

[serial 1916]: Threads::AutoBrake.i
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211]->
Q [212] << NEXT_MA = next_ma >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "NEXT_MA" in its postcondition [serial 1914]
. . . done guided substitution of equals  [14.2 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1916]: Threads::AutoBrake.i
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211]->
Q [212] << NEXT_MA = next_ma >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "NEXT_MA" in its postcondition [serial 1914]
Done guided substituting an equals
step:  399
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1916]: Threads::AutoBrake.i
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211]->
Q [212] << NEXT_MA = next_ma >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "NEXT_MA" in its postcondition [serial 1914]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1890]: Threads::AutoBrake.i
P [212] << ma = CMA >>
S [213]i := 1
Q [214] << i = 1
  and ma = CMA >>
What for:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  400
#[serial 1908] <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028]
step:  401
****atomic****
applying atomic actions . . .
solving assignment on line 213
replacing "i" with "1"
makes:  << ( 1 ) = 1
  and ma = CMA >>

This Proof Obligation:

[serial 1890]: Threads::AutoBrake.i
P [212] << ma = CMA >>
S [213]i := 1
Q [214] << i = 1
  and ma = CMA >>
What for:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1917]: Threads::AutoBrake.i
P [212] << ma = CMA >>
S [213]->
Q [214] << ( 1 ) = 1
  and ma = CMA >>
What for:  applied wp for assignment [serial 1890]
. . . done applying atomic actions [14.2 seconds ]
After "atomic" remaining 
Obligations:

[serial 1917]: Threads::AutoBrake.i
P [212] << ma = CMA >>
S [213]->
Q [214] << ( 1 ) = 1
  and ma = CMA >>
What for:  applied wp for assignment [serial 1890]
Done reducing atomic actions
step:  402
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1917]: Threads::AutoBrake.i
P [212] << ma = CMA >>
S [213]->
Q [214] << ( 1 ) = 1
  and ma = CMA >>
What for:  applied wp for assignment [serial 1890]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1919]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma
  and 1 = 1 >>
What for:    normalization of [serial 1917]
. . . done Normalizing Unsolved Proof Obligations [14.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1919]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma
  and 1 = 1 >>
What for:    normalization of [serial 1917]
Done Normalizing
step:  403
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1919]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma
  and 1 = 1 >>
What for:    normalization of [serial 1917]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 1921]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma
  and true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1919]

This Proof Obligation:

[serial 1921]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma
  and true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1919]
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1922]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << ( CMA = ma ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1921]
. . . done Applying Laws [14.2 seconds ]
After "laws" remaining 
Obligations:

[serial 1922]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << ( CMA = ma ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1921]
Done applying laws
step:  404
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1922]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << ( CMA = ma ) >>
What for:  Law of And-Simplification:  P and true is P [serial 1921]
Reason solved:  Add Unnecessary Parentheses For No Good Reason: a = (a)
Has been normalized to get:

[serial 1924]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma >>
What for:    normalization of [serial 1922]
. . . done Normalizing Unsolved Proof Obligations [14.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1924]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma >>
What for:    normalization of [serial 1922]
Done Normalizing
step:  405
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1924]: Threads::AutoBrake.i
P [212] << CMA = ma >>
S [213]->
Q [214] << CMA = ma >>
What for:    normalization of [serial 1922]
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1891]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]iSeg := ma.seg[1]
Q [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
What for:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1028]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  406
#[serial 1909] <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1028]
step:  407
****atomic****
applying atomic actions . . .
solving assignment on line 215
replacing "iSeg" with "
^{ma 
 ^{. 
  ^{seg 
   ^{[ 
    ^{QUANTITY 1}}}}}"
makes:  << i = 1
  and ma = CMA
  and ma.seg[1] = CMA.seg[i] >>

This Proof Obligation:

[serial 1891]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]iSeg := ma.seg[1]
Q [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
What for:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1028]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1926]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << i = 1
  and ma = CMA
  and ma.seg[1] = CMA.seg[i] >>
What for:  applied wp for assignment [serial 1891]
. . . done applying atomic actions [14.2 seconds ]
After "atomic" remaining 
Obligations:

[serial 1926]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << i = 1
  and ma = CMA
  and ma.seg[1] = CMA.seg[i] >>
What for:  applied wp for assignment [serial 1891]
Done reducing atomic actions
step:  408
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1926]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << i = 1
  and ma = CMA
  and ma.seg[1] = CMA.seg[i] >>
What for:  applied wp for assignment [serial 1891]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1927]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << i = 1 >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1926]

[serial 1928]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma = CMA >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1926]

[serial 1929]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1] = CMA.seg[i] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1926]
. . . done splitting postcondition  [14.2 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1927]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << i = 1 >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1926]

[serial 1928]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma = CMA >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1926]

[serial 1929]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1] = CMA.seg[i] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1926]
Done splitting postcondition
step:  409
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1927]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << i = 1 >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1926]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1928]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma = CMA >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1926]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1929]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1] = CMA.seg[i] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1926]
Done trying to apply axioms
step:  410
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  ma = CMA

This Proof Obligation:

[serial 1929]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1] = CMA.seg[i] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1926]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1930]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1] = ma.seg[i] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1929]
. . . done guided substitution of equals  [14.2 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1930]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1] = ma.seg[i] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1929]
Done guided substituting an equals
step:  411
****guided-sub-equals****
guided substitution of equals "i" . . .
equality selected for substitution:  i = 1

This Proof Obligation:

[serial 1930]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1] = ma.seg[i] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1929]
Reason solved:  Guided Substitution of Equals
Has substituted 
"i" with its = "( 1 )"
 to get:

[serial 1931]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1] = ma.seg[( 1 )] >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1930]
. . . done guided substitution of equals  [14.2 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1931]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1] = ma.seg[( 1 )] >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1930]
Done guided substituting an equals
step:  412
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1931]: Threads::AutoBrake.i
P [214] << i = 1
  and ma = CMA >>
S [215]->
Q [216] << ma.seg[1] = ma.seg[( 1 )] >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1930]
Reasons solved:  
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1933]: Threads::AutoBrake.i
P [214] << CMA = ma
  and i = 1 >>
S [215]->
Q [216] << ma.seg[1] = ma.seg[1] >>
What for:    normalization of [serial 1931]
. . . done Normalizing Unsolved Proof Obligations [14.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1933]: Threads::AutoBrake.i
P [214] << CMA = ma
  and i = 1 >>
S [215]->
Q [216] << ma.seg[1] = ma.seg[1] >>
What for:    normalization of [serial 1931]
Done Normalizing
step:  413
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1933]: Threads::AutoBrake.i
P [214] << CMA = ma
  and i = 1 >>
S [215]->
Q [216] << ma.seg[1] = ma.seg[1] >>
What for:    normalization of [serial 1931]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 1935]: Threads::AutoBrake.i
P [214] << CMA = ma
  and i = 1 >>
S [215]->
Q [216] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1933]
. . . done Applying Laws [14.2 seconds ]
After "laws" remaining 
Obligations:

[serial 1935]: Threads::AutoBrake.i
P [214] << CMA = ma
  and i = 1 >>
S [215]->
Q [216] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1933]
Done applying laws
step:  414
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1935]: Threads::AutoBrake.i
P [214] << CMA = ma
  and i = 1 >>
S [215]->
Q [216] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1933]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1892]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : ma) >>
What for:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1028]
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  415
#[serial 1910] <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1028]
step:  416
****remove-axioms-post****
removing axioms from postconditions. . .
This proof obligation:

[serial 1892]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : ma) >>
What for:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1028]
Reason solved:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
has been transformed into:

[serial 1936]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and true >>
What for:   add user-defined axioms to postcondition
by removing axioms from postconditions.

. . . done removing axioms from postconditions  [14.2 seconds ]
After "remove axioms from postconditions" remaining 
Obligations:

[serial 1936]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and true >>
What for:   add user-defined axioms to postcondition
Done removing axioms from postconditions
step:  417
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1936]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and true >>
What for:   add user-defined axioms to postcondition
Reason solved:  Law of And-Simplification:  P and true is P
Has applied law "Law of And-Simplification:  P and true is P " to get:

[serial 1937]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1] >>
What for:  Law of And-Simplification:  P and true is P [serial 1936]
. . . done Applying Laws [14.2 seconds ]
After "laws" remaining 
Obligations:

[serial 1937]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1] >>
What for:  Law of And-Simplification:  P and true is P [serial 1936]
Done applying laws
step:  418
****atomic****
applying atomic actions . . .
solving assignment on line 217
replacing "nSeg" with "
^{ma 
 ^{. 
  ^{seg 
   ^{[ 
    ^{QUANTITY 2}}}}}"
makes:  << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and ma.seg[2] = CMA.seg[i + 1] >>

This Proof Obligation:

[serial 1937]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1] >>
What for:  Law of And-Simplification:  P and true is P [serial 1936]
Reason solved:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
Has applied := to get:

[serial 1938]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and ma.seg[2] = CMA.seg[i + 1] >>
What for:  applied wp for assignment [serial 1937]
. . . done applying atomic actions [14.2 seconds ]
After "atomic" remaining 
Obligations:

[serial 1938]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and ma.seg[2] = CMA.seg[i + 1] >>
What for:  applied wp for assignment [serial 1937]
Done reducing atomic actions
step:  419
****split-post****
Splitting postcondition:  make <<A=>B and C>> into <<A=>B>> and <<A=>C>>
splitting postcondition . . .

This Proof Obligation:

[serial 1938]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and ma.seg[2] = CMA.seg[i + 1] >>
What for:  applied wp for assignment [serial 1937]
Reason solved:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
Has split postcondition to get:

[serial 1939]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << i = 1 >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938]

[serial 1940]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma = CMA >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938]

[serial 1941]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << iSeg = CMA.seg[i] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938]

[serial 1942]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma.seg[2] = CMA.seg[i + 1] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938]
. . . done splitting postcondition  [14.2 seconds ]
After splitting postcondition remaining 
Obligations:

[serial 1939]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << i = 1 >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938]

[serial 1940]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma = CMA >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938]

[serial 1941]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << iSeg = CMA.seg[i] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938]

[serial 1942]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma.seg[2] = CMA.seg[i + 1] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938]
Done splitting postcondition
step:  420
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1939]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << i = 1 >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1940]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma = CMA >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X

This Proof Obligation:

[serial 1941]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << iSeg = CMA.seg[i] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938]
Reason solved:  And Introduction Schema (aisph):  (X and Y)->X
Has been solved by And Introduction Schema (aisph):  (X and Y)->X
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:

[serial 1942]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma.seg[2] = CMA.seg[i + 1] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938]
Done trying to apply axioms
step:  421
****guided-sub-equals****
guided substitution of equals "i" . . .
equality selected for substitution:  i = 1

This Proof Obligation:

[serial 1942]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma.seg[2] = CMA.seg[i + 1] >>
What for:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938]
Reason solved:  Guided Substitution of Equals
Has substituted 
"i" with its = "( 1 )"
 to get:

[serial 1943]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma.seg[2] = CMA.seg[( 1 ) + 1] >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1942]
. . . done guided substitution of equals  [14.2 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1943]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma.seg[2] = CMA.seg[( 1 ) + 1] >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1942]
Done guided substituting an equals
step:  422
****normalize****
Normalizing Unsolved Proof Obligations . . .

This Proof Obligation:

[serial 1943]: Threads::AutoBrake.i
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217]->
Q [218] << ma.seg[2] = CMA.seg[( 1 ) + 1] >>
What for:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1942]
Reasons solved:  
   Literal Arithmetic
   Reflexivity of Equality: (a=b) = (b=a)
   Add Unnecessary Parentheses For No Good Reason: a = (a)
   Reflexivity of Conjunction: (m and k) = (k and m)
Has been normalized to get:

[serial 1945]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217]->
Q [218] << CMA.seg[2] = ma.seg[2] >>
What for:    normalization of [serial 1943]
. . . done Normalizing Unsolved Proof Obligations [14.2 seconds ]
After "normalize" remaining 
Obligations:

[serial 1945]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217]->
Q [218] << CMA.seg[2] = ma.seg[2] >>
What for:    normalization of [serial 1943]
Done Normalizing
step:  423
****guided-sub-equals****
guided substitution of equals "CMA" . . .
equality selected for substitution:  CMA = ma

This Proof Obligation:

[serial 1945]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217]->
Q [218] << CMA.seg[2] = ma.seg[2] >>
What for:    normalization of [serial 1943]
Reason solved:  Guided Substitution of Equals
Has substituted 
"CMA" with its = "ma"
 to get:

[serial 1947]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217]->
Q [218] << ma.seg[2] = ma.seg[2] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1945]
. . . done guided substitution of equals  [14.2 seconds ]
After guided substituting an equals remaining 
Obligations:

[serial 1947]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217]->
Q [218] << ma.seg[2] = ma.seg[2] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1945]
Done guided substituting an equals
step:  424
****laws****
Applying Laws . . .

This Proof Obligation:

[serial 1947]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217]->
Q [218] << ma.seg[2] = ma.seg[2] >>
What for:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1945]
Reason solved:  Equality Law (idistr):  a=a <-> true
Has applied law "Equality Law (idistr):  a=a <-> true " to get:

[serial 1948]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217]->
Q [218] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1947]
. . . done Applying Laws [14.2 seconds ]
After "laws" remaining 
Obligations:

[serial 1948]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217]->
Q [218] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1947]
Done applying laws
step:  425
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1948]: Threads::AutoBrake.i
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217]->
Q [218] << true >>
What for:  Equality Law (idistr):  a=a <-> true [serial 1947]
Reason solved:  True Conclusion Schema (tc): P->true
Has been solved by True Conclusion Schema (tc): P->true
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1029]: driver.xl -> motor.xl
P [1] << xl = OPERATOR_XL >>
S [2]->
Q [1] << xl = OPERATOR_XL >>
What for:  Composition of Subcomponents via Directional Connection driver.xl -> motor.xl:
 xl -> xl
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  426
#[serial 1029] Composition of Subcomponents via Directional Connection driver.xl -> motor.xl:
step:  427
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1029]: driver.xl -> motor.xl
P [1] << xl = OPERATOR_XL >>
S [2]->
Q [1] << xl = OPERATOR_XL >>
What for:  Composition of Subcomponents via Directional Connection driver.xl -> motor.xl:
 xl -> xl
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1030]: sensor.p -> controller.control.p
P [1] << p = POSITION >>
S [2]->
Q [1] << p = POSITION >>
What for:  Composition of Subcomponents via Directional Connection sensor.p -> controller.control.p:
 p -> p
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  428
#[serial 1030] Composition of Subcomponents via Directional Connection sensor.p -> controller.control.p:
step:  429
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1030]: sensor.p -> controller.control.p
P [1] << p = POSITION >>
S [2]->
Q [1] << p = POSITION >>
What for:  Composition of Subcomponents via Directional Connection sensor.p -> controller.control.p:
 p -> p
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1031]: sensor.v -> controller.control.v
P [1] << v = VELOCITY >>
S [2]->
Q [1] << v = VELOCITY >>
What for:  Composition of Subcomponents via Directional Connection sensor.v -> controller.control.v:
 v -> v
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  430
#[serial 1031] Composition of Subcomponents via Directional Connection sensor.v -> controller.control.v:
step:  431
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1031]: sensor.v -> controller.control.v
P [1] << v = VELOCITY >>
S [2]->
Q [1] << v = VELOCITY >>
What for:  Composition of Subcomponents via Directional Connection sensor.v -> controller.control.v:
 v -> v
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1032]: controller.control.sb -> sbrake.brake
P [1] << SB()
  and not EB() >>
S [2]->
Q [1] << SB()
  and not EB() >>
What for:  Composition of Subcomponents via Directional Connection controller.control.sb -> sbrake.brake:
 sb -> brake
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  432
#[serial 1032] Composition of Subcomponents via Directional Connection controller.control.sb -> sbrake.brake:
step:  433
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1032]: controller.control.sb -> sbrake.brake
P [1] << SB()
  and not EB() >>
S [2]->
Q [1] << SB()
  and not EB() >>
What for:  Composition of Subcomponents via Directional Connection controller.control.sb -> sbrake.brake:
 sb -> brake
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1033]: controller.control.eb -> ebrake.brake
P [1] << EB() >>
S [2]->
Q [1] << EB() >>
What for:  Composition of Subcomponents via Directional Connection controller.control.eb -> ebrake.brake:
 eb -> brake
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  434
#[serial 1033] Composition of Subcomponents via Directional Connection controller.control.eb -> ebrake.brake:
step:  435
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1033]: controller.control.eb -> ebrake.brake
P [1] << EB() >>
S [2]->
Q [1] << EB() >>
What for:  Composition of Subcomponents via Directional Connection controller.control.eb -> ebrake.brake:
 eb -> brake
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1034]: rbc.ma -> train.controller.control.m_a
P [1] << ma_m_a = RMA >>
S [2]->
Q [1] << ma_m_a = RMA >>
What for:  Composition of Subcomponents via Directional Connection rbc.ma -> train.controller.control.m_a:
 ma -> m_a
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  436
#[serial 1034] Composition of Subcomponents via Directional Connection rbc.ma -> train.controller.control.m_a:
step:  437
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1034]: rbc.ma -> train.controller.control.m_a
P [1] << ma_m_a = RMA >>
S [2]->
Q [1] << ma_m_a = RMA >>
What for:  Composition of Subcomponents via Directional Connection rbc.ma -> train.controller.control.m_a:
 ma -> m_a
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1035]: CTCS::MovementAuthority.i.ma
P [27] << ma = RMA >>
S [19]->
Q [14] << ma = RMA >>
What for:  Composition of Subcomponents via Directional Connection CTCS::MovementAuthority.i.ma:
 ma -> ma
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  438
#[serial 1035] Composition of Subcomponents via Directional Connection CTCS::MovementAuthority.i.ma:
step:  439
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1035]: CTCS::MovementAuthority.i.ma
P [27] << ma = RMA >>
S [19]->
Q [14] << ma = RMA >>
What for:  Composition of Subcomponents via Directional Connection CTCS::MovementAuthority.i.ma:
 ma -> ma
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1036]: Train::Train.i.auth
P [14] << ma_m_a = RMA >>
S [73]->
Q [94] << ma_m_a = RMA >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.auth:
 ma -> m_a
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  440
#[serial 1036] Composition of Subcomponents via Directional Connection Train::Train.i.auth:
step:  441
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1036]: Train::Train.i.auth
P [14] << ma_m_a = RMA >>
S [73]->
Q [94] << ma_m_a = RMA >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.auth:
 ma -> m_a
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1037]: Train::Train.i.pos
P [32] << p = POSITION >>
S [74]->
Q [89] << p = POSITION >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.pos:
 p -> p
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  442
#[serial 1037] Composition of Subcomponents via Directional Connection Train::Train.i.pos:
step:  443
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1037]: Train::Train.i.pos
P [32] << p = POSITION >>
S [74]->
Q [89] << p = POSITION >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.pos:
 p -> p
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1038]: Train::Train.i.vel
P [34] << v = VELOCITY >>
S [75]->
Q [91] << v = VELOCITY >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.vel:
 v -> v
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  444
#[serial 1038] Composition of Subcomponents via Directional Connection Train::Train.i.vel:
step:  445
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1038]: Train::Train.i.vel
P [34] << v = VELOCITY >>
S [75]->
Q [91] << v = VELOCITY >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.vel:
 v -> v
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1039]: Train::Train.i.dxl
P [59] << xl = OPERATOR_XL >>
S [76]->
Q [23] << xl = OPERATOR_XL >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.dxl:
 xl -> xl
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  446
#[serial 1039] Composition of Subcomponents via Directional Connection Train::Train.i.dxl:
step:  447
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1039]: Train::Train.i.dxl
P [59] << xl = OPERATOR_XL >>
S [76]->
Q [23] << xl = OPERATOR_XL >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.dxl:
 xl -> xl
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1040]: Train::Train.i.cpsb
P [85] << SB()
  and not EB() >>
S [77]->
Q [44] << SB()
  and not EB() >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.cpsb:
 sb -> brake
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  448
#[serial 1040] Composition of Subcomponents via Directional Connection Train::Train.i.cpsb:
step:  449
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1040]: Train::Train.i.cpsb
P [85] << SB()
  and not EB() >>
S [77]->
Q [44] << SB()
  and not EB() >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.cpsb:
 sb -> brake
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1041]: Train::Train.i.cpeb
P [87] << EB() >>
S [78]->
Q [51] << EB() >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.cpeb:
 eb -> brake
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  450
#[serial 1041] Composition of Subcomponents via Directional Connection Train::Train.i.cpeb:
step:  451
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1041]: Train::Train.i.cpeb
P [87] << EB() >>
S [78]->
Q [51] << EB() >>
What for:  Composition of Subcomponents via Directional Connection Train::Train.i.cpeb:
 eb -> brake
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1042]: Train::ControllerProcess.i.conn_s
P [89] << p = POSITION >>
S [103]->
Q [19] << p = POSITION >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_s:
 p -> p
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  452
#[serial 1042] Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_s:
step:  453
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1042]: Train::ControllerProcess.i.conn_s
P [89] << p = POSITION >>
S [103]->
Q [19] << p = POSITION >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_s:
 p -> p
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1043]: Train::ControllerProcess.i.conn_v
P [91] << v = VELOCITY >>
S [104]->
Q [21] << v = VELOCITY >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_v:
 v -> v
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  454
#[serial 1043] Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_v:
step:  455
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1043]: Train::ControllerProcess.i.conn_v
P [91] << v = VELOCITY >>
S [104]->
Q [21] << v = VELOCITY >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_v:
 v -> v
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1044]: Train::ControllerProcess.i.conn_ma
P [94] << m_a = RMA >>
S [106]->
Q [17] << m_a = RMA >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_ma:
 m_a -> m_a
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  456
#[serial 1044] Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_ma:
step:  457
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1044]: Train::ControllerProcess.i.conn_ma
P [94] << m_a = RMA >>
S [106]->
Q [17] << m_a = RMA >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_ma:
 m_a -> m_a
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1045]: Train::ControllerProcess.i.conn_sb
P [12] << SB()
  and not EB() >>
S [108]->
Q [85] << SB()
  and not EB() >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_sb:
 sb -> sb
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  458
#[serial 1045] Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_sb:
step:  459
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1045]: Train::ControllerProcess.i.conn_sb
P [12] << SB()
  and not EB() >>
S [108]->
Q [85] << SB()
  and not EB() >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_sb:
 sb -> sb
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
Obligations:

[serial 1046]: Train::ControllerProcess.i.conn_eb
P [14] << EB() >>
S [109]->
Q [87] << EB() >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_eb:
 eb -> eb
The next initial proof obligation was moved to unsolved proof obligations.
*****************************************************************************************
step:  460
#[serial 1046] Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_eb:
step:  461
****axioms****
Applying Axioms . . .

This Proof Obligation:

[serial 1046]: Train::ControllerProcess.i.conn_eb
P [14] << EB() >>
S [109]->
Q [87] << EB() >>
What for:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_eb:
 eb -> eb
Reason solved:  Identity (id):  P->P is tautology
Has been solved by Identity (id):  P->P is tautology
. . . done Applying Axioms [14.2 seconds ]
After "axioms" remaining 
Obligations:
Done trying to apply axioms
There are no more unsolved proof obligations.
All proof obligations have been solved.  Q.E.D.
opening proof file "/Applications/OSATE-for-HAMR-and-BLESS/Eclipse-OfHaB.app/Contents/MacOS/proof.txt" Wed Jun 14 16:21:33 CDT 2023
Theorem (1)                               [serial 1003] 
P [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [39] ->
Q [39] << true >>
Why created:  <<M(MoveForwardLastSegment)>> -> <<I>> from invariant I when complete state MoveForwardLastSegment has Assertion <<M(MoveForwardLastSegment)>> in its definition.
Solved by:  True Conclusion Schema (tc): P->true


Theorem (2)                               [serial 1004] 
P [54] << true >>
S [39] ->
Q [39] << true >>
Why created:  <<M(WaitFirstMA)>> -> <<I>> from invariant I when complete state WaitFirstMA has Assertion <<M(WaitFirstMA)>> in its definition.
Solved by:  True Conclusion Schema (tc): P->true


Theorem (3)                               [serial 1005] 
P [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [39] ->
Q [39] << true >>
Why created:  <<M(MoveForward)>> -> <<I>> from invariant I when complete state MoveForward has Assertion <<M(MoveForward)>> in its definition.
Solved by:  True Conclusion Schema (tc): P->true


Theorem (4)                               [serial 1048] 
P [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [39] ->
Q [39] << true >>
Why created:    normalization of [serial 1006]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (5)                               [serial 1006] 
P [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [39] ->
Q [39] << true >>
Why created:  <<M(GotNewMA)>> -> <<I>> from invariant I when complete state GotNewMA has Assertion <<M(GotNewMA)>> in its definition.
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 4:
Theorem (4) [serial 1048] used for:
    normalization of [serial 1006] 


Theorem (6)                               [serial 1054] 
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [59] ->
Q [59] << true >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1053]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (7)                               [serial 1053] 
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [59] ->
Q [59] << ( not ( p < iSeg.e ) )
   or p < iSeg.e >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1051]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 6:
Theorem (6) [serial 1054] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1053] 


Theorem (8)                               [serial 1051] 
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [59] ->
Q [59] << iSeg.e <= p
   or p < iSeg.e >>
Why created:    normalization of [serial 1007]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 7:
Theorem (7) [serial 1053] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1051] 


Theorem (9)                               [serial 1007] 
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [59] ->
Q [59] << ( p < iSeg.e )
   or ( p >= iSeg.e ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForward, <<M(CheckMoveForward)>> -> <<e1 or e2 or . . . en>>
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 8:
Theorem (8) [serial 1051] used for:
    normalization of [serial 1007] 


Theorem (10)                               [serial 1055] 
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [65] ->
Q [65] << true >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1008]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (11)                               [serial 1008] 
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
S [65] ->
Q [65] << ( not m_a'fresh )
   or m_a'fresh >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForwardLastSegment, <<M(CheckMoveForwardLastSegment)>> -> <<e1 or e2 or . . . en>>
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 10:
Theorem (10) [serial 1055] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1008] 


Theorem (12)                               [serial 1009] 
P [53] << true >>
S [53] ->
Q [53] << true >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state Start, <<M(Start)>> -> <<e1 or e2 or . . . en>>
Solved by:  True Conclusion Schema (tc): P->true


Theorem (13)                               [serial 1059] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [61] ->
Q [61] << true >>
Why created:  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1057]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (14)                               [serial 1057] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg >>
S [61] ->
Q [61] << i = ma.num_segments
   or i < ma.num_segments
   or ma.num_segments < i >>
Why created:    normalization of [serial 1010]
Solved by:  Less than, greater than, or equal:  |-a<b or b<a or a=b
and theorem 13:
Theorem (13) [serial 1059] used for:
  Less than, greater than, or equal:  |-a<b or b<a or a=b [serial 1057] 


Theorem (15)                               [serial 1010] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
S [61] ->
Q [61] << ( i < ma.num_segments )
   or ( i = ma.num_segments )
   or ( i > ma.num_segments ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckForLastSegment, <<M(CheckForLastSegment)>> -> <<e1 or e2 or . . . en>>
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of Greater Than: (a>b) = (b<a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 14:
Theorem (14) [serial 1057] used for:
    normalization of [serial 1010] 


Theorem (16)                               [serial 1060] 
P [55] << true >>
S [55] ->
Q [55] << true >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1011]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (17)                               [serial 1011] 
P [55] << true >>
S [55] ->
Q [55] << ( not m_a'fresh )
   or m_a'fresh >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckFirstMA, <<M(CheckFirstMA)>> -> <<e1 or e2 or . . . en>>
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 16:
Theorem (16) [serial 1060] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1011] 


Theorem (18)                               [serial 1065] 
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70] ->
Q [70] << true >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1064]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (19)                               [serial 1064] 
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70] ->
Q [70] << ( not ( p < ma.ea ) )
   or p < ma.ea >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1062]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 18:
Theorem (18) [serial 1065] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1064] 


Theorem (20)                               [serial 1062] 
P [70] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70] ->
Q [70] << ma.ea <= p
   or p < ma.ea >>
Why created:    normalization of [serial 1012]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 19:
Theorem (19) [serial 1064] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1062] 


Theorem (21)                               [serial 1012] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
S [70] ->
Q [70] << ( p < ma.ea )
   or ( p >= ma.ea ) >>
Why created:  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMATransition, <<M(CheckMATransition)>> -> <<e1 or e2 or . . . en>>
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 20:
Theorem (20) [serial 1062] used for:
    normalization of [serial 1012] 


Theorem (22)                               [serial 1067] 
P [53] << true >>
S [76] ->
Q [76] << true >>
Why created:  applied port output <<pre>> -> <<M[r]>> [serial 1066]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (23)                               [serial 1068] 
P [76] << ( true )
  and true@now >>
S [76] ->
Q [54] << true >>
Why created:  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1066]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (24)                               [serial 1066] 
P [53] << true >>
S [76] r!
Q [54] << true >>
Why created:  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1013]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
and theorems 22 23:
Theorem (22) [serial 1067] used for:
  applied port output <<pre>> -> <<M[r]>> [serial 1066] 
Theorem (23) [serial 1068] used for:
  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1066] 


Theorem (25)                               [serial 1013] 
P [53] << true >>
S [76] r!
Q [54] << true >>
Why created:   <<M(Start)>> A <<M(WaitFirstMA)>> for Go: Start-[ ]->WaitFirstMA{A};
Solved by:  Introduction of Existential Quantification
and theorem 24:
Theorem (24) [serial 1066] used for:
  as <<P>> S <<Q>> in <<P>> { S } <<Q>> [serial 1013] 


Theorem (26)                               [serial 1014] 
P [79] << ( true )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [78] ->
Q [55] << true >>
Why created:   <<M(WaitFirstMA) and x>> -> <<M(CheckFirstMA)>> for FirstMA: WaitFirstMA-[x]->CheckFirstMA{};
Solved by:  True Conclusion Schema (tc): P->true


Theorem (27)                               [serial 1015] 
P [82] << not m_a'fresh >>
S [81] ->
Q [54] << true >>
Why created:   <<M(CheckFirstMA) and x>> -> <<M(WaitFirstMA)>> for NotYet: CheckFirstMA-[x]->WaitFirstMA{};
Solved by:  True Conclusion Schema (tc): P->true


Theorem (28)                               [serial 1075] 
P [85] << m_a'fresh >>
S [85] ->
Q [86] << true >>
Why created:   add user-defined axioms to postcondition
Solved by:  True Conclusion Schema (tc): P->true


Theorem (29)                               [serial 1075] 
P [85] << m_a'fresh >>
S [85] ->
Q [86] << true >>
Why created:   add user-defined axioms to postcondition
Solved by:  True Conclusion Schema (tc): P->true


Theorem (30)                               [serial 1069] 
P [85] << m_a'fresh >>
S [85] ->
Q [86] << AXIOM_CMA_IS_RMA() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1016]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 29 29:
Theorem (29) [serial 1075] used for:
   add user-defined axioms to postcondition 
Theorem (29) [serial 1075] used for:
   add user-defined axioms to postcondition 


Theorem (31)                               [serial 1096] 
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57] ->
Q [57] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (32)                               [serial 1097] 
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57] ->
Q [57] << CMA.seg[i] = iSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (33)                               [serial 1098] 
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57] ->
Q [57] << CMA.seg[1 + i] = nSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (34)                               [serial 1109] 
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57] ->
Q [57] << 1 < CMA.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1107]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (35)                               [serial 1107] 
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57] ->
Q [57] << 1 < ma.num_segments >>
Why created:    normalization of [serial 1105]
Solved by:  Guided Substitution of Equals
and theorem 34:
Theorem (34) [serial 1109] used for:
  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1107] 


Theorem (36)                               [serial 1105] 
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57] ->
Q [57] << ( 1 ) < ma.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1103]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 35:
Theorem (35) [serial 1107] used for:
    normalization of [serial 1105] 


Theorem (37)                               [serial 1103] 
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < CMA.num_segments >>
S [57] ->
Q [57] << i < ma.num_segments >>
Why created:    normalization of [serial 1101]
Solved by:  Guided Substitution of Equals
and theorem 36:
Theorem (36) [serial 1105] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1103] 


Theorem (38)                               [serial 1101] 
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and ( 1 < CMA.num_segments ) >>
S [57] ->
Q [57] << i < ma.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1100]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 37:
Theorem (37) [serial 1103] used for:
    normalization of [serial 1101] 


Theorem (39)                               [serial 1100] 
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and ( 1 < CMA.num_segments ) >>
S [57] ->
Q [57] << i < CMA.num_segments >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1099]
Solved by:  Guided Substitution of Equals
and theorem 38:
Theorem (38) [serial 1101] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1100] 


Theorem (40)                               [serial 1099] 
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57] ->
Q [57] << i < CMA.num_segments >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081]
Solved by:  Substitution of Assertion Labels
and theorem 39:
Theorem (39) [serial 1100] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1099] 


Theorem (41)                               [serial 1081] 
P [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57] ->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1070]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 31 32 33 40:
Theorem (31) [serial 1096] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081] 
Theorem (32) [serial 1097] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081] 
Theorem (33) [serial 1098] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081] 
Theorem (40) [serial 1099] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1081] 


Theorem (42)                               [serial 1070] 
P [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : CMA) >>
S [57] ->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<Q4>> -> <<Q>> in sequential composition for [serial 1016]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 41:
Theorem (41) [serial 1081] used for:
    normalization of [serial 1070] 


Theorem (43)                               [serial 1115] 
P [87] << CMA = RMA
  and RMA = ma >>
S [87] ->
Q [88] << RMA = ma >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "RMA" in its postcondition [serial 1113]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (44)                               [serial 1113] 
P [87] << CMA = RMA
  and RMA = ma >>
S [87] ->
Q [88] << CMA = ma >>
Why created:    normalization of [serial 1111]
Solved by:  Guided Substitution of Equals
and theorem 43:
Theorem (43) [serial 1115] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "RMA" in its postcondition [serial 1113] 


Theorem (45)                               [serial 1111] 
P [87] << ( ( CMA = RMA ) )
  and ma = RMA >>
S [87] ->
Q [88] << CMA = ma >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1110]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 44:
Theorem (44) [serial 1113] used for:
    normalization of [serial 1111] 


Theorem (46)                               [serial 1110] 
P [87] << ( AXIOM_CMA_IS_RMA() )
  and ma = RMA >>
S [87] ->
Q [88] << CMA = ma >>
Why created:  applied port input of value <<pre and ma=M(m_a)>> -> <<post>> [serial 1083]
Solved by:  Substitution of Assertion Labels
and theorem 45:
Theorem (45) [serial 1111] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1110] 


Theorem (47)                               [serial 1083] 
P [86] << AXIOM_CMA_IS_RMA() >>
S [87] m_a?(ma)
Q [88] << CMA = ma >>
Why created:    normalization of [serial 1071]
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
and theorem 46:
Theorem (46) [serial 1110] used for:
  applied port input of value <<pre and ma=M(m_a)>> -> <<post>> [serial 1083] 


Theorem (48)                               [serial 1071] 
P [86] << AXIOM_CMA_IS_RMA() >>
S [87] m_a?(ma)
Q [88] << ma = CMA >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 47:
Theorem (47) [serial 1083] used for:
    normalization of [serial 1071] 


Theorem (49)                               [serial 1123] 
P [88] << CMA = ma >>
S [89] ->
Q [90] << CMA = ma >>
Why created:    normalization of [serial 1121]
Solved by:  Identity (id):  P->P is tautology


Theorem (50)                               [serial 1121] 
P [88] << CMA = ma >>
S [89] ->
Q [90] << ( CMA = ma ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1120]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 49:
Theorem (49) [serial 1123] used for:
    normalization of [serial 1121] 


Theorem (51)                               [serial 1120] 
P [88] << CMA = ma >>
S [89] ->
Q [90] << CMA = ma
  and true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1118]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 50:
Theorem (50) [serial 1121] used for:
  Law of And-Simplification:  P and true is P [serial 1120] 


Theorem (52)                               [serial 1118] 
P [88] << CMA = ma >>
S [89] ->
Q [90] << CMA = ma
  and 1 = 1 >>
Why created:    normalization of [serial 1116]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 51:
Theorem (51) [serial 1120] used for:
  Equality Law (idistr):  a=a <-> true [serial 1118] 


Theorem (53)                               [serial 1116] 
P [88] << CMA = ma >>
S [89] ->
Q [90] << CMA = ma
  and ( 1 ) = 1 >>
Why created:  applied wp for assignment [serial 1085]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 52:
Theorem (52) [serial 1118] used for:
    normalization of [serial 1116] 


Theorem (54)                               [serial 1085] 
P [88] << CMA = ma >>
S [89] i := 1
Q [90] << CMA = ma
  and i = 1 >>
Why created:    normalization of [serial 1072]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 53:
Theorem (53) [serial 1116] used for:
  applied wp for assignment [serial 1085] 


Theorem (55)                               [serial 1072] 
P [88] << ma = CMA >>
S [89] i := 1
Q [90] << i = 1
  and ma = CMA >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1016]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 54:
Theorem (54) [serial 1085] used for:
    normalization of [serial 1072] 


Theorem (56)                               [serial 1126] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (57)                               [serial 1134] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1132]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (58)                               [serial 1132] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << ma.seg[1] = ma.seg[1] >>
Why created:    normalization of [serial 1130]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 57:
Theorem (57) [serial 1134] used for:
  Equality Law (idistr):  a=a <-> true [serial 1132] 


Theorem (59)                               [serial 1130] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << ma.seg[( 1 )] = ma.seg[1] >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1129]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 58:
Theorem (58) [serial 1132] used for:
    normalization of [serial 1130] 


Theorem (60)                               [serial 1129] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << ma.seg[i] = ma.seg[1] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1127]
Solved by:  Guided Substitution of Equals
and theorem 59:
Theorem (59) [serial 1130] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1129] 


Theorem (61)                               [serial 1127] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << CMA.seg[i] = ma.seg[1] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Solved by:  Guided Substitution of Equals
and theorem 60:
Theorem (60) [serial 1129] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1127] 


Theorem (62)                               [serial 1128] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << i = 1 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (63)                               [serial 1125] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << CMA = ma
  and CMA.seg[i] = ma.seg[1]
  and i = 1 >>
Why created:  applied wp for assignment [serial 1088]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 56 61 62:
Theorem (56) [serial 1126] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125] 
Theorem (61) [serial 1127] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125] 
Theorem (62) [serial 1128] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125] 


Theorem (64)                               [serial 1088] 
P [90] << CMA = ma
  and i = 1 >>
S [91] iSeg := ma.seg[1]
Q [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
Why created:    normalization of [serial 1078]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 63:
Theorem (63) [serial 1125] used for:
  applied wp for assignment [serial 1088] 


Theorem (65)                               [serial 1078] 
P [90] << i = 1
  and ma = CMA >>
S [91] iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
Why created:  Law of And-Simplification:  P and true is P [serial 1076]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 64:
Theorem (64) [serial 1088] used for:
    normalization of [serial 1078] 


Theorem (66)                               [serial 1076] 
P [90] << i = 1
  and ma = CMA >>
S [91] iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 65:
Theorem (65) [serial 1078] used for:
  Law of And-Simplification:  P and true is P [serial 1076] 


Theorem (67)                               [serial 1126] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (68)                               [serial 1134] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1132]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (69)                               [serial 1132] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << ma.seg[1] = ma.seg[1] >>
Why created:    normalization of [serial 1130]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 68:
Theorem (68) [serial 1134] used for:
  Equality Law (idistr):  a=a <-> true [serial 1132] 


Theorem (70)                               [serial 1130] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << ma.seg[( 1 )] = ma.seg[1] >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1129]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 69:
Theorem (69) [serial 1132] used for:
    normalization of [serial 1130] 


Theorem (71)                               [serial 1129] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << ma.seg[i] = ma.seg[1] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1127]
Solved by:  Guided Substitution of Equals
and theorem 70:
Theorem (70) [serial 1130] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1129] 


Theorem (72)                               [serial 1127] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << CMA.seg[i] = ma.seg[1] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Solved by:  Guided Substitution of Equals
and theorem 71:
Theorem (71) [serial 1129] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1127] 


Theorem (73)                               [serial 1128] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << i = 1 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (74)                               [serial 1125] 
P [90] << CMA = ma
  and i = 1 >>
S [91] ->
Q [92] << CMA = ma
  and CMA.seg[i] = ma.seg[1]
  and i = 1 >>
Why created:  applied wp for assignment [serial 1088]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 67 72 73:
Theorem (67) [serial 1126] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125] 
Theorem (72) [serial 1127] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125] 
Theorem (73) [serial 1128] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1125] 


Theorem (75)                               [serial 1088] 
P [90] << CMA = ma
  and i = 1 >>
S [91] iSeg := ma.seg[1]
Q [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
Why created:    normalization of [serial 1078]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 74:
Theorem (74) [serial 1125] used for:
  applied wp for assignment [serial 1088] 


Theorem (76)                               [serial 1078] 
P [90] << i = 1
  and ma = CMA >>
S [91] iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
Why created:  Law of And-Simplification:  P and true is P [serial 1076]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 75:
Theorem (75) [serial 1088] used for:
    normalization of [serial 1078] 


Theorem (77)                               [serial 1076] 
P [90] << i = 1
  and ma = CMA >>
S [91] iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 76:
Theorem (76) [serial 1078] used for:
  Law of And-Simplification:  P and true is P [serial 1076] 


Theorem (78)                               [serial 1073] 
P [90] << i = 1
  and ma = CMA >>
S [91] iSeg := ma.seg[1]
Q [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1016]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 77 77:
Theorem (77) [serial 1076] used for:
   add user-defined axioms to postcondition 
Theorem (77) [serial 1076] used for:
   add user-defined axioms to postcondition 


Theorem (79)                               [serial 1150] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << CMA.seg[i] = iSeg >>
Why created:  Guided Substitution of Equals 
 replacing "1" with its = "i" in its postcondition [serial 1148]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (80)                               [serial 1148] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << CMA.seg[1] = iSeg >>
Why created:    normalization of [serial 1146]
Solved by:  Guided Substitution of Equals
and theorem 79:
Theorem (79) [serial 1150] used for:
  Guided Substitution of Equals 
 replacing "1" with its = "i" in its postcondition [serial 1148] 


Theorem (81)                               [serial 1146] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << iSeg = CMA.seg[1] >>
Why created:  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1144]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 80:
Theorem (80) [serial 1148] used for:
    normalization of [serial 1146] 


Theorem (82)                               [serial 1144] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << iSeg = ma.seg[1] >>
Why created:    normalization of [serial 1142]
Solved by:  Guided Substitution of Equals
and theorem 81:
Theorem (81) [serial 1146] used for:
  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1144] 


Theorem (83)                               [serial 1142] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << ( ma.seg[1] = iSeg ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1141]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 82:
Theorem (82) [serial 1144] used for:
    normalization of [serial 1142] 


Theorem (84)                               [serial 1141] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << true
  and ma.seg[1] = iSeg
  and true
  and true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1140]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 83:
Theorem (83) [serial 1142] used for:
  Law of And-Simplification:  P and true is P [serial 1141] 


Theorem (85)                               [serial 1140] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = ma.seg[2]
  and 1 = 1 >>
Why created:  applied wp for assignment [serial 1139]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 84:
Theorem (84) [serial 1141] used for:
  Equality Law (idistr):  a=a <-> true [serial 1140] 


Theorem (86)                               [serial 1139] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = nSeg
  and 1 = 1 >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1137]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 85:
Theorem (85) [serial 1140] used for:
  applied wp for assignment [serial 1139] 


Theorem (87)                               [serial 1137] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[1] = iSeg
  and CMA.seg[2] = nSeg
  and 1 = 1 >>
Why created:    normalization of [serial 1135]
Solved by:  Guided Substitution of Equals
and theorem 86:
Theorem (86) [serial 1139] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1137] 


Theorem (88)                               [serial 1135] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[( 1 )] = iSeg
  and CMA.seg[1 + ( 1 )] = nSeg
  and ( 1 ) = 1 >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1090]
Solved by:  Literal Arithmetic
  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 87:
Theorem (87) [serial 1137] used for:
    normalization of [serial 1135] 


Theorem (89)                               [serial 1090] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1 >>
Why created:    normalization of [serial 1079]
Solved by:  Guided Substitution of Equals
and theorem 88:
Theorem (88) [serial 1135] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1090] 


Theorem (90)                               [serial 1079] 
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1] >>
Why created:  Law of And-Simplification:  P and true is P [serial 1077]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 89:
Theorem (89) [serial 1090] used for:
    normalization of [serial 1079] 


Theorem (91)                               [serial 1077] 
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 90:
Theorem (90) [serial 1079] used for:
  Law of And-Simplification:  P and true is P [serial 1077] 


Theorem (92)                               [serial 1150] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << CMA.seg[i] = iSeg >>
Why created:  Guided Substitution of Equals 
 replacing "1" with its = "i" in its postcondition [serial 1148]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (93)                               [serial 1148] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << CMA.seg[1] = iSeg >>
Why created:    normalization of [serial 1146]
Solved by:  Guided Substitution of Equals
and theorem 92:
Theorem (92) [serial 1150] used for:
  Guided Substitution of Equals 
 replacing "1" with its = "i" in its postcondition [serial 1148] 


Theorem (94)                               [serial 1146] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << iSeg = CMA.seg[1] >>
Why created:  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1144]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 93:
Theorem (93) [serial 1148] used for:
    normalization of [serial 1146] 


Theorem (95)                               [serial 1144] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << iSeg = ma.seg[1] >>
Why created:    normalization of [serial 1142]
Solved by:  Guided Substitution of Equals
and theorem 94:
Theorem (94) [serial 1146] used for:
  Guided Substitution of Equals 
 replacing "ma" with its = "CMA" in its postcondition [serial 1144] 


Theorem (96)                               [serial 1142] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << ( ma.seg[1] = iSeg ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1141]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 95:
Theorem (95) [serial 1144] used for:
    normalization of [serial 1142] 


Theorem (97)                               [serial 1141] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << true
  and ma.seg[1] = iSeg
  and true
  and true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1140]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 96:
Theorem (96) [serial 1142] used for:
  Law of And-Simplification:  P and true is P [serial 1141] 


Theorem (98)                               [serial 1140] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] ->
Q [95] << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = ma.seg[2]
  and 1 = 1 >>
Why created:  applied wp for assignment [serial 1139]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 97:
Theorem (97) [serial 1141] used for:
  Equality Law (idistr):  a=a <-> true [serial 1140] 


Theorem (99)                               [serial 1139] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << ma = ma
  and ma.seg[1] = iSeg
  and ma.seg[2] = nSeg
  and 1 = 1 >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1137]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 98:
Theorem (98) [serial 1140] used for:
  applied wp for assignment [serial 1139] 


Theorem (100)                               [serial 1137] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[1] = iSeg
  and CMA.seg[2] = nSeg
  and 1 = 1 >>
Why created:    normalization of [serial 1135]
Solved by:  Guided Substitution of Equals
and theorem 99:
Theorem (99) [serial 1139] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1137] 


Theorem (101)                               [serial 1135] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[( 1 )] = iSeg
  and CMA.seg[1 + ( 1 )] = nSeg
  and ( 1 ) = 1 >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1090]
Solved by:  Literal Arithmetic
  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 100:
Theorem (100) [serial 1137] used for:
    normalization of [serial 1135] 


Theorem (102)                               [serial 1090] 
P [92] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1 >>
Why created:    normalization of [serial 1079]
Solved by:  Guided Substitution of Equals
and theorem 101:
Theorem (101) [serial 1135] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1090] 


Theorem (103)                               [serial 1079] 
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1] >>
Why created:  Law of And-Simplification:  P and true is P [serial 1077]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 102:
Theorem (102) [serial 1090] used for:
    normalization of [serial 1079] 


Theorem (104)                               [serial 1077] 
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 103:
Theorem (103) [serial 1079] used for:
  Law of And-Simplification:  P and true is P [serial 1077] 


Theorem (105)                               [serial 1074] 
P [92] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and AXIOM_NUM_SEG(ma : ma) >>
S [94] nSeg := ma.seg[2]
Q [95] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : CMA) >>
Why created:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1016]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 104 104:
Theorem (104) [serial 1077] used for:
   add user-defined axioms to postcondition 
Theorem (104) [serial 1077] used for:
   add user-defined axioms to postcondition 


Theorem (106)                               [serial 1016] 
P [85] << m_a'fresh >>
S [86]   << AXIOM_CMA_IS_RMA() >>
  m_a?(ma)
  ;
  << ma = CMA >>
  i := 1
  ;
  << i = 1
    and ma = CMA >>
  iSeg := ma.seg[1]
  ;
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and AXIOM_NUM_SEG(ma : ma) >>
  nSeg := ma.seg[2]
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1]
    and AXIOM_NUM_SEG(ma : CMA) >> 
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:   <<M(CheckFirstMA) and x>> A <<M(MoveForward)>> for GotFirstMA: CheckFirstMA-[x]->MoveForward{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 30 42 48 55 78 105:
Theorem (30) [serial 1069] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1016] 
Theorem (42) [serial 1070] used for:
  <<Q4>> -> <<Q>> in sequential composition for [serial 1016] 
Theorem (48) [serial 1071] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1016] 
Theorem (55) [serial 1072] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1016] 
Theorem (78) [serial 1073] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1016] 
Theorem (105) [serial 1074] used for:
  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1016] 


Theorem (107)                               [serial 1166] 
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100] ->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Law of And-Simplification:  P and true is P [serial 1165]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (108)                               [serial 1165] 
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100] ->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and true
  and true
  and true
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 107:
Theorem (107) [serial 1166] used for:
  Law of And-Simplification:  P and true is P [serial 1165] 


Theorem (109)                               [serial 1166] 
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100] ->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Law of And-Simplification:  P and true is P [serial 1165]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (110)                               [serial 1165] 
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100] ->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and true
  and true
  and true
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 109:
Theorem (109) [serial 1166] used for:
  Law of And-Simplification:  P and true is P [serial 1165] 


Theorem (111)                               [serial 1152] 
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [100] ->
Q [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1151]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 110 110:
Theorem (110) [serial 1165] used for:
   add user-defined axioms to postcondition 
Theorem (110) [serial 1165] used for:
   add user-defined axioms to postcondition 


Theorem (112)                               [serial 1182] 
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105] ->
Q [105] << true >>
Why created:    normalization of [serial 1180]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (113)                               [serial 1180] 
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105] ->
Q [105] << ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1179]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 112:
Theorem (112) [serial 1182] used for:
    normalization of [serial 1180] 


Theorem (114)                               [serial 1179] 
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105] ->
Q [105] << ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1178]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 113:
Theorem (113) [serial 1180] used for:
  Law of And-Simplification:  P and P is P [serial 1179] 


Theorem (115)                               [serial 1178] 
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105] ->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1177]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 114:
Theorem (114) [serial 1179] used for:
  Law of And-Simplification:  P and P is P [serial 1178] 


Theorem (116)                               [serial 1177] 
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105] ->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1176]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 115:
Theorem (115) [serial 1178] used for:
  Law of And-Simplification:  P and P is P [serial 1177] 


Theorem (117)                               [serial 1176] 
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105] ->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1175]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 116:
Theorem (116) [serial 1177] used for:
  Law of And-Simplification:  P and P is P [serial 1176] 


Theorem (118)                               [serial 1175] 
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105] ->
Q [105] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1174]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 117:
Theorem (117) [serial 1176] used for:
  Law of And-Simplification:  P and P is P [serial 1175] 


Theorem (119)                               [serial 1174] 
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105] ->
Q [105] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
Why created:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1172]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 118:
Theorem (118) [serial 1175] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1174] 


Theorem (120)                               [serial 1172] 
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105] ->
Q [105] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v < iSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:    normalization of [serial 1170]
Solved by:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 119:
Theorem (119) [serial 1174] used for:
  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1172] 


Theorem (121)                               [serial 1170] 
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105] ->
Q [105] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( ( not ( v < iSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1168]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 120:
Theorem (120) [serial 1172] used for:
    normalization of [serial 1170] 


Theorem (122)                               [serial 1168] 
P [101] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [105] ->
Q [105] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:    normalization of [serial 1154]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 121:
Theorem (121) [serial 1170] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1168] 


Theorem (123)                               [serial 1154] 
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [105] ->
Q [105] << ( v >= iSeg.v_e )
   or ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1153]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 122:
Theorem (122) [serial 1168] used for:
    normalization of [serial 1154] 


Theorem (124)                               [serial 1212] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107] ->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
Why created:    normalization of [serial 1208]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (125)                               [serial 1208] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [107] ->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1191]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 124:
Theorem (124) [serial 1212] used for:
    normalization of [serial 1208] 


Theorem (126)                               [serial 1191] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107] ->
Q [14] << EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188]
Solved by:  Substitution of Assertion Labels
and theorem 125:
Theorem (125) [serial 1208] used for:
  Substituted assertions' predicates for labels  [serial 1191] 


Theorem (127)                               [serial 1197] 
P [107] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( EB() )@now >>
S [107] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1192]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (128)                               [serial 1192] 
P [107] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( EB() )@now >>
S [107] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1188]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 127:
Theorem (127) [serial 1197] used for:
  Associativity: (b.c).a = a.b.c [serial 1192] 


Theorem (129)                               [serial 1188] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107] eb!(true)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1186]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 126 128:
Theorem (126) [serial 1191] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1188] 
Theorem (128) [serial 1192] used for:
  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1188] 


Theorem (130)                               [serial 1221] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107] ->
Q [107] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1216]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (131)                               [serial 1216] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107] ->
Q [107] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1210]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 130:
Theorem (130) [serial 1221] used for:
  Associativity: (b.c).a = a.b.c [serial 1216] 


Theorem (132)                               [serial 1210] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [107] ->
Q [107] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1205]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 131:
Theorem (131) [serial 1216] used for:
    normalization of [serial 1210] 


Theorem (133)                               [serial 1205] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107] ->
Q [107] << EB()
   or not SB() >>
Why created:    normalization of [serial 1200]
Solved by:  Substitution of Assertion Labels
and theorem 132:
Theorem (132) [serial 1210] used for:
  Substituted assertions' predicates for labels  [serial 1205] 


Theorem (134)                               [serial 1200] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107] ->
Q [107] << ( not ( SB() )
   or not ( not EB() ) ) >>
Why created:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1193]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 133:
Theorem (133) [serial 1205] used for:
    normalization of [serial 1200] 


Theorem (135)                               [serial 1193] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107] ->
Q [107] << not ( SB()
  and not EB() ) >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1189]
Solved by:  DeMorgan's Law: not (A and B) = (not A) or (not B)
and theorem 134:
Theorem (134) [serial 1200] used for:
  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1193] 


Theorem (136)                               [serial 1198] 
P [107] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( not ( SB()
  and not EB() ) )@now >>
S [107] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1194]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (137)                               [serial 1194] 
P [107] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( not ( SB()
  and not EB() ) )@now >>
S [107] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1189]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 136:
Theorem (136) [serial 1198] used for:
  Associativity: (b.c).a = a.b.c [serial 1194] 


Theorem (138)                               [serial 1189] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107] sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1186]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 135 137:
Theorem (135) [serial 1193] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1189] 
Theorem (137) [serial 1194] used for:
  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1189] 


Theorem (139)                               [serial 1199] 
P [107] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( ca = ( 0 mpss ) )@now >>
S [107] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1195]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (140)                               [serial 1195] 
P [107] << ( iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( ca = ( 0 mpss ) )@now >>
S [107] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1190]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 139:
Theorem (139) [serial 1199] used for:
  Associativity: (b.c).a = a.b.c [serial 1195] 


Theorem (141)                               [serial 1220] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107] ->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1214]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (142)                               [serial 1214] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [107] ->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1209]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 141:
Theorem (141) [serial 1220] used for:
  Associativity: (b.c).a = a.b.c [serial 1214] 


Theorem (143)                               [serial 1209] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [107] ->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1203]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 142:
Theorem (142) [serial 1214] used for:
    normalization of [serial 1209] 


Theorem (144)                               [serial 1203] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107] ->
Q [33] << EB()
   or SB() >>
Why created:    normalization of [serial 1196]
Solved by:  Substitution of Assertion Labels
and theorem 143:
Theorem (143) [serial 1209] used for:
  Substituted assertions' predicates for labels  [serial 1203] 


Theorem (145)                               [serial 1196] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1190]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 144:
Theorem (144) [serial 1203] used for:
    normalization of [serial 1196] 


Theorem (146)                               [serial 1190] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107] ca!(0 mpss)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1186]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 140 145:
Theorem (140) [serial 1195] used for:
  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1190] 
Theorem (145) [serial 1196] used for:
  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1190] 


Theorem (147)                               [serial 1186] 
P [105] << iSeg.v_e <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [107]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1184]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 129 138 146:
Theorem (129) [serial 1188] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1186] 
Theorem (138) [serial 1189] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1186] 
Theorem (146) [serial 1190] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1186] 


Theorem (148)                               [serial 1184] 
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( v >= iSeg.v_e ) >>
S [107]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1160]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 147:
Theorem (147) [serial 1186] used for:
    normalization of [serial 1184] 


Theorem (149)                               [serial 1160] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1155]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 148:
Theorem (148) [serial 1184] used for:
  Associativity: (b.c).a = a.b.c [serial 1160] 


Theorem (150)                               [serial 1155] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [107]   {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1153]
Solved by:  Introduction of Existential Quantification
and theorem 149:
Theorem (149) [serial 1160] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1155] 


Theorem (151)                               [serial 1242] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110] ->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
Why created:    normalization of [serial 1238]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (152)                               [serial 1238] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [110] ->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1229]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 151:
Theorem (151) [serial 1242] used for:
    normalization of [serial 1238] 


Theorem (153)                               [serial 1229] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110] ->
Q [14] << EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1226]
Solved by:  Substitution of Assertion Labels
and theorem 152:
Theorem (152) [serial 1238] used for:
  Substituted assertions' predicates for labels  [serial 1229] 


Theorem (154)                               [serial 1235] 
P [110] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( EB() )@now >>
S [110] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1230]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (155)                               [serial 1230] 
P [110] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( EB() )@now >>
S [110] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1226]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 154:
Theorem (154) [serial 1235] used for:
  Associativity: (b.c).a = a.b.c [serial 1230] 


Theorem (156)                               [serial 1226] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110] eb!(true)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1224]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 153 155:
Theorem (153) [serial 1229] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1226] 
Theorem (155) [serial 1230] used for:
  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1226] 


Theorem (157)                               [serial 1261] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110] ->
Q [110] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1258]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (158)                               [serial 1258] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110] ->
Q [110] << ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1255]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 157:
Theorem (157) [serial 1261] used for:
  Associativity: (b.c).a = a.b.c [serial 1258] 


Theorem (159)                               [serial 1255] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110] ->
Q [110] << ( not ( not ( iSeg.v_e <= v ) )
   or not ( not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1253]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 158:
Theorem (158) [serial 1258] used for:
    normalization of [serial 1255] 


Theorem (160)                               [serial 1253] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110] ->
Q [110] << not ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) )
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1250]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 159:
Theorem (159) [serial 1255] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1253] 


Theorem (161)                               [serial 1250] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110] ->
Q [110] << ( not ( ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or not ( ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1244]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 160:
Theorem (160) [serial 1253] used for:
    normalization of [serial 1250] 


Theorem (162)                               [serial 1244] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110] ->
Q [110] << not ( not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
Why created:    normalization of [serial 1239]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 161:
Theorem (161) [serial 1250] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1244] 


Theorem (163)                               [serial 1239] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [110] ->
Q [110] << not ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1231]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 162:
Theorem (162) [serial 1244] used for:
    normalization of [serial 1239] 


Theorem (164)                               [serial 1231] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110] ->
Q [110] << not ( SB()
  and not EB() ) >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1227]
Solved by:  Substitution of Assertion Labels
and theorem 163:
Theorem (163) [serial 1239] used for:
  Substituted assertions' predicates for labels  [serial 1231] 


Theorem (165)                               [serial 1236] 
P [110] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( not ( SB()
  and not EB() ) )@now >>
S [110] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1232]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (166)                               [serial 1232] 
P [110] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( not ( SB()
  and not EB() ) )@now >>
S [110] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1227]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 165:
Theorem (165) [serial 1236] used for:
  Associativity: (b.c).a = a.b.c [serial 1232] 


Theorem (167)                               [serial 1227] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110] sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1224]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 164 166:
Theorem (164) [serial 1231] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1227] 
Theorem (166) [serial 1232] used for:
  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1227] 


Theorem (168)                               [serial 1237] 
P [110] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and ( ca = ( 0 mpss ) )@now >>
S [110] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1233]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (169)                               [serial 1233] 
P [110] << ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( ca = ( 0 mpss ) )@now >>
S [110] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1228]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 168:
Theorem (168) [serial 1237] used for:
  Associativity: (b.c).a = a.b.c [serial 1233] 


Theorem (170)                               [serial 1260] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110] ->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1246]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (171)                               [serial 1246] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [110] ->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1240]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 170:
Theorem (170) [serial 1260] used for:
  Associativity: (b.c).a = a.b.c [serial 1246] 


Theorem (172)                               [serial 1240] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments >>
S [110] ->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1234]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 171:
Theorem (171) [serial 1246] used for:
    normalization of [serial 1240] 


Theorem (173)                               [serial 1234] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1228]
Solved by:  Substitution of Assertion Labels
and theorem 172:
Theorem (172) [serial 1240] used for:
  Substituted assertions' predicates for labels  [serial 1234] 


Theorem (174)                               [serial 1228] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110] ca!(0 mpss)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1224]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 169 173:
Theorem (169) [serial 1233] used for:
  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1228] 
Theorem (173) [serial 1234] used for:
  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1228] 


Theorem (175)                               [serial 1224] 
P [105] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments >>
S [110]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1222]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 156 167 174:
Theorem (156) [serial 1226] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1224] 
Theorem (167) [serial 1227] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1224] 
Theorem (174) [serial 1228] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1224] 


Theorem (176)                               [serial 1222] 
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1161]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 175:
Theorem (175) [serial 1224] used for:
    normalization of [serial 1222] 


Theorem (177)                               [serial 1161] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1156]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 176:
Theorem (176) [serial 1222] used for:
  Associativity: (b.c).a = a.b.c [serial 1161] 


Theorem (178)                               [serial 1156] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [110]   {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1153]
Solved by:  Introduction of Existential Quantification
and theorem 177:
Theorem (177) [serial 1161] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1156] 


Theorem (179)                               [serial 1333] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [86] << v < iSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1332]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (180)                               [serial 1334] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1332]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (181)                               [serial 1337] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
Why created:    normalization of [serial 1335]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (182)                               [serial 1335] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1332]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 181:
Theorem (181) [serial 1337] used for:
    normalization of [serial 1335] 


Theorem (183)                               [serial 1332] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1326]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 179 180 182:
Theorem (179) [serial 1333] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1332] 
Theorem (180) [serial 1334] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1332] 
Theorem (182) [serial 1335] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1332] 


Theorem (184)                               [serial 1326] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:    normalization of [serial 1322]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 183:
Theorem (183) [serial 1332] used for:
  Associativity: (b.c).a = a.b.c [serial 1326] 


Theorem (185)                               [serial 1322] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1314]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 184:
Theorem (184) [serial 1326] used for:
    normalization of [serial 1322] 


Theorem (186)                               [serial 1314] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:    normalization of [serial 1310]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 185:
Theorem (185) [serial 1322] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1314] 


Theorem (187)                               [serial 1310] 
P [105] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1302]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 186:
Theorem (186) [serial 1314] used for:
    normalization of [serial 1310] 


Theorem (188)                               [serial 1302] 
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1298]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 187:
Theorem (187) [serial 1310] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1302] 


Theorem (189)                               [serial 1298] 
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1281]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 188:
Theorem (188) [serial 1302] used for:
    normalization of [serial 1298] 


Theorem (190)                               [serial 1281] 
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [12] << SB()
  and not EB() >>
Why created:    normalization of [serial 1271]
Solved by:  Substitution of Assertion Labels
and theorem 189:
Theorem (189) [serial 1298] used for:
  Substituted assertions' predicates for labels  [serial 1281] 


Theorem (191)                               [serial 1271] 
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [114] ->
Q [12] << SB()
  and not EB() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1265]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 190:
Theorem (190) [serial 1281] used for:
    normalization of [serial 1271] 


Theorem (192)                               [serial 1265] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114] ->
Q [12] << SB()
  and not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1262]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 191:
Theorem (191) [serial 1271] used for:
  Associativity: (b.c).a = a.b.c [serial 1265] 


Theorem (193)                               [serial 1287] 
P [114] << iSeg.v_n <= v
  and ( SB()
  and not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1277]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (194)                               [serial 1277] 
P [114] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( SB()
  and not EB() )@now >>
S [114] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1272]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 193:
Theorem (193) [serial 1287] used for:
    normalization of [serial 1277] 


Theorem (195)                               [serial 1272] 
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
  and ( SB()
  and not EB() )@now >>
S [114] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1266]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 194:
Theorem (194) [serial 1277] used for:
  Associativity: (b.c).a = a.b.c [serial 1272] 


Theorem (196)                               [serial 1266] 
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( SB()
  and not EB() )@now >>
S [114] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1262]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 195:
Theorem (195) [serial 1272] used for:
  Associativity: (b.c).a = a.b.c [serial 1266] 


Theorem (197)                               [serial 1262] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114] sb!(true)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1162]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 192 196:
Theorem (192) [serial 1265] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1262] 
Theorem (196) [serial 1266] used for:
  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1262] 


Theorem (198)                               [serial 1328] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [114] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:    normalization of [serial 1323]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (199)                               [serial 1323] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [114] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1316]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 198:
Theorem (198) [serial 1328] used for:
    normalization of [serial 1323] 


Theorem (200)                               [serial 1316] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [114] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
Why created:    normalization of [serial 1311]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 199:
Theorem (199) [serial 1323] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1316] 


Theorem (201)                               [serial 1311] 
P [105] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [114] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1304]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 200:
Theorem (200) [serial 1316] used for:
    normalization of [serial 1311] 


Theorem (202)                               [serial 1304] 
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [114] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1299]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 201:
Theorem (201) [serial 1311] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1304] 


Theorem (203)                               [serial 1299] 
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [114] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1283]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 202:
Theorem (202) [serial 1304] used for:
    normalization of [serial 1299] 


Theorem (204)                               [serial 1283] 
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [114] << not EB() >>
Why created:    normalization of [serial 1273]
Solved by:  Substitution of Assertion Labels
and theorem 203:
Theorem (203) [serial 1299] used for:
  Substituted assertions' predicates for labels  [serial 1283] 


Theorem (205)                               [serial 1273] 
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [114] ->
Q [114] << not EB() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1267]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 204:
Theorem (204) [serial 1283] used for:
    normalization of [serial 1273] 


Theorem (206)                               [serial 1267] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114] ->
Q [114] << not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1263]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 205:
Theorem (205) [serial 1273] used for:
  Associativity: (b.c).a = a.b.c [serial 1267] 


Theorem (207)                               [serial 1289] 
P [114] << iSeg.v_n <= v
  and ( not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1278]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (208)                               [serial 1278] 
P [114] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( not EB() )@now >>
S [114] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1274]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 207:
Theorem (207) [serial 1289] used for:
    normalization of [serial 1278] 


Theorem (209)                               [serial 1274] 
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
  and ( not EB() )@now >>
S [114] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1268]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 208:
Theorem (208) [serial 1278] used for:
  Associativity: (b.c).a = a.b.c [serial 1274] 


Theorem (210)                               [serial 1268] 
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( not EB() )@now >>
S [114] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1263]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 209:
Theorem (209) [serial 1274] used for:
  Associativity: (b.c).a = a.b.c [serial 1268] 


Theorem (211)                               [serial 1263] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114] eb!(false)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1162]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 206 210:
Theorem (206) [serial 1267] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1263] 
Theorem (210) [serial 1268] used for:
  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1263] 


Theorem (212)                               [serial 1291] 
P [114] << iSeg.v_n <= v
  and ( ca = 0 mpss )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1279]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (213)                               [serial 1279] 
P [114] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and ( ca = ( 0 mpss ) )@now >>
S [114] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1275]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 212:
Theorem (212) [serial 1291] used for:
    normalization of [serial 1279] 


Theorem (214)                               [serial 1275] 
P [114] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
  and ( ca = ( 0 mpss ) )@now >>
S [114] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1269]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 213:
Theorem (213) [serial 1279] used for:
  Associativity: (b.c).a = a.b.c [serial 1275] 


Theorem (215)                               [serial 1269] 
P [114] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) )
  and ( ca = ( 0 mpss ) )@now >>
S [114] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1264]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 214:
Theorem (214) [serial 1275] used for:
  Associativity: (b.c).a = a.b.c [serial 1269] 


Theorem (216)                               [serial 1331] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1318]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (217)                               [serial 1318] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v < iSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:    normalization of [serial 1312]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 216:
Theorem (216) [serial 1331] used for:
  Associativity: (b.c).a = a.b.c [serial 1318] 


Theorem (218)                               [serial 1312] 
P [105] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1306]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 217:
Theorem (217) [serial 1318] used for:
    normalization of [serial 1312] 


Theorem (219)                               [serial 1306] 
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1300]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 218:
Theorem (218) [serial 1312] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1306] 


Theorem (220)                               [serial 1300] 
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1285]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 219:
Theorem (219) [serial 1306] used for:
    normalization of [serial 1300] 


Theorem (221)                               [serial 1285] 
P [105] << iSeg.v_n <= v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [114] ->
Q [33] << EB()
   or SB() >>
Why created:    normalization of [serial 1276]
Solved by:  Substitution of Assertion Labels
and theorem 220:
Theorem (220) [serial 1300] used for:
  Substituted assertions' predicates for labels  [serial 1285] 


Theorem (222)                               [serial 1276] 
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) >>
S [114] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1270]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 221:
Theorem (221) [serial 1285] used for:
    normalization of [serial 1276] 


Theorem (223)                               [serial 1270] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1264]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 222:
Theorem (222) [serial 1276] used for:
  Associativity: (b.c).a = a.b.c [serial 1270] 


Theorem (224)                               [serial 1264] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114] ca!(0 mpss)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1162]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 215 223:
Theorem (215) [serial 1269] used for:
  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1264] 
Theorem (223) [serial 1270] used for:
  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1264] 


Theorem (225)                               [serial 1162] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]   sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1157]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 197 211 224:
Theorem (197) [serial 1262] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1162] 
Theorem (211) [serial 1263] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1162] 
Theorem (224) [serial 1264] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1162] 


Theorem (226)                               [serial 1157] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [114]   {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:    <<P and B2>> S2 <<Q>> in alternative for [serial 1153]
Solved by:  Introduction of Existential Quantification
and theorem 225:
Theorem (225) [serial 1162] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1157] 


Theorem (227)                               [serial 1410] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [86] << v < iSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1409]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (228)                               [serial 1411] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1409]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (229)                               [serial 1418] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
Why created:    normalization of [serial 1412]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (230)                               [serial 1412] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1409]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 229:
Theorem (229) [serial 1418] used for:
    normalization of [serial 1412] 


Theorem (231)                               [serial 1409] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1403]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 227 228 230:
Theorem (227) [serial 1410] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1409] 
Theorem (228) [serial 1411] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1409] 
Theorem (230) [serial 1412] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1409] 


Theorem (232)                               [serial 1403] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:    normalization of [serial 1399]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 231:
Theorem (231) [serial 1409] used for:
  Associativity: (b.c).a = a.b.c [serial 1403] 


Theorem (233)                               [serial 1399] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1391]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 232:
Theorem (232) [serial 1403] used for:
    normalization of [serial 1399] 


Theorem (234)                               [serial 1391] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:    normalization of [serial 1387]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 233:
Theorem (233) [serial 1399] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1391] 


Theorem (235)                               [serial 1387] 
P [105] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1379]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 234:
Theorem (234) [serial 1391] used for:
    normalization of [serial 1387] 


Theorem (236)                               [serial 1379] 
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1375]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 235:
Theorem (235) [serial 1387] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1379] 


Theorem (237)                               [serial 1375] 
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1358]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 236:
Theorem (236) [serial 1379] used for:
    normalization of [serial 1375] 


Theorem (238)                               [serial 1358] 
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [12] << SB()
  and not EB() >>
Why created:    normalization of [serial 1348]
Solved by:  Substitution of Assertion Labels
and theorem 237:
Theorem (237) [serial 1375] used for:
  Substituted assertions' predicates for labels  [serial 1358] 


Theorem (239)                               [serial 1348] 
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [119] ->
Q [12] << SB()
  and not EB() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1342]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 238:
Theorem (238) [serial 1358] used for:
    normalization of [serial 1348] 


Theorem (240)                               [serial 1342] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119] ->
Q [12] << SB()
  and not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1339]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 239:
Theorem (239) [serial 1348] used for:
  Associativity: (b.c).a = a.b.c [serial 1342] 


Theorem (241)                               [serial 1364] 
P [119] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( SB()
  and not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1354]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (242)                               [serial 1354] 
P [119] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( SB()
  and not EB() )@now >>
S [119] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1349]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 241:
Theorem (241) [serial 1364] used for:
    normalization of [serial 1354] 


Theorem (243)                               [serial 1349] 
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and ( SB()
  and not EB() )@now >>
S [119] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1343]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 242:
Theorem (242) [serial 1354] used for:
  Associativity: (b.c).a = a.b.c [serial 1349] 


Theorem (244)                               [serial 1343] 
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( SB()
  and not EB() )@now >>
S [119] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1339]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 243:
Theorem (243) [serial 1349] used for:
  Associativity: (b.c).a = a.b.c [serial 1343] 


Theorem (245)                               [serial 1339] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119] sb!(true)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1163]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 240 244:
Theorem (240) [serial 1342] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1339] 
Theorem (244) [serial 1343] used for:
  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1339] 


Theorem (246)                               [serial 1405] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [119] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:    normalization of [serial 1400]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (247)                               [serial 1400] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [119] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1393]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 246:
Theorem (246) [serial 1405] used for:
    normalization of [serial 1400] 


Theorem (248)                               [serial 1393] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [119] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
Why created:    normalization of [serial 1388]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 247:
Theorem (247) [serial 1400] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1393] 


Theorem (249)                               [serial 1388] 
P [105] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [119] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1381]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 248:
Theorem (248) [serial 1393] used for:
    normalization of [serial 1388] 


Theorem (250)                               [serial 1381] 
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [119] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1376]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 249:
Theorem (249) [serial 1388] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1381] 


Theorem (251)                               [serial 1376] 
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [119] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1360]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 250:
Theorem (250) [serial 1381] used for:
    normalization of [serial 1376] 


Theorem (252)                               [serial 1360] 
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [119] << not EB() >>
Why created:    normalization of [serial 1350]
Solved by:  Substitution of Assertion Labels
and theorem 251:
Theorem (251) [serial 1376] used for:
  Substituted assertions' predicates for labels  [serial 1360] 


Theorem (253)                               [serial 1350] 
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [119] ->
Q [119] << not EB() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1344]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 252:
Theorem (252) [serial 1360] used for:
    normalization of [serial 1350] 


Theorem (254)                               [serial 1344] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119] ->
Q [119] << not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1340]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 253:
Theorem (253) [serial 1350] used for:
  Associativity: (b.c).a = a.b.c [serial 1344] 


Theorem (255)                               [serial 1366] 
P [119] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( not EB() )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1355]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (256)                               [serial 1355] 
P [119] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( not EB() )@now >>
S [119] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1351]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 255:
Theorem (255) [serial 1366] used for:
    normalization of [serial 1355] 


Theorem (257)                               [serial 1351] 
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and ( not EB() )@now >>
S [119] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1345]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 256:
Theorem (256) [serial 1355] used for:
  Associativity: (b.c).a = a.b.c [serial 1351] 


Theorem (258)                               [serial 1345] 
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( not EB() )@now >>
S [119] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1340]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 257:
Theorem (257) [serial 1351] used for:
  Associativity: (b.c).a = a.b.c [serial 1345] 


Theorem (259)                               [serial 1340] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119] eb!(false)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1163]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 254 258:
Theorem (254) [serial 1344] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1340] 
Theorem (258) [serial 1345] used for:
  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1340] 


Theorem (260)                               [serial 1368] 
P [119] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and ( ca = 0 mpss )@now
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1356]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (261)                               [serial 1356] 
P [119] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and ( ca = ( 0 mpss ) )@now >>
S [119] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1352]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 260:
Theorem (260) [serial 1368] used for:
    normalization of [serial 1356] 


Theorem (262)                               [serial 1352] 
P [119] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and ( ca = ( 0 mpss ) )@now >>
S [119] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1346]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 261:
Theorem (261) [serial 1356] used for:
  Associativity: (b.c).a = a.b.c [serial 1352] 


Theorem (263)                               [serial 1346] 
P [119] << ( ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) )
  and ( ca = ( 0 mpss ) )@now >>
S [119] ->
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1341]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 262:
Theorem (262) [serial 1352] used for:
  Associativity: (b.c).a = a.b.c [serial 1346] 


Theorem (264)                               [serial 1414] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [33] << not ( v < iSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:    normalization of [serial 1408]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (265)                               [serial 1408] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1395]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 264:
Theorem (264) [serial 1414] used for:
    normalization of [serial 1408] 


Theorem (266)                               [serial 1395] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:    normalization of [serial 1389]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 265:
Theorem (265) [serial 1408] used for:
  Associativity: (b.c).a = a.b.c [serial 1395] 


Theorem (267)                               [serial 1389] 
P [105] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1383]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 266:
Theorem (266) [serial 1395] used for:
    normalization of [serial 1389] 


Theorem (268)                               [serial 1383] 
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1377]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 267:
Theorem (267) [serial 1389] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1383] 


Theorem (269)                               [serial 1377] 
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1362]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 268:
Theorem (268) [serial 1383] used for:
    normalization of [serial 1377] 


Theorem (270)                               [serial 1362] 
P [105] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [119] ->
Q [33] << EB()
   or SB() >>
Why created:    normalization of [serial 1353]
Solved by:  Substitution of Assertion Labels
and theorem 269:
Theorem (269) [serial 1377] used for:
  Substituted assertions' predicates for labels  [serial 1362] 


Theorem (271)                               [serial 1353] 
P [105] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) >>
S [119] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1347]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 270:
Theorem (270) [serial 1362] used for:
    normalization of [serial 1353] 


Theorem (272)                               [serial 1347] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1341]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 271:
Theorem (271) [serial 1353] used for:
  Associativity: (b.c).a = a.b.c [serial 1347] 


Theorem (273)                               [serial 1341] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119] ca!(0 mpss)
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1163]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 263 272:
Theorem (263) [serial 1346] used for:
  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1341] 
Theorem (272) [serial 1347] used for:
  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1341] 


Theorem (274)                               [serial 1163] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]   sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1158]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 245 259 273:
Theorem (245) [serial 1339] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1163] 
Theorem (259) [serial 1340] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1163] 
Theorem (273) [serial 1341] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1163] 


Theorem (275)                               [serial 1158] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [119]   {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:    <<P and B3>> S3 <<Q>> in alternative for [serial 1153]
Solved by:  Introduction of Existential Quantification
and theorem 274:
Theorem (274) [serial 1163] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1158] 


Theorem (276)                               [serial 1465] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
Why created:    normalization of [serial 1461]
Solved by:  Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}


Theorem (277)                               [serial 1461] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) )
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1457]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 276:
Theorem (276) [serial 1465] used for:
    normalization of [serial 1461] 


Theorem (278)                               [serial 1457] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << not ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:    normalization of [serial 1453]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 277:
Theorem (277) [serial 1461] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1457] 


Theorem (279)                               [serial 1453] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or not ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1451]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 278:
Theorem (278) [serial 1457] used for:
    normalization of [serial 1453] 


Theorem (280)                               [serial 1451] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1448]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 279:
Theorem (279) [serial 1453] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1451] 


Theorem (281)                               [serial 1448] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1444]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 280:
Theorem (280) [serial 1451] used for:
  Associativity: (b.c).a = a.b.c [serial 1448] 


Theorem (282)                               [serial 1444] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1441]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 281:
Theorem (281) [serial 1448] used for:
    normalization of [serial 1444] 


Theorem (283)                               [serial 1441] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << EB()
   or not SB() >>
Why created:    normalization of [serial 1438]
Solved by:  Substitution of Assertion Labels
and theorem 282:
Theorem (282) [serial 1444] used for:
  Substituted assertions' predicates for labels  [serial 1441] 


Theorem (284)                               [serial 1438] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << ( not ( SB() )
   or not ( not EB() ) ) >>
Why created:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1430]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 283:
Theorem (283) [serial 1441] used for:
    normalization of [serial 1438] 


Theorem (285)                               [serial 1430] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << not ( SB()
  and not EB() ) >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1427]
Solved by:  DeMorgan's Law: not (A and B) = (not A) or (not B)
and theorem 284:
Theorem (284) [serial 1438] used for:
  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1430] 


Theorem (286)                               [serial 1435] 
P [124] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( SB()
  and not EB() ) )@now >>
S [124] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1431]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (287)                               [serial 1431] 
P [124] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( SB()
  and not EB() ) )@now >>
S [124] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1427]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 286:
Theorem (286) [serial 1435] used for:
  Associativity: (b.c).a = a.b.c [serial 1431] 


Theorem (288)                               [serial 1427] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1424]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 285 287:
Theorem (285) [serial 1430] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1427] 
Theorem (287) [serial 1431] used for:
  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1427] 


Theorem (289)                               [serial 1424] 
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124] sb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1422]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 288:
Theorem (288) [serial 1427] used for:
  Associativity: (b.c).a = a.b.c [serial 1424] 


Theorem (290)                               [serial 1469] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [124] ->
Q [86] << v < iSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1468]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (291)                               [serial 1470] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [124] ->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1468]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (292)                               [serial 1468] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [124] ->
Q [124] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:  Transitivity: x<y and y<z -> x<z  [serial 1463]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 290 291:
Theorem (290) [serial 1469] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1468] 
Theorem (291) [serial 1470] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1468] 


Theorem (293)                               [serial 1463] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:    normalization of [serial 1460]
Solved by:  Transitivity: x<y and y<z -> x<z
and theorem 292:
Theorem (292) [serial 1468] used for:
  Transitivity: x<y and y<z -> x<z  [serial 1463] 


Theorem (294)                               [serial 1460] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1455]
Solved by:  Reflexivity of Addition: a+b=b+a
  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 293:
Theorem (293) [serial 1463] used for:
    normalization of [serial 1460] 


Theorem (295)                               [serial 1455] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
Why created:    normalization of [serial 1452]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 294:
Theorem (294) [serial 1460] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1455] 


Theorem (296)                               [serial 1452] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1446]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 295:
Theorem (295) [serial 1455] used for:
    normalization of [serial 1452] 


Theorem (297)                               [serial 1446] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and i < CMA.num_segments
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1443]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 296:
Theorem (296) [serial 1452] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1446] 


Theorem (298)                               [serial 1443] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1432]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 297:
Theorem (297) [serial 1446] used for:
    normalization of [serial 1443] 


Theorem (299)                               [serial 1432] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ->
Q [124] << not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1428]
Solved by:  Substitution of Assertion Labels
and theorem 298:
Theorem (298) [serial 1443] used for:
  Substituted assertions' predicates for labels  [serial 1432] 


Theorem (300)                               [serial 1436] 
P [124] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not EB() )@now >>
S [124] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1433]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (301)                               [serial 1433] 
P [124] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not EB() )@now >>
S [124] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1428]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 300:
Theorem (300) [serial 1436] used for:
  Associativity: (b.c).a = a.b.c [serial 1433] 


Theorem (302)                               [serial 1428] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] eb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1425]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 299 301:
Theorem (299) [serial 1432] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1428] 
Theorem (301) [serial 1433] used for:
  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1428] 


Theorem (303)                               [serial 1425] 
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124] eb!(false)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1422]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 302:
Theorem (302) [serial 1428] used for:
  Associativity: (b.c).a = a.b.c [serial 1425] 


Theorem (304)                               [serial 1437] 
P [124] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( ca = xl )@now >>
S [124] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1434]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (305)                               [serial 1434] 
P [124] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( ca = xl )@now >>
S [124] ->
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1429]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 304:
Theorem (304) [serial 1437] used for:
  Associativity: (b.c).a = a.b.c [serial 1434] 


Theorem (306)                               [serial 1429] 
P [105] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [124] ca!(xl)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1426]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorem 305:
Theorem (305) [serial 1434] used for:
  applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1429] 


Theorem (307)                               [serial 1426] 
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124] ca!(xl)
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1422]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 306:
Theorem (306) [serial 1429] used for:
  Associativity: (b.c).a = a.b.c [serial 1426] 


Theorem (308)                               [serial 1422] 
P [105] << ( CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and i < CMA.num_segments )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [124]   sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1164]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 289 303 307:
Theorem (289) [serial 1424] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1422] 
Theorem (303) [serial 1425] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1422] 
Theorem (307) [serial 1426] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1422] 


Theorem (309)                               [serial 1164] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [124]   sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1159]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 308:
Theorem (308) [serial 1422] used for:
    normalization of [serial 1164] 


Theorem (310)                               [serial 1159] 
P [105] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [124]   {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:    <<P and B4>> S4 <<Q>> in alternative for [serial 1153]
Solved by:  Introduction of Existential Quantification
and theorem 309:
Theorem (309) [serial 1164] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1159] 


Theorem (311)                               [serial 1153] 
P [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [105]   if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1151]
Solved by:  Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>>
and theorems 123 150 178 226 275 310:
Theorem (123) [serial 1154] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1153] 
Theorem (150) [serial 1155] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1153] 
Theorem (178) [serial 1156] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1153] 
Theorem (226) [serial 1157] used for:
    <<P and B2>> S2 <<Q>> in alternative for [serial 1153] 
Theorem (275) [serial 1158] used for:
    <<P and B3>> S3 <<Q>> in alternative for [serial 1153] 
Theorem (310) [serial 1159] used for:
    <<P and B4>> S4 <<Q>> in alternative for [serial 1153] 


Theorem (312)                               [serial 1151] 
P [100] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1017]
Solved by:  Introduction of Existential Quantification
and theorems 111 311:
Theorem (111) [serial 1152] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1151] 
Theorem (311) [serial 1153] used for:
  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1151] 


Theorem (313)                               [serial 1017] 
P [100] << ( i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [101] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:   <<M(MoveForward) and x>> A <<M(CheckMoveForward)>> for CheckSpeed: MoveForward-[x]->CheckMoveForward{A};
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 312:
Theorem (312) [serial 1151] used for:
  Associativity: (b.c).a = a.b.c [serial 1017] 


Theorem (314)                               [serial 1472] 
P [59] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments
  and p < iSeg.e >>
S [128] ->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1018]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (315)                               [serial 1018] 
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p < iSeg.e ) >>
S [128] ->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:   <<M(CheckMoveForward) and x>> -> <<M(MoveForward)>> for SameSegment: CheckMoveForward-[x]->MoveForward{};
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 314:
Theorem (314) [serial 1472] used for:
    normalization of [serial 1018] 


Theorem (316)                               [serial 1479] 
P [59] << iSeg.e <= p
  and CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
S [134] ->
Q [135] << CMA = ma
  and CMA.seg[1 + i] = nSeg >>
Why created:    normalization of [serial 1476]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (317)                               [serial 1476] 
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134] ->
Q [135] << nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  applied wp for assignment [serial 1474]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 316:
Theorem (316) [serial 1479] used for:
    normalization of [serial 1476] 


Theorem (318)                               [serial 1474] 
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134] iSeg := nSeg
Q [135] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1019]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 317:
Theorem (317) [serial 1476] used for:
  applied wp for assignment [serial 1474] 


Theorem (319)                               [serial 1481] 
P [135] << CMA = ma
  and CMA.seg[1 + i] = iSeg >>
S [136] ->
Q [61] << CMA = ma
  and CMA.seg[1 + i] = iSeg >>
Why created:    normalization of [serial 1477]
Solved by:  Identity (id):  P->P is tautology


Theorem (320)                               [serial 1477] 
P [135] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [136] ->
Q [61] << iSeg = CMA.seg[( i + 1 )]
  and ma = CMA >>
Why created:  applied wp for assignment [serial 1475]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 319:
Theorem (319) [serial 1481] used for:
    normalization of [serial 1477] 


Theorem (321)                               [serial 1475] 
P [135] << iSeg = CMA.seg[i + 1]
  and ma = CMA >>
S [136] i := i + 1
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1019]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 320:
Theorem (320) [serial 1477] used for:
  applied wp for assignment [serial 1475] 


Theorem (322)                               [serial 1019] 
P [59] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA
  and ( p >= iSeg.e ) >>
S [134]   iSeg := nSeg
  ;
  << iSeg = CMA.seg[i + 1]
    and ma = CMA >>
  i := i + 1 
Q [61] << iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:   <<M(CheckMoveForward) and x>> A <<M(CheckForLastSegment)>> for NextSegment: CheckMoveForward-[x]->CheckForLastSegment{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 318 321:
Theorem (318) [serial 1474] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1019] 
Theorem (321) [serial 1475] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1019] 


Theorem (323)                               [serial 1488] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141] ->
Q [57] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1486]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (324)                               [serial 1489] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141] ->
Q [57] << CMA.seg[i] = iSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1486]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (325)                               [serial 1494] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141] ->
Q [57] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1492]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (326)                               [serial 1492] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141] ->
Q [57] << ma.seg[1 + i] = ma.seg[1 + i] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1490]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 325:
Theorem (325) [serial 1494] used for:
  Equality Law (idistr):  a=a <-> true [serial 1492] 


Theorem (327)                               [serial 1490] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141] ->
Q [57] << CMA.seg[1 + i] = ma.seg[1 + i] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1486]
Solved by:  Guided Substitution of Equals
and theorem 326:
Theorem (326) [serial 1492] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1490] 


Theorem (328)                               [serial 1493] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141] ->
Q [57] << i < ma.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1491]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (329)                               [serial 1491] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141] ->
Q [57] << i < CMA.num_segments >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1486]
Solved by:  Guided Substitution of Equals
and theorem 328:
Theorem (328) [serial 1493] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1491] 


Theorem (330)                               [serial 1486] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i < ma.num_segments >>
S [141] ->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = ma.seg[1 + i]
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1484]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 323 324 327 329:
Theorem (323) [serial 1488] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1486] 
Theorem (324) [serial 1489] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1486] 
Theorem (327) [serial 1490] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1486] 
Theorem (329) [serial 1491] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1486] 


Theorem (331)                               [serial 1484] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141] ->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma.seg[i + 1] = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  applied wp for assignment [serial 1020]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 330:
Theorem (330) [serial 1486] used for:
    normalization of [serial 1484] 


Theorem (332)                               [serial 1020] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i < ma.num_segments ) >>
S [141] nSeg := ma.seg[i + 1]
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:   <<M(CheckForLastSegment) and x>> A <<M(MoveForward)>> for NotLastSegment: CheckForLastSegment-[x]->MoveForward{A};
Solved by:  Asserted Action:  <<P>> { <<P1>> S1 <<Q1>> } <<Q>> is <<P>> -> <<P1>>, <<Q1>> -> <<Q>>, and <<P1>> S1 <<Q1>>
  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 331:
Theorem (331) [serial 1484] used for:
  applied wp for assignment [serial 1020] 


Theorem (333)                               [serial 1501] 
P [61] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146] ->
Q [146] << true >>
Why created:    normalization of [serial 1497]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (334)                               [serial 1497] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146] ->
Q [146] << true >>
Why created:  applied port output <<pre>> -> <<M[r]>> [serial 1495]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 333:
Theorem (333) [serial 1501] used for:
    normalization of [serial 1497] 


Theorem (335)                               [serial 1519] 
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146] ->
Q [147] << CMA = ma >>
Why created:    normalization of [serial 1514]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (336)                               [serial 1514] 
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146] ->
Q [147] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1509]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 335:
Theorem (335) [serial 1519] used for:
    normalization of [serial 1514] 


Theorem (337)                               [serial 1530] 
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146] ->
Q [147] << i = ma.num_segments >>
Why created:    normalization of [serial 1527]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (338)                               [serial 1527] 
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146] ->
Q [147] << ma.num_segments = i >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1521]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
and theorem 337:
Theorem (337) [serial 1530] used for:
    normalization of [serial 1527] 


Theorem (339)                               [serial 1521] 
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146] ->
Q [147] << CMA.num_segments = i >>
Why created:    normalization of [serial 1515]
Solved by:  Guided Substitution of Equals
and theorem 338:
Theorem (338) [serial 1527] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1521] 


Theorem (340)                               [serial 1515] 
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146] ->
Q [147] << CMA.num_segments = i >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1509]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 339:
Theorem (339) [serial 1521] used for:
    normalization of [serial 1515] 


Theorem (341)                               [serial 1523] 
P [146] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments >>
S [146] ->
Q [147] << CMA.seg[i] = iSeg >>
Why created:    normalization of [serial 1516]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (342)                               [serial 1516] 
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146] ->
Q [147] << CMA.seg[i] = iSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1509]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 341:
Theorem (341) [serial 1523] used for:
    normalization of [serial 1516] 


Theorem (343)                               [serial 1509] 
P [146] << ( ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) ) >>
S [146] ->
Q [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
Why created:  Law of And-Simplification:  P and true is P [serial 1503]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 336 340 342:
Theorem (336) [serial 1514] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1509] 
Theorem (340) [serial 1515] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1509] 
Theorem (342) [serial 1516] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1509] 


Theorem (344)                               [serial 1503] 
P [146] << true
  and ( CMA = ma
  and CMA.seg[i] = iSeg
  and i = ma.num_segments ) >>
S [146] ->
Q [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
Why created:    normalization of [serial 1498]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 343:
Theorem (343) [serial 1509] used for:
  Law of And-Simplification:  P and true is P [serial 1503] 


Theorem (345)                               [serial 1498] 
P [146] << ( iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) )
  and true@now >>
S [146] ->
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1495]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Constants are always the same
and theorem 344:
Theorem (344) [serial 1503] used for:
    normalization of [serial 1498] 


Theorem (346)                               [serial 1495] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146] r!
Q [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1021]
Solved by:  Port Event Output: when <<A and p@now>> -> <<B>> and <<A>> -> <<M(p)>> then <<A>> p! <<B>>
and theorems 334 345:
Theorem (334) [serial 1497] used for:
  applied port output <<pre>> -> <<M[r]>> [serial 1495] 
Theorem (345) [serial 1498] used for:
  applied port output <<pre and M[r]@now>> -> <<post>> [serial 1495] 


Theorem (347)                               [serial 1510] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (348)                               [serial 1511] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << CMA.num_segments = i >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (349)                               [serial 1512] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << CMA.seg[i] = iSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (350)                               [serial 1534] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1533]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (351)                               [serial 1533] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << ( [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] ) = [segment: v_n->0 mps; 
v_e->0 mps; e->ma.ea;] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1532]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 350:
Theorem (350) [serial 1534] used for:
  Equality Law (idistr):  a=a <-> true [serial 1533] 


Theorem (352)                               [serial 1532] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] ) = [segment: v_n->0 mps; 
v_e->0 mps; e->ma.ea;] >>
Why created:  Substituted assertions' predicates for labels in postconditions [serial 1513]
Solved by:  Guided Substitution of Equals
and theorem 351:
Theorem (351) [serial 1533] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1532] 


Theorem (353)                               [serial 1513] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505]
Solved by:  Guided Substitution of Equals
  Substitution of Assertion Labels
and theorem 352:
Theorem (352) [serial 1532] used for:
  Substituted assertions' predicates for labels in postconditions [serial 1513] 


Theorem (354)                               [serial 1505] 
P [147] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
S [149] ->
Q [63] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NULL_SEGMENT() = [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] >>
Why created:    normalization of [serial 1499]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 347 348 349 353:
Theorem (347) [serial 1510] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505] 
Theorem (348) [serial 1511] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505] 
Theorem (349) [serial 1512] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505] 
Theorem (353) [serial 1513] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1505] 


Theorem (355)                               [serial 1499] 
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149] ->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ( [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] ) = NULL_SEGMENT()
  and ma = CMA >>
Why created:  applied wp for assignment [serial 1496]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 354:
Theorem (354) [serial 1505] used for:
    normalization of [serial 1499] 


Theorem (356)                               [serial 1496] 
P [147] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA >>
S [149] nSeg := [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;]
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1021]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 355:
Theorem (355) [serial 1499] used for:
  applied wp for assignment [serial 1496] 


Theorem (357)                               [serial 1021] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i = ma.num_segments ) >>
S [146]   r!
  ;
  << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA >>
  nSeg := [segment: v_n->0 mps; v_e->0 mps; e->ma.ea;] 
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:   <<M(CheckForLastSegment) and x>> A <<M(MoveForwardLastSegment)>> for IsLastSegment: CheckForLastSegment-[x]->MoveForwardLastSegment{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 346 356:
Theorem (346) [serial 1495] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1021] 
Theorem (356) [serial 1496] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1021] 


Theorem (358)                               [serial 1022] 
P [61] << iSeg = CMA.seg[i]
  and ma = CMA
  and ( i > ma.num_segments ) >>
S [155] ->
Q [72] << true >>
Why created:   <<M(CheckForLastSegment) and x>> -> <<M(FAIL)>> for PastLastSegment: CheckForLastSegment-[x]->FAIL{};
Solved by:  True Conclusion Schema (tc): P->true


Theorem (359)                               [serial 1576] 
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159] ->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1575]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (360)                               [serial 1575] 
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159] ->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and true
  and true
  and true
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 359:
Theorem (359) [serial 1576] used for:
  Law of And-Simplification:  P and true is P [serial 1575] 


Theorem (361)                               [serial 1576] 
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159] ->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Law of And-Simplification:  P and true is P [serial 1575]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (362)                               [serial 1575] 
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159] ->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and true
  and true
  and true
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 361:
Theorem (361) [serial 1576] used for:
  Law of And-Simplification:  P and true is P [serial 1575] 


Theorem (363)                               [serial 1569] 
P [159] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159] ->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1549]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 362 362:
Theorem (362) [serial 1575] used for:
   add user-defined axioms to postcondition 
Theorem (362) [serial 1575] used for:
   add user-defined axioms to postcondition 


Theorem (364)                               [serial 1549] 
P [159] << p@now
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() ) >>
S [159] ->
Q [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
Why created:    normalization of [serial 1535]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 363:
Theorem (363) [serial 1569] used for:
  Associativity: (b.c).a = a.b.c [serial 1549] 


Theorem (365)                               [serial 1535] 
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [159] ->
Q [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
Why created:  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 364:
Theorem (364) [serial 1549] used for:
    normalization of [serial 1535] 


Theorem (366)                               [serial 1589] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163] ->
Q [163] << true >>
Why created:    normalization of [serial 1587]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (367)                               [serial 1587] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163] ->
Q [163] << ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1586]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 366:
Theorem (366) [serial 1589] used for:
    normalization of [serial 1587] 


Theorem (368)                               [serial 1586] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163] ->
Q [163] << ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1585]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 367:
Theorem (367) [serial 1587] used for:
  Law of And-Simplification:  P and P is P [serial 1586] 


Theorem (369)                               [serial 1585] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163] ->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1584]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 368:
Theorem (368) [serial 1586] used for:
  Law of And-Simplification:  P and P is P [serial 1585] 


Theorem (370)                               [serial 1584] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163] ->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1583]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 369:
Theorem (369) [serial 1585] used for:
  Law of And-Simplification:  P and P is P [serial 1584] 


Theorem (371)                               [serial 1583] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163] ->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of And-Simplification:  P and P is P [serial 1582]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 370:
Theorem (370) [serial 1584] used for:
  Law of And-Simplification:  P and P is P [serial 1583] 


Theorem (372)                               [serial 1582] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163] ->
Q [163] << ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true )
  and ( true ) >>
Why created:  Law of Excluded Middle: P or not P is tautology [serial 1581]
Solved by:  Law of And-Simplification:  P and P is P
and theorem 371:
Theorem (371) [serial 1583] used for:
  Law of And-Simplification:  P and P is P [serial 1582] 


Theorem (373)                               [serial 1581] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163] ->
Q [163] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v < iSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
   or not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
Why created:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1579]
Solved by:  Law of Excluded Middle: P or not P is tautology
and theorem 372:
Theorem (372) [serial 1582] used for:
  Law of Excluded Middle: P or not P is tautology [serial 1581] 


Theorem (374)                               [serial 1579] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163] ->
Q [163] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v < iSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:    normalization of [serial 1577]
Solved by:  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and
and theorem 373:
Theorem (373) [serial 1581] used for:
  Distribution of preconditions, and over or, and distribution of postcondtitions, or over and  while transforming into
  conjunctive normal form [serial 1579] 


Theorem (375)                               [serial 1577] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163] ->
Q [163] << ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( ( not ( v < iSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1551]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 374:
Theorem (374) [serial 1579] used for:
    normalization of [serial 1577] 


Theorem (376)                               [serial 1551] 
P [160] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163] ->
Q [163] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
Why created:    normalization of [serial 1537]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 375:
Theorem (375) [serial 1577] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1551] 


Theorem (377)                               [serial 1537] 
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163] ->
Q [163] << ( v >= iSeg.v_e )
   or ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1536]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 376:
Theorem (376) [serial 1551] used for:
    normalization of [serial 1537] 


Theorem (378)                               [serial 1607] 
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165] ->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
Why created:    normalization of [serial 1603]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (379)                               [serial 1603] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165] ->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1594]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 378:
Theorem (378) [serial 1607] used for:
    normalization of [serial 1603] 


Theorem (380)                               [serial 1594] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165] ->
Q [14] << EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1591]
Solved by:  Substitution of Assertion Labels
and theorem 379:
Theorem (379) [serial 1603] used for:
  Substituted assertions' predicates for labels  [serial 1594] 


Theorem (381)                               [serial 1600] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( EB() )@now >>
S [165] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1595]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (382)                               [serial 1595] 
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( EB() )@now >>
S [165] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1591]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 381:
Theorem (381) [serial 1600] used for:
  Associativity: (b.c).a = a.b.c [serial 1595] 


Theorem (383)                               [serial 1591] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165] eb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1570]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 380 382:
Theorem (380) [serial 1594] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1591] 
Theorem (382) [serial 1595] used for:
  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1591] 


Theorem (384)                               [serial 1626] 
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165] ->
Q [165] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1623]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (385)                               [serial 1623] 
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165] ->
Q [165] << ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1620]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 384:
Theorem (384) [serial 1626] used for:
  Associativity: (b.c).a = a.b.c [serial 1623] 


Theorem (386)                               [serial 1620] 
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165] ->
Q [165] << ( not ( not ( iSeg.v_e <= v ) )
   or not ( not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or ( not ( iSeg.v_n <= v )
  and not ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1618]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 385:
Theorem (385) [serial 1623] used for:
    normalization of [serial 1620] 


Theorem (387)                               [serial 1618] 
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165] ->
Q [165] << not ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) )
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1615]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 386:
Theorem (386) [serial 1620] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1618] 


Theorem (388)                               [serial 1615] 
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165] ->
Q [165] << ( not ( ( not ( iSeg.v_e <= v )
  and not ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) ) )
   or not ( ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1609]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 387:
Theorem (387) [serial 1618] used for:
    normalization of [serial 1615] 


Theorem (389)                               [serial 1609] 
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165] ->
Q [165] << not ( not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) ) >>
Why created:    normalization of [serial 1604]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 388:
Theorem (388) [serial 1615] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1609] 


Theorem (390)                               [serial 1604] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165] ->
Q [165] << not ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1596]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 389:
Theorem (389) [serial 1609] used for:
    normalization of [serial 1604] 


Theorem (391)                               [serial 1596] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165] ->
Q [165] << not ( SB()
  and not EB() ) >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1592]
Solved by:  Substitution of Assertion Labels
and theorem 390:
Theorem (390) [serial 1604] used for:
  Substituted assertions' predicates for labels  [serial 1596] 


Theorem (392)                               [serial 1601] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( not ( SB()
  and not EB() ) )@now >>
S [165] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1597]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (393)                               [serial 1597] 
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( not ( SB()
  and not EB() ) )@now >>
S [165] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1592]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 392:
Theorem (392) [serial 1601] used for:
  Associativity: (b.c).a = a.b.c [serial 1597] 


Theorem (394)                               [serial 1592] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165] sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1570]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 391 393:
Theorem (391) [serial 1596] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1592] 
Theorem (393) [serial 1597] used for:
  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1592] 


Theorem (395)                               [serial 1602] 
P [165] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v
  and ( ca = ( 0 mpss ) )@now >>
S [165] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1598]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (396)                               [serial 1598] 
P [165] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v )
  and ( ca = ( 0 mpss ) )@now >>
S [165] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1593]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 395:
Theorem (395) [serial 1602] used for:
  Associativity: (b.c).a = a.b.c [serial 1598] 


Theorem (397)                               [serial 1625] 
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165] ->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1611]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (398)                               [serial 1611] 
P [163] << iSeg.v_e <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [165] ->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1605]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 397:
Theorem (397) [serial 1625] used for:
  Associativity: (b.c).a = a.b.c [serial 1611] 


Theorem (399)                               [serial 1605] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and iSeg.v_e <= v >>
S [165] ->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1599]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 398:
Theorem (398) [serial 1611] used for:
    normalization of [serial 1605] 


Theorem (400)                               [serial 1599] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1593]
Solved by:  Substitution of Assertion Labels
and theorem 399:
Theorem (399) [serial 1605] used for:
  Substituted assertions' predicates for labels  [serial 1599] 


Theorem (401)                               [serial 1593] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165] ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1570]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 396 400:
Theorem (396) [serial 1598] used for:
  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1593] 
Theorem (400) [serial 1599] used for:
  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1593] 


Theorem (402)                               [serial 1570] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and iSeg.v_e <= v >>
S [165]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1553]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 383 394 401:
Theorem (383) [serial 1591] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1570] 
Theorem (394) [serial 1592] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1570] 
Theorem (401) [serial 1593] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1570] 


Theorem (403)                               [serial 1553] 
P [163] << iSeg.v_e <= v
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [165]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:    normalization of [serial 1543]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 402:
Theorem (402) [serial 1570] used for:
  Associativity: (b.c).a = a.b.c [serial 1553] 


Theorem (404)                               [serial 1543] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1538]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 403:
Theorem (403) [serial 1553] used for:
    normalization of [serial 1543] 


Theorem (405)                               [serial 1538] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_e ) >>
S [165]   {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B0>> S0 <<Q>> in alternative for [serial 1536]
Solved by:  Introduction of Existential Quantification
and theorem 404:
Theorem (404) [serial 1543] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1538] 


Theorem (406)                               [serial 1667] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168] ->
Q [14] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
Why created:    normalization of [serial 1663]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (407)                               [serial 1663] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168] ->
Q [14] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1637]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 406:
Theorem (406) [serial 1667] used for:
    normalization of [serial 1663] 


Theorem (408)                               [serial 1637] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168] ->
Q [14] << EB() >>
Why created:    normalization of [serial 1630]
Solved by:  Substitution of Assertion Labels
and theorem 407:
Theorem (407) [serial 1663] used for:
  Substituted assertions' predicates for labels  [serial 1637] 


Theorem (409)                               [serial 1630] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168] ->
Q [14] << EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1627]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 408:
Theorem (408) [serial 1637] used for:
    normalization of [serial 1630] 


Theorem (410)                               [serial 1654] 
P [168] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and EB()@now >>
S [168] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1639]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (411)                               [serial 1639] 
P [168] << EB()@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:    normalization of [serial 1631]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 410:
Theorem (410) [serial 1654] used for:
  Associativity: (b.c).a = a.b.c [serial 1639] 


Theorem (412)                               [serial 1631] 
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( EB() )@now >>
S [168] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1627]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 411:
Theorem (411) [serial 1639] used for:
    normalization of [serial 1631] 


Theorem (413)                               [serial 1627] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168] eb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1571]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 409 412:
Theorem (409) [serial 1630] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|true]>> [serial 1627] 
Theorem (412) [serial 1631] used for:
  applied port output <<pre and (EB())@now>> -> <<post>> [serial 1627] 


Theorem (414)                               [serial 1676] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168] ->
Q [168] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1671]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (415)                               [serial 1671] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168] ->
Q [168] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1665]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 414:
Theorem (414) [serial 1676] used for:
  Associativity: (b.c).a = a.b.c [serial 1671] 


Theorem (416)                               [serial 1665] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168] ->
Q [168] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1661]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 415:
Theorem (415) [serial 1671] used for:
    normalization of [serial 1665] 


Theorem (417)                               [serial 1661] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168] ->
Q [168] << EB()
   or not SB() >>
Why created:    normalization of [serial 1657]
Solved by:  Substitution of Assertion Labels
and theorem 416:
Theorem (416) [serial 1665] used for:
  Substituted assertions' predicates for labels  [serial 1661] 


Theorem (418)                               [serial 1657] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168] ->
Q [168] << ( not ( SB() )
   or not ( not EB() ) ) >>
Why created:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1641]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 417:
Theorem (417) [serial 1661] used for:
    normalization of [serial 1657] 


Theorem (419)                               [serial 1641] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168] ->
Q [168] << not ( SB()
  and not EB() ) >>
Why created:    normalization of [serial 1632]
Solved by:  DeMorgan's Law: not (A and B) = (not A) or (not B)
and theorem 418:
Theorem (418) [serial 1657] used for:
  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1641] 


Theorem (420)                               [serial 1632] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168] ->
Q [168] << not ( SB()
  and not EB() ) >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1628]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 419:
Theorem (419) [serial 1641] used for:
    normalization of [serial 1632] 


Theorem (421)                               [serial 1655] 
P [168] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not ( SB()
  and not EB() ) )@now >>
S [168] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1643]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (422)                               [serial 1643] 
P [168] << ( not ( SB()
  and not EB() ) )@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:    normalization of [serial 1633]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 421:
Theorem (421) [serial 1655] used for:
  Associativity: (b.c).a = a.b.c [serial 1643] 


Theorem (423)                               [serial 1633] 
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( not ( SB()
  and not EB() ) )@now >>
S [168] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1628]
Solved by:  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 422:
Theorem (422) [serial 1643] used for:
    normalization of [serial 1633] 


Theorem (424)                               [serial 1628] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168] sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1571]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 420 423:
Theorem (420) [serial 1632] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1628] 
Theorem (423) [serial 1633] used for:
  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1628] 


Theorem (425)                               [serial 1656] 
P [168] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = 0 mpss )@now >>
S [168] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1645]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (426)                               [serial 1645] 
P [168] << ( ca = 0 mpss )@now
  and ( e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:    normalization of [serial 1634]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 425:
Theorem (425) [serial 1656] used for:
  Associativity: (b.c).a = a.b.c [serial 1645] 


Theorem (427)                               [serial 1634] 
P [168] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( ca = ( 0 mpss ) )@now >>
S [168] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1629]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 426:
Theorem (426) [serial 1645] used for:
    normalization of [serial 1634] 


Theorem (428)                               [serial 1679] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168] ->
Q [33] << iSeg.v_e <= v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
Why created:    normalization of [serial 1675]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (429)                               [serial 1675] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168] ->
Q [33] << iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
   or iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1669]
Solved by:  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 428:
Theorem (428) [serial 1679] used for:
    normalization of [serial 1675] 


Theorem (430)                               [serial 1669] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e >>
S [168] ->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1664]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 429:
Theorem (429) [serial 1675] used for:
  Associativity: (b.c).a = a.b.c [serial 1669] 


Theorem (431)                               [serial 1664] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [168] ->
Q [33] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1647]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 430:
Theorem (430) [serial 1669] used for:
    normalization of [serial 1664] 


Theorem (432)                               [serial 1647] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [168] ->
Q [33] << EB()
   or SB() >>
Why created:    normalization of [serial 1635]
Solved by:  Substitution of Assertion Labels
and theorem 431:
Theorem (431) [serial 1664] used for:
  Substituted assertions' predicates for labels  [serial 1647] 


Theorem (433)                               [serial 1635] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1629]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 432:
Theorem (432) [serial 1647] used for:
    normalization of [serial 1635] 


Theorem (434)                               [serial 1629] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168] ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1571]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 427 433:
Theorem (427) [serial 1634] used for:
  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1629] 
Theorem (433) [serial 1635] used for:
  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1629] 


Theorem (435)                               [serial 1571] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v >>
S [168]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1555]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 413 424 434:
Theorem (413) [serial 1627] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1571] 
Theorem (424) [serial 1628] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1571] 
Theorem (434) [serial 1629] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1571] 


Theorem (436)                               [serial 1555] 
P [163] << e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [168]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:    normalization of [serial 1544]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 435:
Theorem (435) [serial 1571] used for:
  Associativity: (b.c).a = a.b.c [serial 1555] 


Theorem (437)                               [serial 1544] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [168]   eb!(true)
  &
  sb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1539]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 436:
Theorem (436) [serial 1555] used for:
    normalization of [serial 1544] 


Theorem (438)                               [serial 1539] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [168]   {
    eb!(true)
    &
    sb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B1>> S1 <<Q>> in alternative for [serial 1536]
Solved by:  Introduction of Existential Quantification
and theorem 437:
Theorem (437) [serial 1544] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1539] 


Theorem (439)                               [serial 1729] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [86] << v < iSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1728]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (440)                               [serial 1730] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1728]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (441)                               [serial 1733] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
Why created:    normalization of [serial 1731]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (442)                               [serial 1731] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1728]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 441:
Theorem (441) [serial 1733] used for:
    normalization of [serial 1731] 


Theorem (443)                               [serial 1728] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1722]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 439 440 442:
Theorem (439) [serial 1729] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1728] 
Theorem (440) [serial 1730] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1728] 
Theorem (442) [serial 1731] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1728] 


Theorem (444)                               [serial 1722] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:    normalization of [serial 1718]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 443:
Theorem (443) [serial 1728] used for:
  Associativity: (b.c).a = a.b.c [serial 1722] 


Theorem (445)                               [serial 1718] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1710]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 444:
Theorem (444) [serial 1722] used for:
    normalization of [serial 1718] 


Theorem (446)                               [serial 1710] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:    normalization of [serial 1706]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 445:
Theorem (445) [serial 1718] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1710] 


Theorem (447)                               [serial 1706] 
P [163] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1698]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 446:
Theorem (446) [serial 1710] used for:
    normalization of [serial 1706] 


Theorem (448)                               [serial 1698] 
P [163] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1694]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 447:
Theorem (447) [serial 1706] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1698] 


Theorem (449)                               [serial 1694] 
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172] ->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1685]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 448:
Theorem (448) [serial 1698] used for:
    normalization of [serial 1694] 


Theorem (450)                               [serial 1685] 
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172] ->
Q [12] << SB()
  and not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1682]
Solved by:  Substitution of Assertion Labels
and theorem 449:
Theorem (449) [serial 1694] used for:
  Substituted assertions' predicates for labels  [serial 1685] 


Theorem (451)                               [serial 1691] 
P [172] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( SB()
  and not EB() )@now >>
S [172] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1686]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (452)                               [serial 1686] 
P [172] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [172] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1682]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 451:
Theorem (451) [serial 1691] used for:
  Associativity: (b.c).a = a.b.c [serial 1686] 


Theorem (453)                               [serial 1682] 
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172] sb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1572]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 450 452:
Theorem (450) [serial 1685] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1682] 
Theorem (452) [serial 1686] used for:
  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1682] 


Theorem (454)                               [serial 1724] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [172] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:    normalization of [serial 1719]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (455)                               [serial 1719] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [172] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1712]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 454:
Theorem (454) [serial 1724] used for:
    normalization of [serial 1719] 


Theorem (456)                               [serial 1712] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [172] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
Why created:    normalization of [serial 1707]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 455:
Theorem (455) [serial 1719] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1712] 


Theorem (457)                               [serial 1707] 
P [163] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [172] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1700]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 456:
Theorem (456) [serial 1712] used for:
    normalization of [serial 1707] 


Theorem (458)                               [serial 1700] 
P [163] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [172] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1695]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 457:
Theorem (457) [serial 1707] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1700] 


Theorem (459)                               [serial 1695] 
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172] ->
Q [172] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1687]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 458:
Theorem (458) [serial 1700] used for:
    normalization of [serial 1695] 


Theorem (460)                               [serial 1687] 
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172] ->
Q [172] << not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1683]
Solved by:  Substitution of Assertion Labels
and theorem 459:
Theorem (459) [serial 1695] used for:
  Substituted assertions' predicates for labels  [serial 1687] 


Theorem (461)                               [serial 1692] 
P [172] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not EB() )@now >>
S [172] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1688]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (462)                               [serial 1688] 
P [172] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( not EB() )@now >>
S [172] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1683]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 461:
Theorem (461) [serial 1692] used for:
  Associativity: (b.c).a = a.b.c [serial 1688] 


Theorem (463)                               [serial 1683] 
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172] eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1572]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 460 462:
Theorem (460) [serial 1687] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1683] 
Theorem (462) [serial 1688] used for:
  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1683] 


Theorem (464)                               [serial 1693] 
P [172] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = ( 0 mpss ) )@now >>
S [172] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1689]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (465)                               [serial 1689] 
P [172] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( ca = ( 0 mpss ) )@now >>
S [172] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1684]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 464:
Theorem (464) [serial 1693] used for:
  Associativity: (b.c).a = a.b.c [serial 1689] 


Theorem (466)                               [serial 1727] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1714]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (467)                               [serial 1714] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v < iSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:    normalization of [serial 1708]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 466:
Theorem (466) [serial 1727] used for:
  Associativity: (b.c).a = a.b.c [serial 1714] 


Theorem (468)                               [serial 1708] 
P [163] << ( not ( v < iSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1702]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 467:
Theorem (467) [serial 1714] used for:
    normalization of [serial 1708] 


Theorem (469)                               [serial 1702] 
P [163] << iSeg.v_n <= v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [172] ->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1696]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 468:
Theorem (468) [serial 1708] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1702] 


Theorem (470)                               [serial 1696] 
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [172] ->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1690]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 469:
Theorem (469) [serial 1702] used for:
    normalization of [serial 1696] 


Theorem (471)                               [serial 1690] 
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1684]
Solved by:  Substitution of Assertion Labels
and theorem 470:
Theorem (470) [serial 1696] used for:
  Substituted assertions' predicates for labels  [serial 1690] 


Theorem (472)                               [serial 1684] 
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172] ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1572]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 465 471:
Theorem (465) [serial 1689] used for:
  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1684] 
Theorem (471) [serial 1690] used for:
  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1684] 


Theorem (473)                               [serial 1572] 
P [163] << iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [172]   sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1557]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 453 463 472:
Theorem (453) [serial 1682] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1572] 
Theorem (463) [serial 1683] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1572] 
Theorem (472) [serial 1684] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1572] 


Theorem (474)                               [serial 1557] 
P [163] << ( iSeg.v_n <= v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [172]   sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:    normalization of [serial 1545]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 473:
Theorem (473) [serial 1572] used for:
  Associativity: (b.c).a = a.b.c [serial 1557] 


Theorem (475)                               [serial 1545] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [172]   sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1540]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 474:
Theorem (474) [serial 1557] used for:
    normalization of [serial 1545] 


Theorem (476)                               [serial 1540] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v >= iSeg.v_n
  and v < iSeg.v_e
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [172]   {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B2>> S2 <<Q>> in alternative for [serial 1536]
Solved by:  Introduction of Existential Quantification
and theorem 475:
Theorem (475) [serial 1545] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1540] 


Theorem (477)                               [serial 1782] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [86] << v < iSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1781]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (478)                               [serial 1783] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1781]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (479)                               [serial 1786] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [35] << not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
Why created:    normalization of [serial 1784]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (480)                               [serial 1784] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [35] << ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1781]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 479:
Theorem (479) [serial 1786] used for:
    normalization of [serial 1784] 


Theorem (481)                               [serial 1781] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [12] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1775]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 477 478 480:
Theorem (477) [serial 1782] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1781] 
Theorem (478) [serial 1783] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1781] 
Theorem (480) [serial 1784] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1781] 


Theorem (482)                               [serial 1775] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [12] << ( v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:    normalization of [serial 1771]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 481:
Theorem (481) [serial 1781] used for:
  Associativity: (b.c).a = a.b.c [serial 1775] 


Theorem (483)                               [serial 1771] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [12] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1763]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 482:
Theorem (482) [serial 1775] used for:
    normalization of [serial 1771] 


Theorem (484)                               [serial 1763] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [12] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
  and ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:    normalization of [serial 1759]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 483:
Theorem (483) [serial 1771] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1763] 


Theorem (485)                               [serial 1759] 
P [163] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [12] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
  and ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1751]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 484:
Theorem (484) [serial 1763] used for:
    normalization of [serial 1759] 


Theorem (486)                               [serial 1751] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [12] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
  and ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1747]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 485:
Theorem (485) [serial 1759] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1751] 


Theorem (487)                               [serial 1747] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177] ->
Q [12] << ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
  and not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1738]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 486:
Theorem (486) [serial 1751] used for:
    normalization of [serial 1747] 


Theorem (488)                               [serial 1738] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177] ->
Q [12] << SB()
  and not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1735]
Solved by:  Substitution of Assertion Labels
and theorem 487:
Theorem (487) [serial 1747] used for:
  Substituted assertions' predicates for labels  [serial 1738] 


Theorem (489)                               [serial 1744] 
P [177] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( SB()
  and not EB() )@now >>
S [177] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1739]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (490)                               [serial 1739] 
P [177] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( SB()
  and not EB() )@now >>
S [177] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1735]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 489:
Theorem (489) [serial 1744] used for:
  Associativity: (b.c).a = a.b.c [serial 1739] 


Theorem (491)                               [serial 1735] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177] sb!(true)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1573]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 488 490:
Theorem (488) [serial 1738] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|true]>> [serial 1735] 
Theorem (490) [serial 1739] used for:
  applied port output <<pre and (SB()
  and not EB())@now>> -> <<post>> [serial 1735] 


Theorem (492)                               [serial 1777] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [177] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:    normalization of [serial 1772]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (493)                               [serial 1772] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [177] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1765]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 492:
Theorem (492) [serial 1777] used for:
    normalization of [serial 1772] 


Theorem (494)                               [serial 1765] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [177] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
Why created:    normalization of [serial 1760]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 493:
Theorem (493) [serial 1772] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1765] 


Theorem (495)                               [serial 1760] 
P [163] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [177] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1753]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 494:
Theorem (494) [serial 1765] used for:
    normalization of [serial 1760] 


Theorem (496)                               [serial 1753] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [177] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1748]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 495:
Theorem (495) [serial 1760] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1753] 


Theorem (497)                               [serial 1748] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177] ->
Q [177] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1740]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 496:
Theorem (496) [serial 1753] used for:
    normalization of [serial 1748] 


Theorem (498)                               [serial 1740] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177] ->
Q [177] << not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1736]
Solved by:  Substitution of Assertion Labels
and theorem 497:
Theorem (497) [serial 1748] used for:
  Substituted assertions' predicates for labels  [serial 1740] 


Theorem (499)                               [serial 1745] 
P [177] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( not EB() )@now >>
S [177] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1741]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (500)                               [serial 1741] 
P [177] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( not EB() )@now >>
S [177] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1736]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 499:
Theorem (499) [serial 1745] used for:
  Associativity: (b.c).a = a.b.c [serial 1741] 


Theorem (501)                               [serial 1736] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177] eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1573]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 498 500:
Theorem (498) [serial 1740] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1736] 
Theorem (500) [serial 1741] used for:
  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1736] 


Theorem (502)                               [serial 1746] 
P [177] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and ( ca = ( 0 mpss ) )@now >>
S [177] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1742]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (503)                               [serial 1742] 
P [177] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( ca = ( 0 mpss ) )@now >>
S [177] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1737]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 502:
Theorem (502) [serial 1746] used for:
  Associativity: (b.c).a = a.b.c [serial 1742] 


Theorem (504)                               [serial 1780] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [33] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1767]
Solved by:  And-Elimination/Or-Introduction Schema (ctao): (P and Q)->(P or R)


Theorem (505)                               [serial 1767] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n )
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [33] << ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) )
   or ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) >>
Why created:    normalization of [serial 1761]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 504:
Theorem (504) [serial 1780] used for:
  Associativity: (b.c).a = a.b.c [serial 1767] 


Theorem (506)                               [serial 1761] 
P [163] << ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [33] << ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) )
   or ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1755]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 505:
Theorem (505) [serial 1767] used for:
    normalization of [serial 1761] 


Theorem (507)                               [serial 1755] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [177] ->
Q [33] << ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v )
   or ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v ) >>
Why created:    normalization of [serial 1749]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 506:
Theorem (506) [serial 1761] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1755] 


Theorem (508)                               [serial 1749] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e ) >>
S [177] ->
Q [33] << ( ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) )
   or ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1743]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 507:
Theorem (507) [serial 1755] used for:
    normalization of [serial 1749] 


Theorem (509)                               [serial 1743] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177] ->
Q [33] << ( SB()
   or EB() ) >>
Why created:  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1737]
Solved by:  Substitution of Assertion Labels
and theorem 508:
Theorem (508) [serial 1749] used for:
  Substituted assertions' predicates for labels  [serial 1743] 


Theorem (510)                               [serial 1737] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177] ca!(0 mpss)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1573]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 503 509:
Theorem (503) [serial 1742] used for:
  applied port output <<pre and (ca=0 mpss)@now>> -> <<post>> [serial 1737] 
Theorem (509) [serial 1743] used for:
  applied port output of conditional expression <<pre>> -> <<( SB()
   or EB() )>> where ( SB()
   or EB() ) -> 0 mpss for ca!(0 mpss) 
[serial 1737] 


Theorem (511)                               [serial 1573] 
P [163] << b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [177]   sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1559]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 491 501 510:
Theorem (491) [serial 1735] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1573] 
Theorem (501) [serial 1736] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1573] 
Theorem (510) [serial 1737] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1573] 


Theorem (512)                               [serial 1559] 
P [163] << ( b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v
  and v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) ) >>
S [177]   sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:    normalization of [serial 1546]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 511:
Theorem (511) [serial 1573] used for:
  Associativity: (b.c).a = a.b.c [serial 1559] 


Theorem (513)                               [serial 1546] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [177]   sb!(true)
  &
  eb!(false)
  &
  ca!(0 mpss) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1541]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 512:
Theorem (512) [serial 1559] used for:
    normalization of [serial 1546] 


Theorem (514)                               [serial 1541] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
  and v < iSeg.v_e
  and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
S [177]   {
    sb!(true)
    &
    eb!(false)
    &
    ca!(0 mpss) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B3>> S3 <<Q>> in alternative for [serial 1536]
Solved by:  Introduction of Existential Quantification
and theorem 513:
Theorem (513) [serial 1546] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1541] 


Theorem (515)                               [serial 1826] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) >>
Why created:    normalization of [serial 1822]
Solved by:  Premise Has All Terms of Conjunction within Disjunction (animporan): |- ( /\( l1 l2 l3 ) -> \/( l4 /\( l2 ) l5 ) ) 
 for proof obligations of the form <<a1 and ... and an>> -> <<b1 or ... or bm>> 
  find any bj=(c1 and ... and cj) such that forall c in {c1,...,cj} there exists a in {a1,...,an}


Theorem (516)                               [serial 1822] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
   or ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) ) >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1821]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 515:
Theorem (515) [serial 1826] used for:
    normalization of [serial 1822] 


Theorem (517)                               [serial 1821] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << ( not ( not ( v < iSeg.v_n ) )
  and not ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) )
   or ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1817]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 516:
Theorem (516) [serial 1822] used for:
  Associativity: (b.c).a = a.b.c [serial 1821] 


Theorem (518)                               [serial 1817] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << not ( not ( v < iSeg.v_n )
   or not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) )
   or ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
Why created:    normalization of [serial 1813]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 517:
Theorem (517) [serial 1821] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1817] 


Theorem (519)                               [serial 1813] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << not ( ( not ( v < iSeg.v_n ) )
   or ( not ( v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n ) ) )
   or ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1809]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 518:
Theorem (518) [serial 1817] used for:
    normalization of [serial 1813] 


Theorem (520)                               [serial 1809] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << not ( iSeg.v_n <= v
   or b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n <= v*v )
   or ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1805]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 519:
Theorem (519) [serial 1813] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1809] 


Theorem (521)                               [serial 1805] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) )
   or not ( v >= iSeg.v_n
   or v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1802]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 520:
Theorem (520) [serial 1809] used for:
    normalization of [serial 1805] 


Theorem (522)                               [serial 1802] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << EB()
   or not SB() >>
Why created:    normalization of [serial 1799]
Solved by:  Substitution of Assertion Labels
and theorem 521:
Theorem (521) [serial 1805] used for:
  Substituted assertions' predicates for labels  [serial 1802] 


Theorem (523)                               [serial 1799] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << ( not ( SB() )
   or not ( not EB() ) ) >>
Why created:  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1791]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Disjunction: (m or k) = (k or m)
and theorem 522:
Theorem (522) [serial 1802] used for:
    normalization of [serial 1799] 


Theorem (524)                               [serial 1791] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << not ( SB()
  and not EB() ) >>
Why created:  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1788]
Solved by:  DeMorgan's Law: not (A and B) = (not A) or (not B)
and theorem 523:
Theorem (523) [serial 1799] used for:
  DeMorgan's Law: not (A and B) = (not A) or (not B)  [serial 1791] 


Theorem (525)                               [serial 1796] 
P [182] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not ( SB()
  and not EB() ) )@now >>
S [182] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1792]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (526)                               [serial 1792] 
P [182] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not ( SB()
  and not EB() ) )@now >>
S [182] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1788]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 525:
Theorem (525) [serial 1796] used for:
  Associativity: (b.c).a = a.b.c [serial 1792] 


Theorem (527)                               [serial 1788] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] sb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S1 <<Q>> in concurrent composition for [serial 1574]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 524 526:
Theorem (524) [serial 1791] used for:
  applied port output of value <<pre>> -> <<M(sb)[sb|false]>> [serial 1788] 
Theorem (526) [serial 1792] used for:
  applied port output <<pre and (not ( SB()
  and not EB() ))@now>> -> <<post>> [serial 1788] 


Theorem (528)                               [serial 1831] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and v < iSeg.v_e >>
S [182] ->
Q [86] << v < iSeg.v_e >>
Why created:  Transitivity: x<y and y<z -> x<z  [serial 1829]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (529)                               [serial 1829] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [86] << v < iSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1824]
Solved by:  Transitivity: x<y and y<z -> x<z
and theorem 528:
Theorem (528) [serial 1831] used for:
  Transitivity: x<y and y<z -> x<z  [serial 1829] 


Theorem (530)                               [serial 1830] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [86] << v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1824]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (531)                               [serial 1824] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << v < iSeg.v_e
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
Why created:    normalization of [serial 1820]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 529 530:
Theorem (529) [serial 1829] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1824] 
Theorem (530) [serial 1830] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1824] 


Theorem (532)                               [serial 1820] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << ( not ( not ( v < iSeg.v_e ) )
  and not ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1815]
Solved by:  Complement
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 531:
Theorem (531) [serial 1824] used for:
    normalization of [serial 1820] 


Theorem (533)                               [serial 1815] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << not ( not ( v < iSeg.v_e )
   or not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) >>
Why created:    normalization of [serial 1812]
Solved by:  DeMorgan's Law: not (A or B) = (not A) and (not B)
and theorem 532:
Theorem (532) [serial 1820] used for:
  DeMorgan's Law: not (A or B) = (not A) and (not B)  [serial 1815] 


Theorem (534)                               [serial 1812] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << not ( ( not ( v < iSeg.v_e ) )
   or ( not ( v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) ) ) >>
Why created:  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1807]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 533:
Theorem (533) [serial 1815] used for:
    normalization of [serial 1812] 


Theorem (535)                               [serial 1807] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and b = CTCS_Property::SB_Rate mpss
  and e = CTCS_Property::EB_Rate mpss
  and nSeg = [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;]
  and iSeg.v_n < iSeg.v_e
  and nSeg.v_n < nSeg.v_e
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << not ( iSeg.v_e <= v
   or e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e <= v*v ) >>
Why created:    normalization of [serial 1804]
Solved by:  At Most Is Not Less Than: (a<=b) = not(b<a)
and theorem 534:
Theorem (534) [serial 1812] used for:
  At Most Is Not Less Than: (a<=b) = not(b<a)  [serial 1807] 


Theorem (536)                               [serial 1804] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = ( [segment: v_n->0 mps; v_e->0 mps; e->CMA.ea;] )
  and ( b = CTCS_Property::SB_Rate mpss )
  and ( e = CTCS_Property::EB_Rate mpss )
  and ( iSeg.v_n < iSeg.v_e )
  and ( nSeg.v_n < nSeg.v_e )
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << not ( v >= iSeg.v_e
   or v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
Why created:  Substituted assertions' predicates for labels  [serial 1793]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 535:
Theorem (535) [serial 1807] used for:
    normalization of [serial 1804] 


Theorem (537)                               [serial 1793] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ->
Q [182] << not EB() >>
Why created:  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1789]
Solved by:  Substitution of Assertion Labels
and theorem 536:
Theorem (536) [serial 1804] used for:
  Substituted assertions' predicates for labels  [serial 1793] 


Theorem (538)                               [serial 1797] 
P [182] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( not EB() )@now >>
S [182] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1794]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (539)                               [serial 1794] 
P [182] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( not EB() )@now >>
S [182] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1789]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 538:
Theorem (538) [serial 1797] used for:
  Associativity: (b.c).a = a.b.c [serial 1794] 


Theorem (540)                               [serial 1789] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] eb!(false)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S2 <<Q>> in concurrent composition for [serial 1574]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorems 537 539:
Theorem (537) [serial 1793] used for:
  applied port output of value <<pre>> -> <<M(eb)[eb|false]>> [serial 1789] 
Theorem (539) [serial 1794] used for:
  applied port output <<pre and (not EB())@now>> -> <<post>> [serial 1789] 


Theorem (541)                               [serial 1798] 
P [182] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e
  and ( ca = xl )@now >>
S [182] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1795]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (542)                               [serial 1795] 
P [182] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e )
  and ( ca = xl )@now >>
S [182] ->
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1790]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 541:
Theorem (541) [serial 1798] used for:
  Associativity: (b.c).a = a.b.c [serial 1795] 


Theorem (543)                               [serial 1790] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182] ca!(xl)
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  <<P>> S3 <<Q>> in concurrent composition for [serial 1574]
Solved by:  Port Data Output: when <<A>> -> <<B>> and <<A>> -> <<e=M(p)>> then <<A>> p!(e) <<B>>
and theorem 542:
Theorem (542) [serial 1795] used for:
  applied port output <<pre and (ca=xl)@now>> -> <<post>> [serial 1790] 


Theorem (544)                               [serial 1574] 
P [163] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg)
  and v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e >>
S [182]   sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1561]
Solved by:  Concurrent Composition Rule:
 <<P>> -> <<P1>>,  <<P>> -> <<P2>>, . . . , <<P>> -> <<Pn>>
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>
 <<Q1 and Q2 and  . . . and Qn>> -> <<Q>>
 -----------------------------------------------
       <<P>> S <<Q>> where S is
 <<P1>> S1 <<Q1>> & <<P2>> S2 <<Q2>> & . . . & <<Pn>> Sn <<Qn>>
and theorems 527 540 543:
Theorem (527) [serial 1788] used for:
  <<P>> S1 <<Q>> in concurrent composition for [serial 1574] 
Theorem (540) [serial 1789] used for:
  <<P>> S2 <<Q>> in concurrent composition for [serial 1574] 
Theorem (543) [serial 1790] used for:
  <<P>> S3 <<Q>> in concurrent composition for [serial 1574] 


Theorem (545)                               [serial 1561] 
P [163] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < b*( iSeg.e - p )*2 + nSeg.v_n*nSeg.v_n
  and v*v < e*( iSeg.e - p )*2 + nSeg.v_e*nSeg.v_e ) >>
S [182]   sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT() >>
Why created:    normalization of [serial 1547]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 544:
Theorem (544) [serial 1574] used for:
  Associativity: (b.c).a = a.b.c [serial 1561] 


Theorem (546)                               [serial 1547] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [182]   sb!(false)
  &
  eb!(false)
  &
  ca!(xl) 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  <<P>> T <<Q>> in existential lattice quantification for [serial 1542]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Multiplication: a*b=b*a
  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 545:
Theorem (545) [serial 1561] used for:
    normalization of [serial 1547] 


Theorem (547)                               [serial 1542] 
P [163] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) )
  and ( v < iSeg.v_n
  and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
  and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ) ) >>
S [182]   {
    sb!(false)
    &
    eb!(false)
    &
    ca!(xl) 
  } 
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:    <<P and B4>> S4 <<Q>> in alternative for [serial 1536]
Solved by:  Introduction of Existential Quantification
and theorem 546:
Theorem (546) [serial 1547] used for:
  <<P>> T <<Q>> in existential lattice quantification for [serial 1542] 


Theorem (548)                               [serial 1536] 
P [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
S [163]   if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1023]
Solved by:  Alternative Rule:
 <<P>> -> <<B1 or B2 or ... or Bn>>,
 <<P and B1>> -> <<P1>>, <<P and B2>> -> <<P2>>, . . . , <<P and Bn>> -> <<Pn>>,
 <<P1>> S1 <<Q1>>, <<P2>> S2 <<Q2>>, . . . , <<Pn>> Sn <<Qn>>,
 <<Q1>> -> <<Q>>, <<Q2>> -> <<Q>>, . . . <<Qn>> -> <<Q>>
 -------------------------------------------------------------------------
 <<P>> if B1-><<P1>>S1<<Q1>> [] B2-><<P2>>S2<<Q2>> [] . . . [] Bn-><<Pn>>Sn<<Qn>> fi <<Q>>
and theorems 377 405 438 476 514 547:
Theorem (377) [serial 1537] used for:
    <<P>> -> <<B1 or B2 or ... or Bn>> in alternative for [serial 1536] 
Theorem (405) [serial 1538] used for:
    <<P and B0>> S0 <<Q>> in alternative for [serial 1536] 
Theorem (438) [serial 1539] used for:
    <<P and B1>> S1 <<Q>> in alternative for [serial 1536] 
Theorem (476) [serial 1540] used for:
    <<P and B2>> S2 <<Q>> in alternative for [serial 1536] 
Theorem (514) [serial 1541] used for:
    <<P and B3>> S3 <<Q>> in alternative for [serial 1536] 
Theorem (547) [serial 1542] used for:
    <<P and B4>> S4 <<Q>> in alternative for [serial 1536] 


Theorem (549)                               [serial 1023] 
P [159] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [160] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and AXIOM_B()
  and AXIOM_E()
  and AXIOM_V(seg : iSeg)
  and AXIOM_V(seg : nSeg) >>
  if 
    (v >= iSeg.v_e)~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v >= nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          eb!(true)
          &
          sb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v >= iSeg.v_n
    and v < iSeg.v_e
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p )
    and v < iSeg.v_e
    and v*v >= nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p ))~> 
        {
          sb!(true)
          &
          eb!(false)
          &
          ca!(0 mpss) 
        }  
  []
    (v < iSeg.v_n
    and v*v < nSeg.v_n*nSeg.v_n + 2*b*( iSeg.e - p )
    and v*v < nSeg.v_e*nSeg.v_e + 2*e*( iSeg.e - p ))~> 
        {
          sb!(false)
          &
          eb!(false)
          &
          ca!(xl) 
        }  
  fi
Q [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:   <<M(MoveForwardLastSegment) and x>> A <<M(CheckMoveForwardLastSegment)>> for LastSegment: MoveForwardLastSegment-[x]->CheckMoveForwardLastSegment{A};
Solved by:  Introduction of Existential Quantification
and theorems 365 548:
Theorem (365) [serial 1535] used for:
  as <<P>> -> <<pre>> in <<P>> { <<pre>> S <<post>> } <<Q>> for [serial 1023] 
Theorem (548) [serial 1536] used for:
  as <<pre>> S <<Q>> in <<P>> { <<pre>> S  } <<Q>> [serial 1023] 


Theorem (550)                               [serial 1024] 
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( not m_a'fresh ) >>
S [186] ->
Q [63] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA >>
Why created:   <<M(CheckMoveForwardLastSegment) and x>> -> <<M(MoveForwardLastSegment)>> for NoMAYet: CheckMoveForwardLastSegment-[x]->MoveForwardLastSegment{};
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (551)                               [serial 1849] 
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65] ->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
Why created:  Law of And-Simplification:  P and true is P [serial 1848]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (552)                               [serial 1848] 
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65] ->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 551:
Theorem (551) [serial 1849] used for:
  Law of And-Simplification:  P and true is P [serial 1848] 


Theorem (553)                               [serial 1849] 
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65] ->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg >>
Why created:  Law of And-Simplification:  P and true is P [serial 1848]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (554)                               [serial 1848] 
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65] ->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 553:
Theorem (553) [serial 1849] used for:
  Law of And-Simplification:  P and true is P [serial 1848] 


Theorem (555)                               [serial 1837] 
P [65] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and nSeg = NULL_SEGMENT()
  and m_a'fresh >>
S [65] ->
Q [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
Why created:    normalization of [serial 1832]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 554 554:
Theorem (554) [serial 1848] used for:
   add user-defined axioms to postcondition 
Theorem (554) [serial 1848] used for:
   add user-defined axioms to postcondition 


Theorem (556)                               [serial 1832] 
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [65] ->
Q [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and AXIOM_NEXT_MA_IS_RMA() >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1025]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 555:
Theorem (555) [serial 1837] used for:
    normalization of [serial 1832] 


Theorem (557)                               [serial 1850] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67] ->
Q [67] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (558)                               [serial 1851] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67] ->
Q [67] << CMA.num_segments = i >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (559)                               [serial 1855] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67] ->
Q [67] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "
^{CMA 
 ^{. num_segments}}" in its postcondition [serial 1852]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (560)                               [serial 1852] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67] ->
Q [67] << CMA.seg[i] = iSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]
Solved by:  Guided Substitution of Equals
and theorem 559:
Theorem (559) [serial 1855] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "
^{CMA 
 ^{. num_segments}}" in its postcondition [serial 1852] 


Theorem (561)                               [serial 1853] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67] ->
Q [68] << NEXT_MA = next_ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (562)                               [serial 1854] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67] ->
Q [67] << NEXT_MA.seg[1] = nSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (563)                               [serial 1839] 
P [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [67] ->
Q [67] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
Why created:    normalization of [serial 1833]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 557 558 560 561 562:
Theorem (557) [serial 1850] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839] 
Theorem (558) [serial 1851] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839] 
Theorem (560) [serial 1852] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839] 
Theorem (561) [serial 1853] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839] 
Theorem (562) [serial 1854] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1839] 


Theorem (564)                               [serial 1833] 
P [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1] >>
S [67] ->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:  <<Q2>> -> <<Q>> in sequential composition for [serial 1025]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 563:
Theorem (563) [serial 1839] used for:
    normalization of [serial 1833] 


Theorem (565)                               [serial 1864] 
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193] ->
Q [195] << CMA = ma >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1860]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (566)                               [serial 1860] 
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193] ->
Q [195] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1858]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 565:
Theorem (565) [serial 1864] used for:
  Associativity: (b.c).a = a.b.c [serial 1860] 


Theorem (567)                               [serial 1865] 
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193] ->
Q [194] << CMA.num_segments = i >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1861]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (568)                               [serial 1861] 
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193] ->
Q [194] << CMA.num_segments = i >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1858]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 567:
Theorem (567) [serial 1865] used for:
  Associativity: (b.c).a = a.b.c [serial 1861] 


Theorem (569)                               [serial 1877] 
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193] ->
Q [195] << CMA.seg[i] = iSeg >>
Why created:  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "
^{CMA 
 ^{. num_segments}}" with its = "i" in its postcondition [serial 1871]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (570)                               [serial 1871] 
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193] ->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:    normalization of [serial 1868]
Solved by:  Guided Substitution of Equals
  Guided Substitution of Equals
and theorem 569:
Theorem (569) [serial 1877] used for:
  Guided Substitution of Equals Guided Substitution of Equals 
 replacing "
^{CMA 
 ^{. num_segments}}" with its = "i" in its postcondition [serial 1871] 


Theorem (571)                               [serial 1868] 
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( NEXT_MA = RMA )
  and RMA = next_ma >>
S [193] ->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1866]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 570:
Theorem (570) [serial 1871] used for:
    normalization of [serial 1868] 


Theorem (572)                               [serial 1866] 
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193] ->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1862]
Solved by:  Substitution of Assertion Labels
and theorem 571:
Theorem (571) [serial 1868] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1866] 


Theorem (573)                               [serial 1862] 
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193] ->
Q [195] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1858]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 572:
Theorem (572) [serial 1866] used for:
  Associativity: (b.c).a = a.b.c [serial 1862] 


Theorem (574)                               [serial 1876] 
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193] ->
Q [194] << RMA = next_ma >>
Why created:  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "RMA" in its postcondition [serial 1873]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (575)                               [serial 1873] 
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = RMA
  and RMA = next_ma >>
S [193] ->
Q [194] << NEXT_MA = next_ma >>
Why created:    normalization of [serial 1869]
Solved by:  Guided Substitution of Equals
and theorem 574:
Theorem (574) [serial 1876] used for:
  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "RMA" in its postcondition [serial 1873] 


Theorem (576)                               [serial 1869] 
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and ( NEXT_MA = RMA )
  and RMA = next_ma >>
S [193] ->
Q [194] << NEXT_MA = next_ma >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1867]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 575:
Theorem (575) [serial 1873] used for:
    normalization of [serial 1869] 


Theorem (577)                               [serial 1867] 
P [193] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA()
  and RMA = next_ma >>
S [193] ->
Q [194] << NEXT_MA = next_ma >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1863]
Solved by:  Substitution of Assertion Labels
and theorem 576:
Theorem (576) [serial 1869] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1867] 


Theorem (578)                               [serial 1863] 
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193] ->
Q [194] << NEXT_MA = next_ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1858]
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 577:
Theorem (577) [serial 1867] used for:
  Associativity: (b.c).a = a.b.c [serial 1863] 


Theorem (579)                               [serial 1858] 
P [193] << RMA = next_ma
  and ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() ) >>
S [193] ->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:    normalization of [serial 1856]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 566 568 573 578:
Theorem (566) [serial 1860] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1858] 
Theorem (568) [serial 1861] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1858] 
Theorem (573) [serial 1862] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1858] 
Theorem (578) [serial 1863] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1858] 


Theorem (580)                               [serial 1856] 
P [193] << ( CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() )
  and next_ma = RMA >>
S [193] ->
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:  applied port input of value <<pre and next_ma=M(m_a)>> -> <<post>> [serial 1841]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 579:
Theorem (579) [serial 1858] used for:
    normalization of [serial 1856] 


Theorem (581)                               [serial 1841] 
P [191] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and AXIOM_NEXT_MA_IS_RMA() >>
S [193] m_a?(next_ma)
Q [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
Why created:    normalization of [serial 1834]
Solved by:  Port Data Input: when <<A and v=M(p)>> -> <<B>> then <<A>> p?(v) <<B>>
and theorem 580:
Theorem (580) [serial 1856] used for:
  applied port input of value <<pre and next_ma=M(m_a)>> -> <<post>> [serial 1841] 


Theorem (582)                               [serial 1834] 
P [191] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and ma = CMA
  and AXIOM_NEXT_MA_IS_RMA() >>
S [193] m_a?(next_ma)
Q [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1025]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 581:
Theorem (581) [serial 1841] used for:
    normalization of [serial 1834] 


Theorem (583)                               [serial 1879] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [198] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (584)                               [serial 1880] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [197] << CMA.num_segments = i >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (585)                               [serial 1881] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [198] << CMA.seg[CMA.num_segments] = iSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (586)                               [serial 1882] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [197] << NEXT_MA = next_ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (587)                               [serial 1885] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [199] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1884]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (588)                               [serial 1884] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [199] << next_ma.seg[1] = next_ma.seg[1] >>
Why created:  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "next_ma" in its postcondition [serial 1883]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 587:
Theorem (587) [serial 1885] used for:
  Equality Law (idistr):  a=a <-> true [serial 1884] 


Theorem (589)                               [serial 1883] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [199] << NEXT_MA.seg[1] = next_ma.seg[1] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878]
Solved by:  Guided Substitution of Equals
and theorem 588:
Theorem (588) [serial 1884] used for:
  Guided Substitution of Equals 
 replacing "NEXT_MA" with its = "next_ma" in its postcondition [serial 1883] 


Theorem (590)                               [serial 1878] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] ->
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = next_ma.seg[1] >>
Why created:  applied wp for assignment [serial 1843]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 583 584 585 586 589:
Theorem (583) [serial 1879] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878] 
Theorem (584) [serial 1880] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878] 
Theorem (585) [serial 1881] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878] 
Theorem (586) [serial 1882] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878] 
Theorem (589) [serial 1883] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1878] 


Theorem (591)                               [serial 1843] 
P [194] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma >>
S [196] nSeg := next_ma.seg[1]
Q [197] << CMA = ma
  and CMA.num_segments = i
  and CMA.seg[CMA.num_segments] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
Why created:    normalization of [serial 1835]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 590:
Theorem (590) [serial 1878] used for:
  applied wp for assignment [serial 1843] 


Theorem (592)                               [serial 1835] 
P [194] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA >>
S [196] nSeg := next_ma.seg[1]
Q [197] << i = CMA.num_segments
  and next_ma = NEXT_MA
  and iSeg = CMA.seg[CMA.num_segments]
  and ma = CMA
  and nSeg = NEXT_MA.seg[1] >>
Why created:  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1025]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 591:
Theorem (591) [serial 1843] used for:
    normalization of [serial 1835] 


Theorem (593)                               [serial 1025] 
P [65] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NULL_SEGMENT()
  and ma = CMA
  and ( m_a'fresh ) >>
S [191]   << i = CMA.num_segments
    and iSeg = CMA.seg[i]
    and ma = CMA
    and AXIOM_NEXT_MA_IS_RMA() >>
  m_a?(next_ma)
  ;
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA >>
  nSeg := next_ma.seg[1]
  << i = CMA.num_segments
    and next_ma = NEXT_MA
    and iSeg = CMA.seg[CMA.num_segments]
    and ma = CMA
    and nSeg = NEXT_MA.seg[1] >> 
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:   <<M(CheckMoveForwardLastSegment) and x>> A <<M(GotNewMA)>> for GetNewMA: CheckMoveForwardLastSegment-[x]->GotNewMA{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 556 564 582 592:
Theorem (556) [serial 1832] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1025] 
Theorem (564) [serial 1833] used for:
  <<Q2>> -> <<Q>> in sequential composition for [serial 1025] 
Theorem (582) [serial 1834] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1025] 
Theorem (592) [serial 1835] used for:
  <<Q1 and P2>> S2 <<Q2>> in sequential composition for [serial 1025] 


Theorem (594)                               [serial 1886] 
P [203] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [202] ->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:  Associativity: (b.c).a = a.b.c [serial 1026]
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (595)                               [serial 1026] 
P [203] << ( i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA )
  and ( p@now )
  and not ( exists u ~ time
  in tops ,, now 
  that p@u  ) >>
S [202] ->
Q [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:   <<M(GotNewMA) and x>> -> <<M(CheckMATransition)>> for LastBitOfMa: GotNewMA-[x]->CheckMATransition{};
Solved by:  Associativity: (b.c).a = a.b.c
and theorem 594:
Theorem (594) [serial 1886] used for:
  Associativity: (b.c).a = a.b.c [serial 1026] 


Theorem (596)                               [serial 1027] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p < ma.ea ) >>
S [205] ->
Q [67] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA >>
Why created:   <<M(CheckMATransition) and x>> -> <<M(GotNewMA)>> for NotEndOfMA: CheckMATransition-[x]->GotNewMA{};
Solved by:  And Introduction Schema (aiswl):  (X and Y and Z)->(X and Y)


Theorem (597)                               [serial 1896] 
P [70] << ma.ea <= p
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70] ->
Q [210] << NEXT_MA = next_ma >>
Why created:    normalization of [serial 1894]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (598)                               [serial 1894] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70] ->
Q [210] << ( next_ma = NEXT_MA ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1893]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 597:
Theorem (597) [serial 1896] used for:
    normalization of [serial 1894] 


Theorem (599)                               [serial 1893] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70] ->
Q [210] << true
  and next_ma = NEXT_MA >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 598:
Theorem (598) [serial 1894] used for:
  Law of And-Simplification:  P and true is P [serial 1893] 


Theorem (600)                               [serial 1896] 
P [70] << ma.ea <= p
  and CMA = ma
  and CMA.num_segments = i
  and CMA.seg[i] = iSeg
  and NEXT_MA = next_ma
  and NEXT_MA.seg[1] = nSeg >>
S [70] ->
Q [210] << NEXT_MA = next_ma >>
Why created:    normalization of [serial 1894]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (601)                               [serial 1894] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70] ->
Q [210] << ( next_ma = NEXT_MA ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1893]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Irreflexivity of At Least: (a>=b) = (b<=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 600:
Theorem (600) [serial 1896] used for:
    normalization of [serial 1894] 


Theorem (602)                               [serial 1893] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70] ->
Q [210] << true
  and next_ma = NEXT_MA >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 601:
Theorem (601) [serial 1894] used for:
  Law of And-Simplification:  P and true is P [serial 1893] 


Theorem (603)                               [serial 1887] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [70] ->
Q [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
Why created:  <<P>> -> <<P1>> in sequential composition for [serial 1028]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 602 602:
Theorem (602) [serial 1893] used for:
   add user-defined axioms to postcondition 
Theorem (602) [serial 1893] used for:
   add user-defined axioms to postcondition 


Theorem (604)                               [serial 1902] 
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57] ->
Q [57] << CMA = ma >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1900]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (605)                               [serial 1903] 
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57] ->
Q [57] << CMA.seg[i] = iSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1900]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (606)                               [serial 1904] 
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57] ->
Q [57] << CMA.seg[1 + i] = nSeg >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1900]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (607)                               [serial 1909] 
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57] ->
Q [57] << 1 < ma.num_segments >>
Why created:    normalization of [serial 1907]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (608)                               [serial 1907] 
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57] ->
Q [57] << ( 1 ) < ma.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1906]
Solved by:  Reflexivity of Addition: a+b=b+a
  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 607:
Theorem (607) [serial 1909] used for:
    normalization of [serial 1907] 


Theorem (609)                               [serial 1906] 
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57] ->
Q [57] << ( 1 ) < CMA.num_segments >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1905]
Solved by:  Guided Substitution of Equals
and theorem 608:
Theorem (608) [serial 1907] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1906] 


Theorem (610)                               [serial 1905] 
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57] ->
Q [57] << i < CMA.num_segments >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1900]
Solved by:  Guided Substitution of Equals
and theorem 609:
Theorem (609) [serial 1906] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1905] 


Theorem (611)                               [serial 1900] 
P [218] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i = 1
  and 1 < ma.num_segments >>
S [57] ->
Q [57] << CMA = ma
  and CMA.seg[i] = iSeg
  and CMA.seg[1 + i] = nSeg
  and i < CMA.num_segments >>
Why created:    normalization of [serial 1898]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 604 605 606 610:
Theorem (604) [serial 1902] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1900] 
Theorem (605) [serial 1903] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1900] 
Theorem (606) [serial 1904] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1900] 
Theorem (610) [serial 1905] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1900] 


Theorem (612)                               [serial 1898] 
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ( 1 < ma.num_segments ) >>
S [57] ->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1888]
Solved by:  Reflexivity of Addition: a+b=b+a
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 611:
Theorem (611) [serial 1900] used for:
    normalization of [serial 1898] 


Theorem (613)                               [serial 1888] 
P [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : ma) >>
S [57] ->
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:  <<Q4>> -> <<Q>> in sequential composition for [serial 1028]
Solved by:  Substitution of Assertion Labels
and theorem 612:
Theorem (612) [serial 1898] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1888] 


Theorem (614)                               [serial 1916] 
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211] ->
Q [212] << NEXT_MA = next_ma >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "NEXT_MA" in its postcondition [serial 1914]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (615)                               [serial 1914] 
P [210] << CMA = NEXT_MA
  and NEXT_MA = next_ma >>
S [211] ->
Q [212] << CMA = next_ma >>
Why created:    normalization of [serial 1912]
Solved by:  Guided Substitution of Equals
and theorem 614:
Theorem (614) [serial 1916] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "NEXT_MA" in its postcondition [serial 1914] 


Theorem (616)                               [serial 1912] 
P [210] << ( CMA = NEXT_MA )
  and next_ma = NEXT_MA >>
S [211] ->
Q [212] << next_ma = CMA >>
Why created:  Substituted assertions' predicates for labels in preconditions [serial 1911]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 615:
Theorem (615) [serial 1914] used for:
    normalization of [serial 1912] 


Theorem (617)                               [serial 1911] 
P [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211] ->
Q [212] << next_ma = CMA >>
Why created:  applied wp for assignment [serial 1889]
Solved by:  Substitution of Assertion Labels
and theorem 616:
Theorem (616) [serial 1912] used for:
  Substituted assertions' predicates for labels in preconditions [serial 1911] 


Theorem (618)                               [serial 1889] 
P [210] << AXIOM_CMA_IS_NEXT_MA()
  and next_ma = NEXT_MA >>
S [211] ma := next_ma
Q [212] << ma = CMA >>
Why created:  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 617:
Theorem (617) [serial 1911] used for:
  applied wp for assignment [serial 1889] 


Theorem (619)                               [serial 1924] 
P [212] << CMA = ma >>
S [213] ->
Q [214] << CMA = ma >>
Why created:    normalization of [serial 1922]
Solved by:  Identity (id):  P->P is tautology


Theorem (620)                               [serial 1922] 
P [212] << CMA = ma >>
S [213] ->
Q [214] << ( CMA = ma ) >>
Why created:  Law of And-Simplification:  P and true is P [serial 1921]
Solved by:  Add Unnecessary Parentheses For No Good Reason: a = (a)
and theorem 619:
Theorem (619) [serial 1924] used for:
    normalization of [serial 1922] 


Theorem (621)                               [serial 1921] 
P [212] << CMA = ma >>
S [213] ->
Q [214] << CMA = ma
  and true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1919]
Solved by:  Law of And-Simplification:  P and true is P
and theorem 620:
Theorem (620) [serial 1922] used for:
  Law of And-Simplification:  P and true is P [serial 1921] 


Theorem (622)                               [serial 1919] 
P [212] << CMA = ma >>
S [213] ->
Q [214] << CMA = ma
  and 1 = 1 >>
Why created:    normalization of [serial 1917]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 621:
Theorem (621) [serial 1921] used for:
  Equality Law (idistr):  a=a <-> true [serial 1919] 


Theorem (623)                               [serial 1917] 
P [212] << ma = CMA >>
S [213] ->
Q [214] << ( 1 ) = 1
  and ma = CMA >>
Why created:  applied wp for assignment [serial 1890]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 622:
Theorem (622) [serial 1919] used for:
    normalization of [serial 1917] 


Theorem (624)                               [serial 1890] 
P [212] << ma = CMA >>
S [213] i := 1
Q [214] << i = 1
  and ma = CMA >>
Why created:  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 623:
Theorem (623) [serial 1917] used for:
  applied wp for assignment [serial 1890] 


Theorem (625)                               [serial 1927] 
P [214] << i = 1
  and ma = CMA >>
S [215] ->
Q [216] << i = 1 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1926]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (626)                               [serial 1928] 
P [214] << i = 1
  and ma = CMA >>
S [215] ->
Q [216] << ma = CMA >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1926]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (627)                               [serial 1935] 
P [214] << CMA = ma
  and i = 1 >>
S [215] ->
Q [216] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1933]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (628)                               [serial 1933] 
P [214] << CMA = ma
  and i = 1 >>
S [215] ->
Q [216] << ma.seg[1] = ma.seg[1] >>
Why created:    normalization of [serial 1931]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 627:
Theorem (627) [serial 1935] used for:
  Equality Law (idistr):  a=a <-> true [serial 1933] 


Theorem (629)                               [serial 1931] 
P [214] << i = 1
  and ma = CMA >>
S [215] ->
Q [216] << ma.seg[1] = ma.seg[( 1 )] >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1930]
Solved by:  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 628:
Theorem (628) [serial 1933] used for:
    normalization of [serial 1931] 


Theorem (630)                               [serial 1930] 
P [214] << i = 1
  and ma = CMA >>
S [215] ->
Q [216] << ma.seg[1] = ma.seg[i] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1929]
Solved by:  Guided Substitution of Equals
and theorem 629:
Theorem (629) [serial 1931] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1930] 


Theorem (631)                               [serial 1929] 
P [214] << i = 1
  and ma = CMA >>
S [215] ->
Q [216] << ma.seg[1] = CMA.seg[i] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1926]
Solved by:  Guided Substitution of Equals
and theorem 630:
Theorem (630) [serial 1930] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1929] 


Theorem (632)                               [serial 1926] 
P [214] << i = 1
  and ma = CMA >>
S [215] ->
Q [216] << i = 1
  and ma = CMA
  and ma.seg[1] = CMA.seg[i] >>
Why created:  applied wp for assignment [serial 1891]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 625 626 631:
Theorem (625) [serial 1927] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1926] 
Theorem (626) [serial 1928] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1926] 
Theorem (631) [serial 1929] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1926] 


Theorem (633)                               [serial 1891] 
P [214] << i = 1
  and ma = CMA >>
S [215] iSeg := ma.seg[1]
Q [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
Why created:  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1028]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 632:
Theorem (632) [serial 1926] used for:
  applied wp for assignment [serial 1891] 


Theorem (634)                               [serial 1939] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] ->
Q [218] << i = 1 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (635)                               [serial 1940] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] ->
Q [218] << ma = CMA >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (636)                               [serial 1941] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] ->
Q [218] << iSeg = CMA.seg[i] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (637)                               [serial 1948] 
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217] ->
Q [218] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1947]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (638)                               [serial 1947] 
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217] ->
Q [218] << ma.seg[2] = ma.seg[2] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1945]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 637:
Theorem (637) [serial 1948] used for:
  Equality Law (idistr):  a=a <-> true [serial 1947] 


Theorem (639)                               [serial 1945] 
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217] ->
Q [218] << CMA.seg[2] = ma.seg[2] >>
Why created:    normalization of [serial 1943]
Solved by:  Guided Substitution of Equals
and theorem 638:
Theorem (638) [serial 1947] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1945] 


Theorem (640)                               [serial 1943] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] ->
Q [218] << ma.seg[2] = CMA.seg[( 1 ) + 1] >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1942]
Solved by:  Literal Arithmetic
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 639:
Theorem (639) [serial 1945] used for:
    normalization of [serial 1943] 


Theorem (641)                               [serial 1942] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] ->
Q [218] << ma.seg[2] = CMA.seg[i + 1] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938]
Solved by:  Guided Substitution of Equals
and theorem 640:
Theorem (640) [serial 1943] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1942] 


Theorem (642)                               [serial 1938] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] ->
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and ma.seg[2] = CMA.seg[i + 1] >>
Why created:  applied wp for assignment [serial 1937]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 634 635 636 641:
Theorem (634) [serial 1939] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938] 
Theorem (635) [serial 1940] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938] 
Theorem (636) [serial 1941] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938] 
Theorem (641) [serial 1942] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938] 


Theorem (643)                               [serial 1937] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1] >>
Why created:  Law of And-Simplification:  P and true is P [serial 1936]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 642:
Theorem (642) [serial 1938] used for:
  applied wp for assignment [serial 1937] 


Theorem (644)                               [serial 1936] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 643:
Theorem (643) [serial 1937] used for:
  Law of And-Simplification:  P and true is P [serial 1936] 


Theorem (645)                               [serial 1939] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] ->
Q [218] << i = 1 >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (646)                               [serial 1940] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] ->
Q [218] << ma = CMA >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (647)                               [serial 1941] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] ->
Q [218] << iSeg = CMA.seg[i] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938]
Solved by:  And Introduction Schema (aisph):  (X and Y)->X


Theorem (648)                               [serial 1948] 
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217] ->
Q [218] << true >>
Why created:  Equality Law (idistr):  a=a <-> true [serial 1947]
Solved by:  True Conclusion Schema (tc): P->true


Theorem (649)                               [serial 1947] 
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217] ->
Q [218] << ma.seg[2] = ma.seg[2] >>
Why created:  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1945]
Solved by:  Equality Law (idistr):  a=a <-> true
and theorem 648:
Theorem (648) [serial 1948] used for:
  Equality Law (idistr):  a=a <-> true [serial 1947] 


Theorem (650)                               [serial 1945] 
P [216] << CMA = ma
  and CMA.seg[i] = iSeg
  and i = 1 >>
S [217] ->
Q [218] << CMA.seg[2] = ma.seg[2] >>
Why created:    normalization of [serial 1943]
Solved by:  Guided Substitution of Equals
and theorem 649:
Theorem (649) [serial 1947] used for:
  Guided Substitution of Equals 
 replacing "CMA" with its = "ma" in its postcondition [serial 1945] 


Theorem (651)                               [serial 1943] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] ->
Q [218] << ma.seg[2] = CMA.seg[( 1 ) + 1] >>
Why created:  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1942]
Solved by:  Literal Arithmetic
  Reflexivity of Equality: (a=b) = (b=a)
  Add Unnecessary Parentheses For No Good Reason: a = (a)
  Reflexivity of Conjunction: (m and k) = (k and m)
and theorem 650:
Theorem (650) [serial 1945] used for:
    normalization of [serial 1943] 


Theorem (652)                               [serial 1942] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] ->
Q [218] << ma.seg[2] = CMA.seg[i + 1] >>
Why created:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938]
Solved by:  Guided Substitution of Equals
and theorem 651:
Theorem (651) [serial 1943] used for:
  Guided Substitution of Equals 
 replacing "i" with its = "( 1 )" in its postcondition [serial 1942] 


Theorem (653)                               [serial 1938] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] ->
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and ma.seg[2] = CMA.seg[i + 1] >>
Why created:  applied wp for assignment [serial 1937]
Solved by:  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D)
and theorems 645 646 647 652:
Theorem (645) [serial 1939] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938] 
Theorem (646) [serial 1940] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938] 
Theorem (647) [serial 1941] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938] 
Theorem (652) [serial 1942] used for:
  Sequent Composition: if A->B and A->C and A->D then A->(B and C and D) [serial 1938] 


Theorem (654)                               [serial 1937] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1] >>
Why created:  Law of And-Simplification:  P and true is P [serial 1936]
Solved by:  Assignment Rule:
 <<P>> -> <<wp(x:=e,Q)>> which is <<Q[x/e]>>
 ---------------------------------------
             <<P>> x:=e <<Q>>
and theorem 653:
Theorem (653) [serial 1938] used for:
  applied wp for assignment [serial 1937] 


Theorem (655)                               [serial 1936] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and true >>
Why created:   add user-defined axioms to postcondition
Solved by:  Law of And-Simplification:  P and true is P
and theorem 654:
Theorem (654) [serial 1937] used for:
  Law of And-Simplification:  P and true is P [serial 1936] 


Theorem (656)                               [serial 1892] 
P [216] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i] >>
S [217] nSeg := ma.seg[2]
Q [218] << i = 1
  and ma = CMA
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and AXIOM_NUM_SEG(ma : ma) >>
Why created:  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1028]
Solved by:  Introduction of an Axiom to Postcondition:
  <<P>> S <<Q>> , <<A>> 
 ----------------
  <<P>> S <<Q and A>>
and theorems 655 655:
Theorem (655) [serial 1936] used for:
   add user-defined axioms to postcondition 
Theorem (655) [serial 1936] used for:
   add user-defined axioms to postcondition 


Theorem (657)                               [serial 1028] 
P [70] << i = CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = NEXT_MA.seg[1]
  and ma = CMA
  and next_ma = NEXT_MA
  and ( p >= ma.ea ) >>
S [210]   << AXIOM_CMA_IS_NEXT_MA()
    and next_ma = NEXT_MA >>
  ma := next_ma
  ;
  << ma = CMA >>
  i := 1
  ;
  << i = 1
    and ma = CMA >>
  iSeg := ma.seg[1]
  ;
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i] >>
  nSeg := ma.seg[2]
  << i = 1
    and ma = CMA
    and iSeg = CMA.seg[i]
    and nSeg = CMA.seg[i + 1]
    and AXIOM_NUM_SEG(ma : ma) >> 
Q [57] << i < CMA.num_segments
  and iSeg = CMA.seg[i]
  and nSeg = CMA.seg[i + 1]
  and ma = CMA >>
Why created:   <<M(CheckMATransition) and x>> A <<M(MoveForward)>> for StartNextMa: CheckMATransition-[x]->MoveForward{A};
Solved by:  Sequential Composition Rule:
   <<P1>> S1 <<Q1 and P2>>
   <<Q1 and P2>> S2 <<Q2 and P3>>
   . . .
   <<Qk-1 and Pk>> Sk <<Qk>>
   P=>P1, Qk=>Q
   _____________________________________________
   <<P>> S <<Q>>
   where S is <<P1>> S1 <<Q1>> ; . . . ; <<Pk>> Sk <<Qk>>
and theorems 603 613 618 624 633 656:
Theorem (603) [serial 1887] used for:
  <<P>> -> <<P1>> in sequential composition for [serial 1028] 
Theorem (613) [serial 1888] used for:
  <<Q4>> -> <<Q>> in sequential composition for [serial 1028] 
Theorem (618) [serial 1889] used for:
  <<P1>> S1 <<Q1 and P2>> in sequential composition for [serial 1028] 
Theorem (624) [serial 1890] used for:
  <<Q1 and P2>> S2 <<Q2 and P3>> in sequential composition for [serial 1028] 
Theorem (633) [serial 1891] used for:
  <<Q2 and P3>> S3 <<Q3 and P4>> in sequential composition for [serial 1028] 
Theorem (656) [serial 1892] used for:
  <<Q3 and P4>> S4 <<Q4>> in sequential composition for [serial 1028] 


Theorem (658)                               [serial 1002] 
P [33] <<   >>
S [39] ->
Q [33] << AutoBrake.i proof obligations >>
Why created:  Initial proof obligations for AutoBrake.i
Solved by:  Component verification conditions
and theorems 1 2 3 5 9 11 12 15 17 21 25 26 27 106 313 315 322 332 357 358 549 550 593 595 596 657:
Theorem (1) [serial 1003] used for:
  <<M(MoveForwardLastSegment)>> -> <<I>> from invariant I when complete state MoveForwardLastSegment has Assertion <<M(MoveForwardLastSegment)>> in its definition. 
Theorem (2) [serial 1004] used for:
  <<M(WaitFirstMA)>> -> <<I>> from invariant I when complete state WaitFirstMA has Assertion <<M(WaitFirstMA)>> in its definition. 
Theorem (3) [serial 1005] used for:
  <<M(MoveForward)>> -> <<I>> from invariant I when complete state MoveForward has Assertion <<M(MoveForward)>> in its definition. 
Theorem (5) [serial 1006] used for:
  <<M(GotNewMA)>> -> <<I>> from invariant I when complete state GotNewMA has Assertion <<M(GotNewMA)>> in its definition. 
Theorem (9) [serial 1007] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForward, <<M(CheckMoveForward)>> -> <<e1 or e2 or . . . en>> 
Theorem (11) [serial 1008] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMoveForwardLastSegment, <<M(CheckMoveForwardLastSegment)>> -> <<e1 or e2 or . . . en>> 
Theorem (12) [serial 1009] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state Start, <<M(Start)>> -> <<e1 or e2 or . . . en>> 
Theorem (15) [serial 1010] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckForLastSegment, <<M(CheckForLastSegment)>> -> <<e1 or e2 or . . . en>> 
Theorem (17) [serial 1011] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckFirstMA, <<M(CheckFirstMA)>> -> <<e1 or e2 or . . . en>> 
Theorem (21) [serial 1012] used for:
  Serban's Theorem:  disjunction of execute conditions leaving execution state CheckMATransition, <<M(CheckMATransition)>> -> <<e1 or e2 or . . . en>> 
Theorem (25) [serial 1013] used for:
   <<M(Start)>> A <<M(WaitFirstMA)>> for Go: Start-[ ]->WaitFirstMA{A}; 
Theorem (26) [serial 1014] used for:
   <<M(WaitFirstMA) and x>> -> <<M(CheckFirstMA)>> for FirstMA: WaitFirstMA-[x]->CheckFirstMA{}; 
Theorem (27) [serial 1015] used for:
   <<M(CheckFirstMA) and x>> -> <<M(WaitFirstMA)>> for NotYet: CheckFirstMA-[x]->WaitFirstMA{}; 
Theorem (106) [serial 1016] used for:
   <<M(CheckFirstMA) and x>> A <<M(MoveForward)>> for GotFirstMA: CheckFirstMA-[x]->MoveForward{A}; 
Theorem (313) [serial 1017] used for:
   <<M(MoveForward) and x>> A <<M(CheckMoveForward)>> for CheckSpeed: MoveForward-[x]->CheckMoveForward{A}; 
Theorem (315) [serial 1018] used for:
   <<M(CheckMoveForward) and x>> -> <<M(MoveForward)>> for SameSegment: CheckMoveForward-[x]->MoveForward{}; 
Theorem (322) [serial 1019] used for:
   <<M(CheckMoveForward) and x>> A <<M(CheckForLastSegment)>> for NextSegment: CheckMoveForward-[x]->CheckForLastSegment{A}; 
Theorem (332) [serial 1020] used for:
   <<M(CheckForLastSegment) and x>> A <<M(MoveForward)>> for NotLastSegment: CheckForLastSegment-[x]->MoveForward{A}; 
Theorem (357) [serial 1021] used for:
   <<M(CheckForLastSegment) and x>> A <<M(MoveForwardLastSegment)>> for IsLastSegment: CheckForLastSegment-[x]->MoveForwardLastSegment{A}; 
Theorem (358) [serial 1022] used for:
   <<M(CheckForLastSegment) and x>> -> <<M(FAIL)>> for PastLastSegment: CheckForLastSegment-[x]->FAIL{}; 
Theorem (549) [serial 1023] used for:
   <<M(MoveForwardLastSegment) and x>> A <<M(CheckMoveForwardLastSegment)>> for LastSegment: MoveForwardLastSegment-[x]->CheckMoveForwardLastSegment{A}; 
Theorem (550) [serial 1024] used for:
   <<M(CheckMoveForwardLastSegment) and x>> -> <<M(MoveForwardLastSegment)>> for NoMAYet: CheckMoveForwardLastSegment-[x]->MoveForwardLastSegment{}; 
Theorem (593) [serial 1025] used for:
   <<M(CheckMoveForwardLastSegment) and x>> A <<M(GotNewMA)>> for GetNewMA: CheckMoveForwardLastSegment-[x]->GotNewMA{A}; 
Theorem (595) [serial 1026] used for:
   <<M(GotNewMA) and x>> -> <<M(CheckMATransition)>> for LastBitOfMa: GotNewMA-[x]->CheckMATransition{}; 
Theorem (596) [serial 1027] used for:
   <<M(CheckMATransition) and x>> -> <<M(GotNewMA)>> for NotEndOfMA: CheckMATransition-[x]->GotNewMA{}; 
Theorem (657) [serial 1028] used for:
   <<M(CheckMATransition) and x>> A <<M(MoveForward)>> for StartNextMa: CheckMATransition-[x]->MoveForward{A}; 


Theorem (659)                               [serial 1029] 
P [1] << xl = OPERATOR_XL >>
S [2] ->
Q [1] << xl = OPERATOR_XL >>
Why created:  Composition of Subcomponents via Directional Connection driver.xl -> motor.xl:
 xl -> xl
Solved by:  Identity (id):  P->P is tautology


Theorem (660)                               [serial 1030] 
P [1] << p = POSITION >>
S [2] ->
Q [1] << p = POSITION >>
Why created:  Composition of Subcomponents via Directional Connection sensor.p -> controller.control.p:
 p -> p
Solved by:  Identity (id):  P->P is tautology


Theorem (661)                               [serial 1031] 
P [1] << v = VELOCITY >>
S [2] ->
Q [1] << v = VELOCITY >>
Why created:  Composition of Subcomponents via Directional Connection sensor.v -> controller.control.v:
 v -> v
Solved by:  Identity (id):  P->P is tautology


Theorem (662)                               [serial 1032] 
P [1] << SB()
  and not EB() >>
S [2] ->
Q [1] << SB()
  and not EB() >>
Why created:  Composition of Subcomponents via Directional Connection controller.control.sb -> sbrake.brake:
 sb -> brake
Solved by:  Identity (id):  P->P is tautology


Theorem (663)                               [serial 1033] 
P [1] << EB() >>
S [2] ->
Q [1] << EB() >>
Why created:  Composition of Subcomponents via Directional Connection controller.control.eb -> ebrake.brake:
 eb -> brake
Solved by:  Identity (id):  P->P is tautology


Theorem (664)                               [serial 1034] 
P [1] << ma_m_a = RMA >>
S [2] ->
Q [1] << ma_m_a = RMA >>
Why created:  Composition of Subcomponents via Directional Connection rbc.ma -> train.controller.control.m_a:
 ma -> m_a
Solved by:  Identity (id):  P->P is tautology


Theorem (665)                               [serial 1035] 
P [27] << ma = RMA >>
S [19] ->
Q [14] << ma = RMA >>
Why created:  Composition of Subcomponents via Directional Connection CTCS::MovementAuthority.i.ma:
 ma -> ma
Solved by:  Identity (id):  P->P is tautology


Theorem (666)                               [serial 1036] 
P [14] << ma_m_a = RMA >>
S [73] ->
Q [94] << ma_m_a = RMA >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.auth:
 ma -> m_a
Solved by:  Identity (id):  P->P is tautology


Theorem (667)                               [serial 1037] 
P [32] << p = POSITION >>
S [74] ->
Q [89] << p = POSITION >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.pos:
 p -> p
Solved by:  Identity (id):  P->P is tautology


Theorem (668)                               [serial 1038] 
P [34] << v = VELOCITY >>
S [75] ->
Q [91] << v = VELOCITY >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.vel:
 v -> v
Solved by:  Identity (id):  P->P is tautology


Theorem (669)                               [serial 1039] 
P [59] << xl = OPERATOR_XL >>
S [76] ->
Q [23] << xl = OPERATOR_XL >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.dxl:
 xl -> xl
Solved by:  Identity (id):  P->P is tautology


Theorem (670)                               [serial 1040] 
P [85] << SB()
  and not EB() >>
S [77] ->
Q [44] << SB()
  and not EB() >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.cpsb:
 sb -> brake
Solved by:  Identity (id):  P->P is tautology


Theorem (671)                               [serial 1041] 
P [87] << EB() >>
S [78] ->
Q [51] << EB() >>
Why created:  Composition of Subcomponents via Directional Connection Train::Train.i.cpeb:
 eb -> brake
Solved by:  Identity (id):  P->P is tautology


Theorem (672)                               [serial 1042] 
P [89] << p = POSITION >>
S [103] ->
Q [19] << p = POSITION >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_s:
 p -> p
Solved by:  Identity (id):  P->P is tautology


Theorem (673)                               [serial 1043] 
P [91] << v = VELOCITY >>
S [104] ->
Q [21] << v = VELOCITY >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_v:
 v -> v
Solved by:  Identity (id):  P->P is tautology


Theorem (674)                               [serial 1044] 
P [94] << m_a = RMA >>
S [106] ->
Q [17] << m_a = RMA >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_ma:
 m_a -> m_a
Solved by:  Identity (id):  P->P is tautology


Theorem (675)                               [serial 1045] 
P [12] << SB()
  and not EB() >>
S [108] ->
Q [85] << SB()
  and not EB() >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_sb:
 sb -> sb
Solved by:  Identity (id):  P->P is tautology


Theorem (676)                               [serial 1046] 
P [14] << EB() >>
S [109] ->
Q [87] << EB() >>
Why created:  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_eb:
 eb -> eb
Solved by:  Identity (id):  P->P is tautology


Theorem (677)                               [serial 1001] 
Why created:  All verification conditions have been proved correct. 
Solved by:  Component and Connection Proofs
and theorems 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676:
Theorem (658) [serial 1002] used for:
  Initial proof obligations for AutoBrake.i 
Theorem (659) [serial 1029] used for:
  Composition of Subcomponents via Directional Connection driver.xl -> motor.xl:
 xl -> xl 
Theorem (660) [serial 1030] used for:
  Composition of Subcomponents via Directional Connection sensor.p -> controller.control.p:
 p -> p 
Theorem (661) [serial 1031] used for:
  Composition of Subcomponents via Directional Connection sensor.v -> controller.control.v:
 v -> v 
Theorem (662) [serial 1032] used for:
  Composition of Subcomponents via Directional Connection controller.control.sb -> sbrake.brake:
 sb -> brake 
Theorem (663) [serial 1033] used for:
  Composition of Subcomponents via Directional Connection controller.control.eb -> ebrake.brake:
 eb -> brake 
Theorem (664) [serial 1034] used for:
  Composition of Subcomponents via Directional Connection rbc.ma -> train.controller.control.m_a:
 ma -> m_a 
Theorem (665) [serial 1035] used for:
  Composition of Subcomponents via Directional Connection CTCS::MovementAuthority.i.ma:
 ma -> ma 
Theorem (666) [serial 1036] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.auth:
 ma -> m_a 
Theorem (667) [serial 1037] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.pos:
 p -> p 
Theorem (668) [serial 1038] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.vel:
 v -> v 
Theorem (669) [serial 1039] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.dxl:
 xl -> xl 
Theorem (670) [serial 1040] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.cpsb:
 sb -> brake 
Theorem (671) [serial 1041] used for:
  Composition of Subcomponents via Directional Connection Train::Train.i.cpeb:
 eb -> brake 
Theorem (672) [serial 1042] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_s:
 p -> p 
Theorem (673) [serial 1043] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_v:
 v -> v 
Theorem (674) [serial 1044] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_ma:
 m_a -> m_a 
Theorem (675) [serial 1045] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_sb:
 sb -> sb 
Theorem (676) [serial 1046] used for:
  Composition of Subcomponents via Directional Connection Train::ControllerProcess.i.conn_eb:
 eb -> eb 


showing tree: Derivations
closing proof.txt file 
proof duration:  14.6 seconds 

